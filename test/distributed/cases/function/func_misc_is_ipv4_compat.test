# IS_IPV4_COMPAT function
# Basic test case from requirements
SELECT IS_IPV4_COMPAT(INET6_ATON('::10.0.5.9')) AS result1;

# Valid IPv4-compatible addresses (should return 1)
SELECT IS_IPV4_COMPAT(INET6_ATON('::10.0.5.9')) AS valid_compat1;
SELECT IS_IPV4_COMPAT(INET6_ATON('::192.168.1.1')) AS valid_compat2;
SELECT IS_IPV4_COMPAT(INET6_ATON('::127.0.0.1')) AS valid_compat3;
SELECT IS_IPV4_COMPAT(INET6_ATON('::1.1.1.1')) AS valid_compat4;

# Invalid addresses (should return 0)
SELECT IS_IPV4_COMPAT(INET6_ATON('::1')) AS invalid1;  -- Regular IPv6, not IPv4-compatible
SELECT IS_IPV4_COMPAT(INET6_ATON('2001:db8::1')) AS invalid2;  -- Regular IPv6
SELECT IS_IPV4_COMPAT(INET6_ATON('::ffff:192.168.1.1')) AS invalid3;  -- IPv4-mapped, not compatible
SELECT IS_IPV4_COMPAT(INET6_ATON('::')) AS invalid4;  -- All zeros (0.0.0.0)
SELECT IS_IPV4_COMPAT(INET6_ATON('2001:0db8:85a3::8a2e:370:7334')) AS invalid5;  -- Regular IPv6

# IPv4 addresses (4 bytes, should return 0)
SELECT IS_IPV4_COMPAT(INET6_ATON('192.168.1.1')) AS invalid6;  -- IPv4 returns 4 bytes, not 16

# NULL handling (should return NULL)
SELECT IS_IPV4_COMPAT(NULL) AS null_input;

# Table usage
CREATE TABLE t1(id INT, ip_str VARCHAR(50));
INSERT INTO t1 VALUES (1, '::10.0.5.9');
INSERT INTO t1 VALUES (2, '::192.168.1.1');
INSERT INTO t1 VALUES (3, '::1');
INSERT INTO t1 VALUES (4, '::ffff:192.168.1.1');
INSERT INTO t1 VALUES (5, '2001:db8::1');
INSERT INTO t1 VALUES (6, NULL);

SELECT id, ip_str, IS_IPV4_COMPAT(INET6_ATON(ip_str)) AS is_compat FROM t1;
DROP TABLE t1;

# WHERE clause
CREATE TABLE t1(id INT, ip_str VARCHAR(50));
INSERT INTO t1 VALUES (1, '::10.0.5.9'), (2, '::1'), (3, '::192.168.1.1'), (4, '2001:db8::1');
SELECT id, ip_str FROM t1 WHERE IS_IPV4_COMPAT(INET6_ATON(ip_str)) = 1;
SELECT id, ip_str FROM t1 WHERE IS_IPV4_COMPAT(INET6_ATON(ip_str)) = 0;
DROP TABLE t1;

# Multiple function calls
SELECT IS_IPV4_COMPAT(INET6_ATON('::10.0.5.9')) AS ip1, IS_IPV4_COMPAT(INET6_ATON('::1')) AS ip2, IS_IPV4_COMPAT(INET6_ATON('::192.168.1.1')) AS ip3;

# Comparison
SELECT IS_IPV4_COMPAT(INET6_ATON('::10.0.5.9')) = 1 AS is_compat;
SELECT IS_IPV4_COMPAT(INET6_ATON('::1')) = 0 AS is_not_compat;

# Edge cases
SELECT IS_IPV4_COMPAT(INET6_ATON('::0.0.0.1')) AS min_compat;
SELECT IS_IPV4_COMPAT(INET6_ATON('::255.255.255.255')) AS max_compat;
SELECT IS_IPV4_COMPAT(INET6_ATON('::127.0.0.1')) AS loopback_compat;

# Combined with other functions
SELECT IS_IPV4_COMPAT(INET6_ATON('::10.0.5.9')) AND IS_IPV4_COMPAT(INET6_ATON('::192.168.1.1')) AS both_compat;
SELECT IS_IPV4_COMPAT(INET6_ATON('::10.0.5.9')) OR IS_IPV4_COMPAT(INET6_ATON('::1')) AS one_compat;

# Difference between IPv4-compatible and IPv4-mapped
SELECT IS_IPV4_COMPAT(INET6_ATON('::192.168.1.1')) AS ipv4_compat;
SELECT IS_IPV4_COMPAT(INET6_ATON('::ffff:192.168.1.1')) AS ipv4_mapped;  -- Should be 0

# Subquery usage
CREATE TABLE t1(id INT, ip_str VARCHAR(50));
INSERT INTO t1 VALUES (1, '::10.0.5.9'), (2, '::1');
SELECT (SELECT IS_IPV4_COMPAT(INET6_ATON(ip_str)) FROM t1 WHERE id = 1) AS subquery_result;
DROP TABLE t1;

# Invalid binary input (wrong length)
SELECT IS_IPV4_COMPAT(UNHEX('C0A80101')) AS invalid_length;  -- 4 bytes instead of 16
SELECT IS_IPV4_COMPAT(UNHEX('01')) AS invalid_length2;  -- Too short

