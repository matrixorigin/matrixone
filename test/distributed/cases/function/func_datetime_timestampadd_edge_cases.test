# TIMESTAMPADD Edge Cases and Boundary Conditions Tests
# Testing MySQL compatibility for edge cases

# ============================================
# 1. Leap Year Tests
# ============================================

# Leap year: Feb 28 + 1 day should return Feb 29
SELECT TIMESTAMPADD(DAY, 1, '2020-02-28') AS leap_year_day;

# Non-leap year: Feb 28 + 1 day should return Mar 1
SELECT TIMESTAMPADD(DAY, 1, '2021-02-28') AS non_leap_year_day;

# Leap year to non-leap year: Feb 29 + 1 year should return Feb 28
SELECT TIMESTAMPADD(YEAR, 1, '2020-02-29') AS leap_to_non_leap;

# Leap year to leap year: Feb 29 + 4 years should return Feb 29
SELECT TIMESTAMPADD(YEAR, 4, '2020-02-29') AS leap_to_leap;

# Leap year: Feb 29 + 1 day should return Mar 1
SELECT TIMESTAMPADD(DAY, 1, '2020-02-29') AS leap_feb29_plus_day;

# ============================================
# 2. Month Overflow Tests
# ============================================

# Jan 31 + 1 month (leap year) should return Feb 29
SELECT TIMESTAMPADD(MONTH, 1, '2024-01-31') AS month_overflow_jan_leap;

# Jan 31 + 1 month (non-leap year) should return Feb 28
SELECT TIMESTAMPADD(MONTH, 1, '2023-01-31') AS month_overflow_jan_non_leap;

# Mar 31 + 1 month should return Apr 30
SELECT TIMESTAMPADD(MONTH, 1, '2024-03-31') AS month_overflow_mar;

# May 31 + 1 month should return Jun 30
SELECT TIMESTAMPADD(MONTH, 1, '2024-05-31') AS month_overflow_may;

# Jul 31 + 1 month should return Aug 31
SELECT TIMESTAMPADD(MONTH, 1, '2024-07-31') AS month_overflow_jul;

# Aug 31 + 1 month should return Sep 30
SELECT TIMESTAMPADD(MONTH, 1, '2024-08-31') AS month_overflow_aug;

# Oct 31 + 1 month should return Nov 30
SELECT TIMESTAMPADD(MONTH, 1, '2024-10-31') AS month_overflow_oct;

# Dec 31 + 1 month should return Jan 31 (next year)
SELECT TIMESTAMPADD(MONTH, 1, '2024-12-31') AS month_overflow_dec;

# Jan 31 + 3 months (quarter) should return Apr 30
SELECT TIMESTAMPADD(MONTH, 3, '2024-01-31') AS month_overflow_quarter;

# ============================================
# 3. Quarter Boundary Tests
# ============================================

# Mar 31 + 1 quarter should return Jun 30
SELECT TIMESTAMPADD(QUARTER, 1, '2024-03-31') AS quarter_overflow_mar;

# May 31 + 1 quarter should return Aug 31
SELECT TIMESTAMPADD(QUARTER, 1, '2024-05-31') AS quarter_overflow_may;

# Aug 31 + 1 quarter should return Nov 30
SELECT TIMESTAMPADD(QUARTER, 1, '2024-08-31') AS quarter_overflow_aug;

# Nov 30 + 1 quarter should return Feb 28/29 (next year)
SELECT TIMESTAMPADD(QUARTER, 1, '2024-11-30') AS quarter_overflow_nov;

# ============================================
# 4. Year Boundary Tests
# ============================================

# Year end + 1 day
SELECT TIMESTAMPADD(DAY, 1, '2024-12-31') AS year_end_plus_day;

# Year start - 1 day
SELECT TIMESTAMPADD(DAY, -1, '2024-01-01') AS year_start_minus_day;

# ============================================
# 5. Date Boundary Tests
# ============================================

# Max date boundary (MySQL supports up to 9999-12-31)
SELECT TIMESTAMPADD(DAY, 1, '9999-12-31') AS max_date_boundary;

# Min date boundary (MySQL supports from 1000-01-01, but we test with 0001-01-01)
SELECT TIMESTAMPADD(DAY, -1, '0001-01-01') AS min_date_boundary;

# ============================================
# 6. Time Boundary Tests
# ============================================

# Time max boundary: 23:59:59 + 1 second should roll over to next day
SELECT TIMESTAMPADD(SECOND, 1, '2024-12-20 23:59:59') AS time_max_boundary_second;

# Time max boundary: 23:59:59 + 1 minute should roll over to next day
SELECT TIMESTAMPADD(MINUTE, 1, '2024-12-20 23:59:59') AS time_max_boundary_minute;

# Time max boundary: 23:59:59 + 1 hour should roll over to next day
SELECT TIMESTAMPADD(HOUR, 1, '2024-12-20 23:59:59') AS time_max_boundary_hour;

# Microsecond max boundary: 23:59:59.999999 + 1 microsecond should roll over
SELECT TIMESTAMPADD(MICROSECOND, 1, '2024-12-20 23:59:59.999999') AS microsecond_max_boundary;

# Time min boundary: 00:00:00 - 1 second should roll back to previous day
SELECT TIMESTAMPADD(SECOND, -1, '2024-12-20 00:00:00') AS time_min_boundary_second;

# ============================================
# 7. Edge Cases with DATE Type
# ============================================

# DATE type with month overflow
CREATE TABLE t1(d DATE);
INSERT INTO t1 VALUES ('2024-01-31'), ('2024-03-31'), ('2024-05-31');
SELECT d, TIMESTAMPADD(MONTH, 1, d) AS next_month FROM t1;
DROP TABLE t1;

# DATE type with leap year
CREATE TABLE t1(d DATE);
INSERT INTO t1 VALUES ('2020-02-28'), ('2021-02-28'), ('2020-02-29');
SELECT d, TIMESTAMPADD(DAY, 1, d) AS next_day FROM t1;
DROP TABLE t1;

# ============================================
# 8. Edge Cases with DATETIME Type
# ============================================

# DATETIME type with time boundary
CREATE TABLE t1(dt DATETIME);
INSERT INTO t1 VALUES ('2024-12-20 23:59:59'), ('2024-12-20 00:00:00');
SELECT dt, TIMESTAMPADD(SECOND, 1, dt) AS next_second FROM t1;
DROP TABLE t1;

# DATETIME type with microsecond precision
CREATE TABLE t1(dt DATETIME(6));
INSERT INTO t1 VALUES ('2024-12-20 23:59:59.999999'), ('2024-12-20 10:30:45.123456');
SELECT dt, TIMESTAMPADD(MICROSECOND, 1, dt) AS next_microsecond FROM t1;
DROP TABLE t1;

# ============================================
# 9. Large Interval Values
# ============================================

# Very large year interval
SELECT TIMESTAMPADD(YEAR, 100, '2024-01-01') AS large_year_interval;

# Very large day interval (about 27 years)
SELECT TIMESTAMPADD(DAY, 10000, '2024-01-01') AS large_day_interval;

# Very large hour interval (about 1 year)
SELECT TIMESTAMPADD(HOUR, 8760, '2024-01-01') AS large_hour_interval;

# ============================================
# 10. Negative Intervals Edge Cases
# ============================================

# Negative month causing year rollback
SELECT TIMESTAMPADD(MONTH, -1, '2024-01-31') AS negative_month_jan;

# Negative year
SELECT TIMESTAMPADD(YEAR, -1, '2024-02-29') AS negative_year_leap;

# Negative day causing month rollback
SELECT TIMESTAMPADD(DAY, -32, '2024-02-01') AS negative_day_feb;

