// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PLAN_FBS_H_
#define FLATBUFFERS_GENERATED_PLAN_FBS_H_

#include "flatbuffers/flatbuffers.h"

namespace fbs {

struct Datum;

struct Type;

struct Const;

struct ParamRef;

struct VarRef;

struct ObjectRef;

struct ColumnRef;

struct Expr;

struct Column;

struct Schema;

struct Cost;

struct ColData;

struct RowsetData;

struct WindowSpec;

struct Node;

struct Query;

inline const flatbuffers::TypeTable *DatumTypeTable();

inline const flatbuffers::TypeTable *TypeTypeTable();

inline const flatbuffers::TypeTable *ConstTypeTable();

inline const flatbuffers::TypeTable *ParamRefTypeTable();

inline const flatbuffers::TypeTable *VarRefTypeTable();

inline const flatbuffers::TypeTable *ObjectRefTypeTable();

inline const flatbuffers::TypeTable *ColumnRefTypeTable();

inline const flatbuffers::TypeTable *ExprTypeTable();

inline const flatbuffers::TypeTable *ColumnTypeTable();

inline const flatbuffers::TypeTable *SchemaTypeTable();

inline const flatbuffers::TypeTable *CostTypeTable();

inline const flatbuffers::TypeTable *ColDataTypeTable();

inline const flatbuffers::TypeTable *RowsetDataTypeTable();

inline const flatbuffers::TypeTable *WindowSpecTypeTable();

inline const flatbuffers::TypeTable *NodeTypeTable();

inline const flatbuffers::TypeTable *QueryTypeTable();

enum class TypeId : uint16_t {
  ANY = 0,
  STAR = 1,
  BOOL = 10,
  INT8 = 20,
  INT16 = 21,
  INT32 = 22,
  INT64 = 23,
  INT128 = 24,
  UINT8 = 25,
  UINT16 = 26,
  UINT32 = 27,
  UINT64 = 28,
  UINT128 = 29,
  FLOAT32 = 30,
  FLOAT64 = 31,
  DECIMAL64 = 32,
  DECIMAL128 = 33,
  DECIMAL = 34,
  ANYINT = 37,
  ANYFLOAT = 38,
  ANYNUMBER = 39,
  UUID = 40,
  UB160 = 41,
  UB184 = 42,
  UB192 = 43,
  UB224 = 44,
  UB256 = 45,
  DATE = 50,
  TIME = 51,
  DATETIME = 52,
  TIMESTAMP = 53,
  INTERVAL = 54,
  ANYTIME = 59,
  CHAR = 60,
  VARCHAR = 61,
  JSON = 62,
  BINARY = 70,
  VARBINARY = 71,
  ARRAY = 90,
  FLEXBUFFER = 91,
  BYTEA8 = 100,
  BYTEA16 = 101,
  BYTEA = 102,
  SEL = 200,
  TUPLE = 201,
  MIN = ANY,
  MAX = TUPLE
};

inline const TypeId (&EnumValuesTypeId())[45] {
  static const TypeId values[] = {
    TypeId::ANY,
    TypeId::STAR,
    TypeId::BOOL,
    TypeId::INT8,
    TypeId::INT16,
    TypeId::INT32,
    TypeId::INT64,
    TypeId::INT128,
    TypeId::UINT8,
    TypeId::UINT16,
    TypeId::UINT32,
    TypeId::UINT64,
    TypeId::UINT128,
    TypeId::FLOAT32,
    TypeId::FLOAT64,
    TypeId::DECIMAL64,
    TypeId::DECIMAL128,
    TypeId::DECIMAL,
    TypeId::ANYINT,
    TypeId::ANYFLOAT,
    TypeId::ANYNUMBER,
    TypeId::UUID,
    TypeId::UB160,
    TypeId::UB184,
    TypeId::UB192,
    TypeId::UB224,
    TypeId::UB256,
    TypeId::DATE,
    TypeId::TIME,
    TypeId::DATETIME,
    TypeId::TIMESTAMP,
    TypeId::INTERVAL,
    TypeId::ANYTIME,
    TypeId::CHAR,
    TypeId::VARCHAR,
    TypeId::JSON,
    TypeId::BINARY,
    TypeId::VARBINARY,
    TypeId::ARRAY,
    TypeId::FLEXBUFFER,
    TypeId::BYTEA8,
    TypeId::BYTEA16,
    TypeId::BYTEA,
    TypeId::SEL,
    TypeId::TUPLE
  };
  return values;
}

inline const char * const *EnumNamesTypeId() {
  static const char * const names[] = {
    "ANY",
    "STAR",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "BOOL",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "INT8",
    "INT16",
    "INT32",
    "INT64",
    "INT128",
    "UINT8",
    "UINT16",
    "UINT32",
    "UINT64",
    "UINT128",
    "FLOAT32",
    "FLOAT64",
    "DECIMAL64",
    "DECIMAL128",
    "DECIMAL",
    "",
    "",
    "ANYINT",
    "ANYFLOAT",
    "ANYNUMBER",
    "UUID",
    "UB160",
    "UB184",
    "UB192",
    "UB224",
    "UB256",
    "",
    "",
    "",
    "",
    "DATE",
    "TIME",
    "DATETIME",
    "TIMESTAMP",
    "INTERVAL",
    "",
    "",
    "",
    "",
    "ANYTIME",
    "CHAR",
    "VARCHAR",
    "JSON",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "BINARY",
    "VARBINARY",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "ARRAY",
    "FLEXBUFFER",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "BYTEA8",
    "BYTEA16",
    "BYTEA",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "SEL",
    "TUPLE",
    nullptr
  };
  return names;
}

inline const char *EnumNameTypeId(TypeId e) {
  if (e < TypeId::ANY || e > TypeId::TUPLE) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTypeId()[index];
}

enum class DataFlag : uint8_t {
  IS_NULL = 1,
  NONE = 0,
  ANY = 1
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(DataFlag, uint8_t)

inline const DataFlag (&EnumValuesDataFlag())[1] {
  static const DataFlag values[] = {
    DataFlag::IS_NULL
  };
  return values;
}

inline const char * const *EnumNamesDataFlag() {
  static const char * const names[] = {
    "IS_NULL",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataFlag(DataFlag e) {
  if (e < DataFlag::IS_NULL || e > DataFlag::IS_NULL) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(DataFlag::IS_NULL);
  return EnumNamesDataFlag()[index];
}

enum class DatumAttr : uint8_t {
  NULL = 32,
  B1 = 40,
  B2 = 41,
  B4 = 42,
  B8 = 43,
  B16 = 44,
  UB1 = 45,
  UB2 = 46,
  UB4 = 47,
  UB8 = 48,
  UB16 = 49,
  MEMAREA = 64,
  MEMAREA_ROWSTE = 65,
  MEMAREA_PLAN = 66,
  MEMAREA_NODE = 67,
  MEMAREA_QUERY = 69,
  FP = 128,
  FP_REMOTE = 129,
  FP_LOCAL = 130,
  FP_QUERY = 131,
  MIN = NULL,
  MAX = FP_QUERY
};

inline const DatumAttr (&EnumValuesDatumAttr())[20] {
  static const DatumAttr values[] = {
    DatumAttr::NULL,
    DatumAttr::B1,
    DatumAttr::B2,
    DatumAttr::B4,
    DatumAttr::B8,
    DatumAttr::B16,
    DatumAttr::UB1,
    DatumAttr::UB2,
    DatumAttr::UB4,
    DatumAttr::UB8,
    DatumAttr::UB16,
    DatumAttr::MEMAREA,
    DatumAttr::MEMAREA_ROWSTE,
    DatumAttr::MEMAREA_PLAN,
    DatumAttr::MEMAREA_NODE,
    DatumAttr::MEMAREA_QUERY,
    DatumAttr::FP,
    DatumAttr::FP_REMOTE,
    DatumAttr::FP_LOCAL,
    DatumAttr::FP_QUERY
  };
  return values;
}

inline const char *EnumNameDatumAttr(DatumAttr e) {
  switch (e) {
    case DatumAttr::NULL: return "NULL";
    case DatumAttr::B1: return "B1";
    case DatumAttr::B2: return "B2";
    case DatumAttr::B4: return "B4";
    case DatumAttr::B8: return "B8";
    case DatumAttr::B16: return "B16";
    case DatumAttr::UB1: return "UB1";
    case DatumAttr::UB2: return "UB2";
    case DatumAttr::UB4: return "UB4";
    case DatumAttr::UB8: return "UB8";
    case DatumAttr::UB16: return "UB16";
    case DatumAttr::MEMAREA: return "MEMAREA";
    case DatumAttr::MEMAREA_ROWSTE: return "MEMAREA_ROWSTE";
    case DatumAttr::MEMAREA_PLAN: return "MEMAREA_PLAN";
    case DatumAttr::MEMAREA_NODE: return "MEMAREA_NODE";
    case DatumAttr::MEMAREA_QUERY: return "MEMAREA_QUERY";
    case DatumAttr::FP: return "FP";
    case DatumAttr::FP_REMOTE: return "FP_REMOTE";
    case DatumAttr::FP_LOCAL: return "FP_LOCAL";
    case DatumAttr::FP_QUERY: return "FP_QUERY";
    default: return "";
  }
}

enum class FuncFlag : uint32_t {
  INTERNAL = 1,
  STABLE = 2,
  VOLATILE = 4,
  STRICT = 8,
  PRODUCE_NULL = 16,
  PRODUCE_NO_NULL = 32,
  VARARG = 64,
  AGG = 128,
  WIN = 256,
  NONE = 0,
  ANY = 511
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(FuncFlag, uint32_t)

inline const FuncFlag (&EnumValuesFuncFlag())[9] {
  static const FuncFlag values[] = {
    FuncFlag::INTERNAL,
    FuncFlag::STABLE,
    FuncFlag::VOLATILE,
    FuncFlag::STRICT,
    FuncFlag::PRODUCE_NULL,
    FuncFlag::PRODUCE_NO_NULL,
    FuncFlag::VARARG,
    FuncFlag::AGG,
    FuncFlag::WIN
  };
  return values;
}

inline const char *EnumNameFuncFlag(FuncFlag e) {
  switch (e) {
    case FuncFlag::INTERNAL: return "INTERNAL";
    case FuncFlag::STABLE: return "STABLE";
    case FuncFlag::VOLATILE: return "VOLATILE";
    case FuncFlag::STRICT: return "STRICT";
    case FuncFlag::PRODUCE_NULL: return "PRODUCE_NULL";
    case FuncFlag::PRODUCE_NO_NULL: return "PRODUCE_NO_NULL";
    case FuncFlag::VARARG: return "VARARG";
    case FuncFlag::AGG: return "AGG";
    case FuncFlag::WIN: return "WIN";
    default: return "";
  }
}

enum class OrderByFlag : uint16_t {
  ASC = 1,
  DESC = 2,
  NULLS_FIRST = 4,
  NULLS_LAST = 8,
  UNIQUE = 16,
  INTERNAL = 32,
  NONE = 0,
  ANY = 63
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(OrderByFlag, uint16_t)

inline const OrderByFlag (&EnumValuesOrderByFlag())[6] {
  static const OrderByFlag values[] = {
    OrderByFlag::ASC,
    OrderByFlag::DESC,
    OrderByFlag::NULLS_FIRST,
    OrderByFlag::NULLS_LAST,
    OrderByFlag::UNIQUE,
    OrderByFlag::INTERNAL
  };
  return values;
}

inline const char *EnumNameOrderByFlag(OrderByFlag e) {
  switch (e) {
    case OrderByFlag::ASC: return "ASC";
    case OrderByFlag::DESC: return "DESC";
    case OrderByFlag::NULLS_FIRST: return "NULLS_FIRST";
    case OrderByFlag::NULLS_LAST: return "NULLS_LAST";
    case OrderByFlag::UNIQUE: return "UNIQUE";
    case OrderByFlag::INTERNAL: return "INTERNAL";
    default: return "";
  }
}

enum class JoinFlag : uint16_t {
  APPLY = 1,
  OUTER = 2,
  SEMI = 4,
  ANTI = 8,
  SINGLE = 16,
  MARK = 32,
  NONE = 0,
  ANY = 63
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(JoinFlag, uint16_t)

inline const JoinFlag (&EnumValuesJoinFlag())[6] {
  static const JoinFlag values[] = {
    JoinFlag::APPLY,
    JoinFlag::OUTER,
    JoinFlag::SEMI,
    JoinFlag::ANTI,
    JoinFlag::SINGLE,
    JoinFlag::MARK
  };
  return values;
}

inline const char *EnumNameJoinFlag(JoinFlag e) {
  switch (e) {
    case JoinFlag::APPLY: return "APPLY";
    case JoinFlag::OUTER: return "OUTER";
    case JoinFlag::SEMI: return "SEMI";
    case JoinFlag::ANTI: return "ANTI";
    case JoinFlag::SINGLE: return "SINGLE";
    case JoinFlag::MARK: return "MARK";
    default: return "";
  }
}

enum class AggType : uint16_t {
  FULL = 0,
  BOTTOM = 1,
  TOP = 2,
  MIN = FULL,
  MAX = TOP
};

inline const AggType (&EnumValuesAggType())[3] {
  static const AggType values[] = {
    AggType::FULL,
    AggType::BOTTOM,
    AggType::TOP
  };
  return values;
}

inline const char * const *EnumNamesAggType() {
  static const char * const names[] = {
    "FULL",
    "BOTTOM",
    "TOP",
    nullptr
  };
  return names;
}

inline const char *EnumNameAggType(AggType e) {
  if (e < AggType::FULL || e > AggType::TOP) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAggType()[index];
}

enum class NodeType : uint32_t {
  UNKNOWN = 0,
  SELECT = 1,
  INSERT = 2,
  DELETE = 3,
  UPDATE = 4,
  ValueScan = 5,
  TableScan = 6,
  FunctionScan = 7,
  ExternalScan = 8,
  Project = 9,
  ExternalFunction = 10,
  Material = 11,
  RecursiveCTE = 12,
  Sink = 13,
  SinkScan = 14,
  Agg = 15,
  Join = 16,
  LimitOffset = 17,
  Sample = 18,
  Sort = 19,
  Union = 20,
  UnionAll = 21,
  Unique = 22,
  Window = 23,
  Broadcast = 24,
  Split = 25,
  Gather = 26,
  Assert = 27,
  MIN = UNKNOWN,
  MAX = Assert
};

inline const NodeType (&EnumValuesNodeType())[28] {
  static const NodeType values[] = {
    NodeType::UNKNOWN,
    NodeType::SELECT,
    NodeType::INSERT,
    NodeType::DELETE,
    NodeType::UPDATE,
    NodeType::ValueScan,
    NodeType::TableScan,
    NodeType::FunctionScan,
    NodeType::ExternalScan,
    NodeType::Project,
    NodeType::ExternalFunction,
    NodeType::Material,
    NodeType::RecursiveCTE,
    NodeType::Sink,
    NodeType::SinkScan,
    NodeType::Agg,
    NodeType::Join,
    NodeType::LimitOffset,
    NodeType::Sample,
    NodeType::Sort,
    NodeType::Union,
    NodeType::UnionAll,
    NodeType::Unique,
    NodeType::Window,
    NodeType::Broadcast,
    NodeType::Split,
    NodeType::Gather,
    NodeType::Assert
  };
  return values;
}

inline const char * const *EnumNamesNodeType() {
  static const char * const names[] = {
    "UNKNOWN",
    "SELECT",
    "INSERT",
    "DELETE",
    "UPDATE",
    "ValueScan",
    "TableScan",
    "FunctionScan",
    "ExternalScan",
    "Project",
    "ExternalFunction",
    "Material",
    "RecursiveCTE",
    "Sink",
    "SinkScan",
    "Agg",
    "Join",
    "LimitOffset",
    "Sample",
    "Sort",
    "Union",
    "UnionAll",
    "Unique",
    "Window",
    "Broadcast",
    "Split",
    "Gather",
    "Assert",
    nullptr
  };
  return names;
}

inline const char *EnumNameNodeType(NodeType e) {
  if (e < NodeType::UNKNOWN || e > NodeType::Assert) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNodeType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Datum FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t a_;
  uint64_t b_;
  uint64_t c_;
  uint64_t d_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DatumTypeTable();
  }
  Datum() {
    memset(static_cast<void *>(this), 0, sizeof(Datum));
  }
  Datum(uint64_t _a, uint64_t _b, uint64_t _c, uint64_t _d)
      : a_(flatbuffers::EndianScalar(_a)),
        b_(flatbuffers::EndianScalar(_b)),
        c_(flatbuffers::EndianScalar(_c)),
        d_(flatbuffers::EndianScalar(_d)) {
  }
  uint64_t a() const {
    return flatbuffers::EndianScalar(a_);
  }
  void mutate_a(uint64_t _a) {
    flatbuffers::WriteScalar(&a_, _a);
  }
  uint64_t b() const {
    return flatbuffers::EndianScalar(b_);
  }
  void mutate_b(uint64_t _b) {
    flatbuffers::WriteScalar(&b_, _b);
  }
  uint64_t c() const {
    return flatbuffers::EndianScalar(c_);
  }
  void mutate_c(uint64_t _c) {
    flatbuffers::WriteScalar(&c_, _c);
  }
  uint64_t d() const {
    return flatbuffers::EndianScalar(d_);
  }
  void mutate_d(uint64_t _d) {
    flatbuffers::WriteScalar(&d_, _d);
  }
};
FLATBUFFERS_STRUCT_END(Datum, 32);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Cost FLATBUFFERS_FINAL_CLASS {
 private:
  double start_;
  double total_;
  double cardinality_;
  double rowsize_;
  double ndv_;

 public:
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CostTypeTable();
  }
  Cost() {
    memset(static_cast<void *>(this), 0, sizeof(Cost));
  }
  Cost(double _start, double _total, double _cardinality, double _rowsize, double _ndv)
      : start_(flatbuffers::EndianScalar(_start)),
        total_(flatbuffers::EndianScalar(_total)),
        cardinality_(flatbuffers::EndianScalar(_cardinality)),
        rowsize_(flatbuffers::EndianScalar(_rowsize)),
        ndv_(flatbuffers::EndianScalar(_ndv)) {
  }
  double start() const {
    return flatbuffers::EndianScalar(start_);
  }
  void mutate_start(double _start) {
    flatbuffers::WriteScalar(&start_, _start);
  }
  double total() const {
    return flatbuffers::EndianScalar(total_);
  }
  void mutate_total(double _total) {
    flatbuffers::WriteScalar(&total_, _total);
  }
  double cardinality() const {
    return flatbuffers::EndianScalar(cardinality_);
  }
  void mutate_cardinality(double _cardinality) {
    flatbuffers::WriteScalar(&cardinality_, _cardinality);
  }
  double rowsize() const {
    return flatbuffers::EndianScalar(rowsize_);
  }
  void mutate_rowsize(double _rowsize) {
    flatbuffers::WriteScalar(&rowsize_, _rowsize);
  }
  double ndv() const {
    return flatbuffers::EndianScalar(ndv_);
  }
  void mutate_ndv(double _ndv) {
    flatbuffers::WriteScalar(&ndv_, _ndv);
  }
};
FLATBUFFERS_STRUCT_END(Cost, 40);

struct Type FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TypeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NULLABLE = 6,
    VT_WIDTH = 8,
    VT_PRECISION = 10
  };
  TypeId id() const {
    return static_cast<TypeId>(GetField<uint16_t>(VT_ID, 0));
  }
  bool mutate_id(TypeId _id) {
    return SetField<uint16_t>(VT_ID, static_cast<uint16_t>(_id), 0);
  }
  bool nullable() const {
    return GetField<uint8_t>(VT_NULLABLE, 0) != 0;
  }
  bool mutate_nullable(bool _nullable) {
    return SetField<uint8_t>(VT_NULLABLE, static_cast<uint8_t>(_nullable), 0);
  }
  int32_t width() const {
    return GetField<int32_t>(VT_WIDTH, 0);
  }
  bool mutate_width(int32_t _width) {
    return SetField<int32_t>(VT_WIDTH, _width, 0);
  }
  int32_t precision() const {
    return GetField<int32_t>(VT_PRECISION, 0);
  }
  bool mutate_precision(int32_t _precision) {
    return SetField<int32_t>(VT_PRECISION, _precision, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_NULLABLE) &&
           VerifyField<int32_t>(verifier, VT_WIDTH) &&
           VerifyField<int32_t>(verifier, VT_PRECISION) &&
           verifier.EndTable();
  }
};

struct TypeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(TypeId id) {
    fbb_.AddElement<uint16_t>(Type::VT_ID, static_cast<uint16_t>(id), 0);
  }
  void add_nullable(bool nullable) {
    fbb_.AddElement<uint8_t>(Type::VT_NULLABLE, static_cast<uint8_t>(nullable), 0);
  }
  void add_width(int32_t width) {
    fbb_.AddElement<int32_t>(Type::VT_WIDTH, width, 0);
  }
  void add_precision(int32_t precision) {
    fbb_.AddElement<int32_t>(Type::VT_PRECISION, precision, 0);
  }
  explicit TypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TypeBuilder &operator=(const TypeBuilder &);
  flatbuffers::Offset<Type> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Type>(end);
    return o;
  }
};

inline flatbuffers::Offset<Type> CreateType(
    flatbuffers::FlatBufferBuilder &_fbb,
    TypeId id = TypeId::ANY,
    bool nullable = false,
    int32_t width = 0,
    int32_t precision = 0) {
  TypeBuilder builder_(_fbb);
  builder_.add_precision(precision);
  builder_.add_width(width);
  builder_.add_id(id);
  builder_.add_nullable(nullable);
  return builder_.Finish();
}

struct Const FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ConstTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYP = 4,
    VT_NAME = 6,
    VT_ISNULL = 8,
    VT_IVAL = 10,
    VT_FVAL = 12,
    VT_SVAL = 14
  };
  const Type *typ() const {
    return GetPointer<const Type *>(VT_TYP);
  }
  Type *mutable_typ() {
    return GetPointer<Type *>(VT_TYP);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  bool isnull() const {
    return GetField<uint8_t>(VT_ISNULL, 0) != 0;
  }
  bool mutate_isnull(bool _isnull) {
    return SetField<uint8_t>(VT_ISNULL, static_cast<uint8_t>(_isnull), 0);
  }
  int64_t ival() const {
    return GetField<int64_t>(VT_IVAL, 0);
  }
  bool mutate_ival(int64_t _ival) {
    return SetField<int64_t>(VT_IVAL, _ival, 0);
  }
  double fval() const {
    return GetField<double>(VT_FVAL, 0.0);
  }
  bool mutate_fval(double _fval) {
    return SetField<double>(VT_FVAL, _fval, 0.0);
  }
  const flatbuffers::String *sval() const {
    return GetPointer<const flatbuffers::String *>(VT_SVAL);
  }
  flatbuffers::String *mutable_sval() {
    return GetPointer<flatbuffers::String *>(VT_SVAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYP) &&
           verifier.VerifyTable(typ()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_ISNULL) &&
           VerifyField<int64_t>(verifier, VT_IVAL) &&
           VerifyField<double>(verifier, VT_FVAL) &&
           VerifyOffset(verifier, VT_SVAL) &&
           verifier.VerifyString(sval()) &&
           verifier.EndTable();
  }
};

struct ConstBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_typ(flatbuffers::Offset<Type> typ) {
    fbb_.AddOffset(Const::VT_TYP, typ);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Const::VT_NAME, name);
  }
  void add_isnull(bool isnull) {
    fbb_.AddElement<uint8_t>(Const::VT_ISNULL, static_cast<uint8_t>(isnull), 0);
  }
  void add_ival(int64_t ival) {
    fbb_.AddElement<int64_t>(Const::VT_IVAL, ival, 0);
  }
  void add_fval(double fval) {
    fbb_.AddElement<double>(Const::VT_FVAL, fval, 0.0);
  }
  void add_sval(flatbuffers::Offset<flatbuffers::String> sval) {
    fbb_.AddOffset(Const::VT_SVAL, sval);
  }
  explicit ConstBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConstBuilder &operator=(const ConstBuilder &);
  flatbuffers::Offset<Const> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Const>(end);
    return o;
  }
};

inline flatbuffers::Offset<Const> CreateConst(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Type> typ = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool isnull = false,
    int64_t ival = 0,
    double fval = 0.0,
    flatbuffers::Offset<flatbuffers::String> sval = 0) {
  ConstBuilder builder_(_fbb);
  builder_.add_fval(fval);
  builder_.add_ival(ival);
  builder_.add_sval(sval);
  builder_.add_name(name);
  builder_.add_typ(typ);
  builder_.add_isnull(isnull);
  return builder_.Finish();
}

inline flatbuffers::Offset<Const> CreateConstDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Type> typ = 0,
    const char *name = nullptr,
    bool isnull = false,
    int64_t ival = 0,
    double fval = 0.0,
    const char *sval = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto sval__ = sval ? _fbb.CreateString(sval) : 0;
  return fbs::CreateConst(
      _fbb,
      typ,
      name__,
      isnull,
      ival,
      fval,
      sval__);
}

struct ParamRef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ParamRefTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYP = 4,
    VT_POS = 6
  };
  const Type *typ() const {
    return GetPointer<const Type *>(VT_TYP);
  }
  Type *mutable_typ() {
    return GetPointer<Type *>(VT_TYP);
  }
  int32_t pos() const {
    return GetField<int32_t>(VT_POS, 0);
  }
  bool mutate_pos(int32_t _pos) {
    return SetField<int32_t>(VT_POS, _pos, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYP) &&
           verifier.VerifyTable(typ()) &&
           VerifyField<int32_t>(verifier, VT_POS) &&
           verifier.EndTable();
  }
};

struct ParamRefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_typ(flatbuffers::Offset<Type> typ) {
    fbb_.AddOffset(ParamRef::VT_TYP, typ);
  }
  void add_pos(int32_t pos) {
    fbb_.AddElement<int32_t>(ParamRef::VT_POS, pos, 0);
  }
  explicit ParamRefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ParamRefBuilder &operator=(const ParamRefBuilder &);
  flatbuffers::Offset<ParamRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ParamRef>(end);
    return o;
  }
};

inline flatbuffers::Offset<ParamRef> CreateParamRef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Type> typ = 0,
    int32_t pos = 0) {
  ParamRefBuilder builder_(_fbb);
  builder_.add_pos(pos);
  builder_.add_typ(typ);
  return builder_.Finish();
}

struct VarRef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return VarRefTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYP = 4,
    VT_NAME = 6
  };
  const Type *typ() const {
    return GetPointer<const Type *>(VT_TYP);
  }
  Type *mutable_typ() {
    return GetPointer<Type *>(VT_TYP);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYP) &&
           verifier.VerifyTable(typ()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct VarRefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_typ(flatbuffers::Offset<Type> typ) {
    fbb_.AddOffset(VarRef::VT_TYP, typ);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(VarRef::VT_NAME, name);
  }
  explicit VarRefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VarRefBuilder &operator=(const VarRefBuilder &);
  flatbuffers::Offset<VarRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VarRef>(end);
    return o;
  }
};

inline flatbuffers::Offset<VarRef> CreateVarRef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Type> typ = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  VarRefBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_typ(typ);
  return builder_.Finish();
}

inline flatbuffers::Offset<VarRef> CreateVarRefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Type> typ = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return fbs::CreateVarRef(
      _fbb,
      typ,
      name__);
}

struct ObjectRef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ObjectRefTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERVER = 4,
    VT_DATABASE = 6,
    VT_SCHEMA = 8,
    VT_OBJECT = 10
  };
  const flatbuffers::String *server() const {
    return GetPointer<const flatbuffers::String *>(VT_SERVER);
  }
  flatbuffers::String *mutable_server() {
    return GetPointer<flatbuffers::String *>(VT_SERVER);
  }
  const flatbuffers::String *database() const {
    return GetPointer<const flatbuffers::String *>(VT_DATABASE);
  }
  flatbuffers::String *mutable_database() {
    return GetPointer<flatbuffers::String *>(VT_DATABASE);
  }
  const flatbuffers::String *schema() const {
    return GetPointer<const flatbuffers::String *>(VT_SCHEMA);
  }
  flatbuffers::String *mutable_schema() {
    return GetPointer<flatbuffers::String *>(VT_SCHEMA);
  }
  const flatbuffers::String *object() const {
    return GetPointer<const flatbuffers::String *>(VT_OBJECT);
  }
  flatbuffers::String *mutable_object() {
    return GetPointer<flatbuffers::String *>(VT_OBJECT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SERVER) &&
           verifier.VerifyString(server()) &&
           VerifyOffset(verifier, VT_DATABASE) &&
           verifier.VerifyString(database()) &&
           VerifyOffset(verifier, VT_SCHEMA) &&
           verifier.VerifyString(schema()) &&
           VerifyOffset(verifier, VT_OBJECT) &&
           verifier.VerifyString(object()) &&
           verifier.EndTable();
  }
};

struct ObjectRefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_server(flatbuffers::Offset<flatbuffers::String> server) {
    fbb_.AddOffset(ObjectRef::VT_SERVER, server);
  }
  void add_database(flatbuffers::Offset<flatbuffers::String> database) {
    fbb_.AddOffset(ObjectRef::VT_DATABASE, database);
  }
  void add_schema(flatbuffers::Offset<flatbuffers::String> schema) {
    fbb_.AddOffset(ObjectRef::VT_SCHEMA, schema);
  }
  void add_object(flatbuffers::Offset<flatbuffers::String> object) {
    fbb_.AddOffset(ObjectRef::VT_OBJECT, object);
  }
  explicit ObjectRefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObjectRefBuilder &operator=(const ObjectRefBuilder &);
  flatbuffers::Offset<ObjectRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectRef>(end);
    return o;
  }
};

inline flatbuffers::Offset<ObjectRef> CreateObjectRef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> server = 0,
    flatbuffers::Offset<flatbuffers::String> database = 0,
    flatbuffers::Offset<flatbuffers::String> schema = 0,
    flatbuffers::Offset<flatbuffers::String> object = 0) {
  ObjectRefBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_schema(schema);
  builder_.add_database(database);
  builder_.add_server(server);
  return builder_.Finish();
}

inline flatbuffers::Offset<ObjectRef> CreateObjectRefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *server = nullptr,
    const char *database = nullptr,
    const char *schema = nullptr,
    const char *object = nullptr) {
  auto server__ = server ? _fbb.CreateString(server) : 0;
  auto database__ = database ? _fbb.CreateString(database) : 0;
  auto schema__ = schema ? _fbb.CreateString(schema) : 0;
  auto object__ = object ? _fbb.CreateString(object) : 0;
  return fbs::CreateObjectRef(
      _fbb,
      server__,
      database__,
      schema__,
      object__);
}

struct ColumnRef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ColumnRefTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYP = 4,
    VT_NAME = 6,
    VT_RELATIONPOS = 8,
    VT_COLUMNPOS = 10
  };
  const Type *typ() const {
    return GetPointer<const Type *>(VT_TYP);
  }
  Type *mutable_typ() {
    return GetPointer<Type *>(VT_TYP);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  int32_t relationPos() const {
    return GetField<int32_t>(VT_RELATIONPOS, 0);
  }
  bool mutate_relationPos(int32_t _relationPos) {
    return SetField<int32_t>(VT_RELATIONPOS, _relationPos, 0);
  }
  int32_t columnPos() const {
    return GetField<int32_t>(VT_COLUMNPOS, 0);
  }
  bool mutate_columnPos(int32_t _columnPos) {
    return SetField<int32_t>(VT_COLUMNPOS, _columnPos, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYP) &&
           verifier.VerifyTable(typ()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_RELATIONPOS) &&
           VerifyField<int32_t>(verifier, VT_COLUMNPOS) &&
           verifier.EndTable();
  }
};

struct ColumnRefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_typ(flatbuffers::Offset<Type> typ) {
    fbb_.AddOffset(ColumnRef::VT_TYP, typ);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ColumnRef::VT_NAME, name);
  }
  void add_relationPos(int32_t relationPos) {
    fbb_.AddElement<int32_t>(ColumnRef::VT_RELATIONPOS, relationPos, 0);
  }
  void add_columnPos(int32_t columnPos) {
    fbb_.AddElement<int32_t>(ColumnRef::VT_COLUMNPOS, columnPos, 0);
  }
  explicit ColumnRefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ColumnRefBuilder &operator=(const ColumnRefBuilder &);
  flatbuffers::Offset<ColumnRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ColumnRef>(end);
    return o;
  }
};

inline flatbuffers::Offset<ColumnRef> CreateColumnRef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Type> typ = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t relationPos = 0,
    int32_t columnPos = 0) {
  ColumnRefBuilder builder_(_fbb);
  builder_.add_columnPos(columnPos);
  builder_.add_relationPos(relationPos);
  builder_.add_name(name);
  builder_.add_typ(typ);
  return builder_.Finish();
}

inline flatbuffers::Offset<ColumnRef> CreateColumnRefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Type> typ = 0,
    const char *name = nullptr,
    int32_t relationPos = 0,
    int32_t columnPos = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return fbs::CreateColumnRef(
      _fbb,
      typ,
      name__,
      relationPos,
      columnPos);
}

struct Expr FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ExprTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYP = 4,
    VT_VALUE = 6,
    VT_PARAM = 8,
    VT_COLREF = 10,
    VT_FUNC = 12,
    VT_ARGS = 14,
    VT_OPTIONS = 16
  };
  const Type *typ() const {
    return GetPointer<const Type *>(VT_TYP);
  }
  Type *mutable_typ() {
    return GetPointer<Type *>(VT_TYP);
  }
  const Const *value() const {
    return GetPointer<const Const *>(VT_VALUE);
  }
  Const *mutable_value() {
    return GetPointer<Const *>(VT_VALUE);
  }
  const ParamRef *param() const {
    return GetPointer<const ParamRef *>(VT_PARAM);
  }
  ParamRef *mutable_param() {
    return GetPointer<ParamRef *>(VT_PARAM);
  }
  const ColumnRef *colref() const {
    return GetPointer<const ColumnRef *>(VT_COLREF);
  }
  ColumnRef *mutable_colref() {
    return GetPointer<ColumnRef *>(VT_COLREF);
  }
  const ObjectRef *func() const {
    return GetPointer<const ObjectRef *>(VT_FUNC);
  }
  ObjectRef *mutable_func() {
    return GetPointer<ObjectRef *>(VT_FUNC);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Expr>> *args() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Expr>> *>(VT_ARGS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Expr>> *mutable_args() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Expr>> *>(VT_ARGS);
  }
  const flatbuffers::String *options() const {
    return GetPointer<const flatbuffers::String *>(VT_OPTIONS);
  }
  flatbuffers::String *mutable_options() {
    return GetPointer<flatbuffers::String *>(VT_OPTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYP) &&
           verifier.VerifyTable(typ()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           VerifyOffset(verifier, VT_PARAM) &&
           verifier.VerifyTable(param()) &&
           VerifyOffset(verifier, VT_COLREF) &&
           verifier.VerifyTable(colref()) &&
           VerifyOffset(verifier, VT_FUNC) &&
           verifier.VerifyTable(func()) &&
           VerifyOffset(verifier, VT_ARGS) &&
           verifier.VerifyVector(args()) &&
           verifier.VerifyVectorOfTables(args()) &&
           VerifyOffset(verifier, VT_OPTIONS) &&
           verifier.VerifyString(options()) &&
           verifier.EndTable();
  }
};

struct ExprBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_typ(flatbuffers::Offset<Type> typ) {
    fbb_.AddOffset(Expr::VT_TYP, typ);
  }
  void add_value(flatbuffers::Offset<Const> value) {
    fbb_.AddOffset(Expr::VT_VALUE, value);
  }
  void add_param(flatbuffers::Offset<ParamRef> param) {
    fbb_.AddOffset(Expr::VT_PARAM, param);
  }
  void add_colref(flatbuffers::Offset<ColumnRef> colref) {
    fbb_.AddOffset(Expr::VT_COLREF, colref);
  }
  void add_func(flatbuffers::Offset<ObjectRef> func) {
    fbb_.AddOffset(Expr::VT_FUNC, func);
  }
  void add_args(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Expr>>> args) {
    fbb_.AddOffset(Expr::VT_ARGS, args);
  }
  void add_options(flatbuffers::Offset<flatbuffers::String> options) {
    fbb_.AddOffset(Expr::VT_OPTIONS, options);
  }
  explicit ExprBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExprBuilder &operator=(const ExprBuilder &);
  flatbuffers::Offset<Expr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Expr>(end);
    return o;
  }
};

inline flatbuffers::Offset<Expr> CreateExpr(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Type> typ = 0,
    flatbuffers::Offset<Const> value = 0,
    flatbuffers::Offset<ParamRef> param = 0,
    flatbuffers::Offset<ColumnRef> colref = 0,
    flatbuffers::Offset<ObjectRef> func = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Expr>>> args = 0,
    flatbuffers::Offset<flatbuffers::String> options = 0) {
  ExprBuilder builder_(_fbb);
  builder_.add_options(options);
  builder_.add_args(args);
  builder_.add_func(func);
  builder_.add_colref(colref);
  builder_.add_param(param);
  builder_.add_value(value);
  builder_.add_typ(typ);
  return builder_.Finish();
}

inline flatbuffers::Offset<Expr> CreateExprDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Type> typ = 0,
    flatbuffers::Offset<Const> value = 0,
    flatbuffers::Offset<ParamRef> param = 0,
    flatbuffers::Offset<ColumnRef> colref = 0,
    flatbuffers::Offset<ObjectRef> func = 0,
    const std::vector<flatbuffers::Offset<Expr>> *args = nullptr,
    const char *options = nullptr) {
  auto args__ = args ? _fbb.CreateVector<flatbuffers::Offset<Expr>>(*args) : 0;
  auto options__ = options ? _fbb.CreateString(options) : 0;
  return fbs::CreateExpr(
      _fbb,
      typ,
      value,
      param,
      colref,
      func,
      args__,
      options__);
}

struct Column FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ColumnTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYP = 4,
    VT_NAME = 6,
    VT_PKIDX = 8
  };
  const Type *typ() const {
    return GetPointer<const Type *>(VT_TYP);
  }
  Type *mutable_typ() {
    return GetPointer<Type *>(VT_TYP);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  int16_t pkidx() const {
    return GetField<int16_t>(VT_PKIDX, 0);
  }
  bool mutate_pkidx(int16_t _pkidx) {
    return SetField<int16_t>(VT_PKIDX, _pkidx, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYP) &&
           verifier.VerifyTable(typ()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int16_t>(verifier, VT_PKIDX) &&
           verifier.EndTable();
  }
};

struct ColumnBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_typ(flatbuffers::Offset<Type> typ) {
    fbb_.AddOffset(Column::VT_TYP, typ);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Column::VT_NAME, name);
  }
  void add_pkidx(int16_t pkidx) {
    fbb_.AddElement<int16_t>(Column::VT_PKIDX, pkidx, 0);
  }
  explicit ColumnBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ColumnBuilder &operator=(const ColumnBuilder &);
  flatbuffers::Offset<Column> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Column>(end);
    return o;
  }
};

inline flatbuffers::Offset<Column> CreateColumn(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Type> typ = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int16_t pkidx = 0) {
  ColumnBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_typ(typ);
  builder_.add_pkidx(pkidx);
  return builder_.Finish();
}

inline flatbuffers::Offset<Column> CreateColumnDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Type> typ = 0,
    const char *name = nullptr,
    int16_t pkidx = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return fbs::CreateColumn(
      _fbb,
      typ,
      name__,
      pkidx);
}

struct Schema FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SchemaTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLUMNS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Column>> *columns() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Column>> *>(VT_COLUMNS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Column>> *mutable_columns() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Column>> *>(VT_COLUMNS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLUMNS) &&
           verifier.VerifyVector(columns()) &&
           verifier.VerifyVectorOfTables(columns()) &&
           verifier.EndTable();
  }
};

struct SchemaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_columns(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Column>>> columns) {
    fbb_.AddOffset(Schema::VT_COLUMNS, columns);
  }
  explicit SchemaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SchemaBuilder &operator=(const SchemaBuilder &);
  flatbuffers::Offset<Schema> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Schema>(end);
    return o;
  }
};

inline flatbuffers::Offset<Schema> CreateSchema(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Column>>> columns = 0) {
  SchemaBuilder builder_(_fbb);
  builder_.add_columns(columns);
  return builder_.Finish();
}

inline flatbuffers::Offset<Schema> CreateSchemaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Column>> *columns = nullptr) {
  auto columns__ = columns ? _fbb.CreateVector<flatbuffers::Offset<Column>>(*columns) : 0;
  return fbs::CreateSchema(
      _fbb,
      columns__);
}

struct ColData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ColDataTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROW_COUNT = 4,
    VT_NULL_COUNT = 6,
    VT_FLAGS = 8,
    VT_I8 = 10,
    VT_I16 = 12,
    VT_I32 = 14,
    VT_I64 = 16,
    VT_F32 = 18,
    VT_F64 = 20,
    VT_S = 22
  };
  int32_t row_count() const {
    return GetField<int32_t>(VT_ROW_COUNT, 0);
  }
  bool mutate_row_count(int32_t _row_count) {
    return SetField<int32_t>(VT_ROW_COUNT, _row_count, 0);
  }
  int32_t null_count() const {
    return GetField<int32_t>(VT_NULL_COUNT, 0);
  }
  bool mutate_null_count(int32_t _null_count) {
    return SetField<int32_t>(VT_NULL_COUNT, _null_count, 0);
  }
  const flatbuffers::Vector<uint8_t> *flags() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_FLAGS);
  }
  flatbuffers::Vector<uint8_t> *mutable_flags() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_FLAGS);
  }
  const flatbuffers::Vector<int8_t> *i8() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_I8);
  }
  flatbuffers::Vector<int8_t> *mutable_i8() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_I8);
  }
  const flatbuffers::Vector<int16_t> *i16() const {
    return GetPointer<const flatbuffers::Vector<int16_t> *>(VT_I16);
  }
  flatbuffers::Vector<int16_t> *mutable_i16() {
    return GetPointer<flatbuffers::Vector<int16_t> *>(VT_I16);
  }
  const flatbuffers::Vector<int32_t> *i32() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_I32);
  }
  flatbuffers::Vector<int32_t> *mutable_i32() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_I32);
  }
  const flatbuffers::Vector<int64_t> *i64() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_I64);
  }
  flatbuffers::Vector<int64_t> *mutable_i64() {
    return GetPointer<flatbuffers::Vector<int64_t> *>(VT_I64);
  }
  const flatbuffers::Vector<float> *f32() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_F32);
  }
  flatbuffers::Vector<float> *mutable_f32() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_F32);
  }
  const flatbuffers::Vector<double> *f64() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_F64);
  }
  flatbuffers::Vector<double> *mutable_f64() {
    return GetPointer<flatbuffers::Vector<double> *>(VT_F64);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *s() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_S);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_s() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_S);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ROW_COUNT) &&
           VerifyField<int32_t>(verifier, VT_NULL_COUNT) &&
           VerifyOffset(verifier, VT_FLAGS) &&
           verifier.VerifyVector(flags()) &&
           VerifyOffset(verifier, VT_I8) &&
           verifier.VerifyVector(i8()) &&
           VerifyOffset(verifier, VT_I16) &&
           verifier.VerifyVector(i16()) &&
           VerifyOffset(verifier, VT_I32) &&
           verifier.VerifyVector(i32()) &&
           VerifyOffset(verifier, VT_I64) &&
           verifier.VerifyVector(i64()) &&
           VerifyOffset(verifier, VT_F32) &&
           verifier.VerifyVector(f32()) &&
           VerifyOffset(verifier, VT_F64) &&
           verifier.VerifyVector(f64()) &&
           VerifyOffset(verifier, VT_S) &&
           verifier.VerifyVector(s()) &&
           verifier.VerifyVectorOfStrings(s()) &&
           verifier.EndTable();
  }
};

struct ColDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_row_count(int32_t row_count) {
    fbb_.AddElement<int32_t>(ColData::VT_ROW_COUNT, row_count, 0);
  }
  void add_null_count(int32_t null_count) {
    fbb_.AddElement<int32_t>(ColData::VT_NULL_COUNT, null_count, 0);
  }
  void add_flags(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> flags) {
    fbb_.AddOffset(ColData::VT_FLAGS, flags);
  }
  void add_i8(flatbuffers::Offset<flatbuffers::Vector<int8_t>> i8) {
    fbb_.AddOffset(ColData::VT_I8, i8);
  }
  void add_i16(flatbuffers::Offset<flatbuffers::Vector<int16_t>> i16) {
    fbb_.AddOffset(ColData::VT_I16, i16);
  }
  void add_i32(flatbuffers::Offset<flatbuffers::Vector<int32_t>> i32) {
    fbb_.AddOffset(ColData::VT_I32, i32);
  }
  void add_i64(flatbuffers::Offset<flatbuffers::Vector<int64_t>> i64) {
    fbb_.AddOffset(ColData::VT_I64, i64);
  }
  void add_f32(flatbuffers::Offset<flatbuffers::Vector<float>> f32) {
    fbb_.AddOffset(ColData::VT_F32, f32);
  }
  void add_f64(flatbuffers::Offset<flatbuffers::Vector<double>> f64) {
    fbb_.AddOffset(ColData::VT_F64, f64);
  }
  void add_s(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> s) {
    fbb_.AddOffset(ColData::VT_S, s);
  }
  explicit ColDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ColDataBuilder &operator=(const ColDataBuilder &);
  flatbuffers::Offset<ColData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ColData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ColData> CreateColData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t row_count = 0,
    int32_t null_count = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> flags = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> i8 = 0,
    flatbuffers::Offset<flatbuffers::Vector<int16_t>> i16 = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> i32 = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> i64 = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> f32 = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> f64 = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> s = 0) {
  ColDataBuilder builder_(_fbb);
  builder_.add_s(s);
  builder_.add_f64(f64);
  builder_.add_f32(f32);
  builder_.add_i64(i64);
  builder_.add_i32(i32);
  builder_.add_i16(i16);
  builder_.add_i8(i8);
  builder_.add_flags(flags);
  builder_.add_null_count(null_count);
  builder_.add_row_count(row_count);
  return builder_.Finish();
}

inline flatbuffers::Offset<ColData> CreateColDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t row_count = 0,
    int32_t null_count = 0,
    const std::vector<uint8_t> *flags = nullptr,
    const std::vector<int8_t> *i8 = nullptr,
    const std::vector<int16_t> *i16 = nullptr,
    const std::vector<int32_t> *i32 = nullptr,
    const std::vector<int64_t> *i64 = nullptr,
    const std::vector<float> *f32 = nullptr,
    const std::vector<double> *f64 = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *s = nullptr) {
  auto flags__ = flags ? _fbb.CreateVector<uint8_t>(*flags) : 0;
  auto i8__ = i8 ? _fbb.CreateVector<int8_t>(*i8) : 0;
  auto i16__ = i16 ? _fbb.CreateVector<int16_t>(*i16) : 0;
  auto i32__ = i32 ? _fbb.CreateVector<int32_t>(*i32) : 0;
  auto i64__ = i64 ? _fbb.CreateVector<int64_t>(*i64) : 0;
  auto f32__ = f32 ? _fbb.CreateVector<float>(*f32) : 0;
  auto f64__ = f64 ? _fbb.CreateVector<double>(*f64) : 0;
  auto s__ = s ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*s) : 0;
  return fbs::CreateColData(
      _fbb,
      row_count,
      null_count,
      flags__,
      i8__,
      i16__,
      i32__,
      i64__,
      f32__,
      f64__,
      s__);
}

struct RowsetData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RowsetDataTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCHEMA = 4,
    VT_COLS = 6
  };
  const Schema *schema() const {
    return GetPointer<const Schema *>(VT_SCHEMA);
  }
  Schema *mutable_schema() {
    return GetPointer<Schema *>(VT_SCHEMA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ColData>> *cols() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ColData>> *>(VT_COLS);
  }
  flatbuffers::Vector<flatbuffers::Offset<ColData>> *mutable_cols() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<ColData>> *>(VT_COLS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SCHEMA) &&
           verifier.VerifyTable(schema()) &&
           VerifyOffset(verifier, VT_COLS) &&
           verifier.VerifyVector(cols()) &&
           verifier.VerifyVectorOfTables(cols()) &&
           verifier.EndTable();
  }
};

struct RowsetDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_schema(flatbuffers::Offset<Schema> schema) {
    fbb_.AddOffset(RowsetData::VT_SCHEMA, schema);
  }
  void add_cols(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ColData>>> cols) {
    fbb_.AddOffset(RowsetData::VT_COLS, cols);
  }
  explicit RowsetDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RowsetDataBuilder &operator=(const RowsetDataBuilder &);
  flatbuffers::Offset<RowsetData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RowsetData>(end);
    return o;
  }
};

inline flatbuffers::Offset<RowsetData> CreateRowsetData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Schema> schema = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ColData>>> cols = 0) {
  RowsetDataBuilder builder_(_fbb);
  builder_.add_cols(cols);
  builder_.add_schema(schema);
  return builder_.Finish();
}

inline flatbuffers::Offset<RowsetData> CreateRowsetDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Schema> schema = 0,
    const std::vector<flatbuffers::Offset<ColData>> *cols = nullptr) {
  auto cols__ = cols ? _fbb.CreateVector<flatbuffers::Offset<ColData>>(*cols) : 0;
  return fbs::CreateRowsetData(
      _fbb,
      schema,
      cols__);
}

struct WindowSpec FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WindowSpecTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARTITION_BY = 4,
    VT_ORDER_BY = 6,
    VT_ORDER_BY_COLLATIONS = 8,
    VT_ORDER_BY_FLAGS = 10,
    VT_LEAD = 12,
    VT_LAG = 14
  };
  const flatbuffers::Vector<flatbuffers::Offset<Expr>> *partition_by() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Expr>> *>(VT_PARTITION_BY);
  }
  flatbuffers::Vector<flatbuffers::Offset<Expr>> *mutable_partition_by() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Expr>> *>(VT_PARTITION_BY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Expr>> *order_by() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Expr>> *>(VT_ORDER_BY);
  }
  flatbuffers::Vector<flatbuffers::Offset<Expr>> *mutable_order_by() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Expr>> *>(VT_ORDER_BY);
  }
  const flatbuffers::Vector<int32_t> *order_by_collations() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ORDER_BY_COLLATIONS);
  }
  flatbuffers::Vector<int32_t> *mutable_order_by_collations() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_ORDER_BY_COLLATIONS);
  }
  const flatbuffers::Vector<uint16_t> *order_by_flags() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_ORDER_BY_FLAGS);
  }
  flatbuffers::Vector<uint16_t> *mutable_order_by_flags() {
    return GetPointer<flatbuffers::Vector<uint16_t> *>(VT_ORDER_BY_FLAGS);
  }
  int32_t lead() const {
    return GetField<int32_t>(VT_LEAD, 0);
  }
  bool mutate_lead(int32_t _lead) {
    return SetField<int32_t>(VT_LEAD, _lead, 0);
  }
  int32_t lag() const {
    return GetField<int32_t>(VT_LAG, 0);
  }
  bool mutate_lag(int32_t _lag) {
    return SetField<int32_t>(VT_LAG, _lag, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARTITION_BY) &&
           verifier.VerifyVector(partition_by()) &&
           verifier.VerifyVectorOfTables(partition_by()) &&
           VerifyOffset(verifier, VT_ORDER_BY) &&
           verifier.VerifyVector(order_by()) &&
           verifier.VerifyVectorOfTables(order_by()) &&
           VerifyOffset(verifier, VT_ORDER_BY_COLLATIONS) &&
           verifier.VerifyVector(order_by_collations()) &&
           VerifyOffset(verifier, VT_ORDER_BY_FLAGS) &&
           verifier.VerifyVector(order_by_flags()) &&
           VerifyField<int32_t>(verifier, VT_LEAD) &&
           VerifyField<int32_t>(verifier, VT_LAG) &&
           verifier.EndTable();
  }
};

struct WindowSpecBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_partition_by(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Expr>>> partition_by) {
    fbb_.AddOffset(WindowSpec::VT_PARTITION_BY, partition_by);
  }
  void add_order_by(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Expr>>> order_by) {
    fbb_.AddOffset(WindowSpec::VT_ORDER_BY, order_by);
  }
  void add_order_by_collations(flatbuffers::Offset<flatbuffers::Vector<int32_t>> order_by_collations) {
    fbb_.AddOffset(WindowSpec::VT_ORDER_BY_COLLATIONS, order_by_collations);
  }
  void add_order_by_flags(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> order_by_flags) {
    fbb_.AddOffset(WindowSpec::VT_ORDER_BY_FLAGS, order_by_flags);
  }
  void add_lead(int32_t lead) {
    fbb_.AddElement<int32_t>(WindowSpec::VT_LEAD, lead, 0);
  }
  void add_lag(int32_t lag) {
    fbb_.AddElement<int32_t>(WindowSpec::VT_LAG, lag, 0);
  }
  explicit WindowSpecBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WindowSpecBuilder &operator=(const WindowSpecBuilder &);
  flatbuffers::Offset<WindowSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WindowSpec>(end);
    return o;
  }
};

inline flatbuffers::Offset<WindowSpec> CreateWindowSpec(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Expr>>> partition_by = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Expr>>> order_by = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> order_by_collations = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> order_by_flags = 0,
    int32_t lead = 0,
    int32_t lag = 0) {
  WindowSpecBuilder builder_(_fbb);
  builder_.add_lag(lag);
  builder_.add_lead(lead);
  builder_.add_order_by_flags(order_by_flags);
  builder_.add_order_by_collations(order_by_collations);
  builder_.add_order_by(order_by);
  builder_.add_partition_by(partition_by);
  return builder_.Finish();
}

inline flatbuffers::Offset<WindowSpec> CreateWindowSpecDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Expr>> *partition_by = nullptr,
    const std::vector<flatbuffers::Offset<Expr>> *order_by = nullptr,
    const std::vector<int32_t> *order_by_collations = nullptr,
    const std::vector<uint16_t> *order_by_flags = nullptr,
    int32_t lead = 0,
    int32_t lag = 0) {
  auto partition_by__ = partition_by ? _fbb.CreateVector<flatbuffers::Offset<Expr>>(*partition_by) : 0;
  auto order_by__ = order_by ? _fbb.CreateVector<flatbuffers::Offset<Expr>>(*order_by) : 0;
  auto order_by_collations__ = order_by_collations ? _fbb.CreateVector<int32_t>(*order_by_collations) : 0;
  auto order_by_flags__ = order_by_flags ? _fbb.CreateVector<uint16_t>(*order_by_flags) : 0;
  return fbs::CreateWindowSpec(
      _fbb,
      partition_by__,
      order_by__,
      order_by_collations__,
      order_by_flags__,
      lead,
      lag);
}

struct Node FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NodeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NODE_TYPE = 6,
    VT_COST = 8,
    VT_FILTER = 10,
    VT_PROJECT = 12,
    VT_CHILDREN = 14,
    VT_JOIN_TYPE = 16,
    VT_ON = 18,
    VT_WHERE = 20,
    VT_GROUP_BY = 22,
    VT_GROUPING_SETS = 24,
    VT_ORDER_BY = 26,
    VT_ORDER_BY_COLLATIONS = 28,
    VT_ORDER_BY_FLAGS = 30,
    VT_WINDOW = 32,
    VT_LIMIT = 34,
    VT_OFFSET = 36,
    VT_TABLE_REF = 38,
    VT_ROWSET_DATA = 40,
    VT_OPTIONS = 42
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool mutate_id(int32_t _id) {
    return SetField<int32_t>(VT_ID, _id, 0);
  }
  NodeType node_type() const {
    return static_cast<NodeType>(GetField<uint32_t>(VT_NODE_TYPE, 0));
  }
  bool mutate_node_type(NodeType _node_type) {
    return SetField<uint32_t>(VT_NODE_TYPE, static_cast<uint32_t>(_node_type), 0);
  }
  const Cost *cost() const {
    return GetStruct<const Cost *>(VT_COST);
  }
  Cost *mutable_cost() {
    return GetStruct<Cost *>(VT_COST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Expr>> *filter() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Expr>> *>(VT_FILTER);
  }
  flatbuffers::Vector<flatbuffers::Offset<Expr>> *mutable_filter() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Expr>> *>(VT_FILTER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Expr>> *project() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Expr>> *>(VT_PROJECT);
  }
  flatbuffers::Vector<flatbuffers::Offset<Expr>> *mutable_project() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Expr>> *>(VT_PROJECT);
  }
  const flatbuffers::Vector<int32_t> *children() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CHILDREN);
  }
  flatbuffers::Vector<int32_t> *mutable_children() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_CHILDREN);
  }
  JoinFlag join_type() const {
    return static_cast<JoinFlag>(GetField<uint16_t>(VT_JOIN_TYPE, 0));
  }
  bool mutate_join_type(JoinFlag _join_type) {
    return SetField<uint16_t>(VT_JOIN_TYPE, static_cast<uint16_t>(_join_type), 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Expr>> *on() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Expr>> *>(VT_ON);
  }
  flatbuffers::Vector<flatbuffers::Offset<Expr>> *mutable_on() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Expr>> *>(VT_ON);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Expr>> *where() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Expr>> *>(VT_WHERE);
  }
  flatbuffers::Vector<flatbuffers::Offset<Expr>> *mutable_where() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Expr>> *>(VT_WHERE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Expr>> *group_by() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Expr>> *>(VT_GROUP_BY);
  }
  flatbuffers::Vector<flatbuffers::Offset<Expr>> *mutable_group_by() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Expr>> *>(VT_GROUP_BY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Expr>> *grouping_sets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Expr>> *>(VT_GROUPING_SETS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Expr>> *mutable_grouping_sets() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Expr>> *>(VT_GROUPING_SETS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Expr>> *order_by() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Expr>> *>(VT_ORDER_BY);
  }
  flatbuffers::Vector<flatbuffers::Offset<Expr>> *mutable_order_by() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Expr>> *>(VT_ORDER_BY);
  }
  const flatbuffers::Vector<int32_t> *order_by_collations() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ORDER_BY_COLLATIONS);
  }
  flatbuffers::Vector<int32_t> *mutable_order_by_collations() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_ORDER_BY_COLLATIONS);
  }
  const flatbuffers::Vector<uint16_t> *order_by_flags() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_ORDER_BY_FLAGS);
  }
  flatbuffers::Vector<uint16_t> *mutable_order_by_flags() {
    return GetPointer<flatbuffers::Vector<uint16_t> *>(VT_ORDER_BY_FLAGS);
  }
  const WindowSpec *window() const {
    return GetPointer<const WindowSpec *>(VT_WINDOW);
  }
  WindowSpec *mutable_window() {
    return GetPointer<WindowSpec *>(VT_WINDOW);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Expr>> *limit() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Expr>> *>(VT_LIMIT);
  }
  flatbuffers::Vector<flatbuffers::Offset<Expr>> *mutable_limit() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Expr>> *>(VT_LIMIT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Expr>> *offset() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Expr>> *>(VT_OFFSET);
  }
  flatbuffers::Vector<flatbuffers::Offset<Expr>> *mutable_offset() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Expr>> *>(VT_OFFSET);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ObjectRef>> *table_ref() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ObjectRef>> *>(VT_TABLE_REF);
  }
  flatbuffers::Vector<flatbuffers::Offset<ObjectRef>> *mutable_table_ref() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<ObjectRef>> *>(VT_TABLE_REF);
  }
  const flatbuffers::Vector<flatbuffers::Offset<RowsetData>> *rowset_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RowsetData>> *>(VT_ROWSET_DATA);
  }
  flatbuffers::Vector<flatbuffers::Offset<RowsetData>> *mutable_rowset_data() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<RowsetData>> *>(VT_ROWSET_DATA);
  }
  const flatbuffers::String *options() const {
    return GetPointer<const flatbuffers::String *>(VT_OPTIONS);
  }
  flatbuffers::String *mutable_options() {
    return GetPointer<flatbuffers::String *>(VT_OPTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<uint32_t>(verifier, VT_NODE_TYPE) &&
           VerifyField<Cost>(verifier, VT_COST) &&
           VerifyOffset(verifier, VT_FILTER) &&
           verifier.VerifyVector(filter()) &&
           verifier.VerifyVectorOfTables(filter()) &&
           VerifyOffset(verifier, VT_PROJECT) &&
           verifier.VerifyVector(project()) &&
           verifier.VerifyVectorOfTables(project()) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.VerifyVector(children()) &&
           VerifyField<uint16_t>(verifier, VT_JOIN_TYPE) &&
           VerifyOffset(verifier, VT_ON) &&
           verifier.VerifyVector(on()) &&
           verifier.VerifyVectorOfTables(on()) &&
           VerifyOffset(verifier, VT_WHERE) &&
           verifier.VerifyVector(where()) &&
           verifier.VerifyVectorOfTables(where()) &&
           VerifyOffset(verifier, VT_GROUP_BY) &&
           verifier.VerifyVector(group_by()) &&
           verifier.VerifyVectorOfTables(group_by()) &&
           VerifyOffset(verifier, VT_GROUPING_SETS) &&
           verifier.VerifyVector(grouping_sets()) &&
           verifier.VerifyVectorOfTables(grouping_sets()) &&
           VerifyOffset(verifier, VT_ORDER_BY) &&
           verifier.VerifyVector(order_by()) &&
           verifier.VerifyVectorOfTables(order_by()) &&
           VerifyOffset(verifier, VT_ORDER_BY_COLLATIONS) &&
           verifier.VerifyVector(order_by_collations()) &&
           VerifyOffset(verifier, VT_ORDER_BY_FLAGS) &&
           verifier.VerifyVector(order_by_flags()) &&
           VerifyOffset(verifier, VT_WINDOW) &&
           verifier.VerifyTable(window()) &&
           VerifyOffset(verifier, VT_LIMIT) &&
           verifier.VerifyVector(limit()) &&
           verifier.VerifyVectorOfTables(limit()) &&
           VerifyOffset(verifier, VT_OFFSET) &&
           verifier.VerifyVector(offset()) &&
           verifier.VerifyVectorOfTables(offset()) &&
           VerifyOffset(verifier, VT_TABLE_REF) &&
           verifier.VerifyVector(table_ref()) &&
           verifier.VerifyVectorOfTables(table_ref()) &&
           VerifyOffset(verifier, VT_ROWSET_DATA) &&
           verifier.VerifyVector(rowset_data()) &&
           verifier.VerifyVectorOfTables(rowset_data()) &&
           VerifyOffset(verifier, VT_OPTIONS) &&
           verifier.VerifyString(options()) &&
           verifier.EndTable();
  }
};

struct NodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Node::VT_ID, id, 0);
  }
  void add_node_type(NodeType node_type) {
    fbb_.AddElement<uint32_t>(Node::VT_NODE_TYPE, static_cast<uint32_t>(node_type), 0);
  }
  void add_cost(const Cost *cost) {
    fbb_.AddStruct(Node::VT_COST, cost);
  }
  void add_filter(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Expr>>> filter) {
    fbb_.AddOffset(Node::VT_FILTER, filter);
  }
  void add_project(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Expr>>> project) {
    fbb_.AddOffset(Node::VT_PROJECT, project);
  }
  void add_children(flatbuffers::Offset<flatbuffers::Vector<int32_t>> children) {
    fbb_.AddOffset(Node::VT_CHILDREN, children);
  }
  void add_join_type(JoinFlag join_type) {
    fbb_.AddElement<uint16_t>(Node::VT_JOIN_TYPE, static_cast<uint16_t>(join_type), 0);
  }
  void add_on(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Expr>>> on) {
    fbb_.AddOffset(Node::VT_ON, on);
  }
  void add_where(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Expr>>> where) {
    fbb_.AddOffset(Node::VT_WHERE, where);
  }
  void add_group_by(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Expr>>> group_by) {
    fbb_.AddOffset(Node::VT_GROUP_BY, group_by);
  }
  void add_grouping_sets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Expr>>> grouping_sets) {
    fbb_.AddOffset(Node::VT_GROUPING_SETS, grouping_sets);
  }
  void add_order_by(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Expr>>> order_by) {
    fbb_.AddOffset(Node::VT_ORDER_BY, order_by);
  }
  void add_order_by_collations(flatbuffers::Offset<flatbuffers::Vector<int32_t>> order_by_collations) {
    fbb_.AddOffset(Node::VT_ORDER_BY_COLLATIONS, order_by_collations);
  }
  void add_order_by_flags(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> order_by_flags) {
    fbb_.AddOffset(Node::VT_ORDER_BY_FLAGS, order_by_flags);
  }
  void add_window(flatbuffers::Offset<WindowSpec> window) {
    fbb_.AddOffset(Node::VT_WINDOW, window);
  }
  void add_limit(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Expr>>> limit) {
    fbb_.AddOffset(Node::VT_LIMIT, limit);
  }
  void add_offset(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Expr>>> offset) {
    fbb_.AddOffset(Node::VT_OFFSET, offset);
  }
  void add_table_ref(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ObjectRef>>> table_ref) {
    fbb_.AddOffset(Node::VT_TABLE_REF, table_ref);
  }
  void add_rowset_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RowsetData>>> rowset_data) {
    fbb_.AddOffset(Node::VT_ROWSET_DATA, rowset_data);
  }
  void add_options(flatbuffers::Offset<flatbuffers::String> options) {
    fbb_.AddOffset(Node::VT_OPTIONS, options);
  }
  explicit NodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NodeBuilder &operator=(const NodeBuilder &);
  flatbuffers::Offset<Node> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Node>(end);
    return o;
  }
};

inline flatbuffers::Offset<Node> CreateNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    NodeType node_type = NodeType::UNKNOWN,
    const Cost *cost = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Expr>>> filter = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Expr>>> project = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> children = 0,
    JoinFlag join_type = static_cast<JoinFlag>(0),
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Expr>>> on = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Expr>>> where = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Expr>>> group_by = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Expr>>> grouping_sets = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Expr>>> order_by = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> order_by_collations = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> order_by_flags = 0,
    flatbuffers::Offset<WindowSpec> window = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Expr>>> limit = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Expr>>> offset = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ObjectRef>>> table_ref = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RowsetData>>> rowset_data = 0,
    flatbuffers::Offset<flatbuffers::String> options = 0) {
  NodeBuilder builder_(_fbb);
  builder_.add_options(options);
  builder_.add_rowset_data(rowset_data);
  builder_.add_table_ref(table_ref);
  builder_.add_offset(offset);
  builder_.add_limit(limit);
  builder_.add_window(window);
  builder_.add_order_by_flags(order_by_flags);
  builder_.add_order_by_collations(order_by_collations);
  builder_.add_order_by(order_by);
  builder_.add_grouping_sets(grouping_sets);
  builder_.add_group_by(group_by);
  builder_.add_where(where);
  builder_.add_on(on);
  builder_.add_children(children);
  builder_.add_project(project);
  builder_.add_filter(filter);
  builder_.add_cost(cost);
  builder_.add_node_type(node_type);
  builder_.add_id(id);
  builder_.add_join_type(join_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Node> CreateNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    NodeType node_type = NodeType::UNKNOWN,
    const Cost *cost = 0,
    const std::vector<flatbuffers::Offset<Expr>> *filter = nullptr,
    const std::vector<flatbuffers::Offset<Expr>> *project = nullptr,
    const std::vector<int32_t> *children = nullptr,
    JoinFlag join_type = static_cast<JoinFlag>(0),
    const std::vector<flatbuffers::Offset<Expr>> *on = nullptr,
    const std::vector<flatbuffers::Offset<Expr>> *where = nullptr,
    const std::vector<flatbuffers::Offset<Expr>> *group_by = nullptr,
    const std::vector<flatbuffers::Offset<Expr>> *grouping_sets = nullptr,
    const std::vector<flatbuffers::Offset<Expr>> *order_by = nullptr,
    const std::vector<int32_t> *order_by_collations = nullptr,
    const std::vector<uint16_t> *order_by_flags = nullptr,
    flatbuffers::Offset<WindowSpec> window = 0,
    const std::vector<flatbuffers::Offset<Expr>> *limit = nullptr,
    const std::vector<flatbuffers::Offset<Expr>> *offset = nullptr,
    const std::vector<flatbuffers::Offset<ObjectRef>> *table_ref = nullptr,
    const std::vector<flatbuffers::Offset<RowsetData>> *rowset_data = nullptr,
    const char *options = nullptr) {
  auto filter__ = filter ? _fbb.CreateVector<flatbuffers::Offset<Expr>>(*filter) : 0;
  auto project__ = project ? _fbb.CreateVector<flatbuffers::Offset<Expr>>(*project) : 0;
  auto children__ = children ? _fbb.CreateVector<int32_t>(*children) : 0;
  auto on__ = on ? _fbb.CreateVector<flatbuffers::Offset<Expr>>(*on) : 0;
  auto where__ = where ? _fbb.CreateVector<flatbuffers::Offset<Expr>>(*where) : 0;
  auto group_by__ = group_by ? _fbb.CreateVector<flatbuffers::Offset<Expr>>(*group_by) : 0;
  auto grouping_sets__ = grouping_sets ? _fbb.CreateVector<flatbuffers::Offset<Expr>>(*grouping_sets) : 0;
  auto order_by__ = order_by ? _fbb.CreateVector<flatbuffers::Offset<Expr>>(*order_by) : 0;
  auto order_by_collations__ = order_by_collations ? _fbb.CreateVector<int32_t>(*order_by_collations) : 0;
  auto order_by_flags__ = order_by_flags ? _fbb.CreateVector<uint16_t>(*order_by_flags) : 0;
  auto limit__ = limit ? _fbb.CreateVector<flatbuffers::Offset<Expr>>(*limit) : 0;
  auto offset__ = offset ? _fbb.CreateVector<flatbuffers::Offset<Expr>>(*offset) : 0;
  auto table_ref__ = table_ref ? _fbb.CreateVector<flatbuffers::Offset<ObjectRef>>(*table_ref) : 0;
  auto rowset_data__ = rowset_data ? _fbb.CreateVector<flatbuffers::Offset<RowsetData>>(*rowset_data) : 0;
  auto options__ = options ? _fbb.CreateString(options) : 0;
  return fbs::CreateNode(
      _fbb,
      id,
      node_type,
      cost,
      filter__,
      project__,
      children__,
      join_type,
      on__,
      where__,
      group_by__,
      grouping_sets__,
      order_by__,
      order_by_collations__,
      order_by_flags__,
      window,
      limit__,
      offset__,
      table_ref__,
      rowset_data__,
      options__);
}

struct Query FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return QueryTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STEPS = 4,
    VT_NODES = 6,
    VT_PARAMS = 8
  };
  const flatbuffers::Vector<int32_t> *steps() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STEPS);
  }
  flatbuffers::Vector<int32_t> *mutable_steps() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_STEPS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Node>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Node>> *>(VT_NODES);
  }
  flatbuffers::Vector<flatbuffers::Offset<Node>> *mutable_nodes() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Node>> *>(VT_NODES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Const>> *params() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Const>> *>(VT_PARAMS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Const>> *mutable_params() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Const>> *>(VT_PARAMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STEPS) &&
           verifier.VerifyVector(steps()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffset(verifier, VT_PARAMS) &&
           verifier.VerifyVector(params()) &&
           verifier.VerifyVectorOfTables(params()) &&
           verifier.EndTable();
  }
};

struct QueryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_steps(flatbuffers::Offset<flatbuffers::Vector<int32_t>> steps) {
    fbb_.AddOffset(Query::VT_STEPS, steps);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Node>>> nodes) {
    fbb_.AddOffset(Query::VT_NODES, nodes);
  }
  void add_params(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Const>>> params) {
    fbb_.AddOffset(Query::VT_PARAMS, params);
  }
  explicit QueryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QueryBuilder &operator=(const QueryBuilder &);
  flatbuffers::Offset<Query> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Query>(end);
    return o;
  }
};

inline flatbuffers::Offset<Query> CreateQuery(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> steps = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Node>>> nodes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Const>>> params = 0) {
  QueryBuilder builder_(_fbb);
  builder_.add_params(params);
  builder_.add_nodes(nodes);
  builder_.add_steps(steps);
  return builder_.Finish();
}

inline flatbuffers::Offset<Query> CreateQueryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *steps = nullptr,
    const std::vector<flatbuffers::Offset<Node>> *nodes = nullptr,
    const std::vector<flatbuffers::Offset<Const>> *params = nullptr) {
  auto steps__ = steps ? _fbb.CreateVector<int32_t>(*steps) : 0;
  auto nodes__ = nodes ? _fbb.CreateVector<flatbuffers::Offset<Node>>(*nodes) : 0;
  auto params__ = params ? _fbb.CreateVector<flatbuffers::Offset<Const>>(*params) : 0;
  return fbs::CreateQuery(
      _fbb,
      steps__,
      nodes__,
      params__);
}

inline const flatbuffers::TypeTable *TypeIdTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TypeIdTypeTable
  };
  static const int64_t values[] = { 0, 1, 10, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 37, 38, 39, 40, 41, 42, 43, 44, 45, 50, 51, 52, 53, 54, 59, 60, 61, 62, 70, 71, 90, 91, 100, 101, 102, 200, 201 };
  static const char * const names[] = {
    "ANY",
    "STAR",
    "BOOL",
    "INT8",
    "INT16",
    "INT32",
    "INT64",
    "INT128",
    "UINT8",
    "UINT16",
    "UINT32",
    "UINT64",
    "UINT128",
    "FLOAT32",
    "FLOAT64",
    "DECIMAL64",
    "DECIMAL128",
    "DECIMAL",
    "ANYINT",
    "ANYFLOAT",
    "ANYNUMBER",
    "UUID",
    "UB160",
    "UB184",
    "UB192",
    "UB224",
    "UB256",
    "DATE",
    "TIME",
    "DATETIME",
    "TIMESTAMP",
    "INTERVAL",
    "ANYTIME",
    "CHAR",
    "VARCHAR",
    "JSON",
    "BINARY",
    "VARBINARY",
    "ARRAY",
    "FLEXBUFFER",
    "BYTEA8",
    "BYTEA16",
    "BYTEA",
    "SEL",
    "TUPLE"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 45, type_codes, type_refs, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DataFlagTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataFlagTypeTable
  };
  static const int64_t values[] = { 1 };
  static const char * const names[] = {
    "IS_NULL"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 1, type_codes, type_refs, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DatumAttrTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DatumAttrTypeTable
  };
  static const int64_t values[] = { 32, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 64, 65, 66, 67, 69, 128, 129, 130, 131 };
  static const char * const names[] = {
    "NULL",
    "B1",
    "B2",
    "B4",
    "B8",
    "B16",
    "UB1",
    "UB2",
    "UB4",
    "UB8",
    "UB16",
    "MEMAREA",
    "MEMAREA_ROWSTE",
    "MEMAREA_PLAN",
    "MEMAREA_NODE",
    "MEMAREA_QUERY",
    "FP",
    "FP_REMOTE",
    "FP_LOCAL",
    "FP_QUERY"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 20, type_codes, type_refs, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FuncFlagTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FuncFlagTypeTable
  };
  static const int64_t values[] = { 1, 2, 4, 8, 16, 32, 64, 128, 256 };
  static const char * const names[] = {
    "INTERNAL",
    "STABLE",
    "VOLATILE",
    "STRICT",
    "PRODUCE_NULL",
    "PRODUCE_NO_NULL",
    "VARARG",
    "AGG",
    "WIN"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 9, type_codes, type_refs, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OrderByFlagTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    OrderByFlagTypeTable
  };
  static const int64_t values[] = { 1, 2, 4, 8, 16, 32 };
  static const char * const names[] = {
    "ASC",
    "DESC",
    "NULLS_FIRST",
    "NULLS_LAST",
    "UNIQUE",
    "INTERNAL"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 6, type_codes, type_refs, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *JoinFlagTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    JoinFlagTypeTable
  };
  static const int64_t values[] = { 1, 2, 4, 8, 16, 32 };
  static const char * const names[] = {
    "APPLY",
    "OUTER",
    "SEMI",
    "ANTI",
    "SINGLE",
    "MARK"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 6, type_codes, type_refs, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *AggTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_USHORT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    AggTypeTypeTable
  };
  static const char * const names[] = {
    "FULL",
    "BOTTOM",
    "TOP"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NodeTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_UINT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    NodeTypeTypeTable
  };
  static const char * const names[] = {
    "UNKNOWN",
    "SELECT",
    "INSERT",
    "DELETE",
    "UPDATE",
    "ValueScan",
    "TableScan",
    "FunctionScan",
    "ExternalScan",
    "Project",
    "ExternalFunction",
    "Material",
    "RecursiveCTE",
    "Sink",
    "SinkScan",
    "Agg",
    "Join",
    "LimitOffset",
    "Sample",
    "Sort",
    "Union",
    "UnionAll",
    "Unique",
    "Window",
    "Broadcast",
    "Split",
    "Gather",
    "Assert"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 28, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DatumTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const int64_t values[] = { 0, 8, 16, 24, 32 };
  static const char * const names[] = {
    "a",
    "b",
    "c",
    "d"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 4, type_codes, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_USHORT, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TypeIdTypeTable
  };
  static const char * const names[] = {
    "id",
    "nullable",
    "width",
    "precision"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ConstTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_LONG, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TypeTypeTable
  };
  static const char * const names[] = {
    "typ",
    "name",
    "isnull",
    "ival",
    "fval",
    "sval"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ParamRefTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TypeTypeTable
  };
  static const char * const names[] = {
    "typ",
    "pos"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *VarRefTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TypeTypeTable
  };
  static const char * const names[] = {
    "typ",
    "name"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ObjectRefTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "server",
    "database",
    "schema",
    "object"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ColumnRefTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TypeTypeTable
  };
  static const char * const names[] = {
    "typ",
    "name",
    "relationPos",
    "columnPos"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ExprTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 1, 5 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TypeTypeTable,
    ConstTypeTable,
    ParamRefTypeTable,
    ColumnRefTypeTable,
    ObjectRefTypeTable,
    ExprTypeTable
  };
  static const char * const names[] = {
    "typ",
    "value",
    "param",
    "colref",
    "func",
    "args",
    "options"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ColumnTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SHORT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TypeTypeTable
  };
  static const char * const names[] = {
    "typ",
    "name",
    "pkidx"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SchemaTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ColumnTypeTable
  };
  static const char * const names[] = {
    "columns"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CostTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 },
    { flatbuffers::ET_DOUBLE, 0, -1 }
  };
  static const int64_t values[] = { 0, 8, 16, 24, 32, 40 };
  static const char * const names[] = {
    "start",
    "total",
    "cardinality",
    "rowsize",
    "ndv"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 5, type_codes, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ColDataTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_UCHAR, 1, 0 },
    { flatbuffers::ET_CHAR, 1, -1 },
    { flatbuffers::ET_SHORT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_LONG, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_DOUBLE, 1, -1 },
    { flatbuffers::ET_STRING, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    DataFlagTypeTable
  };
  static const char * const names[] = {
    "row_count",
    "null_count",
    "flags",
    "i8",
    "i16",
    "i32",
    "i64",
    "f32",
    "f64",
    "s"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 10, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RowsetDataTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    SchemaTypeTable,
    ColDataTypeTable
  };
  static const char * const names[] = {
    "schema",
    "cols"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *WindowSpecTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_USHORT, 1, 1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ExprTypeTable,
    OrderByFlagTypeTable
  };
  static const char * const names[] = {
    "partition_by",
    "order_by",
    "order_by_collations",
    "order_by_flags",
    "lead",
    "lag"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NodeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_UINT, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_USHORT, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_USHORT, 1, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_SEQUENCE, 1, 6 },
    { flatbuffers::ET_SEQUENCE, 1, 7 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    NodeTypeTypeTable,
    CostTypeTable,
    ExprTypeTable,
    JoinFlagTypeTable,
    OrderByFlagTypeTable,
    WindowSpecTypeTable,
    ObjectRefTypeTable,
    RowsetDataTypeTable
  };
  static const char * const names[] = {
    "id",
    "node_type",
    "cost",
    "filter",
    "project",
    "children",
    "join_type",
    "on",
    "where",
    "group_by",
    "grouping_sets",
    "order_by",
    "order_by_collations",
    "order_by_flags",
    "window",
    "limit",
    "offset",
    "table_ref",
    "rowset_data",
    "options"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 20, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QueryTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    NodeTypeTable,
    ConstTypeTable
  };
  static const char * const names[] = {
    "steps",
    "nodes",
    "params"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

}  // namespace fbs

#endif  // FLATBUFFERS_GENERATED_PLAN_FBS_H_
