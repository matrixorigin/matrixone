// Copyright 2022 MatrixOrigin.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";
package txn; 
option go_package = "github.com/matrixorigin/matrixone/pkg/pb/txn";

import "github.com/gogo/protobuf/gogoproto/gogo.proto";
import "timestamp.proto";
import "metadata.proto";

option (gogoproto.goproto_enum_prefix_all) = true;

// TxnStatus transaction status
enum TxnStatus {
    // Active is the state of transaction creation, in this state, can execute the 
    // transaction Read/Write/Commit/Rollback.
    Active = 0;
    // Prepared for distributed transactions across DNs, a 2pc commit is performed, 
    // and the prepared status means that the transaction on a DN was executed 
    // successfully in the first phase. 
    // 
    // Note that this status needs to be logged to the LogService. Once the first 
    // phase of a transaction is successful, data cannot be lost.
    Prepared = 1;
    // Committing for distributed transactions across DNs, once all DNs have completed
    // the first phase, the transaction enters the Committing state and initiates an 
    // asynchronous process to handle the commit of temporary data.
    //
    // Note that when all DNs involved are in the prepared state, the distributed 
    // transaction can be considered committed because all data has been written 
    // successfully. The subsequent Committing process just explicitly converts these
    // writes into committed data.
    //
    // Note that the state exists only in memory and is not persisted to the LogService.
    // It can be restored through the Prepared state, if all(DN).Status == Prepared.
    Committing = 2;
    // Committed after the Committing phase has transformed all DN data involved into 
    // committed data, the status of the distributed transaction is explicitly recorded 
    // as Committed.
    //
    // Note that this status needs to be logged to the LogService
    Committed = 3;
    // Aborting a client initiating a Rollback call or a distributed transaction that has
    // any error in the first phase will enter the Aborting state. This state starts an 
    // asynchronous task to clean up the temporary data written by the transaction.
    //
    // Note that the state exists only in memory and is not persisted to the LogService.
    // It can be restored through the Prepared state, if Any(DN).Status != Prepared.
    Aborting  = 4;
    // Aborted after the Aborting phase, all data involved in the DN is cleaned up and 
    // the transaction status is explicitly recorded as Aborted.
    //
    // Note that this status needs to be logged to the LogService
    Aborted   = 5;
}

// TxnMeta transaction metadata
message TxnMeta {
    // ID transaction id, generated at the CN node at the time of transaction creation, 
    // globally unique.
    bytes               ID          = 1;
    // Status transaction status
    TxnStatus           Status      = 2;
    // SnapshotTS transaction read timestamp, generated at the CN node at the time of 
    // transaction creation. All data.TS < txn.SnapshotTS is visible for the current 
    // transaction.
    timestamp.Timestamp SnapshotTS  = 3 [(gogoproto.nullable) = false];
    // PreparedTS timestamp to complete the first phase of a 2pc commit transaction.
    timestamp.Timestamp PreparedTS  = 4;
    // CommitTS transaction commit timestamp. For a 2pc transaction, commitTS = max(preparedTS).
    timestamp.Timestamp CommitTS    = 5;
    // Coordinator the coordinator DN. CN uses the first DN of the transaction operation
    // as the Coordinator.
    metadata.DN         Coordinator = 6;
}

// CNOpRequest cn read/write request, CN -> DN. If data is written to more than one DN (>1) in a 
// single transaction, then the transaction becomes a 2pc transaction.
message CNOpRequest {
    // OpCode request operation type
    uint32      OpCode  = 1;
    // Payload the content of the request, TxnClient does not perceive the exact
    // format and content
    bytes       Payload = 2;
    // Target target to which the request was sent
	metadata.DN Target  = 3 [(gogoproto.nullable) = false]; 
}

// CNOpResponse cn read/write response, DN -> CN. A request corresponds to a response.
message CNOpResponse {
    // Payload response payload
	bytes Payload = 1;
}

// TxnOp transaction operations
enum TxnOp {
    // Read transaction read
    Read              = 0;
    // Write transaction write
    Write             = 1;
    // Commit commit transaction
    Commit            = 2;
    // Rollback rollback transaction
    Rollback          = 3;
    // Prepare when DN(Coordinator) receives a commit request from CN, it sends a prepare to 
    // each DN(partition)
    Prepare           = 4;
    // GetStatus query the status of a transaction on a DN. When a DN encounters a transaction
    // in the Prepared state, it needs to go to the DN(Coordinator) to query the status of the 
    // current transaction. When a DN encounters a transaction in the Prepared state during the 
    // recover, it needs to query the status of the transaction on each DN(partition) to determine
    // if the transaction is committed.
    GetStatus         = 5;
    // CommitPartition after the 2pc transaction is committed, the temporary data on each DN needs
    // to be explicitly converted to committed data.
    CommitPartition   = 6;
    // RollbackPartition after the 2pc transaction is aborted, the temporary data on each DN needs
    // to cleanup.
    RollbackPartition = 7;
}

// TxnRequest transaction request. All requests for the transaction are made using TxnRequest, so that 
// the codec and logical processing of the RPC can be unified. Specific requests are selected according 
// to TxnOp.
//
// Request flow of TxnRequest as below:
// 1. CN -> DN (TxnOp.Read, TxnOp.Write, TxnOp.Commit, TxnOp.Rollback)
// 2. DN -> DN (TxnOp.Prepare, TxnOp.GetStatus, TxnOp.CommitPartition, TxnOp.RollbackPartition)
message TxnRequest {
    // Txn transaction metadata
    TxnMeta                     Txn                      = 1 [(gogoproto.nullable) = false];
    // TxnOp TxnRequest opCode, select the Request defined below according to TxnOp.
    TxnOp                       Op                       = 2;
    // Flag request flag
    uint32                      Flag                     = 3;
    // CNOpRequest corresponds to TxnOp.Read, TxnOp.Write
    CNOpRequest                 CNRequest                = 4; 
    // TxnCommitRequest corresponds to TxnOp.Commit
    TxnCommitRequest            CommitRequest            = 5;
    // TxnRollbackRequest corresponds to TxnOp.Rollback
    TxnRollbackRequest          RollbackRequest          = 6;
    // TxnPrepareRequest corresponds to TxnOp.Prepare
    TxnPrepareRequest           PrepareRequest           = 7;
    // TxnGetStatusRequest corresponds to TxnOp.GetStatus
    TxnGetStatusRequest         GetStatusRequest         = 8;
    // TxnCommitPartitionRequest corresponds to TxnOp.CommitPartition
    TxnCommitPartitionRequest   CommitPartitionRequest   = 9;
    // TxnRollbackPartitionRequest corresponds to TxnOp.RollbackPartition
    TxnRollbackPartitionRequest RollbackPartitionRequest = 10;
}

// TxnResponse response of TxnRequest.
message TxnResponse {
    // Txn transaction metadata. TxnResponse.TxnMeta and TxnRequest.TxnMeta may differ 
    // in that the node initiating the TxnRequest needs to process the returned TxnMeta, 
    // e.g. to determine whether the transaction is Aborted by the status of the returned 
    // TxnMeta.
    TxnMeta                      Txn                       = 1;
    // Op same as TxnRequest.TxnOp
    TxnOp                        Op                        = 2;
    // Flag request flag, same as the corresponding request
    uint32                       Flag                      = 3;
    // TxnError explicit error
    TxnError                     TxnError                  = 4;
    // CNOpResponse corresponds to TxnOp.Read, TxnOp.Write response
    CNOpResponse                 CNOpResponse              = 5; 
    // TxnCommitResponse corresponds to TxnOp.Commit response
    TxnCommitResponse            CommitResponse            = 6;
    // TxnRollbackResponse corresponds to TxnOp.Rollback response
    TxnRollbackResponse          RollbackResponse          = 7;
    // TxnPrepareResponse corresponds to TxnOp.Prepare response
    TxnPrepareResponse           PrepareResponse           = 8;
    // TxnGetStatusResponse corresponds to TxnOp.GetStatus response
    TxnGetStatusResponse         GetStatusResponse         = 9;
    // TxnCommitPartitionResponse corresponds to TxnOp.CommitPartition response
    TxnCommitPartitionResponse   CommitPartitionResponse   = 10;
    // TxnRollbackPartitionResponse corresponds to TxnOp.RollbackPartition response
    TxnRollbackPartitionResponse RollbackPartitionResponse = 11;
}

// TxnCommitRequest CN sent the commit request to coordinator DN.
message TxnCommitRequest {
    // Partitions DNs for which data has been written in the current transaction.
    repeated metadata.DN Partitions = 1 [(gogoproto.nullable) = false]; 
}

// TxnCommitResponse response of TxnCommitRequest. 
message TxnCommitResponse {
}

// TxnCommitRequest CN sent the rollback request to coordinator DN.
message TxnRollbackRequest {
    // Partitions DNs for which data has been written in the current transaction.
    repeated metadata.DN Partitions = 1 [(gogoproto.nullable) = false]; 
}

// TxnRollbackResponse response of TxnRollbackRequest.
message TxnRollbackResponse {
}

// TxnPrepareRequest when a DN(coordinator) receives a Commit request from a CN, if 
// more than one DN is involved, the 2PC commit process is enabled and the first phase
// is to send prepare requests to all DNs.
message TxnPrepareRequest {
    // Partition prepare DN
    metadata.DN          Partition  = 1;
    // Partitions if the partition is the coordinator DN, partitions is not empty, 
    // otherwise is empty. The coordinator DN needs to write the partitions and prepare 
    // data together atomically to the LogService. So during error recovery we can use 
    // the coordinator DN to find all the DNs involved in the transaction to commit or
    // rollback the transaction.
    repeated metadata.DN Partitions = 2 [(gogoproto.nullable) = false]; 
}

// TxnPrepareResponse response of TxnPrepareRequest
message TxnPrepareResponse {

}

// TxnGetStatusRequest query the status of a transaction on DN
message TxnGetStatusRequest {
    // Partition target DN
    metadata.DN Partition = 1;
}

// TxnGetStatusResponse response of TxnGetStatusRequest
message TxnGetStatusResponse {
}

// TxnCommitPartitionRequest commit txn on partition. Data needs to be written to the 
// LogService.
message TxnCommitPartitionRequest {
     // Partition target DN
     metadata.DN Partition = 1;
}

// TxnCommitPartitionResponse response of TxnCommitPartitionRequest
message TxnCommitPartitionResponse {
}

// TxnCommitPartitionRequest rollback txn on partition
message TxnRollbackPartitionRequest {
     // Partition target DN
     metadata.DN Partition = 1;
}

// TxnRollbackPartitionResponse response of TxnRollbackPartitionRequest
message TxnRollbackPartitionResponse {
}

// TxnError all explicit errors in transaction operations.
message TxnError {

}