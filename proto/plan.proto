/*
 * Copyright 2021 Matrix Origin
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";
package plan;

import "github.com/gogo/protobuf/gogoproto/gogo.proto";

option go_package = "github.com/matrixorigin/matrixone/pkg/pb/plan";
option (gogoproto.sizer_all) = false;
option (gogoproto.protosizer_all) = true;

message Type {
	int32 id         = 1;
	bool notNullable = 2;
	bool auto_incr   = 3;
	int32 width      = 4;
	int32 scale      = 5;
	string table     = 6;
	repeated string enumvalues = 7;
};

// Const: if a const value can be reprensented by int64 or
// double, use that, otherwise store a string representation.
message Const {
	bool isnull			= 1;
	oneof value {
		int32 i8val		= 2;  // pb have no int8
		int32 i16val	= 3;  // pb have no int16
		int32 i32val	= 4;
		int64 i64val	= 5;
		uint32 u8val 	= 6;  // pb have no uint8
		uint32 u16val 	= 7;  // pb have no uint16
		uint32 u32val 	= 8;
		uint64 u64val 	= 9;
		double dval 	= 10;
		string sval		= 11;
		bool bval 		= 12;
		float fval		= 13;
		int32 dateval 	= 14;
		int64 timeval 	= 15;
		int64 datetimeval			= 16;
		decimal64 decimal64val 		= 17;
		decimal128 decimal128val 	= 18;
		int64 timestampval 			= 19;
		string jsonval 				= 20;
		bool defaultval 			= 21;
		bool updateVal 				= 22;
	}
	bool isBin = 23;
	Expr src = 24; // if generated by replacing an existing expr
}

// Bounded param for prepared statement.  User fill on execution.
message ParamRef {
	int32 pos	= 1;
}

// Session variable ref, compiler should fold.
message VarRef {
	string name = 1;
	bool system = 2;
	bool global = 3;
}

// Reference a column in the proj list of a node.
message ColRef {
	int32	rel_pos	= 1;
	int32	col_pos	= 2;
	string	name	= 3;
}

// Reference a column by its internal table id and column id
message RawColRef {
	uint64 tbl_id = 1;
	uint64 col_id = 2;
}

// Reference a correlated column in the proj list of a node.
message CorrColRef {
	int32 rel_pos	= 1;
	int32 col_pos	= 2;
	int32 depth		= 3;
}

// ExprList is a type of Expr
message ExprList {
	repeated Expr list = 1;
}

message MaxValue {
	string value = 1;
}

// TargetType used in cast function as target type
message TargetType {
	Type typ = 1;
}

// Reference a subquery
message SubqueryRef {
	enum Type {
		SCALAR		= 0;
		EXISTS		= 1;
		NOT_EXISTS	= 2;
		IN			= 3;
		NOT_IN		= 4;
		ANY			= 5;
		ALL			= 6;
	}

	Type typ		= 1;
	int32 node_id	= 2;
	string op		= 3;
	Expr child		= 4;
	int32 row_size	= 5;
}

// Object ref, reference a object in database, 4 part name.
message ObjectRef {
	int64 server	= 1;
	int64 db		= 2;
	int64 schema	= 3;
	int64 obj		= 4;
	string server_name	= 5;
	string db_name		= 6;
	string schema_name	= 7;
	string obj_name		= 8;
	string subscription_name = 9;
	PubInfo pub_info = 10;
}

message PubInfo {
	int32 tenant_id = 1;
}

message SubscriptionMeta{
	string name = 1; // pubName
	int32 account_id = 2; // pubAccountID
	string db_name = 3; // pubDbName
	string account_name = 4;// pubAccountName
	string sub_name = 5; // subName(subscription side db name)
}

message Function {
	// Function flags
	enum FuncFlag {
		NONE     = 0;
		// Internal function is generated by system, cannot
		// by called by user.
		INTERNAL = 1;

		// Function, by default is immutable.
		STABLE   = 2;
		VOLATILE = 4;

		// Nulls
		STRICT				= 8;
		PRODUCE_NULL		= 16;
		PRODUCE_NO_NULL		= 32;

		// Vararg, all trailing args must be of the same type.
		VARARG     = 64;

		// Window and Agg
		AGG        = 128;
		WIN_VALUE				= 256;
		WIN_ORDER				= 512;

		// Monotonic function can filter by zonemap
		MONOTONIC = 1024;
	}

	ObjectRef func		= 1;
	repeated Expr args	= 2;
}

message Expr {
	Type typ = 1;
	oneof expr {
		Const		c		= 2;
		ParamRef	p		= 3;
		VarRef		v		= 4;
		ColRef		col 	= 5;
		RawColRef	raw		= 6;
		Function	f		= 7;
		WindowSpec w = 8;
		SubqueryRef	sub		= 9;
		CorrColRef	corr	= 10;
		TargetType  t		= 11;
		ExprList	list	= 12;
		MaxValue	max		= 13;
	}

	int32 aux_id = 14;
	double ndv = 15;
	double selectivity = 16;
}

enum CompressType {
	None 	= 0;
	Lz4 	= 1;
}

message decimal64 {
	int64 a = 1;
}

message decimal128 {
	int64 a = 1;
	int64 b = 2;
}

message ResultColDef {
	repeated ColDef ResultCols = 1;
}

message ColDef {
	uint64 col_id		= 1;
	string name 		= 2;
	bool hidden			= 3;
	CompressType alg 	= 4;
	Type typ			= 5;
	bool not_null		= 6;
	Default default 	= 7;
	string comment		= 8;
	OnUpdate on_update  = 9;
	bool low_card 		= 10;
	uint32 seqnum		= 11;

	// XXX: Deprecated and to be removed soon.
	bool clusterBy		= 12;
	bool primary        = 13;
	int32 pkidx 		= 14;
}

message Default {
	Expr expr = 1;
	string origin_string = 2;

	// XXX: Deprecated and to be removed soon.
	bool null_ability = 3;
}

message OnUpdate {
	Expr expr = 1;
	string origin_string = 2;
}

message IndexOption {
	bool create_extra_table = 1;
}

message PrimaryKeyDef {
	// currently not used
	repeated uint64 cols	= 1;
	// currently not used
	uint64 pkey_col_id		= 2;
	// currently not used
	IndexOption option		= 3;

	// Composed primary key column name: __mo_cpkey
	string pkey_col_name = 4;
	// XXX: Deprecated and to be removed soon.
	repeated string names = 5;
	// Composite primary key column definition
	ColDef comp_pkey_col = 6;
}

message IndexDef {
	// Generate UUID for each index, currently not used
	string idx_id			       = 1;
	string index_name        = 2;
	// The constituent columns of the index
	repeated string parts    = 3;
	bool unique				       = 4;
	string index_table_name  = 5;
	bool table_exist        = 6;
	string comment          = 7;
	bool visible          = 8;
	// currently not used
	IndexOption option		  = 9;
}


message ForeignKeyDef {
	enum RefAction {
		RESTRICT	= 0;
		CASCADE		= 1;
		SET_NULL	= 2;
		SET_DEFAULT	= 3;
		NO_ACTION	= 4;
	}

	string name						= 1;
	repeated uint64 cols			= 2;
	uint64 foreign_tbl				= 3;
	repeated uint64 foreign_cols	= 4;
	RefAction on_delete				= 5;
	RefAction on_update				= 6;
}

message CheckDef {
	string name	= 1;
	// Name for anonymous constraints, __mo_chk_[INDEX_ID]
	Expr check	= 2;
}

message ClusterByDef {
	// XXX: Deprecated and to be removed soon.
	string name = 1;
	// Composite cluster by column definition
	ColDef comp_cbkey_col = 2;
}

message PropertyDef {
	string key 		= 1;
	string value 	= 2;
}

message Property {
	string key 		= 1;
	string value 	= 2;
}

message PropertiesDef {
	repeated Property properties 	= 1;
}


enum PartitionType {
	KEY = 0;
	LINEAR_KEY = 1;
	HASH = 2;
	LINEAR_HASH = 3;
	RANGE = 4;
	RANGE_COLUMNS = 5;
	LIST = 6;
	LIST_COLUMNS = 7;
}

message PartitionByDef {
	PartitionType type = 1;
	PartitionExpr partition_expr = 2;
	Expr partition_expression = 3;
	PartitionColumns partition_columns = 4;
	uint64 partitionNum = 5;
	repeated PartitionItem partitions = 6;
	int64 algorithm = 7;
	bool is_sub_partition = 8;
	string partition_msg = 9;
	repeated string partition_table_names = 10;
}

message PartitionExpr {
	Expr expr = 1;
	string expr_str = 2;
}

message PartitionColumns {
	repeated Expr columns = 1;
	repeated string partition_columns = 2;
}

message PartitionItem {
	string partition_name = 1;
	uint32 ordinal_position = 2;
	string description = 3;
	string comment = 4;
	repeated Expr less_than = 5;
	repeated Expr in_values = 6;
	string partition_table_name = 7;// the table name of a partition
}


message ViewDef {
	string view  = 1;
}

message TableDef {
	// XXX: Deprecated and to be removed soon.
	message DefType {
		oneof def {
			PropertiesDef properties	= 1;
		}
	}

	uint64 tbl_id			= 1;
	string name				= 2;
	bool hidden				= 3;
	repeated ColDef cols	= 4;
	string table_type 		= 5;
	string createsql 		= 6;
	TableFunction tbl_func	= 7;
	uint32 version 			= 8;

	PrimaryKeyDef pkey				= 11;
	repeated IndexDef indexes = 12;
	repeated ForeignKeyDef fkeys	= 13;
	repeated uint64 ref_child_tbls	= 14;
	repeated CheckDef checks		= 15;

	PartitionByDef partition		= 21;
	ClusterByDef cluster_by		= 22;
	repeated PropertyDef props	= 23;
	ViewDef view_sql			= 24;

	// XXX: Deprecated and to be removed soon.
	repeated DefType defs	= 25;
	map<string, int32> name2col_index = 26;
	bool isLocked = 27;
	TableLockType tableLockType = 28;
	bool is_temporary = 29;

	uint64 auto_incr_offset = 30;
}

message TableFunction{
	string name = 1;
	bytes param = 2;
}

enum ShuffleType {
	Hash = 0;
	Range = 1;
}

enum ShuffleMethod {
	Noraml = 0;
	Follow = 1;
	Reshuffle = 2;
}

message Stats {
	//for scan, number of blocks to read from S3
	int32  block_num        = 1;
	//for scan, cost of reading from S3, basically the read lines
	//for other nodes, it means the estimated cost of current node
	double cost				= 2;
	//number of output lines
	double outcnt			= 3;
	// average size of one row, currently not used
	double rowsize	        = 4;
	// hashmap size for nodes which build a hashmap
	double hashmap_size		= 5;
	//for scan, this means total count of all table, before filtering
	double table_cnt = 6;
	//for scan, selectivity means outcnt divide total count
	double selectivity = 7;

	// for group by and join node with big hashmap, use shuffle
	// shuffle on which column. choose a column with max ndv
	bool shuffle = 8;
	int32 shuffleColIdx = 9;
	// shuffle type
	ShuffleType shuffleType = 10;
	// for range shuffle on integer column, need to know its min and max value
	int64 shuffleColMin = 11;
	int64 shuffleColMax = 12;
	ShuffleMethod shuffleMethod = 13;
	//not used for now
	int32   parallelism = 14;
}

message RowsetExpr {
    int32 row_pos = 1;
    int32 pos = 2;
    Expr expr = 3;
}

message ColData {
    repeated RowsetExpr data = 1;
}

message RowsetData {
	repeated ColData cols	= 1;
}

message OrderBySpec {
	enum OrderByFlag {
		INTERNAL    = 0;
		ASC  		= 1;
		DESC 		= 2;
		NULLS_FIRST = 4;
		NULLS_LAST  = 8;
		UNIQUE      = 16;
	}

	Expr expr = 1;
	string collation = 2;
	OrderByFlag flag = 3;
}

message WindowSpec {
	Expr window_func = 1;
	repeated Expr partition_by = 2;
	repeated OrderBySpec order_by = 3;
	FrameClause frame = 4;
	string name = 5;
}

message FrameClause {
	enum FrameType {
		ROWS = 0;
		RANGE = 1;
	}
	FrameType type = 1;
	FrameBound start = 2;
	FrameBound end = 3;
}

message FrameBound {
	enum BoundType {
		FOLLOWING = 0;
		PRECEDING = 1;
		CURRENT_ROW = 2;
	}
	BoundType type = 1;
	bool unBounded = 2;
	Expr val = 3;
}

message OnDuplicateKeyCtx {
	TableDef table_def					= 1;
	repeated int32 on_duplicate_idx		= 2;
	map<string, Expr> on_duplicate_expr	= 3;
}

message InsertCtx {
	ObjectRef ref			= 1;
	bool add_affected_rows 	= 2;
	bool is_cluster_table	= 3;
	TableDef table_def		= 4;
	// Align array index with the partition number
	repeated uint64 partition_table_ids = 5;
	repeated string partition_table_names = 6;
	int32 partition_idx = 7;
}

message AnalyzeInfo {
    int64 input_rows = 1;
    int64 output_rows = 2;
    int64 input_size = 3;
    int64 output_size = 4;
    int64 time_consumed = 5;
    int64 memory_size = 6;
    int64 wait_time_consumed = 7;
    int64 diskIO = 8;
    int64 s3IO_byte = 9;
    int64 s3IO_input_count = 10;
    int64 s3IO_output_count = 11;
    int64 networkIO = 12;
	int64 scanTime = 13;
	int64 insertTime = 14;
}

message Node {
	enum NodeType {
		UNKNOWN = 0;
		// Node Types

		// Scans
		VALUE_SCAN = 1;
		TABLE_SCAN = 2;
		FUNCTION_SCAN = 3;
		EXTERNAL_SCAN = 4;
		MATERIAL_SCAN = 5;

		// Proj, for convenience
		PROJECT = 10;
		// External function call (UDF)
		EXTERNAL_FUNCTION = 11;

		// Material, CTE, etc.
		MATERIAL = 20;
		RECURSIVE_CTE = 21;
		SINK = 22;
		SINK_SCAN = 23;
		RECURSIVE_SCAN = 24;

		// Proper Relational Operators
		AGG = 30;
		DISTINCT = 31;
		FILTER = 32;
		JOIN = 33;
		SAMPLE = 34;
		SORT = 35;
		UNION = 36;
		UNION_ALL = 37;
		UNIQUE = 38;
		WINDOW = 39;

		// Physical tuple mover
		BROADCAST = 40;
		SPLIT = 41;
		GATHER = 42;

		// Misc
		ASSERT = 50;

		//
		INSERT = 51;
		DELETE = 52;
		//
		LOCK_OP = 53;

		//
		INTERSECT = 54;
		INTERSECT_ALL = 55;
		MINUS = 56;
		MINUS_ALL = 57;

		//
		ON_DUPLICATE_KEY = 58;
		PRE_INSERT = 59;
		PRE_DELETE = 60;
		// the node which build insert batch for hidden table(unique key)
		PRE_INSERT_UK = 61;
	}

	enum JoinType {
		INNER	= 0;
		LEFT	= 1;
		RIGHT	= 2;
		OUTER	= 3;
		SEMI	= 4;
		ANTI	= 5;
		SINGLE	= 6;
		MARK	= 7;
		APPLY	= 8;
	}

	enum AggMode {
		FULL = 0;
		BOTTOM = 1;
		TOP = 2;
	}

	NodeType node_type = 1;
	int32 node_id = 2;
	Stats stats = 3;
	repeated int32 children = 4;

	// PROJECT
	repeated Expr project_list = 5;

	// JOIN
	JoinType join_type = 6;
	repeated Expr on_list = 7;
	bool build_on_left = 8;

	// FILTER
	repeated Expr filter_list = 9;

	// AGG
	repeated Expr group_by = 10;
	repeated Expr grouping_set = 11;
	repeated Expr agg_list = 12;

	// WINDOW
	repeated Expr win_spec_list = 13;

	// SORT
	repeated OrderBySpec order_by = 14;

	// LIMIT
	Expr limit = 15;
	Expr offset = 16;

	TableDef table_def = 18;
	repeated TableDef table_def_vec = 19;
	ObjectRef obj_ref = 20;
	RowsetData rowset_data = 21;

	string extra_options = 22;
	DeleteCtx delete_ctx = 23;

	repeated int32 binding_tags = 24;

    AnalyzeInfo analyze_info = 25;

	repeated Expr tbl_func_expr_list = 26;

	ClusterTable cluster_table = 28;
	bool not_cacheable = 29;
	InsertCtx insert_ctx = 30;

	// used to connect two plans[steps]
	repeated int32 source_step = 31;

	PreDeleteCtx pre_delete_ctx = 32;
	PreInsertCtx pre_insert_ctx = 33;
	// build unique key batch before insert into hidden table which keep the unique key
	PreInsertUkCtx pre_insert_uk_ctx = 34;
	OnDuplicateKeyCtx on_duplicate_key = 35;

	bool IsEnd = 36;
	repeated LockTarget lock_targets = 37;
	repeated Expr block_filter_list = 38;

	// Runtime filters
	repeated RuntimeFilterSpec runtime_filter_probe_list = 39;
	repeated RuntimeFilterSpec runtime_filter_build_list = 40;

    bytes uuid = 41;
}

message LockTarget {
  uint64 table_id           	= 1;
  int32 primary_col_idx_in_bat  = 2;
  Type primary_col_typ          = 3;
  int32 refresh_ts_idx_in_bat   = 4;
  int32 filter_col_idx_in_bat   = 5;
  bool lock_table 				= 6;
	bool is_partition_table = 7;
	repeated uint64 partition_table_ids = 8;
	bool                block   = 9;
}

message PreInsertUkCtx {
	// index of columns(parts of unique key) in pre batch
	repeated int32 columns 	= 1;
	int32 pk_column 		= 2;
	Type pk_type 			= 3;
	Type uk_type			= 4;
	TableDef table_def 		= 5;
}

message PreDeleteCtx {
	//the indexes of row_id&pk column in the batch
	repeated int32 idx = 1;
}

message PreInsertCtx {
	ObjectRef ref 			= 1;
	TableDef table_def 		= 2;
	bool has_auto_col		= 3;
	bool is_update			= 4;
}

message RuntimeFilterSpec {
	int32 tag = 1;
	Expr expr = 2;
}

message IdList {
	repeated int64 list = 1;
}

message ColPosMap {
	map<string, int32> map = 1;
}

message DeleteCtx {
	bool can_truncate 		= 1;
	ObjectRef ref 			= 2;
	int32 row_id_idx		= 3;
	bool add_affected_rows 	= 4;
	bool is_cluster_table	= 5;
	// Align array index with the partition number
	repeated uint64 partition_table_ids = 6;
	repeated string partition_table_names = 7;
	int32 partition_idx = 8;
	int32 primary_key_idx = 9;
}

message Query {
	enum StatementType {
		UNKNOWN		= 0;
		SELECT		= 1;
		INSERT		= 2;
		DELETE		= 3;
		UPDATE		= 4;
		MERGE		= 5;
	}

	StatementType stmt_type		= 1;

	// A query may need to run in steps.   This in theory is not
	// necessary but often convenient and/or can be better optimized.
	// For example, executing non correctlated scalar subquery first
	// we can plug the value in the optmizer and the newly available
	// value may generate better plan.

	// Each step is simply a root node.  Root node refers to other
	// node as children and the whole step is a DAG.
	repeated int32 steps	= 2;

	// All the nodes.  It is OK to have dangle nodes, we only excute nodes
	// reachable from step roots.
	repeated Node nodes		= 3;

	// Bound Parameter for the query.
	repeated Expr params	= 4;

	// return head
	repeated string headings = 5;

	// load Tag
	bool loadTag = 6;
}

message TransationControl {
	enum TclType {
		BEGIN 		= 0;
		COMMIT 		= 1;
		ROLLBACK 	= 2;
	}
	//TransationControl type
	TclType tcl_type = 1;
	oneof action {
		TransationBegin begin 		= 2;
		TransationCommit commit 	= 3;
		TransationRollback rollback = 4;
	}
}

message TransationBegin {
	enum TransationMode {
		NONE 		= 0;
		READ_ONLY 	= 1;
		READ_WRITE 	= 2;
	}
	TransationMode mode = 1;
}

enum TransationCompletionType {
	CHAIN 		= 0;
	NO_CHAIN 	= 1;
	RELEASE 	= 2;
}
message TransationCommit {
	TransationCompletionType completion_type = 1;
}
message TransationRollback {
	TransationCompletionType completion_type = 1;
}

message Plan {
	oneof plan {
		Query query 			= 1;
		TransationControl tcl 	= 2;
		DataDefinition ddl 		= 3;
		DataControl	dcl			= 4;
	}
	int32 try_run_times = 5;
	bool is_prepare 	= 6;
}

message column{
	repeated Expr column = 1;
}

message DataControl {
	enum DclType {
		SET_VARIABLES	= 0;
		GRANT			= 1;
		REVOKE			= 2;
		DENY			= 3;
		PREPARE			= 4;
		EXECUTE			= 5;
		DEALLOCATE		= 6;
	}
	//DataDefinition type
	DclType dcl_type = 1;
	oneof control {
		SetVariables set_variables  = 2;
		Prepare prepare 			= 3;
		Execute execute				= 4;
		Deallocate deallocate 		= 5;
	}
}

message DataDefinition {
	enum DdlType {
		CREATE_DATABASE 	= 0;
		ALTER_DATABASE 		= 1;
		DROP_DATABASE		= 2;
		CREATE_TABLE 		= 3;
		ALTER_TABLE			= 4;
		DROP_TABLE			= 5;
		CREATE_INDEX		= 6;
		ALTER_INDEX			= 7;
		DROP_INDEX			= 8;
		TRUNCATE_TABLE		= 9;
		CREATE_VIEW			= 10;
		ALTER_VIEW			= 11;
		DROP_VIEW			= 12;
		SHOW_CREATEDATABASE = 13;
		SHOW_CREATETABLE 	= 14;
		SHOW_DATABASES		= 15;
		SHOW_TABLES			= 16;
		SHOW_COLUMNS		= 17;
		SHOW_INDEX			= 18;
		SHOW_VARIABLES		= 19;
		SHOW_WARNINGS		= 20;
		SHOW_ERRORS			= 21;
		SHOW_STATUS			= 22;
		SHOW_PROCESSLIST	= 23;
		SHOW_TABLE_STATUS 	= 24;
		SHOW_TARGET 		= 25;
		SHOW_COLLATION 		= 26;
		LOCK_TABLES         = 27;
		UNLOCK_TABLES       = 28;
		CREATE_SEQUENCE		= 29;
		ALTER_SEQUENCE		= 30;
		DROP_SEQUENCE		= 31;
		SHOW_SEQUENCES      = 32;

	}
	//DataDefinition type
	DdlType ddl_type = 1;

	//other show statement we will rewrite to a select statement
	//then we will get a Query
	//eg: 'show databases' will rewrite to 'select md.datname as `Database` from mo_database md'
	Query query = 2;

	oneof definition {
		CreateDatabase create_database 	= 3;
		AlterDatabase alter_database 	= 4;
		DropDatabase drop_database		= 5;
		CreateTable create_table		= 6;
		AlterTable alter_table 			= 7;
		DropTable drop_table			= 8;
		CreateIndex create_index 		= 9;
		AlterIndex alter_index 			= 10;
		DropIndex drop_index 			= 11;
		TruncateTable truncate_table	= 12;
		ShowVariables show_variables 	= 13;
		AlterView alter_view			= 14;
		LockTables lock_tables          = 15;
		UnLockTables unlock_tables      = 16;
		CreateSequence create_sequence  = 17;
		DropSequence   drop_sequence    = 18;
		AlterSequence  alter_sequence   = 19;

	}
}


message SubscriptionOption{
	string from = 1;
	string publication = 2;
}

message CreateDatabase {
	bool if_not_exists 	= 1;
	string database 	= 2;
	SubscriptionOption subscription_option = 3;
}

message AlterDatabase {
	bool if_exists 		= 1;
	string database 	= 2;
}

message DropDatabase {
	bool if_exists 		= 1;
	string database 	= 2;
	uint64 database_id	= 3;
}

message FkColName {
	repeated string cols = 1;
}

message CreateTable {
	bool if_not_exists 	= 1;
	bool temporary 		= 2;
	string database 	= 3;
	TableDef table_def 	= 4;
	repeated TableDef index_tables = 5;
	// we need the db/table name of foreign key when create table. but we don't need it in ForeignKeyDef
	repeated string fk_dbs = 6;
	repeated string fk_tables = 7;
	// we need column name when create table, but not in ForeignKeyDef
	repeated FkColName fk_cols = 8;
	repeated TableDef partition_tables = 9;// partition tables for partitions
}

message AlterTableDrop {
	enum Typ {
		COLUMN 		= 0;
		INDEX 		= 1;
		KEY 		= 2;
		PRIMARY_KEY	= 3;
		FOREIGN_KEY	= 4;
	}
	Typ typ		= 1;
	string name	= 2;
	string index_table_name = 3;
}

message AlterTableAddFk {
	string db_name 			= 1;
	string table_name		= 2;
	repeated string cols 	= 3;
	ForeignKeyDef fkey 		= 4;
}

message AlterTableAddIndex {
	string db_name = 1;
	string table_name = 2;
	string	origin_table_primary_key = 3;
	CreateTable indexInfo = 4;
	bool index_table_exist = 5;
}

message AlterTableDropIndex {
	string db_name = 1;
	string table_name = 2;
	string index_name = 3;
	string index_table_name = 4;
}

message AlterTableAlterIndex {
	string db_name = 1;
	string table_name = 2;
	string index_name = 3;
	bool visible = 4;
}

message AlterTableComment {
	string new_comment = 1;
}

message AlterTableName {
	string old_name = 1;
	string new_name = 2;
}

message AlterAddCol {
	string name = 1;
	string pre_name = 2;
	Type type = 3;
	int32 pos = 4;
}

message AlterDropCol {
	uint32 idx = 1;
	uint32 seq = 2;
}

message AlterTable {
	message Action {
		oneof action {
			AlterTableDrop drop 	= 1;
			AlterTableAddFk add_fk 	= 2;
			AlterTableAddIndex add_index = 3;
			AlterTableAlterIndex alter_index = 4;
			AlterTableComment alter_comment = 5;
			AlterTableName alter_name = 6;
			AlterAddCol add_col = 7;
			AlterDropCol drop_col = 8;
		};
	}
	string database			= 1;
	TableDef table_def 		= 2;
	bool is_cluster_table	= 3;
	repeated Action actions = 4;
}

message DropTable {
	bool if_exists 	= 1;
	string database = 2;
	string table 	= 3;
	repeated string index_table_names = 4;
	ClusterTable cluster_table = 5;
	uint64 table_id = 6;
	repeated uint64 foreign_tbl = 7;
	repeated string partition_table_names = 8;
	bool isView = 9;
	TableDef table_def 	= 10;
}

message AlterView {
	bool if_exists		= 1;
	string database 	= 2;
	TableDef table_def	= 4;
}

message CreateSequence {
	bool if_not_exists		=1;
	string database 		=2;
	TableDef table_def 		=3;
}

message DropSequence {
	bool if_exists 		= 1;
	string database 	=2;
	string table 		=3;
	uint64	table_id 	= 4;
}

message AlterSequence {
}

message CreateIndex {
	string database = 1;
	string table = 2;
	TableDef table_def 		= 3;
	string	origin_table_primary_key = 4;
	CreateTable index = 5;
	bool table_exist = 6;
}

message AlterIndex {
	string index = 1;
}

message DropIndex {
	string database = 1;
	string table = 2;
	string index_name = 3;
	string index_table_name = 4;
}

message TruncateTable {
	string database = 1;
	string table = 2;
	repeated string index_table_names = 3;
	repeated string partition_table_names = 4;
	ClusterTable cluster_table = 5;
	uint64 table_id = 6;
	repeated uint64 foreign_tbl = 7;
}

message ClusterTable{
	bool is_cluster_table = 1;//insert into a cluster table
	repeated uint32 accountIDs = 2;//insert data into the cluster table for every account
	int32 column_index_of_accountId = 3;//the column index of the account id in the cluster table
}

message ShowVariables {
	bool global 			= 1;
	repeated Expr where 	= 2;
}

message SetVariables {
	repeated SetVariablesItem items	= 1;
}

message SetVariablesItem {
	bool system     = 1;
	bool global     = 2;
	string name     = 3;
	Expr   value    = 4;
	Expr   reserved = 5;
}

message Prepare {
	string name		 			= 1;
	repeated ObjectRef schemas 	= 2;
	Plan   plan		 			= 3;
	repeated int32 param_types  = 4;
}

message Execute {
	string name 		= 1;
	repeated Expr args 	= 2;
}

message Deallocate {
	string name			= 1;
}

enum TableLockType {
	TableLockNone = 0;
	TableLockRead = 1;
	TableLockReadLocal = 2;
	TableLockWrite = 3;
	TableLockLowPriorityWrite = 4;
}

message TableLockInfo {
	TableLockType lockType = 1;
	TableDef tableDef     = 2;
}

message LockTables {
	repeated TableLockInfo tableLocks = 1;
}

message UnLockTables{}

message MetadataScanInfo {
	enum MetadataScanInfoType {
		COL_NAME      = 0;
		BLOCK_ID      = 1;
		OBJECT_NAME = 2; 
		ENTRY_STATE   = 3;
		SORTED        = 4;
		IS_HIDDEN = 5;
		META_LOC      = 6;
		DELTA_LOC     = 7;
		COMMIT_TS     = 8;
		CREATE_TS     = 9;
		DELETE_TS     = 10;
		SEG_ID         = 11;
		ROWS_CNT      = 12;
		NULL_CNT      = 13;
		COMPRESS_SIZE = 14;
		ORIGIN_SIZE   = 15;
		MIN           = 16;
		MAX           =  17;
	} 
	string ColName  = 1;
	bytes BlockId = 2;
	string ObjectName = 3;
	bool EntryState= 4;
	bool Sorted     = 5;
	bool IsHidden = 6;
	bytes MetaLoc     = 7;
	bytes DelLoc      = 8;
	bytes CommitTs    = 9;
	bytes CreateTs    = 10;
	bytes DeleteTs    = 11;
	bytes SegId        = 12;
	int64 RowCnt      = 13;
	int64 NullCnt     = 14;
	int64 CompressSize = 15;
	int64 OriginSize  = 16;
	bytes Min          = 17;
	bytes Max          = 18;
}
