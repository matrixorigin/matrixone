/*
 * Copyright 2021 Matrix Origin
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";
package plan;

import "github.com/gogo/protobuf/gogoproto/gogo.proto";
import "lock.proto";
import "timestamp.proto";

option go_package = "github.com/matrixorigin/matrixone/pkg/pb/plan";
option (gogoproto.sizer_all) = false;
option (gogoproto.protosizer_all) = true;

message Type {
	int32 id         = 1;
	bool notNullable = 2;
	bool auto_incr   = 3;
	int32 width      = 4;
	int32 scale      = 5;
	string table     = 6;
	string enumvalues = 7;
};

message	msgHeader {
	int32 msg_tag = 1;
	int32 msg_type =2;
};

// Literal: if a literal value can be reprensented by int64 or
// double, use that, otherwise store a string representation.
message Literal {
	bool isnull			= 1;
	oneof value {
		int32 i8val		= 2;  // pb have no int8
		int32 i16val	= 3;  // pb have no int16
		int32 i32val	= 4;
		int64 i64val	= 5;
		uint32 u8val 	= 6;  // pb have no uint8
		uint32 u16val 	= 7;  // pb have no uint16
		uint32 u32val 	= 8;
		uint64 u64val 	= 9;
		double dval 	= 10;
		string sval		= 11;
		bool bval 		= 12;
		float fval		= 13;
		int32 dateval 	= 14;
		int64 timeval 	= 15;
		int64 datetimeval			= 16;
		decimal64 decimal64val 		= 17;
		decimal128 decimal128val 	= 18;
		int64 timestampval 			= 19;
		string jsonval 				= 20;
		bool defaultval 			= 21;
		bool updateVal 				= 22;
		uint32 enumVal = 23; // pb have no uint32
	}
	bool isBin = 24;
	Expr src = 25; // if generated by replacing an existing expr
}

// Bounded param for prepared statement.  User fill on execution.
message ParamRef {
	int32 pos	= 1;
}

// Session variable ref, compiler should fold.
message VarRef {
	string name = 1;
	bool system = 2;
	bool global = 3;
}

// Reference a column in the proj list of a node.
message ColRef {
	int32	rel_pos	= 1;
	int32	col_pos	= 2;
	string	name	= 3;
	string	tbl_name = 4;
	string	db_name	= 5;
}

// Reference a column by its internal table id and column id
message RawColRef {
	uint64 tbl_id = 1;
	uint64 col_id = 2;
}

// Reference a correlated column in the proj list of a node.
message CorrColRef {
	int32 rel_pos	= 1;
	int32 col_pos	= 2;
	int32 depth		= 3;
}

// ExprList is a type of Expr
message ExprList {
	repeated Expr list = 1;
}

message MaxValue {
	string value = 1;
}

// TargetType used in cast function as target type
message TargetType {
}

// Reference a subquery
message SubqueryRef {
	enum Type {
		SCALAR		= 0;
		EXISTS		= 1;
		NOT_EXISTS	= 2;
		IN			= 3;
		NOT_IN		= 4;
		ANY			= 5;
		ALL			= 6;
	}

	Type typ		= 1;
	int32 node_id	= 2;
	string op		= 3;
	Expr child		= 4;
	int32 row_size	= 5;
}

// Object ref, reference a object in database, 4 part name.
message ObjectRef {
	int64 server	= 1;
	int64 db		= 2;
	int64 schema	= 3;
	int64 obj		= 4;
	string server_name	= 5;
	string db_name		= 6;
	string schema_name	= 7;
	string obj_name		= 8;
	string subscription_name = 9;
	PubInfo pub_info = 10;
}

message PubInfo {
	int32 tenant_id = 1;
}

message SubscriptionMeta{
	string name = 1; // pubName
	int32 account_id = 2; // pubAccountID
	string db_name = 3; // pubDbName
	string account_name = 4;// pubAccountName
	string sub_name = 5; // subName(subscription side db name)
}

message Function {
	// Function flags
	enum FuncFlag {
		NONE     = 0;
		// Internal function is generated by system, cannot
		// by called by user.
		INTERNAL = 1;

		// Function, by default is immutable.
		STABLE   = 2;
		VOLATILE = 4;

		// Nulls
		STRICT				= 8;
		PRODUCE_NULL		= 16;
		PRODUCE_NO_NULL		= 32;

		// Vararg, all trailing args must be of the same type.
		VARARG     = 64;

		// Window and Agg
		AGG        = 128;
		WIN_VALUE				= 256;
		WIN_ORDER				= 512;

		// Filter which can be applied on zonemaps
		ZONEMAPPABLE = 1024;
	}

	ObjectRef func		= 1;
	repeated Expr args	= 2;
}

message Expr {
	Type typ = 1 [(gogoproto.nullable) = false];
	oneof expr {
		Literal		lit		= 2;
		ParamRef	p		= 3;
		VarRef		v		= 4;
		ColRef		col 	= 5;
		RawColRef	raw		= 6;
		Function	f		= 7;
		WindowSpec	w		= 8;
		SubqueryRef	sub		= 9;
		CorrColRef	corr	= 10;
		TargetType	t		= 11;
		ExprList	list	= 12;
		MaxValue	max		= 13;
		LiteralVec	vec	= 14;
	}

	int32 aux_id = 15;
	double ndv = 16;
	double selectivity = 17;
}

message LiteralVec {
	int32 len	= 1;
	bytes data	= 2;
}

enum CompressType {
	None 	= 0;
	Lz4 	= 1;
}

message decimal64 {
	int64 a = 1;
}

message decimal128 {
	int64 a = 1;
	int64 b = 2;
}

message ResultColDef {
	repeated ColDef ResultCols = 1;
}

message ColDef {
	uint64 col_id		= 1;
	string name 		= 2;
	bool hidden			= 3;
	CompressType alg 	= 4;
	Type typ			= 5 [(gogoproto.nullable) = false];
	bool not_null		= 6;
	Default default 	= 7;
	string comment		= 8;
	OnUpdate on_update  = 9;
	bool low_card 		= 10;
	uint32 seqnum		= 11;

	// XXX: Deprecated and to be removed soon.
	bool clusterBy		= 12;
	bool primary        = 13;
	int32 pkidx 		= 14;
	bool headers = 15;
	string header = 16;

	string tbl_name = 17;
	string db_name = 18;
}

message Default {
	Expr expr = 1;
	string origin_string = 2;

	// XXX: Deprecated and to be removed soon.
	bool null_ability = 3;
}

message OnUpdate {
	Expr expr = 1;
	string origin_string = 2;
}

message IndexOption {
	bool create_extra_table = 1;
}

message PrimaryKeyDef {
	// currently not used
	repeated uint64 cols	= 1;
	// currently not used
	uint64 pkey_col_id		= 2;
	// currently not used
	IndexOption option		= 3;

	// Composed primary key column name: __mo_cpkey
	string pkey_col_name = 4;
	// XXX: Deprecated and to be removed soon.
	repeated string names = 5;
	// Composite primary key column definition
	ColDef comp_pkey_col = 6;
}

message IndexDef {
	// Generate UUID for each index, currently not used
	string idx_id			       = 1;
	string index_name        = 2;
	// The constituent columns of the index
	repeated string parts    = 3;
	bool unique				       = 4;
	string index_table_name  = 5;
	bool table_exist        = 6;
	string comment          = 7;
	bool visible          = 8;
	// currently not used
	IndexOption option		  = 9;
	string index_algo = 10;
	string index_algo_table_type = 11;
	string index_algo_params=12;
}


message ForeignKeyDef {
	enum RefAction {
		RESTRICT	= 0;
		CASCADE		= 1;
		SET_NULL	= 2;
		SET_DEFAULT	= 3;
		NO_ACTION	= 4;
	}

	string name						= 1;
	repeated uint64 cols			= 2;
	// Foreign key parent table Id
	uint64 foreign_tbl				= 3;
	// Foreign key parent table dependent column colids
	repeated uint64 foreign_cols	= 4;
	RefAction on_delete				= 5;
	RefAction on_update				= 6;
}

message CheckDef {
	string name	= 1;
	// Name for anonymous constraints, __mo_chk_[INDEX_ID]
	Expr check	= 2;
}

message ClusterByDef {
	// XXX: Deprecated and to be removed soon.
	string name = 1;
	// Composite cluster by column definition
	ColDef comp_cbkey_col = 2;
}

message PropertyDef {
	string key 		= 1;
	string value 	= 2;
}

message Property {
	string key 		= 1;
	string value 	= 2;
}

message PropertiesDef {
	repeated Property properties 	= 1;
}


enum PartitionType {
	KEY = 0;
	LINEAR_KEY = 1;
	HASH = 2;
	LINEAR_HASH = 3;
	RANGE = 4;
	RANGE_COLUMNS = 5;
	LIST = 6;
	LIST_COLUMNS = 7;
}

message PartitionByDef {
	PartitionType type = 1;
	PartitionExpr partition_expr = 2;
	Expr partition_expression = 3;
	PartitionColumns partition_columns = 4;
	uint64 partitionNum = 5;
	repeated PartitionItem partitions = 6;
	int64 algorithm = 7;
	bool is_sub_partition = 8;
	string partition_msg = 9;
	repeated string partition_table_names = 10;
}

message PartitionExpr {
	Expr expr = 1;
	string expr_str = 2;
	// string expr_fmt_str = 3;
}

message PartitionColumns {
	repeated Expr columns = 1;
	repeated string partition_columns = 2;
	// repeated string partition_fmt_columns = 3;
}

message PartitionItem {
	string partition_name = 1;
	uint32 ordinal_position = 2;
	string description = 3;
	string comment = 4;
	repeated Expr less_than = 5;
	repeated Expr in_values = 6;
	string partition_table_name = 7;// the table name of a partition
}


message ViewDef {
	string view  = 1;
}

message TableDef {
	// XXX: Deprecated and to be removed soon.
	message DefType {
		oneof def {
			PropertiesDef properties	= 1;
		}
	}

	uint64 tbl_id			= 1;
	string name				= 2;
	bool hidden				= 3;
	repeated ColDef cols	= 4;
	string table_type 		= 5;
	string createsql 		= 6;
	TableFunction tbl_func	= 7;
	uint32 version 			= 8;

	PrimaryKeyDef pkey				= 11;
	repeated IndexDef indexes = 12;
	repeated ForeignKeyDef fkeys	= 13;
	repeated uint64 ref_child_tbls	= 14;
	repeated CheckDef checks		= 15;

	PartitionByDef partition		= 21;
	ClusterByDef cluster_by		= 22;
	repeated PropertyDef props	= 23;
	ViewDef view_sql			= 24;

	// XXX: Deprecated and to be removed soon.
	repeated DefType defs	= 25;
	map<string, int32> name2col_index = 26;
	bool isLocked = 27;
	TableLockType tableLockType = 28;
	bool is_temporary = 29;

	uint64 auto_incr_offset = 30;
	bool is_dynamic = 31;

	string db_name = 32;
}

message TableFunction{
	string name = 1;
	bytes param = 2;
}

enum ShuffleType {
	Hash = 0;
	Range = 1;
}

enum ShuffleMethod {
	Normal = 0;
	Reuse = 1;
	Reshuffle = 2;
}

enum ShuffleTypeForMultiCN {
	Simple = 0;
	Hybrid = 1;
}

message HashMapStats{
	// hashmap size for nodes which build a hashmap
	double hashmap_size		= 1;
	bool hashOnPK = 2;

	// for group by and join node with big hashmap, use shuffle
	// shuffle on which column. choose a column with max ndv
	bool shuffle = 3;
	int32 shuffleColIdx = 4;
	// shuffle type
	ShuffleType shuffleType = 5;
	ShuffleTypeForMultiCN shuffleTypeForMultiCN = 6;
	// for range shuffle on integer column, need to know its min and max value
	int64 shuffleColMin = 7;
	int64 shuffleColMax = 8;
	ShuffleMethod shuffleMethod = 9;
	int64 nullcnt=10;
	repeated double ranges	= 11;
}

message Stats {
	//for scan, number of blocks to read from S3
	int32  block_num        = 1;
	//for scan, cost of reading from S3, basically the read lines
	//for other nodes, it means the estimated cost of current node
	double cost				= 2;
	//number of output lines
	double outcnt			= 3;
	// average size of one row, currently not used
	double rowsize	        = 4;
	//for scan, this means total count of all table, before filtering
	double table_cnt = 5;
	//for scan, selectivity means outcnt divide total count
	double selectivity = 6;
	bool forceOneCN = 7;

	HashMapStats hashmapStats = 8;
}

message RowsetExpr {
	int32 row_pos = 1;
	int32 pos = 2;
	Expr expr = 3;
}

message ColData {
	repeated RowsetExpr data = 1;
}

message RowsetData {
	repeated ColData cols	= 1;
	int32 row_count = 2;
}

message OrderBySpec {
	enum OrderByFlag {
		INTERNAL    = 0;
		ASC  		= 1;
		DESC 		= 2;
		NULLS_FIRST = 4;
		NULLS_LAST  = 8;
		UNIQUE      = 16;
	}

	Expr expr = 1;
	string collation = 2;
	OrderByFlag flag = 3;
}

message WindowSpec {
	Expr window_func = 1;
	repeated Expr partition_by = 2;
	repeated OrderBySpec order_by = 3;
	FrameClause frame = 4;
	string name = 5;
}

message SampleFuncSpec {
	int32 Rows = 1;
	double Percent = 2;
	bool UsingRow = 3;
}

message FrameClause {
	enum FrameType {
		ROWS = 0;
		RANGE = 1;
	}
	FrameType type = 1;
	FrameBound start = 2;
	FrameBound end = 3;
}

message FrameBound {
	enum BoundType {
		FOLLOWING = 0;
		PRECEDING = 1;
		CURRENT_ROW = 2;
	}
	BoundType type = 1;
	bool unBounded = 2;
	Expr val = 3;
}

message OnDuplicateKeyCtx {
	repeated string attrs = 1;
	int32 insert_col_count = 2;
	repeated Expr unique_col_check_expr = 3;
	repeated string unique_cols = 4;
	repeated int32 on_duplicate_idx		= 5;
	map<string, Expr> on_duplicate_expr	= 6;
	bool is_ignore 						= 7;
	string table_name         = 8;
	uint64 table_id           = 9;
	uint32 table_version			= 10;
}

message InsertCtx {
	ObjectRef ref			= 1;
	bool add_affected_rows 	= 2;
	bool is_cluster_table	= 3;
	TableDef table_def		= 4;
	// Align array index with the partition number
	repeated uint64 partition_table_ids = 5;
	repeated string partition_table_names = 6;
	int32 partition_idx = 7;
}

message ReplaceCtx {
	ObjectRef ref			= 1;
	bool add_affected_rows 	= 2;
	bool is_cluster_table	= 3;
	TableDef table_def		= 4;
	string delete_cond    = 5;
	// Align array index with the partition number
	repeated uint64 partition_table_ids = 6;
	repeated string partition_table_names = 7;
	int32 partition_idx = 8;
}

message AnalyzeInfo {
	int64 input_rows = 1;
	int64 output_rows = 2;
	int64 input_size = 3;
	int64 output_size = 4;
	int64 time_consumed = 5;
	int64 memory_size = 6;
	int64 wait_time_consumed = 7;
	int64 diskIO = 8;
	int64 s3IO_byte = 9;
	int64 s3IO_input_count = 10;
	int64 s3IO_output_count = 11;
	int64 networkIO = 12;
	int64 scanTime = 13;
	int64 insertTime = 14;
	repeated int64 time_consumed_array_major = 15;
	repeated int64 time_consumed_array_minor = 16;
}

message PartitionPrune {
	bool isPruned = 1;
	repeated PartitionItem selected_partitions = 2;
}

message OriginTableMessageForFuzzy {
	string ParentTableName = 1;
	repeated ColDef ParentUniqueCols = 2;
}

message Node {
	enum NodeType {
		UNKNOWN = 0;
		// Node Types

		// Scans
		VALUE_SCAN = 1;
		TABLE_SCAN = 2;
		FUNCTION_SCAN = 3;
		EXTERNAL_SCAN = 4;
		MATERIAL_SCAN = 5;
		SOURCE_SCAN = 6;

		// Proj, for convenience
		PROJECT = 10;
		// External function call (UDF)
		EXTERNAL_FUNCTION = 11;

		// Material, CTE, etc.
		MATERIAL = 20;
		RECURSIVE_CTE = 21;
		SINK = 22;
		SINK_SCAN = 23;
		RECURSIVE_SCAN = 24;

		// Proper Relational Operators
		AGG = 30;
		DISTINCT = 31;
		FILTER = 32;
		JOIN = 33;
		SAMPLE = 34;
		SORT = 35;
		UNION = 36;
		UNION_ALL = 37;
		UNIQUE = 38;
		WINDOW = 39;

		// Physical tuple mover
		BROADCAST = 40;
		SPLIT = 41;
		GATHER = 42;

		// Misc
		ASSERT = 50;

		//
		INSERT = 51;
		DELETE = 52;
		REPLACE = 53;
		//
		LOCK_OP = 54;

		//
		INTERSECT = 55;
		INTERSECT_ALL = 56;
		MINUS = 57;
		MINUS_ALL = 58;

		//
		ON_DUPLICATE_KEY = 59;
		PRE_INSERT = 60;
		PRE_DELETE = 61;
		// the node which build insert batch for hidden table(unique key)
		PRE_INSERT_UK = 62;
		PRE_INSERT_SK = 63;
		//
		TIME_WINDOW = 64;
		FILL = 65;
		PARTITION = 66;
		FUZZY_FILTER = 67;
	}

	enum JoinType {
		INNER	= 0;
		LEFT	= 1;
		RIGHT	= 2;
		OUTER	= 3;
		SEMI	= 4;
		ANTI	= 5;
		SINGLE	= 6;
		MARK	= 7;
		APPLY	= 8;
		INDEX = 9;
	}

	enum AggMode {
		FULL = 0;
		BOTTOM = 1;
		TOP = 2;
	}

	enum FillType {
		NONE = 0;
		PREV = 1;
		NEXT = 2;
		NULL = 3;
		VALUE = 4;
		LINEAR = 5;
	}

	NodeType node_type = 1;
	int32 node_id = 2;
	Stats stats = 3;
	repeated int32 children = 4;

	// PROJECT
	repeated Expr project_list = 5;

	// JOIN
	JoinType join_type = 6;
	repeated Expr on_list = 7;
	bool build_on_left = 8;

	// FILTER
	repeated Expr filter_list = 9;

	// AGG
	repeated Expr group_by = 10;
	repeated Expr grouping_set = 11;
	repeated Expr agg_list = 12;

	// WINDOW
	repeated Expr win_spec_list = 13;

	// SORT
	repeated OrderBySpec order_by = 14;

	// LIMIT
	Expr limit = 15;
	Expr offset = 16;

	TableDef table_def = 17;
	ObjectRef obj_ref = 18;
	ObjectRef parent_obj_ref = 19;
	RowsetData rowset_data = 20;

	string extra_options = 22;
	DeleteCtx delete_ctx = 23;

	repeated int32 binding_tags = 24;

	AnalyzeInfo analyze_info = 25;

	repeated Expr tbl_func_expr_list = 26;

	ClusterTable cluster_table = 28;
	bool not_cacheable = 29;
	InsertCtx insert_ctx = 30;
	ReplaceCtx replace_ctx = 31;

	// used to connect two plans[steps]
	repeated int32 source_step = 32;

	PreDeleteCtx pre_delete_ctx = 33;
	PreInsertCtx pre_insert_ctx = 34;
	// build unique key batch before insert into hidden table which keep the unique key
	PreInsertUkCtx pre_insert_uk_ctx = 35;
	OnDuplicateKeyCtx on_duplicate_key = 36;

	bool IsEnd = 37;
	repeated LockTarget lock_targets = 38;
	repeated Expr block_filter_list = 39;

	// Runtime filters
	repeated RuntimeFilterSpec runtime_filter_probe_list = 40;
	repeated RuntimeFilterSpec runtime_filter_build_list = 41;

	bytes uuid = 42;
	bool recursive_sink = 43;
	ExternScan extern_scan = 44;
	PartitionPrune partition_prune = 45;

	PreInsertUkCtx pre_insert_sk_ctx = 46;
	Expr interval = 47;
	Expr sliding = 48;

	FillType fill_type = 49;
	repeated Expr fill_val = 50;

	// sample function related.
	SampleFuncSpec sample_func = 51;

	int32 window_idx = 52;
	repeated Expr onUpdateExprs = 53;
	OriginTableMessageForFuzzy fuzzymessage = 54;

	//for message
	repeated msgHeader send_msg_list = 55;
	repeated msgHeader recv_msg_list = 56;

	Snapshot scan_snapshot = 57;
}

// Snapshot Represents a snapshot of the database
message Snapshot {
	// The timestamp of the snapshot
	timestamp.Timestamp TS = 1;
	// Tenant information for creating snapshots
	SnapshotTenant tenant = 2;
}

// Tenant information for creating snapshots
message SnapshotTenant {
	string tenantName = 1;
	uint32 tenantID = 2;
}


message ExternScan {
    int32 type = 1;
    string data = 2;
    string format = 3;
    uint64 ignored_lines = 4;
    bytes  enclosed_by = 5;
    string terminated = 6;
	string json_type = 7;
}

message LockTarget {
	uint64 table_id           	= 1;
	int32 primary_col_idx_in_bat  = 2;
	Type primary_col_typ          = 3 [(gogoproto.nullable) = false];
	int32 refresh_ts_idx_in_bat   = 4;
	int32 filter_col_idx_in_bat   = 5;
	bool lock_table 				= 6;
	bool is_partition_table = 7;
	repeated uint64 partition_table_ids = 8;
	bool                block   = 9;
	lock.LockMode Mode  = 10;
}

message PreInsertUkCtx {
	// index of columns(parts of unique key) in pre batch
	repeated int32 columns 	= 1;
	int32 pk_column 		= 2;
	Type pk_type 			= 3 [(gogoproto.nullable) = false];
	Type uk_type			= 4 [(gogoproto.nullable) = false];
}

message PreDeleteCtx {
	//the indexes of row_id&pk column in the batch
	repeated int32 idx = 1;
}

message PreInsertCtx {
	ObjectRef ref 			= 1;
	TableDef table_def 		= 2;
	bool has_auto_col		= 3;
	bool is_update			= 4;
}

message RuntimeFilterSpec {
	int32 tag = 1;
	bool match_prefix = 2;
	int32 upper_limit = 3;
	Expr expr = 4;
	bool handled = 5;
}

message IdList {
	repeated int64 list = 1;
}

message ColPosMap {
	map<string, int32> map = 1;
}

message DeleteCtx {
	bool can_truncate 		= 1;
	ObjectRef ref 			= 2;
	int32 row_id_idx		= 3;
	bool add_affected_rows 	= 4;
	bool is_cluster_table	= 5;
	// Align array index with the partition number
	repeated uint64 partition_table_ids = 6;
	repeated string partition_table_names = 7;
	int32 partition_idx = 8;
	int32 primary_key_idx = 9;
	TruncateTable truncate_table = 10;
	TableDef table_def 	= 11;
}

message Query {
	enum StatementType {
		UNKNOWN		= 0;
		SELECT		= 1;
		INSERT		= 2;
		REPLACE   = 3;
		DELETE		= 4;
		UPDATE		= 5;
		MERGE		= 6;
	}

	StatementType stmt_type		= 1;

	// A query may need to run in steps.   This in theory is not
	// necessary but often convenient and/or can be better optimized.
	// For example, executing non correctlated scalar subquery first
	// we can plug the value in the optmizer and the newly available
	// value may generate better plan.

	// Each step is simply a root node.  Root node refers to other
	// node as children and the whole step is a DAG.
	repeated int32 steps	= 2;

	// All the nodes.  It is OK to have dangle nodes, we only excute nodes
	// reachable from step roots.
	repeated Node nodes		= 3;

	// Bound Parameter for the query.
	repeated Expr params	= 4;

	// return head
	repeated string headings = 5;

	// load Tag
	bool loadTag = 6;

	//detectSqls are sqls detect fk self refer constraint
	repeated string detectSqls= 7;
}

message TransationControl {
	enum TclType {
		BEGIN 		= 0;
		COMMIT 		= 1;
		ROLLBACK 	= 2;
	}
	//TransationControl type
	TclType tcl_type = 1;
	oneof action {
		TransationBegin begin 		= 2;
		TransationCommit commit 	= 3;
		TransationRollback rollback = 4;
	}
}

message TransationBegin {
	enum TransationMode {
		NONE 		= 0;
		READ_ONLY 	= 1;
		READ_WRITE 	= 2;
	}
	TransationMode mode = 1;
}

enum TransationCompletionType {
	CHAIN 		= 0;
	NO_CHAIN 	= 1;
	RELEASE 	= 2;
}
message TransationCommit {
	TransationCompletionType completion_type = 1;
}
message TransationRollback {
	TransationCompletionType completion_type = 1;
}

message Plan {
	oneof plan {
		Query query 			= 1;
		TransationControl tcl 	= 2;
		DataDefinition ddl 		= 3;
		DataControl	dcl			= 4;
	}
	int32 try_run_times = 5;
	bool is_prepare 	= 6;
}

message column{
	repeated Expr column = 1;
}

message DataControl {
	enum DclType {
		SET_VARIABLES	= 0;
		GRANT			= 1;
		REVOKE			= 2;
		DENY			= 3;
		PREPARE			= 4;
		EXECUTE			= 5;
		DEALLOCATE		= 6;
		CREATE_ACCOUNT  = 7;
		ALTER_ACCOUNT   = 8;
		DROP_ACCOUNT    = 9;
	}
	//DataDefinition type
	DclType dcl_type = 1;
	oneof control {
		SetVariables set_variables  = 2;
		Prepare prepare 			= 3;
		Execute execute				= 4;
		Deallocate deallocate 		= 5;
		OtherDCL other = 6;
	}
}

message DataDefinition {
	enum DdlType {
		CREATE_DATABASE 	= 0;
		ALTER_DATABASE 		= 1;
		DROP_DATABASE		= 2;
		CREATE_TABLE 		= 3;
		ALTER_TABLE			= 4;
		DROP_TABLE			= 5;
		CREATE_INDEX		= 6;
		ALTER_INDEX			= 7;
		DROP_INDEX			= 8;
		TRUNCATE_TABLE		= 9;
		CREATE_VIEW			= 10;
		ALTER_VIEW			= 11;
		DROP_VIEW			= 12;
		SHOW_CREATEDATABASE = 13;
		SHOW_CREATETABLE 	= 14;
		SHOW_DATABASES		= 15;
		SHOW_TABLES			= 16;
		SHOW_COLUMNS		= 17;
		SHOW_INDEX			= 18;
		SHOW_VARIABLES		= 19;
		SHOW_WARNINGS		= 20;
		SHOW_ERRORS			= 21;
		SHOW_STATUS			= 22;
		SHOW_PROCESSLIST	= 23;
		SHOW_TABLE_STATUS 	= 24;
		SHOW_TARGET 		= 25;
		SHOW_COLLATION 		= 26;
		LOCK_TABLES         = 27;
		UNLOCK_TABLES       = 28;
		CREATE_SEQUENCE		= 29;
		ALTER_SEQUENCE		= 30;
		DROP_SEQUENCE		= 31;
		SHOW_SEQUENCES      = 32;
		SHOW_CONNECTORS = 33;
		SHOW_UPGRADE = 34;
	}
	//DataDefinition type
	DdlType ddl_type = 1;

	//other show statement we will rewrite to a select statement
	//then we will get a Query
	//eg: 'show databases' will rewrite to 'select md.datname as `Database` from mo_database md'
	Query query = 2;

	oneof definition {
		CreateDatabase create_database 	= 3;
		AlterDatabase alter_database 	= 4;
		DropDatabase drop_database		= 5;
		CreateTable create_table		= 6;
		AlterTable alter_table 			= 7;
		DropTable drop_table			= 8;
		CreateIndex create_index 		= 9;
		AlterIndex alter_index 			= 10;
		DropIndex drop_index 			= 11;
		TruncateTable truncate_table	= 12;
		ShowVariables show_variables 	= 13;
		AlterView alter_view			= 14;
		LockTables lock_tables          = 15;
		UnLockTables unlock_tables      = 16;
		CreateSequence create_sequence  = 17;
		DropSequence   drop_sequence    = 18;
		AlterSequence  alter_sequence   = 19;

	}
}


message SubscriptionOption{
	string from = 1;
	string publication = 2;
}

message CreateDatabase {
	bool if_not_exists 	= 1;
	string database 	= 2;
	SubscriptionOption subscription_option = 3;
	string sql = 4;
}

message AlterDatabase {
	bool if_exists 		= 1;
	string database 	= 2;
}

message DropDatabase {
	bool if_exists 		= 1;
	string database 	= 2;
	uint64 database_id	= 3;
	// drop database should delete fk records related to this database
	// from mo_foreign_keys
	string updateFkSql = 4;
	// drop database should check mo_foreign_keys to find fk records
	// that refer to this database before dropping the database
	string checkFKSql = 5;
}

message FkColName {
	repeated string cols = 1;
}

/* ForeignKeyInfo holds the fk forward reference.

	Example: t2(b) --fk--> t1(a) but t1 defined after t2

		set foreign_key_checks=0;

		create table t2(b int, constraint c1 foreign key (b) references t1(a));

		create table t1(a int primary key);

	The reason we need ForeignKeyInfo instead of using ForeignKeyDef is that:

		ForeignKeyDef only has table id, column id that does not exist in handling fk forward reference.
		ForeignKeyDef does not have database name, table name and column names,
		ForeignKeyInfo also has the ForeignKeyDef internally that holds the child table fk definition.
 */
message ForeignKeyInfo{
	string db = 1; // database name of child table
	string table = 2; // child table name
	FkColName cols = 3; // fk names in child table
	FkColName colsReferred = 4; // referred names in parent table
	ForeignKeyDef def = 5; //child table fk def
}

message CreateTable {
	bool if_not_exists 	= 1;
	bool temporary 		= 2;
	string database 	= 3;
	bool replace        = 4;
	TableDef table_def 	= 5;
	repeated TableDef index_tables = 6;
	// we need the db/table name of foreign key when create table. but we don't need it in ForeignKeyDef
	repeated string fk_dbs = 7;
	repeated string fk_tables = 8;
	// we need column name when create table, but not in ForeignKeyDef
	repeated FkColName fk_cols = 9;
	repeated TableDef partition_tables = 10;// partition tables for partitions
	string create_as_select_sql = 11;
	// create table may insert fk records related to this table
	// into mo_foreign_keys
	repeated string updateFkSqls = 12;
	// fks forward reference to me
	repeated ForeignKeyInfo fksReferToMe = 13;
}

message AlterTableDrop {
	enum Typ {
		COLUMN 		= 0;
		INDEX 		= 1;
		KEY 		= 2;
		PRIMARY_KEY	= 3;
		FOREIGN_KEY	= 4;
	}
	Typ typ		= 1;
	string name	= 2;
	string index_table_name = 3;
}

message AlterTableAddFk {
	string db_name 			= 1;
	string table_name		= 2;
	repeated string cols 	= 3;
	ForeignKeyDef fkey 		= 4;
}

message AlterTableAddIndex {
	string db_name = 1;
	string table_name = 2;
	string	origin_table_primary_key = 3;
	CreateTable indexInfo = 4;
	bool index_table_exist = 5;
}

message AlterTableDropIndex {
	string db_name = 1;
	string table_name = 2;
	string index_name = 3;
	string index_table_name = 4;
}

message AlterTableAlterIndex {
	string db_name = 1;
	string table_name = 2;
	string index_name = 3;
	bool visible = 4;
}

message AlterTableAlterReIndex {
	string db_name = 1;
	string table_name = 2;
	string index_name = 3;
	int64 index_algo_param_list = 4;
}

message AlterTableAddPartition {
	repeated PartitionItem definitions = 1;
	repeated TableDef partition_tables = 2;
	PartitionByDef PartitionDef = 3;
}

message AlterTableComment {
	string new_comment = 1;
}

message AlterTableName {
	string old_name = 1;
	string new_name = 2;
}

message AlterAddColumn {
	string name = 1;
	string pre_name = 2;
	Type type = 3 [(gogoproto.nullable) = false];
	int32 pos = 4;
}

message AlterDropColumn {
	uint32 idx = 1;
	uint32 seq = 2;
}

message AlterTable {
	enum AlgorithmType {
		DEFAULT = 0;
		COPY  = 1;
		INSTANT  = 2;
		INPLACE  = 3;
	}
	message Action {
		oneof action {
			AlterTableDrop drop 	= 1;
			AlterTableAddFk add_fk 	= 2;
			AlterTableAddIndex add_index = 3;
			AlterTableAlterIndex alter_index = 4;
			AlterTableComment alter_comment = 5;
			AlterTableName alter_name = 6;
			AlterAddColumn add_column = 7;
			AlterDropColumn drop_column = 8;
			AlterTableAlterReIndex alter_reindex = 9;
			AlterTableAddPartition addPartition = 10;
		};
	}
	string database			      = 1;
	TableDef table_def 		    = 2;
	TableDef copy_table_def 	= 3;
	bool is_cluster_table	    = 4;
	repeated Action actions   = 5;
	AlgorithmType algorithm_type = 6;
	string create_tmp_table_sql = 7;
	string insert_tmp_data_sql = 8;
	string create_table_sql = 9;
	string insert_data_sql = 10;
	map<uint64, ColDef> change_tbl_colId_map = 11;
	//detect fk self refer constraint
	repeated string detectSqls= 12;
	// alter table may insert fk records related to this table
	// into mo_foreign_keys
	repeated string updateFkSqls = 13;
}

message DropTable {
	bool if_exists 	= 1;
	string database = 2;
	string table 	= 3;
	repeated string index_table_names = 4;
	ClusterTable cluster_table = 5;
	uint64 table_id = 6;
	repeated uint64 foreign_tbl = 7;
	repeated string partition_table_names = 8;
	bool isView = 9;
	TableDef table_def 	= 10;
	// drop table may delete fk records related to this table
	// into mo_foreign_keys
	repeated string updateFkSqls = 11;
	//fk child table id that refers to me
	repeated uint64 fkChildTblsReferToMe = 12;
}

message AlterView {
	bool if_exists		= 1;
	string database 	= 2;
	TableDef table_def	= 4;
}

message CreateSequence {
	bool if_not_exists		=1;
	string database 		=2;
	TableDef table_def 		=3;
}

message DropSequence {
	bool if_exists 		= 1;
	string database 	=2;
	string table 		=3;
	uint64	table_id 	= 4;
}

message AlterSequence {
	bool if_exists		=1;
	string database 		=2;
	TableDef table_def 		=3;
}

message CreateIndex {
	string database = 1;
	string table = 2;
	TableDef table_def 		= 3;
	string	origin_table_primary_key = 4;
	CreateTable index = 5;
	bool table_exist = 6;
}

message AlterIndex {
	string index = 1;
}

message DropIndex {
	string database = 1;
	string table = 2;
	string index_name = 3;
	string index_table_name = 4;
}

message TruncateTable {
	string database = 1;
	string table = 2;
	repeated string index_table_names = 3;
	repeated string partition_table_names = 4;
	ClusterTable cluster_table = 5;
	uint64 table_id = 6;
	repeated uint64 foreign_tbl = 7;
	bool	is_delete = 8;
}

message ClusterTable{
	bool is_cluster_table = 1;//insert into a cluster table
	repeated uint32 accountIDs = 2;//insert data into the cluster table for every account
	int32 column_index_of_accountId = 3;//the column index of the account id in the cluster table
}

message ShowVariables {
	bool global 			= 1;
	repeated Expr where 	= 2;
}

message SetVariables {
	repeated SetVariablesItem items	= 1;
}

message SetVariablesItem {
	bool system     = 1;
	bool global     = 2;
	string name     = 3;
	Expr   value    = 4;
	Expr   reserved = 5;
}

message Prepare {
	string name		 			= 1;
	repeated ObjectRef schemas 	= 2;
	Plan   plan		 			= 3;
	repeated int32 param_types  = 4;
}

message Execute {
	string name 		= 1;
	repeated Expr args 	= 2;
}

message Deallocate {
	string name			= 1;
}

message OtherDCL {
	repeated int32 paramTypes = 1;
}

enum TableLockType {
	TableLockNone = 0;
	TableLockRead = 1;
	TableLockReadLocal = 2;
	TableLockWrite = 3;
	TableLockLowPriorityWrite = 4;
}

message TableLockInfo {
	TableLockType lockType = 1;
	TableDef tableDef     = 2;
}

message LockTables {
	repeated TableLockInfo tableLocks = 1;
}

message UnLockTables{}

message MetadataScanInfo {
	enum MetadataScanInfoType {
		COL_NAME      = 0;
		OBJECT_NAME   = 1;
		IS_HIDDEN     = 2;
		OBJ_LOC       = 3;
		CREATE_TS     = 4;
		DELETE_TS     = 5;
		ROWS_CNT      = 6;
		NULL_CNT      = 7;
		COMPRESS_SIZE = 8;
		ORIGIN_SIZE   = 9;
		MIN           = 10;
		MAX           = 11;
		SUM           = 12;
	}
	string col_name     = 1;
	string object_name  = 2;
	bool is_hidden      = 3;
	bytes obj_loc       = 4;
	bytes create_ts     = 5;
	bytes delete_ts     = 6;
	int64 row_cnt       = 7;
	int64 null_cnt      = 8;
	int64 compress_size = 9;
	int64 origin_size   = 10;
	bytes zone_map      = 11;
}
