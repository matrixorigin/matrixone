/* 
 * Copyright 2021 Matrix Origin
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";
package plan;

import "github.com/gogo/protobuf/gogoproto/gogo.proto";

option go_package = "github.com/matrixorigin/matrixone/pkg/pb/plan";
option (gogoproto.sizer_all) = false;
option (gogoproto.protosizer_all) = true;

message Type {
	int32 id            = 1;
	bool notNullable	= 2;
	bool auto_incr      = 3;
	int32 width			= 4;
	int32 precision		= 5;
	int32 size 			= 6;
	int32 scale 		= 7;
	string table 		= 8;
};

// Const: if a const value can be reprensented by int64 or
// double, use that, otherwise store a string representation.
message Const {
	bool isnull			= 1;
	oneof value {
		int32 i8val		= 2;  // pb have no int8
		int32 i16val	= 3;  // pb have no int16
		int32 i32val	= 4;
		int64 i64val	= 5;
		uint32 u8val 	= 6;  // pb have no uint8
		uint32 u16val 	= 7;  // pb have no uint16
		uint32 u32val 	= 8;
		uint64 u64val 	= 9;
		double dval 	= 10;
		string sval		= 11;
		bool bval 		= 12;
		float fval		= 13;
		int32 dateval 	= 14;
		int64 timeval 	= 15;
		int64 datetimeval			= 16;
		decimal64 decimal64val 		= 17;
		decimal128 decimal128val 	= 18;
		int64 timestampval 			= 19;
		string jsonval 				= 20;
		bool defaultval 			= 21;
		bool updateVal 				= 22;
	}
	bool isBin = 23;
	Expr src = 24; // if generated by replacing an existing expr
}

// Bounded param for prepared statement.  User fill on execution.
message ParamRef {
	int32 pos	= 1;
}

// Session variable ref, compiler should fold.
message VarRef {
	string name = 1;
	bool system = 2;
	bool global = 3;
}

// Reference a column in the proj list of a node.
message ColRef {
	int32	rel_pos	= 1;
	int32	col_pos	= 2;
	string	name	= 3;
}

// Reference a column by its internal table id and column id
message RawColRef {
	uint64 tbl_id = 1;
	uint64 col_id = 2;
}

// Reference a correlated column in the proj list of a node.
message CorrColRef {
	int32 rel_pos	= 1;
	int32 col_pos	= 2;
	int32 depth		= 3;
}

// ExprList is a type of Expr
message ExprList {
	repeated Expr list = 1;
}

message MaxValue {
	string value = 1;
}

// TargetType used in cast function as target type
message TargetType {
	Type typ = 1;
}

// Reference a subquery
message SubqueryRef {
	enum Type {
		SCALAR		= 0;
		EXISTS		= 1;
		NOT_EXISTS	= 2;
		IN			= 3;
		NOT_IN		= 4;
		ANY			= 5;
		ALL			= 6;
	}

	Type typ		= 1;
	int32 node_id	= 2;
	string op		= 3;
	Expr child		= 4;
	int32 row_size	= 5;
}

// Object ref, reference a object in database, 4 part name.
message ObjectRef {
	int64 server	= 1;
	int64 db		= 2;
	int64 schema	= 3;
	int64 obj		= 4;
	string server_name	= 5;
	string db_name		= 6;
	string schema_name	= 7;
	string obj_name		= 8;
}

message Function {
	// Function flags
	enum FuncFlag {
		NONE     = 0;
		// Internal function is generated by system, cannot
		// by called by user.
		INTERNAL = 1;

		// Function, by default is immutable.
		STABLE   = 2;
		VOLATILE = 4;

		// Nulls
		STRICT				= 8;
		PRODUCE_NULL		= 16;
		PRODUCE_NO_NULL		= 32;

		// Vararg, all trailing args must be of the same type.
		VARARG     = 64;

		// Window and Agg
		AGG        = 128;
		WIN        = 256;

		// Monotonic function can filter by zonemap
		MONOTONIC = 512;
	}

	ObjectRef func		= 1;
	repeated Expr args	= 2;
}

message Expr {
	Type typ = 1;
	oneof expr {
		Const		c		= 2;
		ParamRef	p		= 3;
		VarRef		v		= 4;
		ColRef		col 	= 5;
		RawColRef	raw		= 6;
		Function	f		= 7;
		SubqueryRef	sub		= 8;
		CorrColRef	corr	= 9;
		TargetType  t		= 10;
		ExprList	list	= 11;
		MaxValue	max		= 12;
	}
}

enum CompressType {
	None 	= 0;
	Lz4 	= 1;
}

message decimal64 {
	int64 a = 1;
}

message decimal128 {
	int64 a = 1;
	int64 b = 2;
}

message ResultColDef {
	repeated ColDef ResultCols = 1;
}

message ColDef {
	uint64 col_id		= 1;
	string name 		= 2;
	bool hidden			= 3;
	CompressType alg 	= 4;
	Type typ			= 5;
	bool not_null		= 6;
	Default default 	= 7;
	string comment		= 8;
	OnUpdate on_update  = 9;
	bool low_card 		= 10;

	// XXX: Deprecated and to be removed soon.
	bool clusterBy		= 11;
	bool primary        = 12;
	int32 pkidx 		= 13;
}

message Default {
	Expr expr = 1;
	string origin_string = 2;

	// XXX: Deprecated and to be removed soon.
	bool null_ability = 3;
}

message OnUpdate {
	Expr expr = 1;
	string origin_string = 2;
}

message IndexOption {
	bool create_extra_table = 1;
}

message PrimaryKeyDef {
	repeated uint64 cols	= 1;
	uint64 pkey_col_id		= 2;
	IndexOption option		= 3;

	// Composed primary key column name: __mo_cpkey
	string pkey_col_name = 4;
	// XXX: Deprecated and to be removed soon.
	repeated string names = 5;
}

message IndexDef {
	// Generate UUID for each index
	string idx_id			= 1;
	string name				= 2;
	// Name for anonymous indices, __mo_idx_[INDEX_ID]
	bool unique				= 3;
	repeated Expr parts		= 4;
	IndexOption option		= 5;

	// Index table name: __mo_idx_[TABLE_ID]_[INDEX_ID]
	// Column name for indexed column(s): __mo_idx_key
	// Column name for original primary key: __mo_orig_pkey
}

message ForeignKeyDef {
	enum RefAction {
		RESTRICT	= 0;
		CASCADE		= 1;
		SET_NULL	= 2;
		SET_DEFAULT	= 3;
		NO_ACTION	= 4;
	}

	string name						= 1;
	repeated uint64 cols			= 2;
	uint64 foreign_tbl				= 3;
	repeated uint64 foreign_cols	= 4;
	RefAction on_delete				= 5;
	RefAction on_update				= 6;
}

message CheckDef {
	string name	= 1;
	// Name for anonymous constraints, __mo_chk_[INDEX_ID]
	Expr check	= 2;
}

message ClusterByDef {
	repeated Expr parts = 1;

	// XXX: Deprecated and to be removed soon.
	string name = 2;
}

message PropertyDef {
	string key 		= 1;
	string value 	= 2;
}

message Property {
	string key 		= 1;
	string value 	= 2;
}

message PropertiesDef {
	repeated Property properties 	= 1;
}


enum PartitionType {
	KEY = 0;
	LINEAR_KEY = 1;
	HASH = 2;
	LINEAR_HASH = 3;
	RANGE = 4;
	RANGE_COLUMNS = 5;
	LIST = 6;
	LIST_COLUMNS = 7;
}

message PartitionByDef {
	PartitionType type = 1;
	PartitionExpr partition_expr = 2;
	Expr partition_expression = 3;
	PartitionColumns partition_columns = 4;
	uint64 partitionNum = 5;
	repeated PartitionItem partitions = 6;
	int64 algorithm = 7;
	bool is_sub_partition = 8;
	string partition_msg = 9;
}

message PartitionExpr {
	Expr expr = 1;
	string expr_str = 2;
}

message PartitionColumns {
	repeated Expr columns = 1;
	repeated string partition_columns = 2;
}

message PartitionItem {
	string partition_name = 1;
	uint32 ordinal_position = 2;
	string description = 3;
	string comment = 4;
	repeated Expr less_than = 5;
	repeated Expr in_values = 6;
}


message ViewDef {
	string view  = 1;
}

message UniqueIndexDef {
	repeated string index_names = 1;
	repeated string table_names = 2;
	repeated Field fields = 3;
	repeated bool table_exists = 4;
	repeated string comments = 5;
}

message SecondaryIndexDef {
	repeated string index_names = 1;
	repeated string table_names = 2;
	repeated Field fields = 3;
	repeated bool table_exists = 4;
	repeated string comments = 5;
}

message Field {
	repeated string parts = 1;
	repeated ColDef cols = 2;
}

message TableDef {
	// XXX: Deprecated and to be removed soon.
	message DefType {
		oneof def {
			PropertiesDef properties	= 1;
			UniqueIndexDef uIdx			= 2;
			SecondaryIndexDef sIdx		= 3;
		}
	}

	uint64 tbl_id			= 1;
	string name				= 2;
	bool hidden				= 3;
	repeated ColDef cols	= 4;
	string table_type 		= 5;
	string createsql 		= 6;
	TableFunction tbl_func	= 7;

	PrimaryKeyDef pkey				= 11;
	repeated IndexDef indices		= 12;
	repeated ForeignKeyDef fkeys	= 13;
	repeated uint64 ref_child_tbls	= 14;
	repeated CheckDef checks		= 15;

	PartitionByDef partition		= 21;
	ClusterByDef cluster_by		= 22;
	repeated PropertyDef props	= 23;
	ViewDef view_sql			= 24;
	repeated ColDef origin_cols	= 25;

	// XXX: Deprecated and to be removed soon.
	repeated DefType defs	= 31;
	map<string, int32> name2col_index = 32;
	ColDef composite_pkey = 33;
}

message TableFunction{
	string name = 1;
	bytes param = 2;
}


message Stats {
	//for scan, number of blocks to read from S3
	//for other nodes, it's meaningless
	int32  block_num        = 1;
	//for scan, cost of reading from S3, basically the read lines
	//for other nodes, it means the estimated cost of current node
	double cost				= 2;
	//number of output lines
	double outcnt			= 3;
	// average size of one row, currently not used
	double rowsize	        = 4;
	// hashmap size for nodes which build a hashmap
	//for other nodes, it's meaningless
	double hashmap_size		= 5;
}

message ColData {
	repeated Expr data = 1;
}

message RowsetData {
	repeated ColData cols	= 1;
}

message OrderBySpec {
	enum OrderByFlag {
		INTERNAL    = 0;
		ASC  		= 1;
		DESC 		= 2;
		NULLS_FIRST = 4;
		NULLS_LAST  = 8;
		UNIQUE      = 16;
	}

	Expr expr = 1;
	string collation = 2;
	OrderByFlag flag = 3;
}

message WindowSpec {
	repeated Expr partition_by = 1;
	repeated OrderBySpec order_by = 2;
	int32 lead = 3;
	int32 lag  = 4;
}

message InsertCtx {
	ObjectRef ref 					= 1;
	repeated int32 idx 				= 2;
	TableDef table_def 				= 3;

	map<string, int32> parent_idx 	= 4;

	ClusterTable cluster_table = 5;
}

message UpdateCtx {
	repeated ObjectRef ref 				= 1;
	repeated IdList idx 				= 2;
	repeated TableDef tableDefs 		= 3;
	repeated ColPosMap update_col 		= 4; 

	repeated ObjectRef idx_ref 			= 5;
	repeated int32 idx_idx 				= 6;

	repeated ObjectRef on_restrict_ref 	= 7;
	repeated int32 on_restrict_idx 		= 8;

	repeated ObjectRef on_cascade_ref 			= 9;
	repeated IdList on_cascade_idx 				= 10;
	repeated TableDef on_cascade_def			= 11;
	repeated ColPosMap on_cascade_update_col 	= 12; 

	repeated ObjectRef on_set_ref 			= 13;
	repeated IdList on_set_idx 				= 14;
	repeated TableDef on_set_def			= 15;
	repeated ColPosMap on_set_update_col 	= 16; 

	repeated ColPosMap parent_idx = 17;
}

message AnalyzeInfo {
    int64 input_rows = 1;
    int64 output_rows = 2;
    int64 input_size = 3;
    int64 output_size = 4;
    int64 time_consumed = 5;
    int64 memory_size = 6;
    int64 wait_time_consumed = 7;
    int64 diskIO = 8;
    int64 s3IO_byte = 9;
    int64 s3IO_count = 10;
    int64 networkIO = 11;
	int64 scanTime = 12;
	int64 insertTime = 13;
}

message Node {
	enum NodeType {
		UNKNOWN = 0;
		// Node Types

		// Scans
		VALUE_SCAN = 1;
		TABLE_SCAN = 2;
		FUNCTION_SCAN = 3;
		EXTERNAL_SCAN = 4;
		MATERIAL_SCAN = 5;

		// Proj, for convenience
		PROJECT = 10;
		// External function call (UDF)
		EXTERNAL_FUNCTION = 11;

		// Material, CTE, etc.
		MATERIAL = 20;
		RECURSIVE_CTE = 21;
		SINK = 22;
		SINK_SCAN = 23;

		// Proper Relational Operators
		AGG = 30;
		DISTINCT = 31;
		FILTER = 32;
		JOIN = 33;
		SAMPLE = 34;
		SORT = 35;
		UNION = 36;
		UNION_ALL = 37;
		UNIQUE = 38;
		WINDOW = 39;

		// Physical tuple mover
		BROADCAST = 40;
		SPLIT = 41;
		GATHER = 42;

		// Misc
		ASSERT = 50;

		//
		INSERT = 51;
		UPDATE = 52;
		DELETE = 53;

		//
		INTERSECT = 54;
		INTERSECT_ALL = 55;
		MINUS = 56;
		MINUS_ALL = 57;
	}

	enum JoinFlag {
		//INNER = 0;
		//OUTER = 1;
		//SEMI = 2;
		//ANTI = 4;
		//SINGLE = 8;
		//MARK = 16;
		//APPLY = 32;

		INNER	= 0;
		LEFT	= 1;
		RIGHT	= 2;
		OUTER	= 3;
		SEMI	= 4;
		ANTI	= 5;
		SINGLE	= 6;
		MARK	= 7;
		APPLY	= 8;
	}

	enum AggMode {
		FULL = 0;
		BOTTOM = 1;
		TOP = 2;
	}

	NodeType node_type = 1;
	int32 node_id = 2;
	Stats stats = 3;

	repeated Expr project_list = 4;
	repeated int32 children = 5;
	JoinFlag join_type = 6;
	repeated Expr on_list = 7;
	repeated Expr filter_list = 8;
	repeated Expr group_by = 9;
	repeated Expr grouping_set = 10;
	repeated Expr agg_list = 11;
	repeated OrderBySpec order_by = 12;
	UpdateCtx update_ctx = 13;
	WindowSpec win_spec = 14;
	Expr limit = 15;
	Expr offset = 16;
	TableDef table_def = 17;
	repeated TableDef table_def_vec = 18;
	ObjectRef obj_ref = 19;
	RowsetData rowset_data = 20;
	string extra_options = 21;
	DeleteCtx delete_ctx = 22;

	repeated int32 binding_tags = 23;

    AnalyzeInfo analyze_info = 24;

	repeated Expr tbl_func_expr_list = 25;

    // The pipeline will determine the parallelism by traversing the plan 
    // when it is received. Then the build is built based on this information.
    int32   parallelism = 26;

	ClusterTable cluster_table = 27;
	bool not_cacheable = 28;
	InsertCtx insert_ctx = 29;
}

message IdList {
	repeated int64 list = 1;
}

message ColPosMap {
	map<string, int32> map = 1;
}

message DeleteCtx {
	repeated ObjectRef ref 			= 1;

	repeated ObjectRef idx_ref 		= 2;
	repeated int32 idx_idx 			= 3;

	repeated ObjectRef on_restrict_ref 	= 4;
	repeated int32 on_restrict_idx 		= 5;

	repeated ObjectRef on_cascade_ref 	= 6;
	repeated int32 on_cascade_idx 		= 7;

	repeated ObjectRef on_set_ref 			= 8;
	repeated TableDef on_set_def 			= 9;
	repeated IdList on_set_idx 				= 10;
	repeated ColPosMap on_set_update_col 	= 11; 
	
	bool can_truncate = 12;
}

message Query {
	enum StatementType {
		UNKNOWN		= 0;
		SELECT		= 1;
		INSERT		= 2;
		DELETE		= 3;
		UPDATE		= 4;
		MERGE		= 5;
	}

	StatementType stmt_type		= 1;

	// A query may need to run in steps.   This in theory is not
	// necessary but often convenient and/or can be better optimized.
	// For example, executing non correctlated scalar subquery first
	// we can plug the value in the optmizer and the newly available
	// value may generate better plan.

	// Each step is simply a root node.  Root node refers to other
	// node as children and the whole step is a DAG.
	repeated int32 steps	= 2;

	// All the nodes.  It is OK to have dangle nodes, we only excute nodes
	// reachable from step roots.
	repeated Node nodes		= 3;

	// Bound Parameter for the query.
	repeated Expr params	= 4;

	// return head
	repeated string headings = 5;

	// load Tag
	bool loadTag = 6;
}

message TransationControl {
	enum TclType {
		BEGIN 		= 0;
		COMMIT 		= 1;
		ROLLBACK 	= 2;
	}
	//TransationControl type
	TclType tcl_type = 1;
	oneof action {
		TransationBegin begin 		= 2;
		TransationCommit commit 	= 3;
		TransationRollback rollback = 4;
	}
}

message TransationBegin {
	enum TransationMode {
		NONE 		= 0;
		READ_ONLY 	= 1;
		READ_WRITE 	= 2;
	}
	TransationMode mode = 1;
}

enum TransationCompletionType {
	CHAIN 		= 0;
	NO_CHAIN 	= 1;
	RELEASE 	= 2;
}
message TransationCommit {
	TransationCompletionType completion_type = 1;
}
message TransationRollback {
	TransationCompletionType completion_type = 1;
}

message Plan {
	oneof plan {
		Query query 			= 1;
		TransationControl tcl 	= 2;
		DataDefinition ddl 		= 3;
		DataControl	dcl			= 4;
	}
}

message column{
	repeated Expr column = 1;
}

message DataControl {
	enum DclType {
		SET_VARIABLES	= 0;
		GRANT			= 1;
		REVOKE			= 2;
		DENY			= 3;
		PREPARE			= 4;
		EXECUTE			= 5;
		DEALLOCATE		= 6;
	}
	//DataDefinition type
	DclType dcl_type = 1;
	oneof control {
		SetVariables set_variables  = 2;
		Prepare prepare 			= 3;
		Execute execute				= 4;
		Deallocate deallocate 		= 5;
	}
}

message DataDefinition {
	enum DdlType {
		CREATE_DATABASE 	= 0;
		ALTER_DATABASE 		= 1;
		DROP_DATABASE		= 2;
		CREATE_TABLE 		= 3;
		ALTER_TABLE			= 4;
		DROP_TABLE			= 5;
		CREATE_INDEX		= 6;
		ALTER_INDEX			= 7;
		DROP_INDEX			= 8;
		TRUNCATE_TABLE		= 9;
		CREATE_VIEW			= 10;
		ALTER_VIEW			= 11;
		DROP_VIEW			= 12;
		SHOW_CREATEDATABASE = 13;
		SHOW_CREATETABLE 	= 14;
		SHOW_DATABASES		= 15;
		SHOW_TABLES			= 16;
		SHOW_COLUMNS		= 17;
		SHOW_INDEX			= 18;
		SHOW_VARIABLES		= 19;
		SHOW_WARNINGS		= 20;
		SHOW_ERRORS			= 21;
		SHOW_STATUS			= 22;
		SHOW_PROCESSLIST	= 23;
		SHOW_TABLE_STATUS 	= 24;
		SHOW_TARGET 		= 25;
		SHOW_COLLATION 		= 26;
	}
	//DataDefinition type
	DdlType ddl_type = 1;

	//other show statement we will rewrite to a select statement
	//then we will get a Query
	//eg: 'show databases' will rewrite to 'select md.datname as `Database` from mo_database md'
	Query query = 2;

	oneof definition {
		CreateDatabase create_database 	= 3;
		AlterDatabase alter_database 	= 4;
		DropDatabase drop_database		= 5;
		CreateTable create_table		= 6;
		AlterTable alter_table 			= 7;
		DropTable drop_table			= 8;
		CreateIndex create_index 		= 9;
		AlterIndex alter_index 			= 10;
		DropIndex drop_index 			= 11;
		TruncateTable truncate_table	= 12;
		ShowVariables show_variables 	= 13;
		AlterView alter_view			= 14;
	}
}

message CreateDatabase {
	bool if_not_exists 	= 1;
	string database 	= 2;
}

message AlterDatabase {
	bool if_exists 		= 1;
	string database 	= 2;
}

message DropDatabase {
	bool if_exists 		= 1;
	string database 	= 2;
}

message CreateTable {
	message FkColName {
		repeated string cols = 1;
	}
	bool if_not_exists 	= 1;
	bool temporary 		= 2;
	string database 	= 3;
	TableDef table_def 	= 4;
	repeated TableDef index_tables = 5;
	// we need the db/table name of foreign key when create table. but we don't need it in ForeignKeyDef
	repeated string fk_dbs = 6;
	repeated string fk_tables = 7;
	// we need column name when create table, but not in ForeignKeyDef
	repeated FkColName fk_cols = 8;
}

message AlterTable {
	string table 		= 1;
	TableDef table_def 	= 2;
}

message AlterView {
	bool if_exists		= 1;
	string database 	= 2;
	bool temporary		= 3;
	string table		= 4;
	TableDef table_def	= 5;
	repeated TableDef index_tables = 6;
}

message DropTable {
	bool if_exists 	= 1;
	string database = 2;
	string table 	= 3;
	repeated string index_table_names = 4;
	ClusterTable cluster_table = 5;
	uint64 table_id = 6;
	repeated uint64 foreign_tbl = 7;
}

message CreateIndex {
	string database = 1;
	string table = 2;
	string	origin_table_primary_key = 3;
	CreateTable index = 4;
	bool table_exist = 5;
}

message AlterIndex {
	string index = 1;
}

message DropIndex {
	string database = 1;
	string table = 2;
	string index_name = 3;
	string index_table_name = 4;
}

message TruncateTable {
	string database = 1;
	string table = 2;
	repeated string index_table_names = 3;
	ClusterTable cluster_table = 4;
	uint64 table_id = 5;
	repeated uint64 foreign_tbl = 6;
}

message ClusterTable{
	bool is_cluster_table = 1;//insert into a cluster table
	repeated uint32 accountIDs = 2;//insert data into the cluster table for every account
	int32 column_index_of_accountId = 3;//the column index of the account id in the cluster table
}

message ShowVariables {
	bool global 			= 1;
	repeated Expr where 	= 2;
}

message SetVariables {
	repeated SetVariablesItem items	= 1;
}

message SetVariablesItem {
	bool system     = 1;
	bool global     = 2;
	string name     = 3;
	Expr   value    = 4;
	Expr   reserved = 5;
}

message Prepare {
	string name		 			= 1;
	repeated ObjectRef schemas 	= 2;
	Plan   plan		 			= 3;
	repeated int32 param_types  = 4;
}

message Execute {
	string name 		= 1;
	repeated Expr args 	= 2;
}

message Deallocate {
	string name			= 1;
}
