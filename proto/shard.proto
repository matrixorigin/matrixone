// Copyright 2021-2024 Matrix Origin
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";
package shard; 
option go_package = "github.com/matrixorigin/matrixone/pkg/pb/shard";

import "github.com/gogo/protobuf/gogoproto/gogo.proto";

option (gogoproto.goproto_enum_prefix_all) = true;
 
// Policy shard policy for a table.
enum Policy {
    // None no sharding for the current table. 
    None      = 0;
    // Partition the user-defined way of sharding data for a partitioned table.
    //
    // The number of Shards is determined when the table is created. It does not 
    // change with the number of CN nodes in the MO cluster.
    //
    // The number of shards is only changed when the user changes the table definition
    // by using alter table.
    //
    // len(Shards) == len(Partitions).
    Partition = 1;
    // Hash auto-sharding data in a way that is based on primary key hash.
    //
    // In this mode, the number of shards of the table changes with the number of 
    // nodes of CN in the mo cluster. len(shards) >= len(CN nodes).
    Hash      = 2;
}

enum CmdType {
    AddShard    = 0;
    DeleteShard = 1;
}

// TableShards table shards metadata. When a Table is created, metadata for the 
// corresponding shards is created and serialized and stored in MO_TABLES. 
message TableShards {
    Policy Policy      = 1;
    uint32 ShardsCount = 2;
    uint32 Version     = 3;
    uint32 TenantID    = 4;
}

// TableShardBind when TableShards are created, the Shards corresponding to a table 
// are determined, and each Shard is assigned a corresponding CN node to handle requests
// for that Shard.
//
// The binding relationship between CN and Shard changes dynamically during the runtime, and 
// presumably if the corresponding CN goes offline, or if a new CN comes online and causes 
// an imbalance between Shard and CN, then the binding relationship will be readjusted.
//
// When the Table's shards count changed, the corresponding Version field increments itself. 
// This makes it easy to found expired information.
message TableShardBind {
    uint64 ShardID       = 1;
    string CN            = 2;
    // Version icrements when shards count changed
    uint32 ShardsVersion = 3;
    // BindVersion icrements when the cn changed
    uint32 BindVersion   = 4;
}


// Method sharding operations
enum Method {
    // Heartbeat heartbeat method
    Heartbeat     = 0;
    // GetShardBinds get table bind shards
    GetShardBinds = 1;
}

message Request {
  uint64                     RequestID           = 1;
  Method                     Method              = 3;
}

message Response {
    uint64                     RequestID            = 1;
    Method                     Method               = 2;
    // Error we use this field to send moerr from service to another cn. Set with 
    // moerr.MarshalBinary, and use moerr.UnmarshalBinary to restore moerr.
    bytes                      Error                = 3;
}

message Cmd {
    CmdType        Type           = 1;
    TableShardBind TableShardBind = 2 [(gogoproto.nullable) = false];
}

