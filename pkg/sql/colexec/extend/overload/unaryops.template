// Copyright 2021 Matrix Origin
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// unaryops.go is generated by unaryops.template and overloadGenerate.go, do not edit it directly.

package overload

import (
	"matrixone/pkg/container/types"
	"matrixone/pkg/container/vector"
	"matrixone/pkg/encoding"
	"matrixone/pkg/vectorize/neg"
	"matrixone/pkg/vm/process"
	"matrixone/pkg/vm/register"
)

func init() {
    UnaryOps[UnaryMinus] = []*UnaryOp{
    {{range .Minus}}
        &UnaryOp{
            Typ:        types.LEFT_TYPE_OID,
            ReturnType: types.RETURN_TYPE_OID,
            Fn: func(v *vector.Vector, proc *process.Process, _ bool) (*vector.Vector, error) {
                rtl := {.RETURN_TYPE_LEN}
                if v.Ref == 1 || v.Ref == 0 {
                    v.Ref = 0
                    vs := v.Col.([]L_GO_TYPE)
                    neg.{.LTYP}Neg(vs, vs)
                    return v, nil
                }
                vs := v.Col.([]L_GO_TYPE)
                vec, err := register.Get(proc, int64(rtl) * int64(len(vs)), v.Typ)
                if err != nil {
                    return nil, err
                }
                rs := encoding.Decode{.RETTYP}Slice(vec.Data)
                rs = rs[:len(vs)]
                vec.Col = rs
                vec.Nsp.Set(v.Nsp)
                vec.SetCol(neg.{.RETTYP}Neg(vs, rs))
                return vec, nil
            },
        },
    {{end}}
    }
}

// init function to init binOpsReturnType from
// plus.go / mult.go / minus.go / div.go / mod.go
func init() {
	unaryOpsReturnType = make([][]types.T, len(unaryOperators))

	for i, op := range unaryOperators {
		unaryOpsReturnType[i] = make([]types.T, maxt)

		for j := range unaryOpsReturnType[i] {
			unaryOpsReturnType[i][j] = noRt
		}

		for _, uo := range UnaryOps[op] {
			unaryOpsReturnType[i][uo.Typ] = uo.ReturnType
		}
	}
}