// Copyright 2021 Matrix Origin
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// unaryops.go is generated by unaryops.template and overloadGenerate.go, do not edit it directly.

package overload

import (
	"github.com/matrixorigin/matrixone/pkg/container/types"
	"github.com/matrixorigin/matrixone/pkg/container/vector"
	"github.com/matrixorigin/matrixone/pkg/encoding"
	"github.com/matrixorigin/matrixone/pkg/vectorize/neg"
	"github.com/matrixorigin/matrixone/pkg/vectorize/not"
	"github.com/matrixorigin/matrixone/pkg/vm/process"
	"github.com/matrixorigin/matrixone/pkg/vm/register"
)

func init() {
    UnaryOps[UnaryMinus] = []*UnaryOp{
    {{range .Minus}}
        {
            Typ:        types.LEFT_TYPE_OID,
            ReturnType: types.RETURN_TYPE_OID,
            Fn: func(v *vector.Vector, proc *process.Process, _ bool) (*vector.Vector, error) {
                rtl := {.RETURN_TYPE_LEN}
                if v.Ref == 1 || v.Ref == 0 {
                    v.Ref = 0
                    vs := v.Col.([]L_GO_TYPE)
                    neg.{.LTYP}Neg(vs, vs)
                    return v, nil
                }
                vs := v.Col.([]L_GO_TYPE)
                vec, err := register.Get(proc, int64(rtl) * int64(len(vs)), v.Typ)
                if err != nil {
                    return nil, err
                }
                rs := encoding.Decode{.RETTYP}Slice(vec.Data)
                rs = rs[:len(vs)]
                vec.Col = rs
                vec.Nsp.Set(v.Nsp)
                vec.SetCol(neg.{.RETTYP}Neg(vs, rs))
                return vec, nil
            },
        },
    {{end}}
    }

    // Unary Not will return int8
     UnaryOps[Not] = []*UnaryOp{
     {{range .Not}}
         {
             Typ:        types.LEFT_TYPE_OID,
             ReturnType: types.RETURN_TYPE_OID,
             Fn: func(v *vector.Vector, proc *process.Process, _ bool) (*vector.Vector, error) {
                 rtl := {.RETURN_TYPE_LEN}
                 if v.Typ.Oid == types.RETURN_TYPE_OID && (v.Ref == 1 || v.Ref == 0) {
                     v.Ref = 0
                     vs := v.Col.([]RETURN_GO_TYPE)
                     not.{.RETTYP}Not(vs, vs)
                     return v, nil
                 }
                 vs := v.Col.([]L_GO_TYPE)
                 vec, err := register.Get(proc, int64(rtl) * int64(len(vs)), types.Type{
                         Oid:    types.RETURN_TYPE_OID,
                         Size:   {.RETURN_TYPE_LEN},
                 })
                 if err != nil {
                     return nil, err
                 }
                 rs := encoding.Decode{.RETTYP}Slice(vec.Data)
                 rs = rs[:len(vs)]
                 vec.SetCol(not.{.LTYP}Not(vs, rs))
                 vec.Nsp.Set(v.Nsp)
                 return vec, nil
             },
         },
     {{end}}
     }
}

// init function to init binOpsReturnType from
// plus.go / mult.go / minus.go / div.go / mod.go
func init() {
	unaryOpsReturnType = make([][]types.T, len(unaryOperators))

	for i, op := range unaryOperators {
		unaryOpsReturnType[i] = make([]types.T, maxt)

		for j := range unaryOpsReturnType[i] {
			unaryOpsReturnType[i][j] = noRt
		}

		for _, uo := range UnaryOps[op] {
			unaryOpsReturnType[i][uo.Typ] = uo.ReturnType
		}
	}
}