// Copyright 2021 Matrix Origin
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ge.go is generated by ge.template and overloadGenerate.go, do not edit it directly.

package overload

import (
	"github.com/matrixorigin/matrixone/pkg/container/types"
	"github.com/matrixorigin/matrixone/pkg/container/vector"
	"github.com/matrixorigin/matrixone/pkg/encoding"
	"github.com/matrixorigin/matrixone/pkg/vectorize/ge"
	"github.com/matrixorigin/matrixone/pkg/vectorize/le"
	"github.com/matrixorigin/matrixone/pkg/vm/process"
	"github.com/matrixorigin/matrixone/pkg/vm/register"

	roaring "github.com/RoaringBitmap/roaring/roaring64"
)

func init() {
    BinOps[GE] = []*BinOp{
    {{range .Numerics}}
        {
            LeftType:   types.LEFT_TYPE_OID,
            RightType:  types.RIGHT_TYPE_OID,
            ReturnType: types.RETURN_TYPE_OID,
            Fn: func(lv, rv *vector.Vector, proc *process.Process, lc, rc bool) (*vector.Vector, error) {
                lvs, rvs := lv.Col.([]L_GO_TYPE), rv.Col.([]R_GO_TYPE)
                rtl := {.RETURN_TYPE_LEN}
                switch {
                case lc && !rc:
                    vec, err := register.Get(proc, int64(rtl) * int64(len(rvs)), SelsType)
                    if err != nil {
                        return nil, err
                    }
                    rs := encoding.DecodeInt64Slice(vec.Data)
                    rs = rs[:len(rvs)]
                    if rv.Nsp.Any() {
                        vec.SetCol(ge.{.RTYP}GeNullableScalar(lvs[0], rvs, rv.Nsp.Np, rs))
                    } else {
                        vec.SetCol(ge.{.RTYP}GeScalar(lvs[0], rvs, rs))
                    }
                    if rv.Ref == 0 {
                        register.Put(proc, rv)
                    }
                    return vec, nil
                case !lc && rc:
                    vec, err := register.Get(proc, int64(rtl) * int64(len(lvs)), SelsType)
                    if err != nil {
                        return nil, err
                    }
                    rs := encoding.DecodeInt64Slice(vec.Data)
                    rs = rs[:len(lvs)]
                    if lv.Nsp.Any() {
                        vec.SetCol(le.{.LTYP}LeNullableScalar(rvs[0], lvs, lv.Nsp.Np, rs))
                    } else {
                        vec.SetCol(le.{.LTYP}LeScalar(rvs[0], lvs, rs))
                    }
                    if lv.Ref == 0 {
                        register.Put(proc, lv)
                    }
                    return vec, nil
                }
                vec, err := register.Get(proc, int64(rtl) * int64(len(lvs)), SelsType)
                if err != nil {
                    return nil, err
                }
                rs := encoding.DecodeInt64Slice(vec.Data)
                rs = rs[:len(lvs)]
                switch {
                case lv.Nsp.Any() && rv.Nsp.Any():
                    vec.SetCol(ge.{.LTYP}GeNullable(lvs, rvs, roaring.Or(lv.Nsp.Np, rv.Nsp.Np), rs))
                case !lv.Nsp.Any() && rv.Nsp.Any():
                    vec.SetCol(ge.{.LTYP}GeNullable(lvs, rvs, rv.Nsp.Np, rs))
                case lv.Nsp.Any() && !rv.Nsp.Any():
                    vec.SetCol(ge.{.LTYP}GeNullable(lvs, rvs, lv.Nsp.Np, rs))
                default:
                    vec.SetCol(ge.{.LTYP}Ge(lvs, rvs, rs))
                }
                if lv.Ref == 0 {
                    register.Put(proc, lv)
                }
                if rv.Ref == 0 {
                    register.Put(proc, rv)
                }
                return vec, nil
            },
        },
    {{end}}

    {{range .CharTypes}}
    {
        LeftType:   types.LEFT_TYPE_OID,
        RightType:  types.LEFT_TYPE_OID,
        ReturnType: types.RETURN_TYPE_OID,
        Fn: func(lv, rv *vector.Vector, proc *process.Process, lc, rc bool) (*vector.Vector, error) {
            lvs, rvs := lv.Col.(*types.Bytes), rv.Col.(*types.Bytes)
            rtl := {.RETURN_TYPE_LEN}
            switch {
            case lc && !rc:
                vec, err := register.Get(proc, int64(rtl) * int64(len(rvs.Lengths)), SelsType)
                if err != nil {
                    return nil, err
                }
                rs := encoding.DecodeInt64Slice(vec.Data)
                rs = rs[:len(rvs.Lengths)]
                if rv.Nsp.Any() {
                    vec.SetCol(ge.StrGeNullableScalar(lvs.Data, rvs, rv.Nsp.Np, rs))
                } else {
                    vec.SetCol(ge.StrGeScalar(lvs.Data, rvs, rs))
                }
                if rv.Ref == 0 {
                    register.Put(proc, rv)
                }
                return vec, nil
            case !lc && rc:
                vec, err := register.Get(proc, int64(rtl) * int64(len(lvs.Lengths)), SelsType)
                if err != nil {
                    return nil, err
                }
                rs := encoding.DecodeInt64Slice(vec.Data)
                rs = rs[:len(lvs.Lengths)]
                if lv.Nsp.Any() {
                    vec.SetCol(le.StrLeNullableScalar(rvs.Data, lvs, lv.Nsp.Np, rs))
                } else {
                    vec.SetCol(le.StrLeScalar(rvs.Data, lvs, rs))
                }
                if lv.Ref == 0 {
                    register.Put(proc, lv)
                }
                return vec, nil
            }
            vec, err := register.Get(proc, int64(rtl) * int64(len(lvs.Lengths)), SelsType)
            if err != nil {
                return nil, err
            }
            rs := encoding.DecodeInt64Slice(vec.Data)
            rs = rs[:len(lvs.Lengths)]
            switch {
            case lv.Nsp.Any() && rv.Nsp.Any():
                vec.SetCol(ge.StrGeNullable(lvs, rvs, roaring.Or(lv.Nsp.Np, rv.Nsp.Np), rs))
            case !lv.Nsp.Any() && rv.Nsp.Any():
                vec.SetCol(ge.StrGeNullable(lvs, rvs, rv.Nsp.Np, rs))
            case lv.Nsp.Any() && !rv.Nsp.Any():
                vec.SetCol(ge.StrGeNullable(lvs, rvs, lv.Nsp.Np, rs))
            default:
                vec.SetCol(ge.StrGe(lvs, rvs, rs))
            }
            if lv.Ref == 0 {
                register.Put(proc, lv)
            }
            if rv.Ref == 0 {
                register.Put(proc, rv)
            }
            return vec, nil
        },
    },
    {{end}}
    }
}