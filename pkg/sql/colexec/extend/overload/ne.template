// Copyright 2021 Matrix Origin
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ne.go is generated by ne.template and overloadGenerate.go, do not edit it directly.

package overload

import (
    "unsafe"
    "github.com/matrixorigin/matrixone/pkg/container/nulls"
	"github.com/matrixorigin/matrixone/pkg/container/types"
	"github.com/matrixorigin/matrixone/pkg/container/vector"
	"github.com/matrixorigin/matrixone/pkg/encoding"
	"github.com/matrixorigin/matrixone/pkg/vectorize/ne"
	"github.com/matrixorigin/matrixone/pkg/vm/process"

	roaring "github.com/RoaringBitmap/roaring/roaring64"
)

func initNe() {
    BinOps[NE] = []*BinOp{
    {{range .Numerics}}
        {
            LeftType:   types.LEFT_TYPE_OID,
            RightType:  types.RIGHT_TYPE_OID,
            ReturnType: types.RETURN_TYPE_OID,
            Fn: func(lv, rv *vector.Vector, proc *process.Process, lc, rc bool) (*vector.Vector, error) {
                lvs, rvs := lv.Col.([]L_GO_TYPE), rv.Col.([]R_GO_TYPE)
                rtl := {.RETURN_TYPE_LEN}
                switch {
                case lc && !rc:
                    vec, err := process.Get(proc, int64(rtl) * int64(len(rvs)), SelsType)
                    if err != nil {
                        return nil, err
                    }
                    rs := encoding.DecodeInt64Slice(vec.Data)
                    rs = rs[:len(rvs)]
                    if nulls.Any(rv.Nsp) {
                        vector.SetCol(vec, ne.{.RTYP}NeNullableScalar(lvs[0], rvs, rv.Nsp.Np, rs))
                    } else {
                        vector.SetCol(vec, ne.{.RTYP}NeScalar(lvs[0], rvs, rs))
                    }
                    if rv.Ref == 0 {
                        process.Put(proc, rv)
                    }
                    return vec, nil
                case !lc && rc:
                    vec, err := process.Get(proc, int64(rtl) * int64(len(lvs)), SelsType)
                    if err != nil {
                        return nil, err
                    }
                    rs := encoding.DecodeInt64Slice(vec.Data)
                    rs = rs[:len(lvs)]
                    if nulls.Any(lv.Nsp) {
                        vector.SetCol(vec, ne.{.LTYP}NeNullableScalar(rvs[0], lvs, lv.Nsp.Np, rs))
                    } else {
                        vector.SetCol(vec, ne.{.LTYP}NeScalar(rvs[0], lvs, rs))
                    }
                    if lv.Ref == 0 {
                        process.Put(proc, lv)
                    }
                    return vec, nil
                }
                vec, err := process.Get(proc, int64(rtl) * int64(len(lvs)), SelsType)
                if err != nil {
                    return nil, err
                }
                rs := encoding.DecodeInt64Slice(vec.Data)
                rs = rs[:len(lvs)]
                switch {
                case nulls.Any(lv.Nsp) && nulls.Any(rv.Nsp):
                    vector.SetCol(vec, ne.{.LTYP}NeNullable(lvs, rvs, roaring.Or(lv.Nsp.Np, rv.Nsp.Np), rs))
                case !nulls.Any(lv.Nsp) && nulls.Any(rv.Nsp):
                    vector.SetCol(vec, ne.{.LTYP}NeNullable(lvs, rvs, rv.Nsp.Np, rs))
                case nulls.Any(lv.Nsp) && !nulls.Any(rv.Nsp):
                    vector.SetCol(vec, ne.{.LTYP}NeNullable(lvs, rvs, lv.Nsp.Np, rs))
                default:
                    vector.SetCol(vec, ne.{.LTYP}Ne(lvs, rvs, rs))
                }
                if lv.Ref == 0 {
                    process.Put(proc, lv)
                }
                if rv.Ref == 0 {
                    process.Put(proc, rv)
                }
                return vec, nil
            },
        },
    {{end}}

    {{range .CharTypes}}
        {
            LeftType:   types.LEFT_TYPE_OID,
            RightType:  types.RIGHT_TYPE_OID,
            ReturnType: types.RETURN_TYPE_OID,
            Fn: func(lv, rv *vector.Vector, proc *process.Process, lc, rc bool) (*vector.Vector, error) {
                lvs, rvs := lv.Col.(*types.Bytes), rv.Col.(*types.Bytes)
                rtl := {.RETURN_TYPE_LEN}
                switch {
                case lc && !rc:
                    vec, err := process.Get(proc, int64(rtl) * int64(len(rvs.Lengths)), SelsType)
                    if err != nil {
                        return nil, err
                    }
                    rs := encoding.DecodeInt64Slice(vec.Data)
                    rs = rs[:len(rvs.Lengths)]
                    if nulls.Any(rv.Nsp) {
                        vector.SetCol(vec, ne.StrNeNullableScalar(lvs.Data, rvs, rv.Nsp.Np, rs))
                    } else {
                        vector.SetCol(vec, ne.StrNeScalar(lvs.Data, rvs, rs))
                    }
                    if rv.Ref == 0 {
                        process.Put(proc, rv)
                    }
                    return vec, nil
                case !lc && rc:
                    vec, err := process.Get(proc, int64(rtl) * int64(len(lvs.Lengths)), SelsType)
                    if err != nil {
                        return nil, err
                    }
                    rs := encoding.DecodeInt64Slice(vec.Data)
                    rs = rs[:len(lvs.Lengths)]
                    if nulls.Any(lv.Nsp) {
                        vector.SetCol(vec, ne.StrNeNullableScalar(rvs.Data, lvs, lv.Nsp.Np, rs))
                    } else {
                        vector.SetCol(vec, ne.StrNeScalar(rvs.Data, lvs, rs))
                    }
                    if lv.Ref == 0 {
                        process.Put(proc, lv)
                    }
                    return vec, nil
                }
                vec, err := process.Get(proc, int64(rtl) * int64(len(lvs.Lengths)), SelsType)
                if err != nil {
                    return nil, err
                }
                rs := encoding.DecodeInt64Slice(vec.Data)
                rs = rs[:len(lvs.Lengths)]
                switch {
                case nulls.Any(lv.Nsp) && nulls.Any(rv.Nsp):
                    vector.SetCol(vec, ne.StrNeNullable(lvs, rvs, roaring.Or(lv.Nsp.Np, rv.Nsp.Np), rs))
                case !nulls.Any(lv.Nsp) && nulls.Any(rv.Nsp):
                    vector.SetCol(vec, ne.StrNeNullable(lvs, rvs, rv.Nsp.Np, rs))
                case nulls.Any(lv.Nsp) && !nulls.Any(rv.Nsp):
                    vector.SetCol(vec, ne.StrNeNullable(lvs, rvs, lv.Nsp.Np, rs))
                default:
                    vector.SetCol(vec, ne.StrNe(lvs, rvs, rs))
                }
                if lv.Ref == 0 {
                    process.Put(proc, lv)
                }
                if rv.Ref == 0 {
                    process.Put(proc, rv)
                }
                return vec, nil
            },
        },
    {{end}}
 		{
 			LeftType:   types.T_date,
 			RightType:  types.T_date,
 			ReturnType: types.T_sel,
 			Fn: func(lv, rv *vector.Vector, proc *process.Process, lc, rc bool) (*vector.Vector, error) {
 				lvs, rvs := lv.Col.([]types.Date), rv.Col.([]types.Date)
 				rtl := 8
 				switch {
 				case lc && !rc:
 					rvsInInt32 := *(*[]int32)(unsafe.Pointer(&rvs))
 					vec, err := process.Get(proc, int64(rtl)*int64(len(rvs)), SelsType)
 					if err != nil {
 						return nil, err
 					}
 					rs := encoding.DecodeInt64Slice(vec.Data)
 					rs = rs[:len(rvs)]
 					if nulls.Any(rv.Nsp) {
 						vector.SetCol(vec, ne.Int32NeNullableScalar(int32(lvs[0]), rvsInInt32, rv.Nsp.Np, rs))
 					} else {
 						vector.SetCol(vec, ne.Int32NeScalar(int32(lvs[0]), rvsInInt32, rs))
 					}
 					if rv.Ref == 0 {
 						process.Put(proc, rv)
 					}
 					return vec, nil
 				case !lc && rc:
 					lvsInInt32 := *(*[]int32)(unsafe.Pointer(&lvs))
 					vec, err := process.Get(proc, int64(rtl)*int64(len(lvs)), SelsType)
 					if err != nil {
 						return nil, err
 					}
 					rs := encoding.DecodeInt64Slice(vec.Data)
 					rs = rs[:len(lvs)]
 					if nulls.Any(lv.Nsp) {
 						vector.SetCol(vec, ne.Int32NeNullableScalar(int32(rvs[0]), lvsInInt32, lv.Nsp.Np, rs))
 					} else {
 						vector.SetCol(vec, ne.Int32NeScalar(int32(rvs[0]), lvsInInt32, rs))
 					}
 					if lv.Ref == 0 {
 						process.Put(proc, lv)
 					}
 					return vec, nil
 				}
 				vec, err := process.Get(proc, int64(rtl)*int64(len(lvs)), SelsType)
 				if err != nil {
 					return nil, err
 				}
 				rs := encoding.DecodeInt64Slice(vec.Data)
 				rs = rs[:len(lvs)]
 				rvsInInt32 := *(*[]int32)(unsafe.Pointer(&rvs))
 				lvsInInt32 := *(*[]int32)(unsafe.Pointer(&lvs))
 				switch {
 				case nulls.Any(lv.Nsp) && nulls.Any(rv.Nsp):
 					vector.SetCol(vec, ne.Int32NeNullable(lvsInInt32, rvsInInt32, roaring.Or(lv.Nsp.Np, rv.Nsp.Np), rs))
 				case !nulls.Any(lv.Nsp) && nulls.Any(rv.Nsp):
 					vector.SetCol(vec, ne.Int32NeNullable(lvsInInt32, rvsInInt32, rv.Nsp.Np, rs))
 				case nulls.Any(lv.Nsp) && !nulls.Any(rv.Nsp):
 					vector.SetCol(vec, ne.Int32NeNullable(lvsInInt32, rvsInInt32, lv.Nsp.Np, rs))
 				default:
 					vector.SetCol(vec, ne.Int32Ne(lvsInInt32, rvsInInt32, rs))
 				}
 				if lv.Ref == 0 {
 					process.Put(proc, lv)
 				}
 				if rv.Ref == 0 {
 					process.Put(proc, rv)
 				}
 				return vec, nil
 			},
 		},

 		{
 			LeftType:   types.T_datetime,
 			RightType:  types.T_datetime,
 			ReturnType: types.T_sel,
 			Fn: func(lv, rv *vector.Vector, proc *process.Process, lc, rc bool) (*vector.Vector, error) {
 				lvs, rvs := lv.Col.([]types.Datetime), rv.Col.([]types.Datetime)
 				rtl := 8
 				switch {
 				case lc && !rc:
 					rvsInInt64 := *(*[]int64)(unsafe.Pointer(&rvs))
 					vec, err := process.Get(proc, int64(rtl)*int64(len(rvs)), SelsType)
 					if err != nil {
 						return nil, err
 					}
 					rs := encoding.DecodeInt64Slice(vec.Data)
 					rs = rs[:len(rvs)]
 					if nulls.Any(rv.Nsp) {
 						vector.SetCol(vec, ne.Int64NeNullableScalar(int64(lvs[0]), rvsInInt64, rv.Nsp.Np, rs))
 					} else {
 						vector.SetCol(vec, ne.Int64NeScalar(int64(lvs[0]), rvsInInt64, rs))
 					}
 					if rv.Ref == 0 {
 						process.Put(proc, rv)
 					}
 					return vec, nil
 				case !lc && rc:
 					lvsInInt64 := *(*[]int64)(unsafe.Pointer(&lvs))
 					vec, err := process.Get(proc, int64(rtl)*int64(len(lvs)), SelsType)
 					if err != nil {
 						return nil, err
 					}
 					rs := encoding.DecodeInt64Slice(vec.Data)
 					rs = rs[:len(lvs)]
 					if nulls.Any(lv.Nsp) {
 						vector.SetCol(vec, ne.Int64NeNullableScalar(int64(rvs[0]), lvsInInt64, lv.Nsp.Np, rs))
 					} else {
 						vector.SetCol(vec, ne.Int64NeScalar(int64(rvs[0]), lvsInInt64, rs))
 					}
 					if lv.Ref == 0 {
 						process.Put(proc, lv)
 					}
 					return vec, nil
 				}
 				vec, err := process.Get(proc, int64(rtl)*int64(len(lvs)), SelsType)
 				if err != nil {
 					return nil, err
 				}
 				rs := encoding.DecodeInt64Slice(vec.Data)
 				rs = rs[:len(lvs)]
 				rvsInInt64 := *(*[]int64)(unsafe.Pointer(&rvs))
 				lvsInInt64 := *(*[]int64)(unsafe.Pointer(&lvs))
 				switch {
 				case nulls.Any(lv.Nsp) && nulls.Any(rv.Nsp):
 					vector.SetCol(vec, ne.Int64NeNullable(lvsInInt64, rvsInInt64, roaring.Or(lv.Nsp.Np, rv.Nsp.Np), rs))
 				case !nulls.Any(lv.Nsp) && nulls.Any(rv.Nsp):
 					vector.SetCol(vec, ne.Int64NeNullable(lvsInInt64, rvsInInt64, rv.Nsp.Np, rs))
 				case nulls.Any(lv.Nsp) && !nulls.Any(rv.Nsp):
 					vector.SetCol(vec, ne.Int64NeNullable(lvsInInt64, rvsInInt64, lv.Nsp.Np, rs))
 				default:
 					vector.SetCol(vec, ne.Int64Ne(lvsInInt64, rvsInInt64, rs))
 				}
 				if lv.Ref == 0 {
 					process.Put(proc, lv)
 				}
 				if rv.Ref == 0 {
 					process.Put(proc, rv)
 				}
 				return vec, nil
 			},
 		},

		{
			LeftType:   types.T_timestamp,
			RightType:  types.T_timestamp,
			ReturnType: types.T_sel,
			Fn: func(lv, rv *vector.Vector, proc *process.Process, lc, rc bool) (*vector.Vector, error) {
				lvs, rvs := lv.Col.([]types.Timestamp), rv.Col.([]types.Timestamp)
				rtl := 8
				switch {
				case lc && !rc:
					rvsInInt64 := *(*[]int64)(unsafe.Pointer(&rvs))
					vec, err := process.Get(proc, int64(rtl)*int64(len(rvs)), SelsType)
					if err != nil {
						return nil, err
					}
					rs := encoding.DecodeInt64Slice(vec.Data)
					rs = rs[:len(rvs)]
					if nulls.Any(rv.Nsp) {
						vector.SetCol(vec, ne.Int64NeNullableScalar(int64(lvs[0]), rvsInInt64, rv.Nsp.Np, rs))
					} else {
						vector.SetCol(vec, ne.Int64NeScalar(int64(lvs[0]), rvsInInt64, rs))
					}
					if rv.Ref == 0 {
						process.Put(proc, rv)
					}
					return vec, nil
				case !lc && rc:
					lvsInInt64 := *(*[]int64)(unsafe.Pointer(&lvs))
					vec, err := process.Get(proc, int64(rtl)*int64(len(lvs)), SelsType)
					if err != nil {
						return nil, err
					}
					rs := encoding.DecodeInt64Slice(vec.Data)
					rs = rs[:len(lvs)]
					if nulls.Any(lv.Nsp) {
						vector.SetCol(vec, ne.Int64NeNullableScalar(int64(rvs[0]), lvsInInt64, lv.Nsp.Np, rs))
					} else {
						vector.SetCol(vec, ne.Int64NeScalar(int64(rvs[0]), lvsInInt64, rs))
					}
					if lv.Ref == 0 {
						process.Put(proc, lv)
					}
					return vec, nil
				}
				vec, err := process.Get(proc, int64(rtl)*int64(len(lvs)), SelsType)
				if err != nil {
					return nil, err
				}
				rs := encoding.DecodeInt64Slice(vec.Data)
				rs = rs[:len(lvs)]
				rvsInInt64 := *(*[]int64)(unsafe.Pointer(&rvs))
				lvsInInt64 := *(*[]int64)(unsafe.Pointer(&lvs))
				switch {
				case nulls.Any(lv.Nsp) && nulls.Any(rv.Nsp):
					vector.SetCol(vec, ne.Int64NeNullable(lvsInInt64, rvsInInt64, roaring.Or(lv.Nsp.Np, rv.Nsp.Np), rs))
				case !nulls.Any(lv.Nsp) && nulls.Any(rv.Nsp):
					vector.SetCol(vec, ne.Int64NeNullable(lvsInInt64, rvsInInt64, rv.Nsp.Np, rs))
				case nulls.Any(lv.Nsp) && !nulls.Any(rv.Nsp):
					vector.SetCol(vec, ne.Int64NeNullable(lvsInInt64, rvsInInt64, lv.Nsp.Np, rs))
				default:
					vector.SetCol(vec, ne.Int64Ne(lvsInInt64, rvsInInt64, rs))
				}
				if lv.Ref == 0 {
					process.Put(proc, lv)
				}
				if rv.Ref == 0 {
					process.Put(proc, rv)
				}
				return vec, nil
			},
		},

		{
			LeftType:   types.T_decimal64,
			RightType:  types.T_decimal64,
			ReturnType: types.T_sel,
			Fn: func(lv, rv *vector.Vector, proc *process.Process, lc, rc bool) (*vector.Vector, error) {
				lvs, rvs := lv.Col.([]types.Decimal64), rv.Col.([]types.Decimal64)
				rtl := 8
				switch {
				case lc && !rc:
					vec, err := process.Get(proc, int64(rtl)*int64(len(rvs)), SelsType)
					if err != nil {
						return nil, err
					}
					rs := encoding.DecodeInt64Slice(vec.Data)
					rs = rs[:len(rvs)]
					if nulls.Any(rv.Nsp) {
						vector.SetCol(vec, ne.Decimal64NeNullableScalar(lvs[0], rvs, lv.Typ.Scale, rv.Typ.Scale, rv.Nsp.Np, rs))
					} else {
						vector.SetCol(vec, ne.Decimal64NeScalar(lvs[0], rvs, lv.Typ.Scale, rv.Typ.Scale, rs))
					}
					if rv.Ref == 0 {
						process.Put(proc, rv)
					}
					return vec, nil
				case !lc && rc:
					vec, err := process.Get(proc, int64(rtl)*int64(len(lvs)), SelsType)
					if err != nil {
						return nil, err
					}
					rs := encoding.DecodeInt64Slice(vec.Data)
					rs = rs[:len(lvs)]
					if nulls.Any(lv.Nsp) {
						vector.SetCol(vec, ne.Decimal64NeNullableScalar(rvs[0], lvs, rv.Typ.Scale, lv.Typ.Scale, lv.Nsp.Np, rs))
					} else {
						vector.SetCol(vec, ne.Decimal64NeScalar(rvs[0], lvs, rv.Typ.Scale, lv.Typ.Scale, rs))
					}
					if lv.Ref == 0 {
						process.Put(proc, lv)
					}
					return vec, nil
				}
				vec, err := process.Get(proc, int64(rtl)*int64(len(lvs)), SelsType)
				if err != nil {
					return nil, err
				}
				rs := encoding.DecodeInt64Slice(vec.Data)
				rs = rs[:len(lvs)]
				switch {
				case nulls.Any(lv.Nsp) && nulls.Any(rv.Nsp):
					vector.SetCol(vec, ne.Decimal64NeNullable(lvs, rvs, lv.Typ.Scale, rv.Typ.Scale, roaring.Or(lv.Nsp.Np, rv.Nsp.Np), rs))
				case !nulls.Any(lv.Nsp) && nulls.Any(rv.Nsp):
					vector.SetCol(vec, ne.Decimal64NeNullable(lvs, rvs, lv.Typ.Scale, rv.Typ.Scale, rv.Nsp.Np, rs))
				case nulls.Any(lv.Nsp) && !nulls.Any(rv.Nsp):
					vector.SetCol(vec, ne.Decimal64NeNullable(lvs, rvs, lv.Typ.Scale, rv.Typ.Scale, lv.Nsp.Np, rs))
				default:
					vector.SetCol(vec, ne.Decimal64Ne(lvs, rvs, lv.Typ.Scale, rv.Typ.Scale, rs))
				}
				if lv.Ref == 0 {
					process.Put(proc, lv)
				}
				if rv.Ref == 0 {
					process.Put(proc, rv)
				}
				return vec, nil
			},
		},
		{
			LeftType:   types.T_decimal128,
			RightType:  types.T_decimal128,
			ReturnType: types.T_sel,
			Fn: func(lv, rv *vector.Vector, proc *process.Process, lc, rc bool) (*vector.Vector, error) {
				lvs, rvs := lv.Col.([]types.Decimal128), rv.Col.([]types.Decimal128)
				rtl := 8
				switch {
				case lc && !rc:
					vec, err := process.Get(proc, int64(rtl)*int64(len(rvs)), SelsType)
					if err != nil {
						return nil, err
					}
					rs := encoding.DecodeInt64Slice(vec.Data)
					rs = rs[:len(rvs)]
					if nulls.Any(rv.Nsp) {
						vector.SetCol(vec, ne.Decimal128NeNullableScalar(lvs[0], rvs, lv.Typ.Scale, rv.Typ.Scale, rv.Nsp.Np, rs))
					} else {
						vector.SetCol(vec, ne.Decimal128NeScalar(lvs[0], rvs, lv.Typ.Scale, rv.Typ.Scale, rs))
					}
					if rv.Ref == 0 {
						process.Put(proc, rv)
					}
					return vec, nil
				case !lc && rc:
					vec, err := process.Get(proc, int64(rtl)*int64(len(lvs)), SelsType)
					if err != nil {
						return nil, err
					}
					rs := encoding.DecodeInt64Slice(vec.Data)
					rs = rs[:len(lvs)]
					if nulls.Any(lv.Nsp) {
						vector.SetCol(vec, ne.Decimal128NeNullableScalar(rvs[0], lvs, rv.Typ.Scale, lv.Typ.Scale, lv.Nsp.Np, rs))
					} else {
						vector.SetCol(vec, ne.Decimal128NeScalar(rvs[0], lvs, rv.Typ.Scale, lv.Typ.Scale, rs))
					}
					if lv.Ref == 0 {
						process.Put(proc, lv)
					}
					return vec, nil
				}
				vec, err := process.Get(proc, int64(rtl)*int64(len(lvs)), SelsType)
				if err != nil {
					return nil, err
				}
				rs := encoding.DecodeInt64Slice(vec.Data)
				rs = rs[:len(lvs)]
				switch {
				case nulls.Any(lv.Nsp) && nulls.Any(rv.Nsp):
					vector.SetCol(vec, ne.Decimal128NeNullable(lvs, rvs, lv.Typ.Scale, rv.Typ.Scale, roaring.Or(lv.Nsp.Np, rv.Nsp.Np), rs))
				case !nulls.Any(lv.Nsp) && nulls.Any(rv.Nsp):
					vector.SetCol(vec, ne.Decimal128NeNullable(lvs, rvs, lv.Typ.Scale, rv.Typ.Scale, rv.Nsp.Np, rs))
				case nulls.Any(lv.Nsp) && !nulls.Any(rv.Nsp):
					vector.SetCol(vec, ne.Decimal128NeNullable(lvs, rvs, lv.Typ.Scale, rv.Typ.Scale, lv.Nsp.Np, rs))
				default:
					vector.SetCol(vec, ne.Decimal128Ne(lvs, rvs, lv.Typ.Scale, rv.Typ.Scale, rs))
				}
				if lv.Ref == 0 {
					process.Put(proc, lv)
				}
				if rv.Ref == 0 {
					process.Put(proc, rv)
				}
				return vec, nil
			},
		},
    }
}