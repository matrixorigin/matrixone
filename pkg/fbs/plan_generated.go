// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package fbs

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type TypeId = uint16
const (
	TypeIdANY TypeId = 0
	TypeIdSTAR TypeId = 1
	TypeIdBOOL TypeId = 10
	TypeIdINT8 TypeId = 20
	TypeIdINT16 TypeId = 21
	TypeIdINT32 TypeId = 22
	TypeIdINT64 TypeId = 23
	TypeIdINT128 TypeId = 24
	TypeIdUINT8 TypeId = 25
	TypeIdUINT16 TypeId = 26
	TypeIdUINT32 TypeId = 27
	TypeIdUINT64 TypeId = 28
	TypeIdUINT128 TypeId = 29
	TypeIdFLOAT32 TypeId = 30
	TypeIdFLOAT64 TypeId = 31
	TypeIdDECIMAL64 TypeId = 32
	TypeIdDECIMAL128 TypeId = 33
	TypeIdDECIMAL TypeId = 34
	TypeIdANYINT TypeId = 37
	TypeIdANYFLOAT TypeId = 38
	TypeIdANYNUMBER TypeId = 39
	TypeIdUUID TypeId = 40
	TypeIdUB160 TypeId = 41
	TypeIdUB184 TypeId = 42
	TypeIdUB192 TypeId = 43
	TypeIdUB224 TypeId = 44
	TypeIdUB256 TypeId = 45
	TypeIdDATE TypeId = 50
	TypeIdTIME TypeId = 51
	TypeIdDATETIME TypeId = 52
	TypeIdTIMESTAMP TypeId = 53
	TypeIdINTERVAL TypeId = 54
	TypeIdANYTIME TypeId = 59
	TypeIdCHAR TypeId = 60
	TypeIdVARCHAR TypeId = 61
	TypeIdJSON TypeId = 62
	TypeIdBINARY TypeId = 70
	TypeIdVARBINARY TypeId = 71
	TypeIdARRAY TypeId = 90
	TypeIdFLEXBUFFER TypeId = 91
	TypeIdBYTEA8 TypeId = 100
	TypeIdBYTEA16 TypeId = 101
	TypeIdBYTEA TypeId = 102
	TypeIdSEL TypeId = 200
	TypeIdTUPLE TypeId = 201
)

var EnumNamesTypeId = map[TypeId]string{
	TypeIdANY:"ANY",
	TypeIdSTAR:"STAR",
	TypeIdBOOL:"BOOL",
	TypeIdINT8:"INT8",
	TypeIdINT16:"INT16",
	TypeIdINT32:"INT32",
	TypeIdINT64:"INT64",
	TypeIdINT128:"INT128",
	TypeIdUINT8:"UINT8",
	TypeIdUINT16:"UINT16",
	TypeIdUINT32:"UINT32",
	TypeIdUINT64:"UINT64",
	TypeIdUINT128:"UINT128",
	TypeIdFLOAT32:"FLOAT32",
	TypeIdFLOAT64:"FLOAT64",
	TypeIdDECIMAL64:"DECIMAL64",
	TypeIdDECIMAL128:"DECIMAL128",
	TypeIdDECIMAL:"DECIMAL",
	TypeIdANYINT:"ANYINT",
	TypeIdANYFLOAT:"ANYFLOAT",
	TypeIdANYNUMBER:"ANYNUMBER",
	TypeIdUUID:"UUID",
	TypeIdUB160:"UB160",
	TypeIdUB184:"UB184",
	TypeIdUB192:"UB192",
	TypeIdUB224:"UB224",
	TypeIdUB256:"UB256",
	TypeIdDATE:"DATE",
	TypeIdTIME:"TIME",
	TypeIdDATETIME:"DATETIME",
	TypeIdTIMESTAMP:"TIMESTAMP",
	TypeIdINTERVAL:"INTERVAL",
	TypeIdANYTIME:"ANYTIME",
	TypeIdCHAR:"CHAR",
	TypeIdVARCHAR:"VARCHAR",
	TypeIdJSON:"JSON",
	TypeIdBINARY:"BINARY",
	TypeIdVARBINARY:"VARBINARY",
	TypeIdARRAY:"ARRAY",
	TypeIdFLEXBUFFER:"FLEXBUFFER",
	TypeIdBYTEA8:"BYTEA8",
	TypeIdBYTEA16:"BYTEA16",
	TypeIdBYTEA:"BYTEA",
	TypeIdSEL:"SEL",
	TypeIdTUPLE:"TUPLE",
}

type DataFlag = byte
const (
	DataFlagIS_NULL DataFlag = 1
)

var EnumNamesDataFlag = map[DataFlag]string{
	DataFlagIS_NULL:"IS_NULL",
}

type DatumAttr = byte
const (
	DatumAttrNULL DatumAttr = 32
	DatumAttrB1 DatumAttr = 40
	DatumAttrB2 DatumAttr = 41
	DatumAttrB4 DatumAttr = 42
	DatumAttrB8 DatumAttr = 43
	DatumAttrB16 DatumAttr = 44
	DatumAttrUB1 DatumAttr = 45
	DatumAttrUB2 DatumAttr = 46
	DatumAttrUB4 DatumAttr = 47
	DatumAttrUB8 DatumAttr = 48
	DatumAttrUB16 DatumAttr = 49
	DatumAttrMEMAREA DatumAttr = 64
	DatumAttrMEMAREA_ROWSTE DatumAttr = 65
	DatumAttrMEMAREA_PLAN DatumAttr = 66
	DatumAttrMEMAREA_NODE DatumAttr = 67
	DatumAttrMEMAREA_QUERY DatumAttr = 69
	DatumAttrFP DatumAttr = 128
	DatumAttrFP_REMOTE DatumAttr = 129
	DatumAttrFP_LOCAL DatumAttr = 130
	DatumAttrFP_QUERY DatumAttr = 131
)

var EnumNamesDatumAttr = map[DatumAttr]string{
	DatumAttrNULL:"NULL",
	DatumAttrB1:"B1",
	DatumAttrB2:"B2",
	DatumAttrB4:"B4",
	DatumAttrB8:"B8",
	DatumAttrB16:"B16",
	DatumAttrUB1:"UB1",
	DatumAttrUB2:"UB2",
	DatumAttrUB4:"UB4",
	DatumAttrUB8:"UB8",
	DatumAttrUB16:"UB16",
	DatumAttrMEMAREA:"MEMAREA",
	DatumAttrMEMAREA_ROWSTE:"MEMAREA_ROWSTE",
	DatumAttrMEMAREA_PLAN:"MEMAREA_PLAN",
	DatumAttrMEMAREA_NODE:"MEMAREA_NODE",
	DatumAttrMEMAREA_QUERY:"MEMAREA_QUERY",
	DatumAttrFP:"FP",
	DatumAttrFP_REMOTE:"FP_REMOTE",
	DatumAttrFP_LOCAL:"FP_LOCAL",
	DatumAttrFP_QUERY:"FP_QUERY",
}

type FuncFlag = uint32
const (
	FuncFlagINTERNAL FuncFlag = 1
	FuncFlagSTABLE FuncFlag = 2
	FuncFlagVOLATILE FuncFlag = 4
	FuncFlagSTRICT FuncFlag = 8
	FuncFlagPRODUCE_NULL FuncFlag = 16
	FuncFlagPRODUCE_NO_NULL FuncFlag = 32
	FuncFlagVARARG FuncFlag = 64
	FuncFlagAGG FuncFlag = 128
	FuncFlagWIN FuncFlag = 256
)

var EnumNamesFuncFlag = map[FuncFlag]string{
	FuncFlagINTERNAL:"INTERNAL",
	FuncFlagSTABLE:"STABLE",
	FuncFlagVOLATILE:"VOLATILE",
	FuncFlagSTRICT:"STRICT",
	FuncFlagPRODUCE_NULL:"PRODUCE_NULL",
	FuncFlagPRODUCE_NO_NULL:"PRODUCE_NO_NULL",
	FuncFlagVARARG:"VARARG",
	FuncFlagAGG:"AGG",
	FuncFlagWIN:"WIN",
}

type OrderByFlag = uint16
const (
	OrderByFlagASC OrderByFlag = 1
	OrderByFlagDESC OrderByFlag = 2
	OrderByFlagNULLS_FIRST OrderByFlag = 4
	OrderByFlagNULLS_LAST OrderByFlag = 8
	OrderByFlagUNIQUE OrderByFlag = 16
	OrderByFlagINTERNAL OrderByFlag = 32
)

var EnumNamesOrderByFlag = map[OrderByFlag]string{
	OrderByFlagASC:"ASC",
	OrderByFlagDESC:"DESC",
	OrderByFlagNULLS_FIRST:"NULLS_FIRST",
	OrderByFlagNULLS_LAST:"NULLS_LAST",
	OrderByFlagUNIQUE:"UNIQUE",
	OrderByFlagINTERNAL:"INTERNAL",
}

type JoinFlag = uint16
const (
	JoinFlagAPPLY JoinFlag = 1
	JoinFlagOUTER JoinFlag = 2
	JoinFlagSEMI JoinFlag = 4
	JoinFlagANTI JoinFlag = 8
	JoinFlagSINGLE JoinFlag = 16
	JoinFlagMARK JoinFlag = 32
)

var EnumNamesJoinFlag = map[JoinFlag]string{
	JoinFlagAPPLY:"APPLY",
	JoinFlagOUTER:"OUTER",
	JoinFlagSEMI:"SEMI",
	JoinFlagANTI:"ANTI",
	JoinFlagSINGLE:"SINGLE",
	JoinFlagMARK:"MARK",
}

type AggType = uint16
const (
	AggTypeFULL AggType = 0
	AggTypeBOTTOM AggType = 1
	AggTypeTOP AggType = 2
)

var EnumNamesAggType = map[AggType]string{
	AggTypeFULL:"FULL",
	AggTypeBOTTOM:"BOTTOM",
	AggTypeTOP:"TOP",
}

type NodeType = uint32
const (
	NodeTypeUNKNOWN NodeType = 0
	NodeTypeSELECT NodeType = 1
	NodeTypeINSERT NodeType = 2
	NodeTypeDELETE NodeType = 3
	NodeTypeUPDATE NodeType = 4
	NodeTypeValueScan NodeType = 5
	NodeTypeTableScan NodeType = 6
	NodeTypeFunctionScan NodeType = 7
	NodeTypeExternalScan NodeType = 8
	NodeTypeProject NodeType = 9
	NodeTypeExternalFunction NodeType = 10
	NodeTypeMaterial NodeType = 11
	NodeTypeRecursiveCTE NodeType = 12
	NodeTypeSink NodeType = 13
	NodeTypeSinkScan NodeType = 14
	NodeTypeAgg NodeType = 15
	NodeTypeJoin NodeType = 16
	NodeTypeLimitOffset NodeType = 17
	NodeTypeSample NodeType = 18
	NodeTypeSort NodeType = 19
	NodeTypeUnion NodeType = 20
	NodeTypeUnionAll NodeType = 21
	NodeTypeUnique NodeType = 22
	NodeTypeWindow NodeType = 23
	NodeTypeBroadcast NodeType = 24
	NodeTypeSplit NodeType = 25
	NodeTypeGather NodeType = 26
	NodeTypeAssert NodeType = 27
)

var EnumNamesNodeType = map[NodeType]string{
	NodeTypeUNKNOWN:"UNKNOWN",
	NodeTypeSELECT:"SELECT",
	NodeTypeINSERT:"INSERT",
	NodeTypeDELETE:"DELETE",
	NodeTypeUPDATE:"UPDATE",
	NodeTypeValueScan:"ValueScan",
	NodeTypeTableScan:"TableScan",
	NodeTypeFunctionScan:"FunctionScan",
	NodeTypeExternalScan:"ExternalScan",
	NodeTypeProject:"Project",
	NodeTypeExternalFunction:"ExternalFunction",
	NodeTypeMaterial:"Material",
	NodeTypeRecursiveCTE:"RecursiveCTE",
	NodeTypeSink:"Sink",
	NodeTypeSinkScan:"SinkScan",
	NodeTypeAgg:"Agg",
	NodeTypeJoin:"Join",
	NodeTypeLimitOffset:"LimitOffset",
	NodeTypeSample:"Sample",
	NodeTypeSort:"Sort",
	NodeTypeUnion:"Union",
	NodeTypeUnionAll:"UnionAll",
	NodeTypeUnique:"Unique",
	NodeTypeWindow:"Window",
	NodeTypeBroadcast:"Broadcast",
	NodeTypeSplit:"Split",
	NodeTypeGather:"Gather",
	NodeTypeAssert:"Assert",
}

type Datum struct {
	_tab flatbuffers.Struct
}

func (rcv *Datum) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Datum) Table() flatbuffers.Table {
	return rcv._tab.Table
}

func (rcv *Datum) A() uint64 {
	return rcv._tab.GetUint64(rcv._tab.Pos + flatbuffers.UOffsetT(0))
}
func (rcv *Datum) MutateA(n uint64) bool {
	return rcv._tab.MutateUint64(rcv._tab.Pos+flatbuffers.UOffsetT(0), n)
}

func (rcv *Datum) B() uint64 {
	return rcv._tab.GetUint64(rcv._tab.Pos + flatbuffers.UOffsetT(8))
}
func (rcv *Datum) MutateB(n uint64) bool {
	return rcv._tab.MutateUint64(rcv._tab.Pos+flatbuffers.UOffsetT(8), n)
}

func (rcv *Datum) C() uint64 {
	return rcv._tab.GetUint64(rcv._tab.Pos + flatbuffers.UOffsetT(16))
}
func (rcv *Datum) MutateC(n uint64) bool {
	return rcv._tab.MutateUint64(rcv._tab.Pos+flatbuffers.UOffsetT(16), n)
}

func (rcv *Datum) D() uint64 {
	return rcv._tab.GetUint64(rcv._tab.Pos + flatbuffers.UOffsetT(24))
}
func (rcv *Datum) MutateD(n uint64) bool {
	return rcv._tab.MutateUint64(rcv._tab.Pos+flatbuffers.UOffsetT(24), n)
}

func CreateDatum(builder *flatbuffers.Builder, a uint64, b uint64, c uint64, d uint64) flatbuffers.UOffsetT {
	builder.Prep(8, 32)
	builder.PrependUint64(d)
	builder.PrependUint64(c)
	builder.PrependUint64(b)
	builder.PrependUint64(a)
	return builder.Offset()
}
type Type struct {
	_tab flatbuffers.Table
}

func GetRootAsType(buf []byte, offset flatbuffers.UOffsetT) *Type {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Type{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Type) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Type) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Type) Id() TypeId {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Type) MutateId(n TypeId) bool {
	return rcv._tab.MutateUint16Slot(4, n)
}

func (rcv *Type) Nullable() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *Type) MutateNullable(n bool) bool {
	return rcv._tab.MutateBoolSlot(6, n)
}

func (rcv *Type) Width() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Type) MutateWidth(n int32) bool {
	return rcv._tab.MutateInt32Slot(8, n)
}

func (rcv *Type) Precision() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Type) MutatePrecision(n int32) bool {
	return rcv._tab.MutateInt32Slot(10, n)
}

func TypeStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func TypeAddId(builder *flatbuffers.Builder, id uint16) {
	builder.PrependUint16Slot(0, id, 0)
}
func TypeAddNullable(builder *flatbuffers.Builder, nullable bool) {
	builder.PrependBoolSlot(1, nullable, false)
}
func TypeAddWidth(builder *flatbuffers.Builder, width int32) {
	builder.PrependInt32Slot(2, width, 0)
}
func TypeAddPrecision(builder *flatbuffers.Builder, precision int32) {
	builder.PrependInt32Slot(3, precision, 0)
}
func TypeEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Const struct {
	_tab flatbuffers.Table
}

func GetRootAsConst(buf []byte, offset flatbuffers.UOffsetT) *Const {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Const{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Const) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Const) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Const) Typ(obj *Type) *Type {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Type)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Const) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Const) Isnull() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *Const) MutateIsnull(n bool) bool {
	return rcv._tab.MutateBoolSlot(8, n)
}

func (rcv *Const) Ival() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Const) MutateIval(n int64) bool {
	return rcv._tab.MutateInt64Slot(10, n)
}

func (rcv *Const) Fval() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *Const) MutateFval(n float64) bool {
	return rcv._tab.MutateFloat64Slot(12, n)
}

func (rcv *Const) Sval() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func ConstStart(builder *flatbuffers.Builder) {
	builder.StartObject(6)
}
func ConstAddTyp(builder *flatbuffers.Builder, typ flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(typ), 0)
}
func ConstAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(name), 0)
}
func ConstAddIsnull(builder *flatbuffers.Builder, isnull bool) {
	builder.PrependBoolSlot(2, isnull, false)
}
func ConstAddIval(builder *flatbuffers.Builder, ival int64) {
	builder.PrependInt64Slot(3, ival, 0)
}
func ConstAddFval(builder *flatbuffers.Builder, fval float64) {
	builder.PrependFloat64Slot(4, fval, 0.0)
}
func ConstAddSval(builder *flatbuffers.Builder, sval flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(sval), 0)
}
func ConstEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ParamRef struct {
	_tab flatbuffers.Table
}

func GetRootAsParamRef(buf []byte, offset flatbuffers.UOffsetT) *ParamRef {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ParamRef{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ParamRef) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ParamRef) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ParamRef) Typ(obj *Type) *Type {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Type)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ParamRef) Pos() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ParamRef) MutatePos(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func ParamRefStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func ParamRefAddTyp(builder *flatbuffers.Builder, typ flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(typ), 0)
}
func ParamRefAddPos(builder *flatbuffers.Builder, pos int32) {
	builder.PrependInt32Slot(1, pos, 0)
}
func ParamRefEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type VarRef struct {
	_tab flatbuffers.Table
}

func GetRootAsVarRef(buf []byte, offset flatbuffers.UOffsetT) *VarRef {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &VarRef{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *VarRef) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *VarRef) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *VarRef) Typ(obj *Type) *Type {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Type)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *VarRef) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func VarRefStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func VarRefAddTyp(builder *flatbuffers.Builder, typ flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(typ), 0)
}
func VarRefAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(name), 0)
}
func VarRefEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ObjectRef struct {
	_tab flatbuffers.Table
}

func GetRootAsObjectRef(buf []byte, offset flatbuffers.UOffsetT) *ObjectRef {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ObjectRef{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ObjectRef) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ObjectRef) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ObjectRef) Server() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ObjectRef) Database() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ObjectRef) Schema() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ObjectRef) Object() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func ObjectRefStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func ObjectRefAddServer(builder *flatbuffers.Builder, server flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(server), 0)
}
func ObjectRefAddDatabase(builder *flatbuffers.Builder, database flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(database), 0)
}
func ObjectRefAddSchema(builder *flatbuffers.Builder, schema flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(schema), 0)
}
func ObjectRefAddObject(builder *flatbuffers.Builder, object flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(object), 0)
}
func ObjectRefEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ColumnRef struct {
	_tab flatbuffers.Table
}

func GetRootAsColumnRef(buf []byte, offset flatbuffers.UOffsetT) *ColumnRef {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ColumnRef{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ColumnRef) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ColumnRef) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ColumnRef) Typ(obj *Type) *Type {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Type)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ColumnRef) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ColumnRef) RelationPos() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ColumnRef) MutateRelationPos(n int32) bool {
	return rcv._tab.MutateInt32Slot(8, n)
}

func (rcv *ColumnRef) ColumnPos() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ColumnRef) MutateColumnPos(n int32) bool {
	return rcv._tab.MutateInt32Slot(10, n)
}

func ColumnRefStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func ColumnRefAddTyp(builder *flatbuffers.Builder, typ flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(typ), 0)
}
func ColumnRefAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(name), 0)
}
func ColumnRefAddRelationPos(builder *flatbuffers.Builder, relationPos int32) {
	builder.PrependInt32Slot(2, relationPos, 0)
}
func ColumnRefAddColumnPos(builder *flatbuffers.Builder, columnPos int32) {
	builder.PrependInt32Slot(3, columnPos, 0)
}
func ColumnRefEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Expr struct {
	_tab flatbuffers.Table
}

func GetRootAsExpr(buf []byte, offset flatbuffers.UOffsetT) *Expr {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Expr{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Expr) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Expr) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Expr) Typ(obj *Type) *Type {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Type)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Expr) Value(obj *Const) *Const {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Const)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Expr) Param(obj *ParamRef) *ParamRef {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(ParamRef)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Expr) Colref(obj *ColumnRef) *ColumnRef {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(ColumnRef)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Expr) Func(obj *ObjectRef) *ObjectRef {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(ObjectRef)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Expr) Args(obj *Expr, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Expr) ArgsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Expr) Options() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func ExprStart(builder *flatbuffers.Builder) {
	builder.StartObject(7)
}
func ExprAddTyp(builder *flatbuffers.Builder, typ flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(typ), 0)
}
func ExprAddValue(builder *flatbuffers.Builder, value flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(value), 0)
}
func ExprAddParam(builder *flatbuffers.Builder, param flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(param), 0)
}
func ExprAddColref(builder *flatbuffers.Builder, colref flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(colref), 0)
}
func ExprAddFunc(builder *flatbuffers.Builder, func_ flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(func_), 0)
}
func ExprAddArgs(builder *flatbuffers.Builder, args flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(args), 0)
}
func ExprStartArgsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ExprAddOptions(builder *flatbuffers.Builder, options flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(options), 0)
}
func ExprEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Column struct {
	_tab flatbuffers.Table
}

func GetRootAsColumn(buf []byte, offset flatbuffers.UOffsetT) *Column {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Column{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Column) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Column) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Column) Typ(obj *Type) *Type {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Type)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Column) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Column) Pkidx() int16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetInt16(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Column) MutatePkidx(n int16) bool {
	return rcv._tab.MutateInt16Slot(8, n)
}

func ColumnStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func ColumnAddTyp(builder *flatbuffers.Builder, typ flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(typ), 0)
}
func ColumnAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(name), 0)
}
func ColumnAddPkidx(builder *flatbuffers.Builder, pkidx int16) {
	builder.PrependInt16Slot(2, pkidx, 0)
}
func ColumnEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Schema struct {
	_tab flatbuffers.Table
}

func GetRootAsSchema(buf []byte, offset flatbuffers.UOffsetT) *Schema {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Schema{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Schema) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Schema) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Schema) Columns(obj *Column, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Schema) ColumnsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func SchemaStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func SchemaAddColumns(builder *flatbuffers.Builder, columns flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(columns), 0)
}
func SchemaStartColumnsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SchemaEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Cost struct {
	_tab flatbuffers.Struct
}

func (rcv *Cost) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Cost) Table() flatbuffers.Table {
	return rcv._tab.Table
}

func (rcv *Cost) Start() float64 {
	return rcv._tab.GetFloat64(rcv._tab.Pos + flatbuffers.UOffsetT(0))
}
func (rcv *Cost) MutateStart(n float64) bool {
	return rcv._tab.MutateFloat64(rcv._tab.Pos+flatbuffers.UOffsetT(0), n)
}

func (rcv *Cost) Total() float64 {
	return rcv._tab.GetFloat64(rcv._tab.Pos + flatbuffers.UOffsetT(8))
}
func (rcv *Cost) MutateTotal(n float64) bool {
	return rcv._tab.MutateFloat64(rcv._tab.Pos+flatbuffers.UOffsetT(8), n)
}

func (rcv *Cost) Cardinality() float64 {
	return rcv._tab.GetFloat64(rcv._tab.Pos + flatbuffers.UOffsetT(16))
}
func (rcv *Cost) MutateCardinality(n float64) bool {
	return rcv._tab.MutateFloat64(rcv._tab.Pos+flatbuffers.UOffsetT(16), n)
}

func (rcv *Cost) Rowsize() float64 {
	return rcv._tab.GetFloat64(rcv._tab.Pos + flatbuffers.UOffsetT(24))
}
func (rcv *Cost) MutateRowsize(n float64) bool {
	return rcv._tab.MutateFloat64(rcv._tab.Pos+flatbuffers.UOffsetT(24), n)
}

func (rcv *Cost) Ndv() float64 {
	return rcv._tab.GetFloat64(rcv._tab.Pos + flatbuffers.UOffsetT(32))
}
func (rcv *Cost) MutateNdv(n float64) bool {
	return rcv._tab.MutateFloat64(rcv._tab.Pos+flatbuffers.UOffsetT(32), n)
}

func CreateCost(builder *flatbuffers.Builder, start float64, total float64, cardinality float64, rowsize float64, ndv float64) flatbuffers.UOffsetT {
	builder.Prep(8, 40)
	builder.PrependFloat64(ndv)
	builder.PrependFloat64(rowsize)
	builder.PrependFloat64(cardinality)
	builder.PrependFloat64(total)
	builder.PrependFloat64(start)
	return builder.Offset()
}
type ColData struct {
	_tab flatbuffers.Table
}

func GetRootAsColData(buf []byte, offset flatbuffers.UOffsetT) *ColData {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ColData{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *ColData) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ColData) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ColData) RowCount() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ColData) MutateRowCount(n int32) bool {
	return rcv._tab.MutateInt32Slot(4, n)
}

func (rcv *ColData) NullCount() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ColData) MutateNullCount(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func (rcv *ColData) Flags(j int) DataFlag {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *ColData) FlagsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ColData) FlagsBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ColData) MutateFlags(j int, n DataFlag) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *ColData) I8(j int) int8 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt8(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *ColData) I8Length() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ColData) MutateI8(j int, n int8) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt8(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *ColData) I16(j int) int16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt16(a + flatbuffers.UOffsetT(j*2))
	}
	return 0
}

func (rcv *ColData) I16Length() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ColData) MutateI16(j int, n int16) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt16(a+flatbuffers.UOffsetT(j*2), n)
	}
	return false
}

func (rcv *ColData) I32(j int) int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *ColData) I32Length() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ColData) MutateI32(j int, n int32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func (rcv *ColData) I64(j int) int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *ColData) I64Length() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ColData) MutateI64(j int, n int64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

func (rcv *ColData) F32(j int) float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetFloat32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *ColData) F32Length() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ColData) MutateF32(j int, n float32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateFloat32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func (rcv *ColData) F64(j int) float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetFloat64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *ColData) F64Length() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ColData) MutateF64(j int, n float64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateFloat64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

func (rcv *ColData) S(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *ColData) SLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func ColDataStart(builder *flatbuffers.Builder) {
	builder.StartObject(10)
}
func ColDataAddRowCount(builder *flatbuffers.Builder, rowCount int32) {
	builder.PrependInt32Slot(0, rowCount, 0)
}
func ColDataAddNullCount(builder *flatbuffers.Builder, nullCount int32) {
	builder.PrependInt32Slot(1, nullCount, 0)
}
func ColDataAddFlags(builder *flatbuffers.Builder, flags flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(flags), 0)
}
func ColDataStartFlagsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func ColDataAddI8(builder *flatbuffers.Builder, i8 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(i8), 0)
}
func ColDataStartI8Vector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func ColDataAddI16(builder *flatbuffers.Builder, i16 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(i16), 0)
}
func ColDataStartI16Vector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(2, numElems, 2)
}
func ColDataAddI32(builder *flatbuffers.Builder, i32 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(i32), 0)
}
func ColDataStartI32Vector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ColDataAddI64(builder *flatbuffers.Builder, i64 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(i64), 0)
}
func ColDataStartI64Vector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func ColDataAddF32(builder *flatbuffers.Builder, f32 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(f32), 0)
}
func ColDataStartF32Vector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ColDataAddF64(builder *flatbuffers.Builder, f64 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(f64), 0)
}
func ColDataStartF64Vector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func ColDataAddS(builder *flatbuffers.Builder, s flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(s), 0)
}
func ColDataStartSVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ColDataEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type RowsetData struct {
	_tab flatbuffers.Table
}

func GetRootAsRowsetData(buf []byte, offset flatbuffers.UOffsetT) *RowsetData {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &RowsetData{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *RowsetData) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *RowsetData) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *RowsetData) Schema(obj *Schema) *Schema {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(Schema)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *RowsetData) Cols(obj *ColData, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *RowsetData) ColsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func RowsetDataStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func RowsetDataAddSchema(builder *flatbuffers.Builder, schema flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(schema), 0)
}
func RowsetDataAddCols(builder *flatbuffers.Builder, cols flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(cols), 0)
}
func RowsetDataStartColsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func RowsetDataEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type WindowSpec struct {
	_tab flatbuffers.Table
}

func GetRootAsWindowSpec(buf []byte, offset flatbuffers.UOffsetT) *WindowSpec {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &WindowSpec{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *WindowSpec) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *WindowSpec) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *WindowSpec) PartitionBy(obj *Expr, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *WindowSpec) PartitionByLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *WindowSpec) OrderBy(obj *Expr, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *WindowSpec) OrderByLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *WindowSpec) OrderByCollations(j int) int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *WindowSpec) OrderByCollationsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *WindowSpec) MutateOrderByCollations(j int, n int32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func (rcv *WindowSpec) OrderByFlags(j int) OrderByFlag {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint16(a + flatbuffers.UOffsetT(j*2))
	}
	return 0
}

func (rcv *WindowSpec) OrderByFlagsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *WindowSpec) MutateOrderByFlags(j int, n OrderByFlag) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint16(a+flatbuffers.UOffsetT(j*2), n)
	}
	return false
}

func (rcv *WindowSpec) Lead() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *WindowSpec) MutateLead(n int32) bool {
	return rcv._tab.MutateInt32Slot(12, n)
}

func (rcv *WindowSpec) Lag() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *WindowSpec) MutateLag(n int32) bool {
	return rcv._tab.MutateInt32Slot(14, n)
}

func WindowSpecStart(builder *flatbuffers.Builder) {
	builder.StartObject(6)
}
func WindowSpecAddPartitionBy(builder *flatbuffers.Builder, partitionBy flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(partitionBy), 0)
}
func WindowSpecStartPartitionByVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func WindowSpecAddOrderBy(builder *flatbuffers.Builder, orderBy flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(orderBy), 0)
}
func WindowSpecStartOrderByVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func WindowSpecAddOrderByCollations(builder *flatbuffers.Builder, orderByCollations flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(orderByCollations), 0)
}
func WindowSpecStartOrderByCollationsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func WindowSpecAddOrderByFlags(builder *flatbuffers.Builder, orderByFlags flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(orderByFlags), 0)
}
func WindowSpecStartOrderByFlagsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(2, numElems, 2)
}
func WindowSpecAddLead(builder *flatbuffers.Builder, lead int32) {
	builder.PrependInt32Slot(4, lead, 0)
}
func WindowSpecAddLag(builder *flatbuffers.Builder, lag int32) {
	builder.PrependInt32Slot(5, lag, 0)
}
func WindowSpecEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Node struct {
	_tab flatbuffers.Table
}

func GetRootAsNode(buf []byte, offset flatbuffers.UOffsetT) *Node {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Node{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Node) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Node) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Node) Id() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Node) MutateId(n int32) bool {
	return rcv._tab.MutateInt32Slot(4, n)
}

func (rcv *Node) NodeType() NodeType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Node) MutateNodeType(n NodeType) bool {
	return rcv._tab.MutateUint32Slot(6, n)
}

func (rcv *Node) Cost(obj *Cost) *Cost {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(Cost)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Node) Filter(obj *Expr, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Node) FilterLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Node) Project(obj *Expr, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Node) ProjectLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Node) Children(j int) int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *Node) ChildrenLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Node) MutateChildren(j int, n int32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func (rcv *Node) JoinType() JoinFlag {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Node) MutateJoinType(n JoinFlag) bool {
	return rcv._tab.MutateUint16Slot(16, n)
}

func (rcv *Node) On(obj *Expr, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Node) OnLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Node) Where(obj *Expr, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Node) WhereLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Node) GroupBy(obj *Expr, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Node) GroupByLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Node) GroupingSets(obj *Expr, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Node) GroupingSetsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Node) OrderBy(obj *Expr, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Node) OrderByLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Node) OrderByCollations(j int) int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *Node) OrderByCollationsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Node) MutateOrderByCollations(j int, n int32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func (rcv *Node) OrderByFlags(j int) OrderByFlag {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint16(a + flatbuffers.UOffsetT(j*2))
	}
	return 0
}

func (rcv *Node) OrderByFlagsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Node) MutateOrderByFlags(j int, n OrderByFlag) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint16(a+flatbuffers.UOffsetT(j*2), n)
	}
	return false
}

func (rcv *Node) Window(obj *WindowSpec) *WindowSpec {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(WindowSpec)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *Node) Limit(obj *Expr, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Node) LimitLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Node) Offset(obj *Expr, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Node) OffsetLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Node) TableRef(obj *ObjectRef, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Node) TableRefLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Node) RowsetData(obj *RowsetData, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Node) RowsetDataLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Node) Options() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func NodeStart(builder *flatbuffers.Builder) {
	builder.StartObject(20)
}
func NodeAddId(builder *flatbuffers.Builder, id int32) {
	builder.PrependInt32Slot(0, id, 0)
}
func NodeAddNodeType(builder *flatbuffers.Builder, nodeType uint32) {
	builder.PrependUint32Slot(1, nodeType, 0)
}
func NodeAddCost(builder *flatbuffers.Builder, cost flatbuffers.UOffsetT) {
	builder.PrependStructSlot(2, flatbuffers.UOffsetT(cost), 0)
}
func NodeAddFilter(builder *flatbuffers.Builder, filter flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(filter), 0)
}
func NodeStartFilterVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func NodeAddProject(builder *flatbuffers.Builder, project flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(project), 0)
}
func NodeStartProjectVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func NodeAddChildren(builder *flatbuffers.Builder, children flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(children), 0)
}
func NodeStartChildrenVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func NodeAddJoinType(builder *flatbuffers.Builder, joinType uint16) {
	builder.PrependUint16Slot(6, joinType, 0)
}
func NodeAddOn(builder *flatbuffers.Builder, on flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(on), 0)
}
func NodeStartOnVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func NodeAddWhere(builder *flatbuffers.Builder, where flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(where), 0)
}
func NodeStartWhereVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func NodeAddGroupBy(builder *flatbuffers.Builder, groupBy flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(groupBy), 0)
}
func NodeStartGroupByVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func NodeAddGroupingSets(builder *flatbuffers.Builder, groupingSets flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(10, flatbuffers.UOffsetT(groupingSets), 0)
}
func NodeStartGroupingSetsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func NodeAddOrderBy(builder *flatbuffers.Builder, orderBy flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(11, flatbuffers.UOffsetT(orderBy), 0)
}
func NodeStartOrderByVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func NodeAddOrderByCollations(builder *flatbuffers.Builder, orderByCollations flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(12, flatbuffers.UOffsetT(orderByCollations), 0)
}
func NodeStartOrderByCollationsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func NodeAddOrderByFlags(builder *flatbuffers.Builder, orderByFlags flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(13, flatbuffers.UOffsetT(orderByFlags), 0)
}
func NodeStartOrderByFlagsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(2, numElems, 2)
}
func NodeAddWindow(builder *flatbuffers.Builder, window flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(14, flatbuffers.UOffsetT(window), 0)
}
func NodeAddLimit(builder *flatbuffers.Builder, limit flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(15, flatbuffers.UOffsetT(limit), 0)
}
func NodeStartLimitVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func NodeAddOffset(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(16, flatbuffers.UOffsetT(offset), 0)
}
func NodeStartOffsetVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func NodeAddTableRef(builder *flatbuffers.Builder, tableRef flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(17, flatbuffers.UOffsetT(tableRef), 0)
}
func NodeStartTableRefVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func NodeAddRowsetData(builder *flatbuffers.Builder, rowsetData flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(18, flatbuffers.UOffsetT(rowsetData), 0)
}
func NodeStartRowsetDataVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func NodeAddOptions(builder *flatbuffers.Builder, options flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(19, flatbuffers.UOffsetT(options), 0)
}
func NodeEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Query struct {
	_tab flatbuffers.Table
}

func GetRootAsQuery(buf []byte, offset flatbuffers.UOffsetT) *Query {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Query{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Query) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Query) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Query) Steps(j int) int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *Query) StepsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Query) MutateSteps(j int, n int32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func (rcv *Query) Nodes(obj *Node, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Query) NodesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Query) Params(obj *Const, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Query) ParamsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func QueryStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func QueryAddSteps(builder *flatbuffers.Builder, steps flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(steps), 0)
}
func QueryStartStepsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func QueryAddNodes(builder *flatbuffers.Builder, nodes flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(nodes), 0)
}
func QueryStartNodesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func QueryAddParams(builder *flatbuffers.Builder, params flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(params), 0)
}
func QueryStartParamsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func QueryEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
