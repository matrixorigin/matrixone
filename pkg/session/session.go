package session

import (
	"context"
	"crypto/tls"
	"fmt"
	"github.com/pingcap/parser"
	"github.com/pingcap/parser/ast"
	"github.com/pingcap/parser/auth"
	"github.com/pingcap/parser/charset"
	"github.com/pingcap/parser/model"
	"github.com/pingcap/parser/terror"
	"matrixone/pkg/sessionctx"
	"matrixone/pkg/sessionctx/variable"
	"matrixone/pkg/util"
	"sync"
	"sync/atomic"
)

type Session interface {
	sessionctx.Context
	Status() uint16 // Flag of current status, such as autocommit.
	Parse(ctx context.Context, sql string) ([]ast.StmtNode, error)
	Auth(user *auth.UserIdentity, auth []byte, salt []byte) bool
	SetPort(port string)
	SetSessionManager(util.SessionManager)
	GetSessionManager() util.SessionManager
	SetCommandValue(byte)
	LastInsertID() uint64 // LastInsertID is the last inserted auto_increment ID.
	LastMessage() string  // LastMessage is the info message that may be generated by last command
	AffectedRows() uint64 // Affected rows by latest executed stmt.
	Close()
	AuthWithoutVerification(user *auth.UserIdentity) bool
	SetClientCapability(uint32) // Set client capability flags.
	SetConnectionID(uint64)
	SetTLSState(*tls.ConnectionState)
	SetCollation(coID int) error
}

type session struct {
	// processInfo is used by ShowProcess(), and should be modified atomically.
	processInfo atomic.Value

	mu struct {
		sync.RWMutex
		values map[fmt.Stringer]interface{}
	}

	currentCtx context.Context // only use for runtime.trace, Please NEVER use it.
	// currentPlan plannercore.Plan

	parser *parser.Parser

	sessionVars    *variable.SessionVars
	sessionManager util.SessionManager

	// lockedTables use to record the table locks hold by the session.
	lockedTables map[int64]model.TableLockTpInfo
}

// Opt describes the option for creating session
type Opt struct {
}

// CreateSession4TestWithOpt creates a new session environment for test.
func CreateSession4TestWithOpt(opt *Opt) (*session, error) {
	s, err := CreateSessionWithOpt(opt)
	return s, err
}

// CreateSession creates a new session environment.
func CreateSession() (*session, error) {
	return CreateSessionWithOpt(nil)
}

// CreateSessionWithOpt creates a new session environment with option.
// Use default option if opt is nil.
func CreateSessionWithOpt(opt *Opt) (*session, error) {
	s, err := createSessionWithOpt(opt)
	if err != nil {
		return nil, err
	}

	return s, nil
}

func createSessionWithOpt(opt *Opt) (*session, error) {
	s := &session{
		parser:      parser.New(),
		sessionVars: variable.NewSessionVars(),
	}
	s.mu.values = make(map[fmt.Stringer]interface{})

	return s, nil
}

func (s *session) SetValue(key fmt.Stringer, value interface{}) {
	s.mu.Lock()
	s.mu.values[key] = value
	s.mu.Unlock()
}

func (s *session) Value(key fmt.Stringer) interface{} {
	s.mu.RLock()
	value := s.mu.values[key]
	s.mu.RUnlock()
	return value
}

func (s *session) ClearValue(key fmt.Stringer) {
	s.mu.Lock()
	delete(s.mu.values, key)
	s.mu.Unlock()
}

func (s *session) Status() uint16 {
	return s.sessionVars.Status
}

func (s *session) LastInsertID() uint64 {
	if s.sessionVars.StmtCtx.LastInsertID > 0 {
		return s.sessionVars.StmtCtx.LastInsertID
	}
	return s.sessionVars.StmtCtx.InsertID
}

func (s *session) LastMessage() string {
	return s.sessionVars.StmtCtx.GetMessage()
}

func (s *session) AffectedRows() uint64 {
	return s.sessionVars.StmtCtx.AffectedRows()
}

func (s *session) Close() {
}

func (s *session) Auth(user *auth.UserIdentity, authentication []byte, salt []byte) bool {
	return true
}

// AuthWithoutVerification is required by the ResetConnection RPC
func (s *session) AuthWithoutVerification(user *auth.UserIdentity) bool {
	return true
}

func (s *session) SetSessionManager(sm util.SessionManager) {
	s.sessionManager = sm
}

func (s *session) GetSessionManager() util.SessionManager {
	return s.sessionManager
}

func (s *session) SetClientCapability(capability uint32) {
	s.sessionVars.ClientCapability = capability
}

func (s *session) SetTLSState(tlsState *tls.ConnectionState) {
	// If user is not connected via TLS, then tlsState == nil.
	if tlsState != nil {
		s.sessionVars.TLSConnectionState = tlsState
	}
}

func (s *session) SetCollation(coID int) error {
	cs, co, err := charset.GetCharsetInfoByID(coID)
	if err != nil {
		return err
	}
	for _, v := range variable.SetNamesVariables {
		terror.Log(s.sessionVars.SetSystemVar(v, cs))
	}
	return s.sessionVars.SetSystemVar(variable.CollationConnection, co)
}

// GetGlobalSysVar implements GlobalVarAccessor.GetGlobalSysVar interface.
func (s *session) GetGlobalSysVar(name string) (string, error) {
	return "", nil
}

// SetGlobalSysVar implements GlobalVarAccessor.SetGlobalSysVar interface.
func (s *session) SetGlobalSysVar(name, value string) error {
	return nil
}

func (s *session) SetConnectionID(connectionID uint64) {
	s.sessionVars.ConnectionID = connectionID
}

// GetSessionVars implements the context.Context interface.
func (s *session) GetSessionVars() *variable.SessionVars {
	return s.sessionVars
}

// rollbackOnError makes sure the next statement starts a new transaction with the latest InfoSchema.
func (s *session) rollbackOnError(ctx context.Context) {
}

func (s *session) ParseSQL(ctx context.Context, sql, charset, collation string) ([]ast.StmtNode, []error, error) {
	s.parser.SetSQLMode(s.sessionVars.SQLMode)
	s.parser.SetParserConfig(s.sessionVars.BuildParserConfig())
	return s.parser.Parse(sql, charset, collation)
}

// Parse parses a query string to raw ast.StmtNode.
func (s *session) Parse(ctx context.Context, sql string) ([]ast.StmtNode, error) {
	charsetInfo, collation := s.sessionVars.GetCharsetInfo()
	stmts, warns, err := s.ParseSQL(ctx, sql, charsetInfo, collation)
	if err != nil {
		s.rollbackOnError(ctx)

		// Only print log message when this SQL is from the user.
		// Mute the warning for internal SQLs.
		// if !s.sessionVars.InRestrictedSQL {
		// 	if s.sessionVars.EnableRedactLog {
		// 		logutil.Logger(ctx).Debug("parse SQL failed", zap.Error(err), zap.String("SQL", sql))
		// 	} else {
		// 		logutil.Logger(ctx).Warn("parse SQL failed", zap.Error(err), zap.String("SQL", sql))
		// 	}
		// }
		return nil, util.SyntaxError(err)
	}

	for _, warn := range warns {
		s.sessionVars.StmtCtx.AppendWarning(util.SyntaxWarn(warn))
	}
	return stmts, nil
}

func (s *session) SetCommandValue(command byte) {
	atomic.StoreUint32(&s.sessionVars.CommandValue, uint32(command))
}

func (s *session) SetPort(port string) {
	s.sessionVars.Port = port
}
