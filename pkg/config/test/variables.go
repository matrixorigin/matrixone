// Code generated by tool; DO NOT EDIT.
package config

import (
	"fmt"
	"github.com/BurntSushi/toml"
	"sync"
)

//all parameters in the system
type Variables struct {
	//read and write lock
	rwlock sync.RWMutex

	/**
	Name:	autoload
	Scope:	[global]
	Access:	[file]
	DataType:	bool
	DomainType:	set
	Values:	[]
	Comment:	autoload something
	UpdateMode:	dynamic
	*/
	autoload bool

	/**
	Name:	rootname
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[root]
	Comment:	root name
	UpdateMode:	dynamic
	*/
	rootname string

	/**
	Name:	rootpassword
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[]
	Comment:	root password
	UpdateMode:	dynamic
	*/
	rootpassword string

	/**
	Name:	dumpuser
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[dump]
	Comment:	dump user name
	UpdateMode:	dynamic
	*/
	dumpuser string

	/**
	Name:	dumppassword
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[111]
	Comment:	dump user password
	UpdateMode:	dynamic
	*/
	dumppassword string

	/**
	Name:	port
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[9000]
	Comment:	port
	UpdateMode:	dynamic
	*/
	port int64

	/**
	Name:	ip
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[localhost 127.0.0.1]
	Comment:	listening ip
	UpdateMode:	dynamic
	*/
	ip string

	//parameter name -> parameter definition string
	name2definition map[string]string
} //end Variables

//all parameters can be set in the configuration file.
type vconfig struct {
	//read and write lock
	rwlock sync.RWMutex

	/**
	Name:	autoload
	Scope:	[global]
	Access:	[file]
	DataType:	bool
	DomainType:	set
	Values:	[]
	Comment:	autoload something
	UpdateMode:	dynamic
	*/
	Autoload bool `toml:"autoload"`

	/**
	Name:	rootname
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[root]
	Comment:	root name
	UpdateMode:	dynamic
	*/
	Rootname string `toml:"rootname"`

	/**
	Name:	rootpassword
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[]
	Comment:	root password
	UpdateMode:	dynamic
	*/
	Rootpassword string `toml:"rootpassword"`

	/**
	Name:	dumpuser
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[dump]
	Comment:	dump user name
	UpdateMode:	dynamic
	*/
	Dumpuser string `toml:"dumpuser"`

	/**
	Name:	dumppassword
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[111]
	Comment:	dump user password
	UpdateMode:	dynamic
	*/
	Dumppassword string `toml:"dumppassword"`

	/**
	Name:	port
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[9000]
	Comment:	port
	UpdateMode:	dynamic
	*/
	Port int64 `toml:"port"`

	/**
	Name:	ip
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[localhost 127.0.0.1]
	Comment:	listening ip
	UpdateMode:	dynamic
	*/
	Ip string `toml:"ip"`

	//parameter name -> updated flag
	name2updatedFlags map[string]bool
} //end vconfig

/**
prepare something before anything else.
it is unsafe in multi-thread environment.
*/
func (ap *Variables) prepareAnything() {
	if ap.name2definition == nil {
		ap.name2definition = make(map[string]string)
	}
}

/**
set parameter and its string of the definition.
*/
func (ap *Variables) PrepareDefinition() {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	ap.prepareAnything()

	ap.name2definition["autoload"] = "	Name:	autoload	Scope:	[global]	Access:	[file]	DataType:	bool	DomainType:	set	Values:	[]	Comment:	autoload something	UpdateMode:	dynamic	"

	ap.name2definition["rootname"] = "	Name:	rootname	Scope:	[global]	Access:	[file]	DataType:	string	DomainType:	set	Values:	[root]	Comment:	root name	UpdateMode:	dynamic	"

	ap.name2definition["rootpassword"] = "	Name:	rootpassword	Scope:	[global]	Access:	[file]	DataType:	string	DomainType:	set	Values:	[]	Comment:	root password	UpdateMode:	dynamic	"

	ap.name2definition["dumpuser"] = "	Name:	dumpuser	Scope:	[global]	Access:	[file]	DataType:	string	DomainType:	set	Values:	[dump]	Comment:	dump user name	UpdateMode:	dynamic	"

	ap.name2definition["dumppassword"] = "	Name:	dumppassword	Scope:	[global]	Access:	[file]	DataType:	string	DomainType:	set	Values:	[111]	Comment:	dump user password	UpdateMode:	dynamic	"

	ap.name2definition["port"] = "	Name:	port	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[9000]	Comment:	port	UpdateMode:	dynamic	"

	ap.name2definition["ip"] = "	Name:	ip	Scope:	[global]	Access:	[file]	DataType:	string	DomainType:	set	Values:	[localhost 127.0.0.1]	Comment:	listening ip	UpdateMode:	dynamic	"

}

/**
get the definition of the parameter.
*/
func (ap *Variables) GetDefinition(name string) (string, error) {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	ap.prepareAnything()
	if p, ok := ap.name2definition[name]; !ok {
		return "", fmt.Errorf("there is no parameter %s", name)
	} else {
		return p, nil
	}
}

/**
check if there is the parameter
*/
func (ap *Variables) HasParameter(name string) bool {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	ap.prepareAnything()
	if _, ok := ap.name2definition[name]; !ok {
		return false
	} else {
		return true
	}
}

/**
Load the initial values of all parameters.
*/
func (ap *Variables) LoadInitialValues() error {
	ap.PrepareDefinition()
	var err error

	autoloadchoices := []bool{}
	if len(autoloadchoices) != 0 {
		if err = ap.setAutoload(autoloadchoices[0]); err != nil {
			return fmt.Errorf("set%s failed.error:%v", "Autoload", err)
		}
	} else {

		if err = ap.setAutoload(false); err != nil {
			return fmt.Errorf("set%s failed.error:%v", "Autoload", err)
		}

	}

	rootnamechoices := []string{

		"root",
	}
	if len(rootnamechoices) != 0 {
		if err = ap.setRootname(rootnamechoices[0]); err != nil {
			return fmt.Errorf("set%s failed.error:%v", "Rootname", err)
		}
	} else {
		//empty string
		if err = ap.setRootname(""); err != nil {
			return fmt.Errorf("set%s failed.error:%v", "Rootname", err)
		}
	}

	rootpasswordchoices := []string{

		"",
	}
	if len(rootpasswordchoices) != 0 {
		if err = ap.setRootpassword(rootpasswordchoices[0]); err != nil {
			return fmt.Errorf("set%s failed.error:%v", "Rootpassword", err)
		}
	} else {
		//empty string
		if err = ap.setRootpassword(""); err != nil {
			return fmt.Errorf("set%s failed.error:%v", "Rootpassword", err)
		}
	}

	dumpuserchoices := []string{

		"dump",
	}
	if len(dumpuserchoices) != 0 {
		if err = ap.setDumpuser(dumpuserchoices[0]); err != nil {
			return fmt.Errorf("set%s failed.error:%v", "Dumpuser", err)
		}
	} else {
		//empty string
		if err = ap.setDumpuser(""); err != nil {
			return fmt.Errorf("set%s failed.error:%v", "Dumpuser", err)
		}
	}

	dumppasswordchoices := []string{

		"111",
	}
	if len(dumppasswordchoices) != 0 {
		if err = ap.setDumppassword(dumppasswordchoices[0]); err != nil {
			return fmt.Errorf("set%s failed.error:%v", "Dumppassword", err)
		}
	} else {
		//empty string
		if err = ap.setDumppassword(""); err != nil {
			return fmt.Errorf("set%s failed.error:%v", "Dumppassword", err)
		}
	}

	portchoices := []int64{

		9000,
	}
	if len(portchoices) != 0 {
		if err = ap.setPort(portchoices[0]); err != nil {
			return fmt.Errorf("set%s failed.error:%v", "Port", err)
		}
	} else {

		if err = ap.setPort(0); err != nil {
			return fmt.Errorf("set%s failed.error:%v", "Port", err)
		}

	}

	ipchoices := []string{

		"localhost",

		"127.0.0.1",
	}
	if len(ipchoices) != 0 {
		if err = ap.setIp(ipchoices[0]); err != nil {
			return fmt.Errorf("set%s failed.error:%v", "Ip", err)
		}
	} else {
		//empty string
		if err = ap.setIp(""); err != nil {
			return fmt.Errorf("set%s failed.error:%v", "Ip", err)
		}
	}

	return nil
}

/**
Get the value of the parameter autoload
*/
func (ap *Variables) GetAutoload() bool {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.autoload
}

/**
Get the value of the parameter rootname
*/
func (ap *Variables) GetRootname() string {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.rootname
}

/**
Get the value of the parameter rootpassword
*/
func (ap *Variables) GetRootpassword() string {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.rootpassword
}

/**
Get the value of the parameter dumpuser
*/
func (ap *Variables) GetDumpuser() string {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.dumpuser
}

/**
Get the value of the parameter dumppassword
*/
func (ap *Variables) GetDumppassword() string {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.dumppassword
}

/**
Get the value of the parameter port
*/
func (ap *Variables) GetPort() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.port
}

/**
Get the value of the parameter ip
*/
func (ap *Variables) GetIp() string {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.ip
}

/**
Set the value of the parameter autoload
*/
func (ap *Variables) SetAutoload(value bool) error {
	return ap.setAutoload(value)
}

/**
Set the value of the parameter rootname
*/
func (ap *Variables) SetRootname(value string) error {
	return ap.setRootname(value)
}

/**
Set the value of the parameter rootpassword
*/
func (ap *Variables) SetRootpassword(value string) error {
	return ap.setRootpassword(value)
}

/**
Set the value of the parameter dumpuser
*/
func (ap *Variables) SetDumpuser(value string) error {
	return ap.setDumpuser(value)
}

/**
Set the value of the parameter dumppassword
*/
func (ap *Variables) SetDumppassword(value string) error {
	return ap.setDumppassword(value)
}

/**
Set the value of the parameter port
*/
func (ap *Variables) SetPort(value int64) error {
	return ap.setPort(value)
}

/**
Set the value of the parameter ip
*/
func (ap *Variables) SetIp(value string) error {
	return ap.setIp(value)
}

/**
Set the value of the parameter autoload
*/
func (ap *Variables) setAutoload(value bool) error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	choices := []bool{}
	if len(choices) != 0 {
		if !isInSliceBool(value, choices) {
			return fmt.Errorf("setAutoload,the value %t is not in set %v", value, choices)
		}
	} //else means any bool value: true or false

	ap.autoload = value
	return nil
}

/**
Set the value of the parameter rootname
*/
func (ap *Variables) setRootname(value string) error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	choices := []string{

		"root",
	}
	if len(choices) != 0 {
		if !isInSlice(value, choices) {
			return fmt.Errorf("setRootname,the value %s is not in set %v", value, choices)
		}
	} //else means any string

	ap.rootname = value
	return nil
}

/**
Set the value of the parameter rootpassword
*/
func (ap *Variables) setRootpassword(value string) error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	choices := []string{

		"",
	}
	if len(choices) != 0 {
		if !isInSlice(value, choices) {
			return fmt.Errorf("setRootpassword,the value %s is not in set %v", value, choices)
		}
	} //else means any string

	ap.rootpassword = value
	return nil
}

/**
Set the value of the parameter dumpuser
*/
func (ap *Variables) setDumpuser(value string) error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	choices := []string{

		"dump",
	}
	if len(choices) != 0 {
		if !isInSlice(value, choices) {
			return fmt.Errorf("setDumpuser,the value %s is not in set %v", value, choices)
		}
	} //else means any string

	ap.dumpuser = value
	return nil
}

/**
Set the value of the parameter dumppassword
*/
func (ap *Variables) setDumppassword(value string) error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	choices := []string{

		"111",
	}
	if len(choices) != 0 {
		if !isInSlice(value, choices) {
			return fmt.Errorf("setDumppassword,the value %s is not in set %v", value, choices)
		}
	} //else means any string

	ap.dumppassword = value
	return nil
}

/**
Set the value of the parameter port
*/
func (ap *Variables) setPort(value int64) error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	choices := []int64{

		9000,
	}
	if len(choices) != 0 {
		if !isInSliceInt64(value, choices) {
			return fmt.Errorf("setPort,the value %d is not in set %v", value, choices)
		}
	} //else means any int64

	ap.port = value
	return nil
}

/**
Set the value of the parameter ip
*/
func (ap *Variables) setIp(value string) error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	choices := []string{

		"localhost",

		"127.0.0.1",
	}
	if len(choices) != 0 {
		if !isInSlice(value, choices) {
			return fmt.Errorf("setIp,the value %s is not in set %v", value, choices)
		}
	} //else means any string

	ap.ip = value
	return nil
}

/**
prepare something before anything else.
it is unsafe in multi-thread environment.
*/
func (config *vconfig) prepareAnything() {
	if config.name2updatedFlags == nil {
		config.name2updatedFlags = make(map[string]bool)
	}
}

/**
reset update flags of configuration items
*/
func (config *vconfig) resetUpdatedFlags() {
	config.rwlock.Lock()
	defer config.rwlock.Unlock()
	config.prepareAnything()

	config.name2updatedFlags["autoload"] = false

	config.name2updatedFlags["rootname"] = false

	config.name2updatedFlags["rootpassword"] = false

	config.name2updatedFlags["dumpuser"] = false

	config.name2updatedFlags["dumppassword"] = false

	config.name2updatedFlags["port"] = false

	config.name2updatedFlags["ip"] = false

}

/**
set update flag of configuration item
*/
func (config *vconfig) setUpdatedFlag(name string, updated bool) {
	config.rwlock.Lock()
	defer config.rwlock.Unlock()
	config.prepareAnything()
	config.name2updatedFlags[name] = updated
}

/**
get update flag of configuration item
*/
func (config *vconfig) getUpdatedFlag(name string) bool {
	config.rwlock.RLock()
	defer config.rwlock.RUnlock()
	config.prepareAnything()
	return config.name2updatedFlags[name]
}

/**
Load parameters' values in the configuration string.
*/
func (config *vconfig) LoadConfigurationFromString(input string) error {
	config.resetUpdatedFlags()

	metadata, err := toml.Decode(input, config)
	if err != nil {
		return err
	} else if failed := metadata.Undecoded(); len(failed) > 0 {
		var failedItems []string
		for _, item := range failed {
			failedItems = append(failedItems, item.String())
		}
		return fmt.Errorf("decode failed %s. error:%v", failedItems, err)
	}

	for _, k := range metadata.Keys() {
		config.setUpdatedFlag(k[0], true)
	}

	return nil
}

/**
Load parameters' values in the configuration file.
*/
func (config *vconfig) LoadConfigurationFromFile(fname string) error {
	config.resetUpdatedFlags()

	metadata, err := toml.DecodeFile(fname, config)
	if err != nil {
		return err
	} else if failed := metadata.Undecoded(); len(failed) > 0 {
		var failedItems []string
		for _, item := range failed {
			failedItems = append(failedItems, item.String())
		}
		return fmt.Errorf("decode failed %s. error:%v", failedItems, err)
	}

	for _, k := range metadata.Keys() {
		config.setUpdatedFlag(k[0], true)
	}

	return nil
}

/**
Update parameters' values with configuration.
*/
func (ap *Variables) UpdateParametersWithConfiguration(config *vconfig) error {
	var err error

	if config.getUpdatedFlag("autoload") {
		if err = ap.setAutoload(config.Autoload); err != nil {
			return fmt.Errorf("update parameter autoload failed.error:%v", err)
		}
	}

	if config.getUpdatedFlag("rootname") {
		if err = ap.setRootname(config.Rootname); err != nil {
			return fmt.Errorf("update parameter rootname failed.error:%v", err)
		}
	}

	if config.getUpdatedFlag("rootpassword") {
		if err = ap.setRootpassword(config.Rootpassword); err != nil {
			return fmt.Errorf("update parameter rootpassword failed.error:%v", err)
		}
	}

	if config.getUpdatedFlag("dumpuser") {
		if err = ap.setDumpuser(config.Dumpuser); err != nil {
			return fmt.Errorf("update parameter dumpuser failed.error:%v", err)
		}
	}

	if config.getUpdatedFlag("dumppassword") {
		if err = ap.setDumppassword(config.Dumppassword); err != nil {
			return fmt.Errorf("update parameter dumppassword failed.error:%v", err)
		}
	}

	if config.getUpdatedFlag("port") {
		if err = ap.setPort(config.Port); err != nil {
			return fmt.Errorf("update parameter port failed.error:%v", err)
		}
	}

	if config.getUpdatedFlag("ip") {
		if err = ap.setIp(config.Ip); err != nil {
			return fmt.Errorf("update parameter ip failed.error:%v", err)
		}
	}

	return nil
}

/**
Load configuration from file into vconfig.
Then update items into Variables
*/
func LoadvconfigFromFile(filename string, params *Variables) error {
	config := &vconfig{}
	if err := config.LoadConfigurationFromFile(filename); err != nil {
		return err
	}

	if err := params.UpdateParametersWithConfiguration(config); err != nil {
		return err
	}
	return nil
}
