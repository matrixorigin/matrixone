// Code generated by tool; DO NOT EDIT.
package config

import (
	"sync"
	"testing"
)

func TestSystemVariables_LoadInitialValues(t *testing.T) {
	ap := &SystemVariables{}
	if err := ap.LoadInitialValues(); err != nil {
		t.Errorf("LoadInitialValues failed. error:%v", err)
	}
}

func isvarsConfigEqual(c1, c2 *varsConfig) bool {

	if c1.Rootpassword != c2.Rootpassword {
		return false
	}

	return true
}

func Test_varsConfig_LoadConfigurationFromString(t *testing.T) {
	t1 := `



rootpassword= ""








		
`
	t1_config := &varsConfig{
		rwlock: sync.RWMutex{},

		Rootpassword: "",

		name2updatedFlags: nil,
	}

	type args struct {
		input  string
		config *varsConfig
	}
	tests := []struct {
		name     string
		args     args
		wantErr  bool
		wantErr2 bool
		wantErr3 bool
	}{
		{"t1", args{t1, t1_config}, false, false, false},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ap := &SystemVariables{}
			if err := ap.LoadInitialValues(); err != nil {
				t.Errorf("LoadInitialValues failed.error %v", err)
			}
			config := &varsConfig{}
			if err := config.LoadConfigurationFromString(tt.args.input); (err != nil) != tt.wantErr {
				t.Errorf("LoadConfigurationFromString() error = %v, wantErr %v", err, tt.wantErr)
			} else if err != nil {
				return
			}

			if err := ap.UpdateParametersWithConfiguration(config); (err != nil) != tt.wantErr2 {
				t.Errorf("UpdateParametersWithConfiguration failed. error:%v", err)
			}

			if (isvarsConfigEqual(config, tt.args.config) != true) != tt.wantErr3 {
				t.Errorf("Configuration are not equal. %v vs %v ", config, tt.args.config)
				return
			}
		})
	}
}
