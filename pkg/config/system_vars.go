
// Code generated by tool; DO NOT EDIT.
package config

import (
	"fmt"
	"sync"
	"github.com/BurntSushi/toml"
)

//all parameters in the system
type SystemVariables struct{
	//read and write lock
	rwlock	sync.RWMutex

	/**
	Name:	rootname
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[root]
	Comment:	root name
	UpdateMode:	fix
	*/
	rootname    string

	/**
	Name:	rootpassword
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[]
	Comment:	root password
	UpdateMode:	dynamic
	*/
	rootpassword    string

	/**
	Name:	dumpuser
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[dump]
	Comment:	dump user name
	UpdateMode:	fix
	*/
	dumpuser    string

	/**
	Name:	dumppassword
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[111]
	Comment:	dump user password
	UpdateMode:	fix
	*/
	dumppassword    string

	/**
	Name:	dumpdatabase
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[default]
	Comment:	dump database name
	UpdateMode:	dynamic
	*/
	dumpdatabase    string

	/**
	Name:	port
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[6001]
	Comment:	port
	UpdateMode:	fix
	*/
	port    int64

	/**
	Name:	host
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[localhost 127.0.0.1 0.0.0.0]
	Comment:	listening ip
	UpdateMode:	fix
	*/
	host    string

	/**
	Name:	sendRow
	Scope:	[global]
	Access:	[file]
	DataType:	bool
	DomainType:	set
	Values:	[]
	Comment:	send data row while producing
	UpdateMode:	dynamic
	*/
	sendRow    bool

	/**
	Name:	dumpEnv
	Scope:	[global]
	Access:	[file]
	DataType:	bool
	DomainType:	set
	Values:	[]
	Comment:	dump Environment with memEngine Null nodes for testing
	UpdateMode:	dynamic
	*/
	dumpEnv    bool

	/**
	Name:	hostMmuLimitation
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[1099511627776]
	Comment:	host mmu limitation. default: 1 << 40 = 1099511627776
	UpdateMode:	dynamic
	*/
	hostMmuLimitation    int64

	/**
	Name:	guestMmuLimitation
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[1099511627776]
	Comment:	guest mmu limitation. default: 1 << 40 = 1099511627776
	UpdateMode:	dynamic
	*/
	guestMmuLimitation    int64

	/**
	Name:	mempoolMaxSize
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[1099511627776]
	Comment:	mempool maxsize. default: 1 << 40 = 1099511627776
	UpdateMode:	dynamic
	*/
	mempoolMaxSize    int64

	/**
	Name:	mempoolFactor
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[8]
	Comment:	mempool factor. default: 8
	UpdateMode:	dynamic
	*/
	mempoolFactor    int64

	/**
	Name:	processLimitationSize
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[42949672960]
	Comment:	process.Limitation.Size. default: 10 << 32 = 42949672960
	UpdateMode:	dynamic
	*/
	processLimitationSize    int64

	/**
	Name:	processLimitationBatchRows
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[42949672960]
	Comment:	process.Limitation.BatchRows. default: 10 << 32 = 42949672960
	UpdateMode:	dynamic
	*/
	processLimitationBatchRows    int64

	/**
	Name:	processLimitationBatchSize
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[0]
	Comment:	process.Limitation.BatchSize. default: 0
	UpdateMode:	dynamic
	*/
	processLimitationBatchSize    int64

	/**
	Name:	processLimitationPartitionRows
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[42949672960]
	Comment:	process.Limitation.PartitionRows. default: 10 << 32 = 42949672960
	UpdateMode:	dynamic
	*/
	processLimitationPartitionRows    int64

	/**
	Name:	countOfRowsPerSendingToClient
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[10]
	Comment:	send the count of rows to the client
	UpdateMode:	dynamic
	*/
	countOfRowsPerSendingToClient    int64

	/**
	Name:	periodOfEpochTimer
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[5]
	Comment:	the period of epoch timer in second
	UpdateMode:	dynamic
	*/
	periodOfEpochTimer    int64

	/**
	Name:	periodOfPersistence
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[20]
	Comment:	the period of persistence in second
	UpdateMode:	dynamic
	*/
	periodOfPersistence    int64

	/**
	Name:	periodOfDDLDeleteTimer
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[20]
	Comment:	the period of the ddl delete in second
	UpdateMode:	dynamic
	*/
	periodOfDDLDeleteTimer    int64

	/**
	Name:	timeoutOfHeartbeat
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[20]
	Comment:	the timeout of heartbeat in second
	UpdateMode:	dynamic
	*/
	timeoutOfHeartbeat    int64


	//parameter name -> parameter definition string
	name2definition map[string]string
}//end SystemVariables

//all parameters can be set in the configuration file.
type varsConfig struct{
	//read and write lock
	rwlock	sync.RWMutex


	

	
	/**
	Name:	rootpassword
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[]
	Comment:	root password
	UpdateMode:	dynamic
	*/
	Rootpassword    string  `toml:"rootpassword"`

	

	

	

	
	/**
	Name:	dumpdatabase
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[default]
	Comment:	dump database name
	UpdateMode:	dynamic
	*/
	Dumpdatabase    string  `toml:"dumpdatabase"`

	

	

	

	
	/**
	Name:	sendRow
	Scope:	[global]
	Access:	[file]
	DataType:	bool
	DomainType:	set
	Values:	[]
	Comment:	send data row while producing
	UpdateMode:	dynamic
	*/
	SendRow    bool  `toml:"sendRow"`

	

	
	/**
	Name:	dumpEnv
	Scope:	[global]
	Access:	[file]
	DataType:	bool
	DomainType:	set
	Values:	[]
	Comment:	dump Environment with memEngine Null nodes for testing
	UpdateMode:	dynamic
	*/
	DumpEnv    bool  `toml:"dumpEnv"`

	

	
	/**
	Name:	hostMmuLimitation
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[1099511627776]
	Comment:	host mmu limitation. default: 1 << 40 = 1099511627776
	UpdateMode:	dynamic
	*/
	HostMmuLimitation    int64  `toml:"hostMmuLimitation"`

	

	
	/**
	Name:	guestMmuLimitation
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[1099511627776]
	Comment:	guest mmu limitation. default: 1 << 40 = 1099511627776
	UpdateMode:	dynamic
	*/
	GuestMmuLimitation    int64  `toml:"guestMmuLimitation"`

	

	
	/**
	Name:	mempoolMaxSize
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[1099511627776]
	Comment:	mempool maxsize. default: 1 << 40 = 1099511627776
	UpdateMode:	dynamic
	*/
	MempoolMaxSize    int64  `toml:"mempoolMaxSize"`

	

	
	/**
	Name:	mempoolFactor
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[8]
	Comment:	mempool factor. default: 8
	UpdateMode:	dynamic
	*/
	MempoolFactor    int64  `toml:"mempoolFactor"`

	

	
	/**
	Name:	processLimitationSize
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[42949672960]
	Comment:	process.Limitation.Size. default: 10 << 32 = 42949672960
	UpdateMode:	dynamic
	*/
	ProcessLimitationSize    int64  `toml:"processLimitationSize"`

	

	
	/**
	Name:	processLimitationBatchRows
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[42949672960]
	Comment:	process.Limitation.BatchRows. default: 10 << 32 = 42949672960
	UpdateMode:	dynamic
	*/
	ProcessLimitationBatchRows    int64  `toml:"processLimitationBatchRows"`

	

	
	/**
	Name:	processLimitationBatchSize
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[0]
	Comment:	process.Limitation.BatchSize. default: 0
	UpdateMode:	dynamic
	*/
	ProcessLimitationBatchSize    int64  `toml:"processLimitationBatchSize"`

	

	
	/**
	Name:	processLimitationPartitionRows
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[42949672960]
	Comment:	process.Limitation.PartitionRows. default: 10 << 32 = 42949672960
	UpdateMode:	dynamic
	*/
	ProcessLimitationPartitionRows    int64  `toml:"processLimitationPartitionRows"`

	

	
	/**
	Name:	countOfRowsPerSendingToClient
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[10]
	Comment:	send the count of rows to the client
	UpdateMode:	dynamic
	*/
	CountOfRowsPerSendingToClient    int64  `toml:"countOfRowsPerSendingToClient"`

	

	
	/**
	Name:	periodOfEpochTimer
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[5]
	Comment:	the period of epoch timer in second
	UpdateMode:	dynamic
	*/
	PeriodOfEpochTimer    int64  `toml:"periodOfEpochTimer"`

	

	
	/**
	Name:	periodOfPersistence
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[20]
	Comment:	the period of persistence in second
	UpdateMode:	dynamic
	*/
	PeriodOfPersistence    int64  `toml:"periodOfPersistence"`

	

	
	/**
	Name:	periodOfDDLDeleteTimer
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[20]
	Comment:	the period of the ddl delete in second
	UpdateMode:	dynamic
	*/
	PeriodOfDDLDeleteTimer    int64  `toml:"periodOfDDLDeleteTimer"`

	

	
	/**
	Name:	timeoutOfHeartbeat
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[20]
	Comment:	the timeout of heartbeat in second
	UpdateMode:	dynamic
	*/
	TimeoutOfHeartbeat    int64  `toml:"timeoutOfHeartbeat"`

	


	//parameter name -> updated flag
	name2updatedFlags map[string]bool
}//end varsConfig

/**
prepare something before anything else.
it is unsafe in multi-thread environment.
*/
func (ap *SystemVariables) prepareAnything(){
	if ap.name2definition == nil {
		ap.name2definition = make(map[string]string)
	}
}

/**
set parameter and its string of the definition.
*/
func (ap *SystemVariables) PrepareDefinition(){
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	ap.prepareAnything()
	
	ap.name2definition["rootname"] = "	Name:	rootname	Scope:	[global]	Access:	[file]	DataType:	string	DomainType:	set	Values:	[root]	Comment:	root name	UpdateMode:	fix	"
	
	ap.name2definition["rootpassword"] = "	Name:	rootpassword	Scope:	[global]	Access:	[file]	DataType:	string	DomainType:	set	Values:	[]	Comment:	root password	UpdateMode:	dynamic	"
	
	ap.name2definition["dumpuser"] = "	Name:	dumpuser	Scope:	[global]	Access:	[file]	DataType:	string	DomainType:	set	Values:	[dump]	Comment:	dump user name	UpdateMode:	fix	"
	
	ap.name2definition["dumppassword"] = "	Name:	dumppassword	Scope:	[global]	Access:	[file]	DataType:	string	DomainType:	set	Values:	[111]	Comment:	dump user password	UpdateMode:	fix	"
	
	ap.name2definition["dumpdatabase"] = "	Name:	dumpdatabase	Scope:	[global]	Access:	[file]	DataType:	string	DomainType:	set	Values:	[default]	Comment:	dump database name	UpdateMode:	dynamic	"
	
	ap.name2definition["port"] = "	Name:	port	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[6001]	Comment:	port	UpdateMode:	fix	"
	
	ap.name2definition["host"] = "	Name:	host	Scope:	[global]	Access:	[file]	DataType:	string	DomainType:	set	Values:	[localhost 127.0.0.1 0.0.0.0]	Comment:	listening ip	UpdateMode:	fix	"
	
	ap.name2definition["sendRow"] = "	Name:	sendRow	Scope:	[global]	Access:	[file]	DataType:	bool	DomainType:	set	Values:	[]	Comment:	send data row while producing	UpdateMode:	dynamic	"
	
	ap.name2definition["dumpEnv"] = "	Name:	dumpEnv	Scope:	[global]	Access:	[file]	DataType:	bool	DomainType:	set	Values:	[]	Comment:	dump Environment with memEngine Null nodes for testing	UpdateMode:	dynamic	"
	
	ap.name2definition["hostMmuLimitation"] = "	Name:	hostMmuLimitation	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[1099511627776]	Comment:	host mmu limitation. default: 1 << 40 = 1099511627776	UpdateMode:	dynamic	"
	
	ap.name2definition["guestMmuLimitation"] = "	Name:	guestMmuLimitation	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[1099511627776]	Comment:	guest mmu limitation. default: 1 << 40 = 1099511627776	UpdateMode:	dynamic	"
	
	ap.name2definition["mempoolMaxSize"] = "	Name:	mempoolMaxSize	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[1099511627776]	Comment:	mempool maxsize. default: 1 << 40 = 1099511627776	UpdateMode:	dynamic	"
	
	ap.name2definition["mempoolFactor"] = "	Name:	mempoolFactor	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[8]	Comment:	mempool factor. default: 8	UpdateMode:	dynamic	"
	
	ap.name2definition["processLimitationSize"] = "	Name:	processLimitationSize	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[42949672960]	Comment:	process.Limitation.Size. default: 10 << 32 = 42949672960	UpdateMode:	dynamic	"
	
	ap.name2definition["processLimitationBatchRows"] = "	Name:	processLimitationBatchRows	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[42949672960]	Comment:	process.Limitation.BatchRows. default: 10 << 32 = 42949672960	UpdateMode:	dynamic	"
	
	ap.name2definition["processLimitationBatchSize"] = "	Name:	processLimitationBatchSize	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[0]	Comment:	process.Limitation.BatchSize. default: 0	UpdateMode:	dynamic	"
	
	ap.name2definition["processLimitationPartitionRows"] = "	Name:	processLimitationPartitionRows	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[42949672960]	Comment:	process.Limitation.PartitionRows. default: 10 << 32 = 42949672960	UpdateMode:	dynamic	"
	
	ap.name2definition["countOfRowsPerSendingToClient"] = "	Name:	countOfRowsPerSendingToClient	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[10]	Comment:	send the count of rows to the client	UpdateMode:	dynamic	"
	
	ap.name2definition["periodOfEpochTimer"] = "	Name:	periodOfEpochTimer	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[5]	Comment:	the period of epoch timer in second	UpdateMode:	dynamic	"
	
	ap.name2definition["periodOfPersistence"] = "	Name:	periodOfPersistence	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[20]	Comment:	the period of persistence in second	UpdateMode:	dynamic	"
	
	ap.name2definition["periodOfDDLDeleteTimer"] = "	Name:	periodOfDDLDeleteTimer	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[20]	Comment:	the period of the ddl delete in second	UpdateMode:	dynamic	"
	
	ap.name2definition["timeoutOfHeartbeat"] = "	Name:	timeoutOfHeartbeat	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[20]	Comment:	the timeout of heartbeat in second	UpdateMode:	dynamic	"
	
}

/**
get the definition of the parameter.
*/
func (ap *SystemVariables) GetDefinition(name string)(string,error){
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	ap.prepareAnything()
	if p,ok := ap.name2definition[name];!ok{
		return "",fmt.Errorf("there is no parameter %s",name)
	}else{
		return p,nil
	}
}

/**
check if there is the parameter
*/
func (ap *SystemVariables) HasParameter(name string)bool{
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	ap.prepareAnything()
	if _,ok := ap.name2definition[name];!ok{
		return false
	}else{
		return true
	}
}

/**
Load the initial values of all parameters.
*/
func (ap *SystemVariables) LoadInitialValues()error{
	ap.PrepareDefinition()
	var err error
	
		
		
			rootnamechoices :=[]string {
				
				"root",
					
			}
			if len(rootnamechoices) != 0{
				if err = ap.setRootname( rootnamechoices[0] ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","Rootname",err)
				}
			}else{
				//empty string
				if err = ap.setRootname( "" ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","Rootname",err)
				}
			}
		
	
		
		
			rootpasswordchoices :=[]string {
				
				"",
					
			}
			if len(rootpasswordchoices) != 0{
				if err = ap.setRootpassword( rootpasswordchoices[0] ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","Rootpassword",err)
				}
			}else{
				//empty string
				if err = ap.setRootpassword( "" ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","Rootpassword",err)
				}
			}
		
	
		
		
			dumpuserchoices :=[]string {
				
				"dump",
					
			}
			if len(dumpuserchoices) != 0{
				if err = ap.setDumpuser( dumpuserchoices[0] ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","Dumpuser",err)
				}
			}else{
				//empty string
				if err = ap.setDumpuser( "" ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","Dumpuser",err)
				}
			}
		
	
		
		
			dumppasswordchoices :=[]string {
				
				"111",
					
			}
			if len(dumppasswordchoices) != 0{
				if err = ap.setDumppassword( dumppasswordchoices[0] ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","Dumppassword",err)
				}
			}else{
				//empty string
				if err = ap.setDumppassword( "" ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","Dumppassword",err)
				}
			}
		
	
		
		
			dumpdatabasechoices :=[]string {
				
				"default",
					
			}
			if len(dumpdatabasechoices) != 0{
				if err = ap.setDumpdatabase( dumpdatabasechoices[0] ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","Dumpdatabase",err)
				}
			}else{
				//empty string
				if err = ap.setDumpdatabase( "" ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","Dumpdatabase",err)
				}
			}
		
	
		
		
			portchoices :=[]int64 {
				
				6001,
					
			}
			if len(portchoices) != 0{
				if err = ap.setPort( portchoices[0] ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","Port",err)
				}
			}else{
				
					if err = ap.setPort( 0 ) ; err != nil{
						return fmt.Errorf("set%s failed.error:%v","Port",err)
					}
				
			}
		
	
		
		
			hostchoices :=[]string {
				
				"localhost",
				
				"127.0.0.1",
				
				"0.0.0.0",
					
			}
			if len(hostchoices) != 0{
				if err = ap.setHost( hostchoices[0] ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","Host",err)
				}
			}else{
				//empty string
				if err = ap.setHost( "" ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","Host",err)
				}
			}
		
	
		
		
			sendRowchoices :=[]bool {
					
			}
			if len(sendRowchoices) != 0{
				if err = ap.setSendRow( sendRowchoices[0] ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","SendRow",err)
				}
			}else{
				
					if err = ap.setSendRow( false ) ; err != nil{
						return fmt.Errorf("set%s failed.error:%v","SendRow",err)
					}	
				
			}
		
	
		
		
			dumpEnvchoices :=[]bool {
					
			}
			if len(dumpEnvchoices) != 0{
				if err = ap.setDumpEnv( dumpEnvchoices[0] ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","DumpEnv",err)
				}
			}else{
				
					if err = ap.setDumpEnv( false ) ; err != nil{
						return fmt.Errorf("set%s failed.error:%v","DumpEnv",err)
					}	
				
			}
		
	
		
		
			hostMmuLimitationchoices :=[]int64 {
				
				1099511627776,
					
			}
			if len(hostMmuLimitationchoices) != 0{
				if err = ap.setHostMmuLimitation( hostMmuLimitationchoices[0] ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","HostMmuLimitation",err)
				}
			}else{
				
					if err = ap.setHostMmuLimitation( 0 ) ; err != nil{
						return fmt.Errorf("set%s failed.error:%v","HostMmuLimitation",err)
					}
				
			}
		
	
		
		
			guestMmuLimitationchoices :=[]int64 {
				
				1099511627776,
					
			}
			if len(guestMmuLimitationchoices) != 0{
				if err = ap.setGuestMmuLimitation( guestMmuLimitationchoices[0] ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","GuestMmuLimitation",err)
				}
			}else{
				
					if err = ap.setGuestMmuLimitation( 0 ) ; err != nil{
						return fmt.Errorf("set%s failed.error:%v","GuestMmuLimitation",err)
					}
				
			}
		
	
		
		
			mempoolMaxSizechoices :=[]int64 {
				
				1099511627776,
					
			}
			if len(mempoolMaxSizechoices) != 0{
				if err = ap.setMempoolMaxSize( mempoolMaxSizechoices[0] ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","MempoolMaxSize",err)
				}
			}else{
				
					if err = ap.setMempoolMaxSize( 0 ) ; err != nil{
						return fmt.Errorf("set%s failed.error:%v","MempoolMaxSize",err)
					}
				
			}
		
	
		
		
			mempoolFactorchoices :=[]int64 {
				
				8,
					
			}
			if len(mempoolFactorchoices) != 0{
				if err = ap.setMempoolFactor( mempoolFactorchoices[0] ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","MempoolFactor",err)
				}
			}else{
				
					if err = ap.setMempoolFactor( 0 ) ; err != nil{
						return fmt.Errorf("set%s failed.error:%v","MempoolFactor",err)
					}
				
			}
		
	
		
		
			processLimitationSizechoices :=[]int64 {
				
				42949672960,
					
			}
			if len(processLimitationSizechoices) != 0{
				if err = ap.setProcessLimitationSize( processLimitationSizechoices[0] ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","ProcessLimitationSize",err)
				}
			}else{
				
					if err = ap.setProcessLimitationSize( 0 ) ; err != nil{
						return fmt.Errorf("set%s failed.error:%v","ProcessLimitationSize",err)
					}
				
			}
		
	
		
		
			processLimitationBatchRowschoices :=[]int64 {
				
				42949672960,
					
			}
			if len(processLimitationBatchRowschoices) != 0{
				if err = ap.setProcessLimitationBatchRows( processLimitationBatchRowschoices[0] ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","ProcessLimitationBatchRows",err)
				}
			}else{
				
					if err = ap.setProcessLimitationBatchRows( 0 ) ; err != nil{
						return fmt.Errorf("set%s failed.error:%v","ProcessLimitationBatchRows",err)
					}
				
			}
		
	
		
		
			processLimitationBatchSizechoices :=[]int64 {
				
				0,
					
			}
			if len(processLimitationBatchSizechoices) != 0{
				if err = ap.setProcessLimitationBatchSize( processLimitationBatchSizechoices[0] ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","ProcessLimitationBatchSize",err)
				}
			}else{
				
					if err = ap.setProcessLimitationBatchSize( 0 ) ; err != nil{
						return fmt.Errorf("set%s failed.error:%v","ProcessLimitationBatchSize",err)
					}
				
			}
		
	
		
		
			processLimitationPartitionRowschoices :=[]int64 {
				
				42949672960,
					
			}
			if len(processLimitationPartitionRowschoices) != 0{
				if err = ap.setProcessLimitationPartitionRows( processLimitationPartitionRowschoices[0] ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","ProcessLimitationPartitionRows",err)
				}
			}else{
				
					if err = ap.setProcessLimitationPartitionRows( 0 ) ; err != nil{
						return fmt.Errorf("set%s failed.error:%v","ProcessLimitationPartitionRows",err)
					}
				
			}
		
	
		
		
			countOfRowsPerSendingToClientchoices :=[]int64 {
				
				10,
					
			}
			if len(countOfRowsPerSendingToClientchoices) != 0{
				if err = ap.setCountOfRowsPerSendingToClient( countOfRowsPerSendingToClientchoices[0] ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","CountOfRowsPerSendingToClient",err)
				}
			}else{
				
					if err = ap.setCountOfRowsPerSendingToClient( 0 ) ; err != nil{
						return fmt.Errorf("set%s failed.error:%v","CountOfRowsPerSendingToClient",err)
					}
				
			}
		
	
		
		
			periodOfEpochTimerchoices :=[]int64 {
				
				5,
					
			}
			if len(periodOfEpochTimerchoices) != 0{
				if err = ap.setPeriodOfEpochTimer( periodOfEpochTimerchoices[0] ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","PeriodOfEpochTimer",err)
				}
			}else{
				
					if err = ap.setPeriodOfEpochTimer( 0 ) ; err != nil{
						return fmt.Errorf("set%s failed.error:%v","PeriodOfEpochTimer",err)
					}
				
			}
		
	
		
		
			periodOfPersistencechoices :=[]int64 {
				
				20,
					
			}
			if len(periodOfPersistencechoices) != 0{
				if err = ap.setPeriodOfPersistence( periodOfPersistencechoices[0] ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","PeriodOfPersistence",err)
				}
			}else{
				
					if err = ap.setPeriodOfPersistence( 0 ) ; err != nil{
						return fmt.Errorf("set%s failed.error:%v","PeriodOfPersistence",err)
					}
				
			}
		
	
		
		
			periodOfDDLDeleteTimerchoices :=[]int64 {
				
				20,
					
			}
			if len(periodOfDDLDeleteTimerchoices) != 0{
				if err = ap.setPeriodOfDDLDeleteTimer( periodOfDDLDeleteTimerchoices[0] ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","PeriodOfDDLDeleteTimer",err)
				}
			}else{
				
					if err = ap.setPeriodOfDDLDeleteTimer( 0 ) ; err != nil{
						return fmt.Errorf("set%s failed.error:%v","PeriodOfDDLDeleteTimer",err)
					}
				
			}
		
	
		
		
			timeoutOfHeartbeatchoices :=[]int64 {
				
				20,
					
			}
			if len(timeoutOfHeartbeatchoices) != 0{
				if err = ap.setTimeoutOfHeartbeat( timeoutOfHeartbeatchoices[0] ) ; err != nil{
					return fmt.Errorf("set%s failed.error:%v","TimeoutOfHeartbeat",err)
				}
			}else{
				
					if err = ap.setTimeoutOfHeartbeat( 0 ) ; err != nil{
						return fmt.Errorf("set%s failed.error:%v","TimeoutOfHeartbeat",err)
					}
				
			}
		
	
	return nil
}



/**
Get the value of the parameter rootname
*/
func (ap * SystemVariables ) GetRootname() string {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.rootname
}

/**
Get the value of the parameter rootpassword
*/
func (ap * SystemVariables ) GetRootpassword() string {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.rootpassword
}

/**
Get the value of the parameter dumpuser
*/
func (ap * SystemVariables ) GetDumpuser() string {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.dumpuser
}

/**
Get the value of the parameter dumppassword
*/
func (ap * SystemVariables ) GetDumppassword() string {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.dumppassword
}

/**
Get the value of the parameter dumpdatabase
*/
func (ap * SystemVariables ) GetDumpdatabase() string {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.dumpdatabase
}

/**
Get the value of the parameter port
*/
func (ap * SystemVariables ) GetPort() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.port
}

/**
Get the value of the parameter host
*/
func (ap * SystemVariables ) GetHost() string {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.host
}

/**
Get the value of the parameter sendRow
*/
func (ap * SystemVariables ) GetSendRow() bool {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.sendRow
}

/**
Get the value of the parameter dumpEnv
*/
func (ap * SystemVariables ) GetDumpEnv() bool {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.dumpEnv
}

/**
Get the value of the parameter hostMmuLimitation
*/
func (ap * SystemVariables ) GetHostMmuLimitation() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.hostMmuLimitation
}

/**
Get the value of the parameter guestMmuLimitation
*/
func (ap * SystemVariables ) GetGuestMmuLimitation() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.guestMmuLimitation
}

/**
Get the value of the parameter mempoolMaxSize
*/
func (ap * SystemVariables ) GetMempoolMaxSize() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.mempoolMaxSize
}

/**
Get the value of the parameter mempoolFactor
*/
func (ap * SystemVariables ) GetMempoolFactor() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.mempoolFactor
}

/**
Get the value of the parameter processLimitationSize
*/
func (ap * SystemVariables ) GetProcessLimitationSize() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.processLimitationSize
}

/**
Get the value of the parameter processLimitationBatchRows
*/
func (ap * SystemVariables ) GetProcessLimitationBatchRows() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.processLimitationBatchRows
}

/**
Get the value of the parameter processLimitationBatchSize
*/
func (ap * SystemVariables ) GetProcessLimitationBatchSize() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.processLimitationBatchSize
}

/**
Get the value of the parameter processLimitationPartitionRows
*/
func (ap * SystemVariables ) GetProcessLimitationPartitionRows() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.processLimitationPartitionRows
}

/**
Get the value of the parameter countOfRowsPerSendingToClient
*/
func (ap * SystemVariables ) GetCountOfRowsPerSendingToClient() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.countOfRowsPerSendingToClient
}

/**
Get the value of the parameter periodOfEpochTimer
*/
func (ap * SystemVariables ) GetPeriodOfEpochTimer() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.periodOfEpochTimer
}

/**
Get the value of the parameter periodOfPersistence
*/
func (ap * SystemVariables ) GetPeriodOfPersistence() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.periodOfPersistence
}

/**
Get the value of the parameter periodOfDDLDeleteTimer
*/
func (ap * SystemVariables ) GetPeriodOfDDLDeleteTimer() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.periodOfDDLDeleteTimer
}

/**
Get the value of the parameter timeoutOfHeartbeat
*/
func (ap * SystemVariables ) GetTimeoutOfHeartbeat() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.timeoutOfHeartbeat
}









/**
Set the value of the parameter rootpassword
*/
func (ap * SystemVariables ) SetRootpassword(value string)error {
	return  ap.setRootpassword(value)
}







/**
Set the value of the parameter dumpdatabase
*/
func (ap * SystemVariables ) SetDumpdatabase(value string)error {
	return  ap.setDumpdatabase(value)
}







/**
Set the value of the parameter sendRow
*/
func (ap * SystemVariables ) SetSendRow(value bool)error {
	return  ap.setSendRow(value)
}



/**
Set the value of the parameter dumpEnv
*/
func (ap * SystemVariables ) SetDumpEnv(value bool)error {
	return  ap.setDumpEnv(value)
}



/**
Set the value of the parameter hostMmuLimitation
*/
func (ap * SystemVariables ) SetHostMmuLimitation(value int64)error {
	return  ap.setHostMmuLimitation(value)
}



/**
Set the value of the parameter guestMmuLimitation
*/
func (ap * SystemVariables ) SetGuestMmuLimitation(value int64)error {
	return  ap.setGuestMmuLimitation(value)
}



/**
Set the value of the parameter mempoolMaxSize
*/
func (ap * SystemVariables ) SetMempoolMaxSize(value int64)error {
	return  ap.setMempoolMaxSize(value)
}



/**
Set the value of the parameter mempoolFactor
*/
func (ap * SystemVariables ) SetMempoolFactor(value int64)error {
	return  ap.setMempoolFactor(value)
}



/**
Set the value of the parameter processLimitationSize
*/
func (ap * SystemVariables ) SetProcessLimitationSize(value int64)error {
	return  ap.setProcessLimitationSize(value)
}



/**
Set the value of the parameter processLimitationBatchRows
*/
func (ap * SystemVariables ) SetProcessLimitationBatchRows(value int64)error {
	return  ap.setProcessLimitationBatchRows(value)
}



/**
Set the value of the parameter processLimitationBatchSize
*/
func (ap * SystemVariables ) SetProcessLimitationBatchSize(value int64)error {
	return  ap.setProcessLimitationBatchSize(value)
}



/**
Set the value of the parameter processLimitationPartitionRows
*/
func (ap * SystemVariables ) SetProcessLimitationPartitionRows(value int64)error {
	return  ap.setProcessLimitationPartitionRows(value)
}



/**
Set the value of the parameter countOfRowsPerSendingToClient
*/
func (ap * SystemVariables ) SetCountOfRowsPerSendingToClient(value int64)error {
	return  ap.setCountOfRowsPerSendingToClient(value)
}



/**
Set the value of the parameter periodOfEpochTimer
*/
func (ap * SystemVariables ) SetPeriodOfEpochTimer(value int64)error {
	return  ap.setPeriodOfEpochTimer(value)
}



/**
Set the value of the parameter periodOfPersistence
*/
func (ap * SystemVariables ) SetPeriodOfPersistence(value int64)error {
	return  ap.setPeriodOfPersistence(value)
}



/**
Set the value of the parameter periodOfDDLDeleteTimer
*/
func (ap * SystemVariables ) SetPeriodOfDDLDeleteTimer(value int64)error {
	return  ap.setPeriodOfDDLDeleteTimer(value)
}



/**
Set the value of the parameter timeoutOfHeartbeat
*/
func (ap * SystemVariables ) SetTimeoutOfHeartbeat(value int64)error {
	return  ap.setTimeoutOfHeartbeat(value)
}






/**
Set the value of the parameter rootname
*/
func (ap * SystemVariables ) setRootname(value string)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	

		
			choices :=[]string {
				
				"root",
					
			}
			if len( choices ) != 0{
				if !isInSlice(value, choices){
					return fmt.Errorf("setRootname,the value %s is not in set %v",value,choices)
				}
			}//else means any string
		

	

	ap.rootname = value
	return nil
}

/**
Set the value of the parameter rootpassword
*/
func (ap * SystemVariables ) setRootpassword(value string)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	

		
			choices :=[]string {
				
				"",
					
			}
			if len( choices ) != 0{
				if !isInSlice(value, choices){
					return fmt.Errorf("setRootpassword,the value %s is not in set %v",value,choices)
				}
			}//else means any string
		

	

	ap.rootpassword = value
	return nil
}

/**
Set the value of the parameter dumpuser
*/
func (ap * SystemVariables ) setDumpuser(value string)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	

		
			choices :=[]string {
				
				"dump",
					
			}
			if len( choices ) != 0{
				if !isInSlice(value, choices){
					return fmt.Errorf("setDumpuser,the value %s is not in set %v",value,choices)
				}
			}//else means any string
		

	

	ap.dumpuser = value
	return nil
}

/**
Set the value of the parameter dumppassword
*/
func (ap * SystemVariables ) setDumppassword(value string)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	

		
			choices :=[]string {
				
				"111",
					
			}
			if len( choices ) != 0{
				if !isInSlice(value, choices){
					return fmt.Errorf("setDumppassword,the value %s is not in set %v",value,choices)
				}
			}//else means any string
		

	

	ap.dumppassword = value
	return nil
}

/**
Set the value of the parameter dumpdatabase
*/
func (ap * SystemVariables ) setDumpdatabase(value string)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	

		
			choices :=[]string {
				
				"default",
					
			}
			if len( choices ) != 0{
				if !isInSlice(value, choices){
					return fmt.Errorf("setDumpdatabase,the value %s is not in set %v",value,choices)
				}
			}//else means any string
		

	

	ap.dumpdatabase = value
	return nil
}

/**
Set the value of the parameter port
*/
func (ap * SystemVariables ) setPort(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	

		
			choices :=[]int64 {
				
				6001,
					
			}
			if len( choices ) != 0{
				if !isInSliceInt64(value, choices){
					return fmt.Errorf("setPort,the value %d is not in set %v",value,choices)
				}
			}//else means any int64
		

	

	ap.port = value
	return nil
}

/**
Set the value of the parameter host
*/
func (ap * SystemVariables ) setHost(value string)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	

		
			choices :=[]string {
				
				"localhost",
				
				"127.0.0.1",
				
				"0.0.0.0",
					
			}
			if len( choices ) != 0{
				if !isInSlice(value, choices){
					return fmt.Errorf("setHost,the value %s is not in set %v",value,choices)
				}
			}//else means any string
		

	

	ap.host = value
	return nil
}

/**
Set the value of the parameter sendRow
*/
func (ap * SystemVariables ) setSendRow(value bool)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	
		
		
			choices :=[]bool {
					
			}
			if len( choices ) != 0{
				if !isInSliceBool(value, choices){
					return fmt.Errorf("setSendRow,the value %t is not in set %v",value,choices)
				}
			}//else means any bool value: true or false
		

	

	ap.sendRow = value
	return nil
}

/**
Set the value of the parameter dumpEnv
*/
func (ap * SystemVariables ) setDumpEnv(value bool)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	
		
		
			choices :=[]bool {
					
			}
			if len( choices ) != 0{
				if !isInSliceBool(value, choices){
					return fmt.Errorf("setDumpEnv,the value %t is not in set %v",value,choices)
				}
			}//else means any bool value: true or false
		

	

	ap.dumpEnv = value
	return nil
}

/**
Set the value of the parameter hostMmuLimitation
*/
func (ap * SystemVariables ) setHostMmuLimitation(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	

		
			choices :=[]int64 {
				
				1099511627776,
					
			}
			if len( choices ) != 0{
				if !isInSliceInt64(value, choices){
					return fmt.Errorf("setHostMmuLimitation,the value %d is not in set %v",value,choices)
				}
			}//else means any int64
		

	

	ap.hostMmuLimitation = value
	return nil
}

/**
Set the value of the parameter guestMmuLimitation
*/
func (ap * SystemVariables ) setGuestMmuLimitation(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	

		
			choices :=[]int64 {
				
				1099511627776,
					
			}
			if len( choices ) != 0{
				if !isInSliceInt64(value, choices){
					return fmt.Errorf("setGuestMmuLimitation,the value %d is not in set %v",value,choices)
				}
			}//else means any int64
		

	

	ap.guestMmuLimitation = value
	return nil
}

/**
Set the value of the parameter mempoolMaxSize
*/
func (ap * SystemVariables ) setMempoolMaxSize(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	

		
			choices :=[]int64 {
				
				1099511627776,
					
			}
			if len( choices ) != 0{
				if !isInSliceInt64(value, choices){
					return fmt.Errorf("setMempoolMaxSize,the value %d is not in set %v",value,choices)
				}
			}//else means any int64
		

	

	ap.mempoolMaxSize = value
	return nil
}

/**
Set the value of the parameter mempoolFactor
*/
func (ap * SystemVariables ) setMempoolFactor(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	

		
			choices :=[]int64 {
				
				8,
					
			}
			if len( choices ) != 0{
				if !isInSliceInt64(value, choices){
					return fmt.Errorf("setMempoolFactor,the value %d is not in set %v",value,choices)
				}
			}//else means any int64
		

	

	ap.mempoolFactor = value
	return nil
}

/**
Set the value of the parameter processLimitationSize
*/
func (ap * SystemVariables ) setProcessLimitationSize(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	

		
			choices :=[]int64 {
				
				42949672960,
					
			}
			if len( choices ) != 0{
				if !isInSliceInt64(value, choices){
					return fmt.Errorf("setProcessLimitationSize,the value %d is not in set %v",value,choices)
				}
			}//else means any int64
		

	

	ap.processLimitationSize = value
	return nil
}

/**
Set the value of the parameter processLimitationBatchRows
*/
func (ap * SystemVariables ) setProcessLimitationBatchRows(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	

		
			choices :=[]int64 {
				
				42949672960,
					
			}
			if len( choices ) != 0{
				if !isInSliceInt64(value, choices){
					return fmt.Errorf("setProcessLimitationBatchRows,the value %d is not in set %v",value,choices)
				}
			}//else means any int64
		

	

	ap.processLimitationBatchRows = value
	return nil
}

/**
Set the value of the parameter processLimitationBatchSize
*/
func (ap * SystemVariables ) setProcessLimitationBatchSize(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	

		
			choices :=[]int64 {
				
				0,
					
			}
			if len( choices ) != 0{
				if !isInSliceInt64(value, choices){
					return fmt.Errorf("setProcessLimitationBatchSize,the value %d is not in set %v",value,choices)
				}
			}//else means any int64
		

	

	ap.processLimitationBatchSize = value
	return nil
}

/**
Set the value of the parameter processLimitationPartitionRows
*/
func (ap * SystemVariables ) setProcessLimitationPartitionRows(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	

		
			choices :=[]int64 {
				
				42949672960,
					
			}
			if len( choices ) != 0{
				if !isInSliceInt64(value, choices){
					return fmt.Errorf("setProcessLimitationPartitionRows,the value %d is not in set %v",value,choices)
				}
			}//else means any int64
		

	

	ap.processLimitationPartitionRows = value
	return nil
}

/**
Set the value of the parameter countOfRowsPerSendingToClient
*/
func (ap * SystemVariables ) setCountOfRowsPerSendingToClient(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	

		
			choices :=[]int64 {
				
				10,
					
			}
			if len( choices ) != 0{
				if !isInSliceInt64(value, choices){
					return fmt.Errorf("setCountOfRowsPerSendingToClient,the value %d is not in set %v",value,choices)
				}
			}//else means any int64
		

	

	ap.countOfRowsPerSendingToClient = value
	return nil
}

/**
Set the value of the parameter periodOfEpochTimer
*/
func (ap * SystemVariables ) setPeriodOfEpochTimer(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	

		
			choices :=[]int64 {
				
				5,
					
			}
			if len( choices ) != 0{
				if !isInSliceInt64(value, choices){
					return fmt.Errorf("setPeriodOfEpochTimer,the value %d is not in set %v",value,choices)
				}
			}//else means any int64
		

	

	ap.periodOfEpochTimer = value
	return nil
}

/**
Set the value of the parameter periodOfPersistence
*/
func (ap * SystemVariables ) setPeriodOfPersistence(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	

		
			choices :=[]int64 {
				
				20,
					
			}
			if len( choices ) != 0{
				if !isInSliceInt64(value, choices){
					return fmt.Errorf("setPeriodOfPersistence,the value %d is not in set %v",value,choices)
				}
			}//else means any int64
		

	

	ap.periodOfPersistence = value
	return nil
}

/**
Set the value of the parameter periodOfDDLDeleteTimer
*/
func (ap * SystemVariables ) setPeriodOfDDLDeleteTimer(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	

		
			choices :=[]int64 {
				
				20,
					
			}
			if len( choices ) != 0{
				if !isInSliceInt64(value, choices){
					return fmt.Errorf("setPeriodOfDDLDeleteTimer,the value %d is not in set %v",value,choices)
				}
			}//else means any int64
		

	

	ap.periodOfDDLDeleteTimer = value
	return nil
}

/**
Set the value of the parameter timeoutOfHeartbeat
*/
func (ap * SystemVariables ) setTimeoutOfHeartbeat(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	

		
			choices :=[]int64 {
				
				20,
					
			}
			if len( choices ) != 0{
				if !isInSliceInt64(value, choices){
					return fmt.Errorf("setTimeoutOfHeartbeat,the value %d is not in set %v",value,choices)
				}
			}//else means any int64
		

	

	ap.timeoutOfHeartbeat = value
	return nil
}



/**
prepare something before anything else.
it is unsafe in multi-thread environment.
*/
func (config *varsConfig) prepareAnything(){
	if config.name2updatedFlags == nil {
		config.name2updatedFlags = make(map[string]bool)
	}
}

/**
reset update flags of configuration items
*/
func (config *varsConfig) resetUpdatedFlags(){
	config.rwlock.Lock()
	defer config.rwlock.Unlock()
	config.prepareAnything()
	
	
	
	
		config.name2updatedFlags["rootpassword"] = false
	
	
	
	
	
	
	
		config.name2updatedFlags["dumpdatabase"] = false
	
	
	
	
	
	
	
		config.name2updatedFlags["sendRow"] = false
	
	
	
		config.name2updatedFlags["dumpEnv"] = false
	
	
	
		config.name2updatedFlags["hostMmuLimitation"] = false
	
	
	
		config.name2updatedFlags["guestMmuLimitation"] = false
	
	
	
		config.name2updatedFlags["mempoolMaxSize"] = false
	
	
	
		config.name2updatedFlags["mempoolFactor"] = false
	
	
	
		config.name2updatedFlags["processLimitationSize"] = false
	
	
	
		config.name2updatedFlags["processLimitationBatchRows"] = false
	
	
	
		config.name2updatedFlags["processLimitationBatchSize"] = false
	
	
	
		config.name2updatedFlags["processLimitationPartitionRows"] = false
	
	
	
		config.name2updatedFlags["countOfRowsPerSendingToClient"] = false
	
	
	
		config.name2updatedFlags["periodOfEpochTimer"] = false
	
	
	
		config.name2updatedFlags["periodOfPersistence"] = false
	
	
	
		config.name2updatedFlags["periodOfDDLDeleteTimer"] = false
	
	
	
		config.name2updatedFlags["timeoutOfHeartbeat"] = false
	
	
}

/**
set update flag of configuration item
*/
func (config *varsConfig) setUpdatedFlag(name string,updated bool){
	config.rwlock.Lock()
	defer config.rwlock.Unlock()
	config.prepareAnything()
	config.name2updatedFlags[name] = updated
}

/**
get update flag of configuration item
*/
func (config *varsConfig) getUpdatedFlag(name string)bool{
	config.rwlock.RLock()
	defer config.rwlock.RUnlock()
	config.prepareAnything()
	return config.name2updatedFlags[name]
}

/**
Load parameters' values in the configuration string.
*/
func (config *varsConfig) LoadConfigurationFromString(input string) error {
	config.resetUpdatedFlags()

	metadata, err := toml.Decode(input, config);
	if err != nil {
		return err
	}else if failed := metadata.Undecoded() ; len(failed) > 0 {
		var failedItems []string
		for _, item := range failed {
			failedItems = append(failedItems, item.String())
		}
		return fmt.Errorf("decode failed %s. error:%v",failedItems,err)
	}

	for _,k := range metadata.Keys(){
		config.setUpdatedFlag(k[0],true)
	}

	return nil
}

/**
Load parameters' values in the configuration file.
*/
func (config *varsConfig) LoadConfigurationFromFile(fname string) error {
	config.resetUpdatedFlags()

	metadata, err := toml.DecodeFile(fname, config);
	if err != nil {
		return err
	}else if failed := metadata.Undecoded() ; len(failed) > 0 {
		var failedItems []string
		for _, item := range failed {
			failedItems = append(failedItems, item.String())
		}
		return fmt.Errorf("decode failed %s. error:%v",failedItems,err)
	}

	for _,k := range metadata.Keys(){
		config.setUpdatedFlag(k[0],true)
	}

	return nil
}

/**
Update parameters' values with configuration.
*/
func (ap * SystemVariables ) UpdateParametersWithConfiguration(config *varsConfig)error{
	var err error
	
	
	
	
	if config.getUpdatedFlag("rootpassword"){
		if err = ap.setRootpassword(config.Rootpassword); err != nil{
			return fmt.Errorf("update parameter rootpassword failed.error:%v",err)
		}
	}
	
	
	
	
	
	
	
	if config.getUpdatedFlag("dumpdatabase"){
		if err = ap.setDumpdatabase(config.Dumpdatabase); err != nil{
			return fmt.Errorf("update parameter dumpdatabase failed.error:%v",err)
		}
	}
	
	
	
	
	
	
	
	if config.getUpdatedFlag("sendRow"){
		if err = ap.setSendRow(config.SendRow); err != nil{
			return fmt.Errorf("update parameter sendRow failed.error:%v",err)
		}
	}
	
	
	
	if config.getUpdatedFlag("dumpEnv"){
		if err = ap.setDumpEnv(config.DumpEnv); err != nil{
			return fmt.Errorf("update parameter dumpEnv failed.error:%v",err)
		}
	}
	
	
	
	if config.getUpdatedFlag("hostMmuLimitation"){
		if err = ap.setHostMmuLimitation(config.HostMmuLimitation); err != nil{
			return fmt.Errorf("update parameter hostMmuLimitation failed.error:%v",err)
		}
	}
	
	
	
	if config.getUpdatedFlag("guestMmuLimitation"){
		if err = ap.setGuestMmuLimitation(config.GuestMmuLimitation); err != nil{
			return fmt.Errorf("update parameter guestMmuLimitation failed.error:%v",err)
		}
	}
	
	
	
	if config.getUpdatedFlag("mempoolMaxSize"){
		if err = ap.setMempoolMaxSize(config.MempoolMaxSize); err != nil{
			return fmt.Errorf("update parameter mempoolMaxSize failed.error:%v",err)
		}
	}
	
	
	
	if config.getUpdatedFlag("mempoolFactor"){
		if err = ap.setMempoolFactor(config.MempoolFactor); err != nil{
			return fmt.Errorf("update parameter mempoolFactor failed.error:%v",err)
		}
	}
	
	
	
	if config.getUpdatedFlag("processLimitationSize"){
		if err = ap.setProcessLimitationSize(config.ProcessLimitationSize); err != nil{
			return fmt.Errorf("update parameter processLimitationSize failed.error:%v",err)
		}
	}
	
	
	
	if config.getUpdatedFlag("processLimitationBatchRows"){
		if err = ap.setProcessLimitationBatchRows(config.ProcessLimitationBatchRows); err != nil{
			return fmt.Errorf("update parameter processLimitationBatchRows failed.error:%v",err)
		}
	}
	
	
	
	if config.getUpdatedFlag("processLimitationBatchSize"){
		if err = ap.setProcessLimitationBatchSize(config.ProcessLimitationBatchSize); err != nil{
			return fmt.Errorf("update parameter processLimitationBatchSize failed.error:%v",err)
		}
	}
	
	
	
	if config.getUpdatedFlag("processLimitationPartitionRows"){
		if err = ap.setProcessLimitationPartitionRows(config.ProcessLimitationPartitionRows); err != nil{
			return fmt.Errorf("update parameter processLimitationPartitionRows failed.error:%v",err)
		}
	}
	
	
	
	if config.getUpdatedFlag("countOfRowsPerSendingToClient"){
		if err = ap.setCountOfRowsPerSendingToClient(config.CountOfRowsPerSendingToClient); err != nil{
			return fmt.Errorf("update parameter countOfRowsPerSendingToClient failed.error:%v",err)
		}
	}
	
	
	
	if config.getUpdatedFlag("periodOfEpochTimer"){
		if err = ap.setPeriodOfEpochTimer(config.PeriodOfEpochTimer); err != nil{
			return fmt.Errorf("update parameter periodOfEpochTimer failed.error:%v",err)
		}
	}
	
	
	
	if config.getUpdatedFlag("periodOfPersistence"){
		if err = ap.setPeriodOfPersistence(config.PeriodOfPersistence); err != nil{
			return fmt.Errorf("update parameter periodOfPersistence failed.error:%v",err)
		}
	}
	
	
	
	if config.getUpdatedFlag("periodOfDDLDeleteTimer"){
		if err = ap.setPeriodOfDDLDeleteTimer(config.PeriodOfDDLDeleteTimer); err != nil{
			return fmt.Errorf("update parameter periodOfDDLDeleteTimer failed.error:%v",err)
		}
	}
	
	
	
	if config.getUpdatedFlag("timeoutOfHeartbeat"){
		if err = ap.setTimeoutOfHeartbeat(config.TimeoutOfHeartbeat); err != nil{
			return fmt.Errorf("update parameter timeoutOfHeartbeat failed.error:%v",err)
		}
	}
	
	
	return nil
}

/**
Load configuration from file into varsConfig.
Then update items into SystemVariables
*/
func LoadvarsConfigFromFile(filename string,params *SystemVariables) error{
	config := &varsConfig{}
	if err := config.LoadConfigurationFromFile(filename); err != nil{
		return err
	}

	if err := params.UpdateParametersWithConfiguration(config); err != nil{
		return err
	}
	return nil
}
