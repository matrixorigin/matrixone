
// Code generated by tool; DO NOT EDIT.
package config

import (
	"fmt"
	"sync"
	"github.com/BurntSushi/toml"
)

//all parameters in the system
type SystemVariables struct{
	//read and write lock
	rwlock	sync.RWMutex

	
	/**
	Name:	rootname
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[root]
	Comment:	root name
	UpdateMode:	fix
	*/
	rootname    string
	
	/**
	Name:	rootpassword
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[]
	Comment:	root password
	UpdateMode:	dynamic
	*/
	rootpassword    string
	
	/**
	Name:	dumpuser
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[dump]
	Comment:	dump user name
	UpdateMode:	fix
	*/
	dumpuser    string
	
	/**
	Name:	dumppassword
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[111]
	Comment:	dump user password
	UpdateMode:	fix
	*/
	dumppassword    string
	
	/**
	Name:	dumpdatabase
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[default]
	Comment:	dump database name
	UpdateMode:	dynamic
	*/
	dumpdatabase    string
	
	/**
	Name:	port
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	range
	Values:	[6001 6001 6010]
	Comment:	port
	UpdateMode:	dynamic
	*/
	port    int64
	
	/**
	Name:	host
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[0.0.0.0 localhost 127.0.0.1]
	Comment:	listening ip
	UpdateMode:	dynamic
	*/
	host    string
	
	/**
	Name:	sendRow
	Scope:	[global]
	Access:	[file]
	DataType:	bool
	DomainType:	set
	Values:	[]
	Comment:	send data row while producing
	UpdateMode:	dynamic
	*/
	sendRow    bool
	
	/**
	Name:	dumpEnv
	Scope:	[global]
	Access:	[file]
	DataType:	bool
	DomainType:	set
	Values:	[]
	Comment:	dump Environment with memEngine Null nodes for testing
	UpdateMode:	dynamic
	*/
	dumpEnv    bool
	
	/**
	Name:	hostMmuLimitation
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[1099511627776]
	Comment:	host mmu limitation. default: 1 << 40 = 1099511627776
	UpdateMode:	dynamic
	*/
	hostMmuLimitation    int64
	
	/**
	Name:	guestMmuLimitation
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[1099511627776]
	Comment:	guest mmu limitation. default: 1 << 40 = 1099511627776
	UpdateMode:	dynamic
	*/
	guestMmuLimitation    int64
	
	/**
	Name:	mempoolMaxSize
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[1099511627776]
	Comment:	mempool maxsize. default: 1 << 40 = 1099511627776
	UpdateMode:	dynamic
	*/
	mempoolMaxSize    int64
	
	/**
	Name:	mempoolFactor
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[8]
	Comment:	mempool factor. default: 8
	UpdateMode:	dynamic
	*/
	mempoolFactor    int64
	
	/**
	Name:	processLimitationSize
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[42949672960]
	Comment:	process.Limitation.Size. default: 10 << 32 = 42949672960
	UpdateMode:	dynamic
	*/
	processLimitationSize    int64
	
	/**
	Name:	processLimitationBatchRows
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[42949672960]
	Comment:	process.Limitation.BatchRows. default: 10 << 32 = 42949672960
	UpdateMode:	dynamic
	*/
	processLimitationBatchRows    int64
	
	/**
	Name:	processLimitationBatchSize
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[0]
	Comment:	process.Limitation.BatchSize. default: 0
	UpdateMode:	dynamic
	*/
	processLimitationBatchSize    int64
	
	/**
	Name:	processLimitationPartitionRows
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[42949672960]
	Comment:	process.Limitation.PartitionRows. default: 10 << 32 = 42949672960
	UpdateMode:	dynamic
	*/
	processLimitationPartitionRows    int64
	
	/**
	Name:	countOfRowsPerSendingToClient
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[10]
	Comment:	send the count of rows to the client
	UpdateMode:	dynamic
	*/
	countOfRowsPerSendingToClient    int64
	
	/**
	Name:	periodOfEpochTimer
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[5]
	Comment:	the period of epoch timer in second
	UpdateMode:	dynamic
	*/
	periodOfEpochTimer    int64
	
	/**
	Name:	periodOfPersistence
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[20]
	Comment:	the period of persistence in second
	UpdateMode:	dynamic
	*/
	periodOfPersistence    int64
	
	/**
	Name:	periodOfDDLDeleteTimer
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[20]
	Comment:	the period of the ddl delete in second
	UpdateMode:	dynamic
	*/
	periodOfDDLDeleteTimer    int64
	
	/**
	Name:	timeoutOfHeartbeat
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[20]
	Comment:	the timeout of heartbeat in second
	UpdateMode:	dynamic
	*/
	timeoutOfHeartbeat    int64
	
	/**
	Name:	rejectWhenHeartbeatFromPDLeaderIsTimeout
	Scope:	[global]
	Access:	[file]
	DataType:	bool
	DomainType:	set
	Values:	[false]
	Comment:	default is false. the server will reject the connection and sql request when the heartbeat from pdleader is timeout.
	UpdateMode:	dynamic
	*/
	rejectWhenHeartbeatFromPDLeaderIsTimeout    bool
	
	/**
	Name:	enableEpochLogging
	Scope:	[global]
	Access:	[file]
	DataType:	bool
	DomainType:	set
	Values:	[false]
	Comment:	default is false. Print logs when the server calls catalog service to run the ddl.
	UpdateMode:	dynamic
	*/
	enableEpochLogging    bool
	
	/**
	Name:	recordTimeElapsedOfSqlRequest
	Scope:	[global]
	Access:	[file]
	DataType:	bool
	DomainType:	set
	Values:	[true]
	Comment:	record the time elapsed of executing sql request
	UpdateMode:	dynamic
	*/
	recordTimeElapsedOfSqlRequest    bool
	
	/**
	Name:	nodeID
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	range
	Values:	[0 0 10]
	Comment:	the Node ID of the cube
	UpdateMode:	dynamic
	*/
	nodeID    int64
	
	/**
	Name:	cubeDirPrefix
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[./cube]
	Comment:	the root direction prefix of the cube. The actual dir is cubeDirPrefix + nodeID
	UpdateMode:	dynamic
	*/
	cubeDirPrefix    string
	
	/**
	Name:	prophetEmbedEtcdJoinAddr
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[http://localhost:40000 http://127.0.0.1:40000]
	Comment:	the join address of prophet of the cube
	UpdateMode:	dynamic
	*/
	prophetEmbedEtcdJoinAddr    string
	
	/**
	Name:	maxReplicas
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	range
	Values:	[1 1 1]
	Comment:	the number of replicas for each resource
	UpdateMode:	dynamic
	*/
	maxReplicas    int64
	
	/**
	Name:	lengthOfQueryPrinted
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	range
	Values:	[50 -1 10000]
	Comment:	the length of query printed into console. -1, complete string. 0, empty string. >0 , length of characters at the header of the string.
	UpdateMode:	dynamic
	*/
	lengthOfQueryPrinted    int64
	
	/**
	Name:	batchSizeInLoadData
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	range
	Values:	[40000 10 100000]
	Comment:	the count of rows in vector of batch in load data
	UpdateMode:	dynamic
	*/
	batchSizeInLoadData    int64
	
	/**
	Name:	loadDataConcurrencyCount
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	range
	Values:	[16 1 16]
	Comment:	default is 16. The count of go routine writing batch into the storage.
	UpdateMode:	dynamic
	*/
	loadDataConcurrencyCount    int64
	
	/**
	Name:	cubeLogLevel
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[error info debug warning warn fatal]
	Comment:	default is error. The log level for cube.
	UpdateMode:	dynamic
	*/
	cubeLogLevel    string
	
	/**
	Name:	cubeMaxEntriesBytes
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[314572800]
	Comment:	default is 300MB. The max entries bytes for the write batch in the cube.
	UpdateMode:	dynamic
	*/
	cubeMaxEntriesBytes    int64

	//parameter name -> parameter definition string
	name2definition map[string]string
}//end SystemVariables

//all parameters can be set in the configuration file.
type varsConfig struct{
	//read and write lock
	rwlock	sync.RWMutex

	
	/**
	Name:	rootpassword
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[]
	Comment:	root password
	UpdateMode:	dynamic
	*/
	Rootpassword    string  `toml:"rootpassword"`
	
	/**
	Name:	dumpdatabase
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[default]
	Comment:	dump database name
	UpdateMode:	dynamic
	*/
	Dumpdatabase    string  `toml:"dumpdatabase"`
	
	/**
	Name:	port
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	range
	Values:	[6001 6001 6010]
	Comment:	port
	UpdateMode:	dynamic
	*/
	Port    int64  `toml:"port"`
	
	/**
	Name:	host
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[0.0.0.0 localhost 127.0.0.1]
	Comment:	listening ip
	UpdateMode:	dynamic
	*/
	Host    string  `toml:"host"`
	
	/**
	Name:	sendRow
	Scope:	[global]
	Access:	[file]
	DataType:	bool
	DomainType:	set
	Values:	[]
	Comment:	send data row while producing
	UpdateMode:	dynamic
	*/
	SendRow    bool  `toml:"sendRow"`
	
	/**
	Name:	dumpEnv
	Scope:	[global]
	Access:	[file]
	DataType:	bool
	DomainType:	set
	Values:	[]
	Comment:	dump Environment with memEngine Null nodes for testing
	UpdateMode:	dynamic
	*/
	DumpEnv    bool  `toml:"dumpEnv"`
	
	/**
	Name:	hostMmuLimitation
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[1099511627776]
	Comment:	host mmu limitation. default: 1 << 40 = 1099511627776
	UpdateMode:	dynamic
	*/
	HostMmuLimitation    int64  `toml:"hostMmuLimitation"`
	
	/**
	Name:	guestMmuLimitation
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[1099511627776]
	Comment:	guest mmu limitation. default: 1 << 40 = 1099511627776
	UpdateMode:	dynamic
	*/
	GuestMmuLimitation    int64  `toml:"guestMmuLimitation"`
	
	/**
	Name:	mempoolMaxSize
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[1099511627776]
	Comment:	mempool maxsize. default: 1 << 40 = 1099511627776
	UpdateMode:	dynamic
	*/
	MempoolMaxSize    int64  `toml:"mempoolMaxSize"`
	
	/**
	Name:	mempoolFactor
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[8]
	Comment:	mempool factor. default: 8
	UpdateMode:	dynamic
	*/
	MempoolFactor    int64  `toml:"mempoolFactor"`
	
	/**
	Name:	processLimitationSize
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[42949672960]
	Comment:	process.Limitation.Size. default: 10 << 32 = 42949672960
	UpdateMode:	dynamic
	*/
	ProcessLimitationSize    int64  `toml:"processLimitationSize"`
	
	/**
	Name:	processLimitationBatchRows
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[42949672960]
	Comment:	process.Limitation.BatchRows. default: 10 << 32 = 42949672960
	UpdateMode:	dynamic
	*/
	ProcessLimitationBatchRows    int64  `toml:"processLimitationBatchRows"`
	
	/**
	Name:	processLimitationBatchSize
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[0]
	Comment:	process.Limitation.BatchSize. default: 0
	UpdateMode:	dynamic
	*/
	ProcessLimitationBatchSize    int64  `toml:"processLimitationBatchSize"`
	
	/**
	Name:	processLimitationPartitionRows
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[42949672960]
	Comment:	process.Limitation.PartitionRows. default: 10 << 32 = 42949672960
	UpdateMode:	dynamic
	*/
	ProcessLimitationPartitionRows    int64  `toml:"processLimitationPartitionRows"`
	
	/**
	Name:	countOfRowsPerSendingToClient
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[10]
	Comment:	send the count of rows to the client
	UpdateMode:	dynamic
	*/
	CountOfRowsPerSendingToClient    int64  `toml:"countOfRowsPerSendingToClient"`
	
	/**
	Name:	periodOfEpochTimer
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[5]
	Comment:	the period of epoch timer in second
	UpdateMode:	dynamic
	*/
	PeriodOfEpochTimer    int64  `toml:"periodOfEpochTimer"`
	
	/**
	Name:	periodOfPersistence
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[20]
	Comment:	the period of persistence in second
	UpdateMode:	dynamic
	*/
	PeriodOfPersistence    int64  `toml:"periodOfPersistence"`
	
	/**
	Name:	periodOfDDLDeleteTimer
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[20]
	Comment:	the period of the ddl delete in second
	UpdateMode:	dynamic
	*/
	PeriodOfDDLDeleteTimer    int64  `toml:"periodOfDDLDeleteTimer"`
	
	/**
	Name:	timeoutOfHeartbeat
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[20]
	Comment:	the timeout of heartbeat in second
	UpdateMode:	dynamic
	*/
	TimeoutOfHeartbeat    int64  `toml:"timeoutOfHeartbeat"`
	
	/**
	Name:	rejectWhenHeartbeatFromPDLeaderIsTimeout
	Scope:	[global]
	Access:	[file]
	DataType:	bool
	DomainType:	set
	Values:	[false]
	Comment:	default is false. the server will reject the connection and sql request when the heartbeat from pdleader is timeout.
	UpdateMode:	dynamic
	*/
	RejectWhenHeartbeatFromPDLeaderIsTimeout    bool  `toml:"rejectWhenHeartbeatFromPDLeaderIsTimeout"`
	
	/**
	Name:	enableEpochLogging
	Scope:	[global]
	Access:	[file]
	DataType:	bool
	DomainType:	set
	Values:	[false]
	Comment:	default is false. Print logs when the server calls catalog service to run the ddl.
	UpdateMode:	dynamic
	*/
	EnableEpochLogging    bool  `toml:"enableEpochLogging"`
	
	/**
	Name:	recordTimeElapsedOfSqlRequest
	Scope:	[global]
	Access:	[file]
	DataType:	bool
	DomainType:	set
	Values:	[true]
	Comment:	record the time elapsed of executing sql request
	UpdateMode:	dynamic
	*/
	RecordTimeElapsedOfSqlRequest    bool  `toml:"recordTimeElapsedOfSqlRequest"`
	
	/**
	Name:	nodeID
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	range
	Values:	[0 0 10]
	Comment:	the Node ID of the cube
	UpdateMode:	dynamic
	*/
	NodeID    int64  `toml:"nodeID"`
	
	/**
	Name:	cubeDirPrefix
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[./cube]
	Comment:	the root direction prefix of the cube. The actual dir is cubeDirPrefix + nodeID
	UpdateMode:	dynamic
	*/
	CubeDirPrefix    string  `toml:"cubeDirPrefix"`
	
	/**
	Name:	prophetEmbedEtcdJoinAddr
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[http://localhost:40000 http://127.0.0.1:40000]
	Comment:	the join address of prophet of the cube
	UpdateMode:	dynamic
	*/
	ProphetEmbedEtcdJoinAddr    string  `toml:"prophetEmbedEtcdJoinAddr"`
	
	/**
	Name:	maxReplicas
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	range
	Values:	[1 1 1]
	Comment:	the number of replicas for each resource
	UpdateMode:	dynamic
	*/
	MaxReplicas    int64  `toml:"maxReplicas"`
	
	/**
	Name:	lengthOfQueryPrinted
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	range
	Values:	[50 -1 10000]
	Comment:	the length of query printed into console. -1, complete string. 0, empty string. >0 , length of characters at the header of the string.
	UpdateMode:	dynamic
	*/
	LengthOfQueryPrinted    int64  `toml:"lengthOfQueryPrinted"`
	
	/**
	Name:	batchSizeInLoadData
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	range
	Values:	[40000 10 100000]
	Comment:	the count of rows in vector of batch in load data
	UpdateMode:	dynamic
	*/
	BatchSizeInLoadData    int64  `toml:"batchSizeInLoadData"`
	
	/**
	Name:	loadDataConcurrencyCount
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	range
	Values:	[16 1 16]
	Comment:	default is 16. The count of go routine writing batch into the storage.
	UpdateMode:	dynamic
	*/
	LoadDataConcurrencyCount    int64  `toml:"loadDataConcurrencyCount"`
	
	/**
	Name:	cubeLogLevel
	Scope:	[global]
	Access:	[file]
	DataType:	string
	DomainType:	set
	Values:	[error info debug warning warn fatal]
	Comment:	default is error. The log level for cube.
	UpdateMode:	dynamic
	*/
	CubeLogLevel    string  `toml:"cubeLogLevel"`
	
	/**
	Name:	cubeMaxEntriesBytes
	Scope:	[global]
	Access:	[file]
	DataType:	int64
	DomainType:	set
	Values:	[314572800]
	Comment:	default is 300MB. The max entries bytes for the write batch in the cube.
	UpdateMode:	dynamic
	*/
	CubeMaxEntriesBytes    int64  `toml:"cubeMaxEntriesBytes"`

	//parameter name -> updated flag
	name2updatedFlags map[string]bool
}//end varsConfig

/**
prepare something before anything else.
it is unsafe in multi-thread environment.
*/
func (ap *SystemVariables) prepareAnything(){
	if ap.name2definition == nil {
		ap.name2definition = make(map[string]string)
	}
}

/**
set parameter and its string of the definition.
*/
func (ap *SystemVariables) PrepareDefinition(){
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()

	ap.prepareAnything()
	
	ap.name2definition["rootname"] = "	Name:	rootname	Scope:	[global]	Access:	[file]	DataType:	string	DomainType:	set	Values:	[root]	Comment:	root name	UpdateMode:	fix	"
	
	ap.name2definition["rootpassword"] = "	Name:	rootpassword	Scope:	[global]	Access:	[file]	DataType:	string	DomainType:	set	Values:	[]	Comment:	root password	UpdateMode:	dynamic	"
	
	ap.name2definition["dumpuser"] = "	Name:	dumpuser	Scope:	[global]	Access:	[file]	DataType:	string	DomainType:	set	Values:	[dump]	Comment:	dump user name	UpdateMode:	fix	"
	
	ap.name2definition["dumppassword"] = "	Name:	dumppassword	Scope:	[global]	Access:	[file]	DataType:	string	DomainType:	set	Values:	[111]	Comment:	dump user password	UpdateMode:	fix	"
	
	ap.name2definition["dumpdatabase"] = "	Name:	dumpdatabase	Scope:	[global]	Access:	[file]	DataType:	string	DomainType:	set	Values:	[default]	Comment:	dump database name	UpdateMode:	dynamic	"
	
	ap.name2definition["port"] = "	Name:	port	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	range	Values:	[6001 6001 6010]	Comment:	port	UpdateMode:	dynamic	"
	
	ap.name2definition["host"] = "	Name:	host	Scope:	[global]	Access:	[file]	DataType:	string	DomainType:	set	Values:	[0.0.0.0 localhost 127.0.0.1]	Comment:	listening ip	UpdateMode:	dynamic	"
	
	ap.name2definition["sendRow"] = "	Name:	sendRow	Scope:	[global]	Access:	[file]	DataType:	bool	DomainType:	set	Values:	[]	Comment:	send data row while producing	UpdateMode:	dynamic	"
	
	ap.name2definition["dumpEnv"] = "	Name:	dumpEnv	Scope:	[global]	Access:	[file]	DataType:	bool	DomainType:	set	Values:	[]	Comment:	dump Environment with memEngine Null nodes for testing	UpdateMode:	dynamic	"
	
	ap.name2definition["hostMmuLimitation"] = "	Name:	hostMmuLimitation	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[1099511627776]	Comment:	host mmu limitation. default: 1 << 40 = 1099511627776	UpdateMode:	dynamic	"
	
	ap.name2definition["guestMmuLimitation"] = "	Name:	guestMmuLimitation	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[1099511627776]	Comment:	guest mmu limitation. default: 1 << 40 = 1099511627776	UpdateMode:	dynamic	"
	
	ap.name2definition["mempoolMaxSize"] = "	Name:	mempoolMaxSize	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[1099511627776]	Comment:	mempool maxsize. default: 1 << 40 = 1099511627776	UpdateMode:	dynamic	"
	
	ap.name2definition["mempoolFactor"] = "	Name:	mempoolFactor	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[8]	Comment:	mempool factor. default: 8	UpdateMode:	dynamic	"
	
	ap.name2definition["processLimitationSize"] = "	Name:	processLimitationSize	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[42949672960]	Comment:	process.Limitation.Size. default: 10 << 32 = 42949672960	UpdateMode:	dynamic	"
	
	ap.name2definition["processLimitationBatchRows"] = "	Name:	processLimitationBatchRows	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[42949672960]	Comment:	process.Limitation.BatchRows. default: 10 << 32 = 42949672960	UpdateMode:	dynamic	"
	
	ap.name2definition["processLimitationBatchSize"] = "	Name:	processLimitationBatchSize	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[0]	Comment:	process.Limitation.BatchSize. default: 0	UpdateMode:	dynamic	"
	
	ap.name2definition["processLimitationPartitionRows"] = "	Name:	processLimitationPartitionRows	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[42949672960]	Comment:	process.Limitation.PartitionRows. default: 10 << 32 = 42949672960	UpdateMode:	dynamic	"
	
	ap.name2definition["countOfRowsPerSendingToClient"] = "	Name:	countOfRowsPerSendingToClient	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[10]	Comment:	send the count of rows to the client	UpdateMode:	dynamic	"
	
	ap.name2definition["periodOfEpochTimer"] = "	Name:	periodOfEpochTimer	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[5]	Comment:	the period of epoch timer in second	UpdateMode:	dynamic	"
	
	ap.name2definition["periodOfPersistence"] = "	Name:	periodOfPersistence	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[20]	Comment:	the period of persistence in second	UpdateMode:	dynamic	"
	
	ap.name2definition["periodOfDDLDeleteTimer"] = "	Name:	periodOfDDLDeleteTimer	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[20]	Comment:	the period of the ddl delete in second	UpdateMode:	dynamic	"
	
	ap.name2definition["timeoutOfHeartbeat"] = "	Name:	timeoutOfHeartbeat	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[20]	Comment:	the timeout of heartbeat in second	UpdateMode:	dynamic	"
	
	ap.name2definition["rejectWhenHeartbeatFromPDLeaderIsTimeout"] = "	Name:	rejectWhenHeartbeatFromPDLeaderIsTimeout	Scope:	[global]	Access:	[file]	DataType:	bool	DomainType:	set	Values:	[false]	Comment:	default is false. the server will reject the connection and sql request when the heartbeat from pdleader is timeout.	UpdateMode:	dynamic	"
	
	ap.name2definition["enableEpochLogging"] = "	Name:	enableEpochLogging	Scope:	[global]	Access:	[file]	DataType:	bool	DomainType:	set	Values:	[false]	Comment:	default is false. Print logs when the server calls catalog service to run the ddl.	UpdateMode:	dynamic	"
	
	ap.name2definition["recordTimeElapsedOfSqlRequest"] = "	Name:	recordTimeElapsedOfSqlRequest	Scope:	[global]	Access:	[file]	DataType:	bool	DomainType:	set	Values:	[true]	Comment:	record the time elapsed of executing sql request	UpdateMode:	dynamic	"
	
	ap.name2definition["nodeID"] = "	Name:	nodeID	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	range	Values:	[0 0 10]	Comment:	the Node ID of the cube	UpdateMode:	dynamic	"
	
	ap.name2definition["cubeDirPrefix"] = "	Name:	cubeDirPrefix	Scope:	[global]	Access:	[file]	DataType:	string	DomainType:	set	Values:	[./cube]	Comment:	the root direction prefix of the cube. The actual dir is cubeDirPrefix + nodeID	UpdateMode:	dynamic	"
	
	ap.name2definition["prophetEmbedEtcdJoinAddr"] = "	Name:	prophetEmbedEtcdJoinAddr	Scope:	[global]	Access:	[file]	DataType:	string	DomainType:	set	Values:	[http://localhost:40000 http://127.0.0.1:40000]	Comment:	the join address of prophet of the cube	UpdateMode:	dynamic	"
	
	ap.name2definition["maxReplicas"] = "	Name:	maxReplicas	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	range	Values:	[1 1 1]	Comment:	the number of replicas for each resource	UpdateMode:	dynamic	"
	
	ap.name2definition["lengthOfQueryPrinted"] = "	Name:	lengthOfQueryPrinted	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	range	Values:	[50 -1 10000]	Comment:	the length of query printed into console. -1, complete string. 0, empty string. >0 , length of characters at the header of the string.	UpdateMode:	dynamic	"
	
	ap.name2definition["batchSizeInLoadData"] = "	Name:	batchSizeInLoadData	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	range	Values:	[40000 10 100000]	Comment:	the count of rows in vector of batch in load data	UpdateMode:	dynamic	"
	
	ap.name2definition["loadDataConcurrencyCount"] = "	Name:	loadDataConcurrencyCount	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	range	Values:	[16 1 16]	Comment:	default is 16. The count of go routine writing batch into the storage.	UpdateMode:	dynamic	"
	
	ap.name2definition["cubeLogLevel"] = "	Name:	cubeLogLevel	Scope:	[global]	Access:	[file]	DataType:	string	DomainType:	set	Values:	[error info debug warning warn fatal]	Comment:	default is error. The log level for cube.	UpdateMode:	dynamic	"
	
	ap.name2definition["cubeMaxEntriesBytes"] = "	Name:	cubeMaxEntriesBytes	Scope:	[global]	Access:	[file]	DataType:	int64	DomainType:	set	Values:	[314572800]	Comment:	default is 300MB. The max entries bytes for the write batch in the cube.	UpdateMode:	dynamic	"
	
}

/**
get the definition of the parameter.
*/
func (ap *SystemVariables) GetDefinition(name string)(string,error){
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	ap.prepareAnything()
	if p,ok := ap.name2definition[name]; !ok {
		return "", fmt.Errorf("there is no parameter %s",name)
	} else {
		return p, nil
	}
}

/**
check if there is the parameter
*/
func (ap *SystemVariables) HasParameter(name string)bool{
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	ap.prepareAnything()
	if _,ok := ap.name2definition[name]; !ok{
		return false
	} else {
		return true
	}
}

/**
Load the initial values of all parameters.
*/
func (ap *SystemVariables) LoadInitialValues()error{
	ap.PrepareDefinition()
	var err error
	
	
	rootnamechoices := []string {
		"root", 
	}
	if len(rootnamechoices) != 0 {
		if err = ap.setRootname(rootnamechoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","Rootname",err)
		}
	} else {
		//empty string
		if err = ap.setRootname("") ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","Rootname",err)
		}
	}
	
	rootpasswordchoices := []string {
		"", 
	}
	if len(rootpasswordchoices) != 0 {
		if err = ap.setRootpassword(rootpasswordchoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","Rootpassword",err)
		}
	} else {
		//empty string
		if err = ap.setRootpassword("") ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","Rootpassword",err)
		}
	}
	
	dumpuserchoices := []string {
		"dump", 
	}
	if len(dumpuserchoices) != 0 {
		if err = ap.setDumpuser(dumpuserchoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","Dumpuser",err)
		}
	} else {
		//empty string
		if err = ap.setDumpuser("") ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","Dumpuser",err)
		}
	}
	
	dumppasswordchoices := []string {
		"111", 
	}
	if len(dumppasswordchoices) != 0 {
		if err = ap.setDumppassword(dumppasswordchoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","Dumppassword",err)
		}
	} else {
		//empty string
		if err = ap.setDumppassword("") ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","Dumppassword",err)
		}
	}
	
	dumpdatabasechoices := []string {
		"default", 
	}
	if len(dumpdatabasechoices) != 0 {
		if err = ap.setDumpdatabase(dumpdatabasechoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","Dumpdatabase",err)
		}
	} else {
		//empty string
		if err = ap.setDumpdatabase("") ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","Dumpdatabase",err)
		}
	}
	
	portchoices :=[]int64 {
		6001,6001,6010,
	}
	if len(portchoices) != 0 {
		if err = ap.setPort(portchoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","Port",err)
		}
	} else { 
		if err = ap.setPort(0) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","Port",err)
		}
	}
	
	hostchoices := []string {
		"0.0.0.0","localhost","127.0.0.1", 
	}
	if len(hostchoices) != 0 {
		if err = ap.setHost(hostchoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","Host",err)
		}
	} else {
		//empty string
		if err = ap.setHost("") ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","Host",err)
		}
	}
	
	sendRowchoices :=[]bool {
		
	}
	if len(sendRowchoices) != 0 {
		if err = ap.setSendRow(sendRowchoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","SendRow",err)
		}
	} else { 
		if err = ap.setSendRow(false) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","SendRow",err)
		}
	}
	
	dumpEnvchoices :=[]bool {
		
	}
	if len(dumpEnvchoices) != 0 {
		if err = ap.setDumpEnv(dumpEnvchoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","DumpEnv",err)
		}
	} else { 
		if err = ap.setDumpEnv(false) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","DumpEnv",err)
		}
	}
	
	hostMmuLimitationchoices :=[]int64 {
		1099511627776,
	}
	if len(hostMmuLimitationchoices) != 0 {
		if err = ap.setHostMmuLimitation(hostMmuLimitationchoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","HostMmuLimitation",err)
		}
	} else { 
		if err = ap.setHostMmuLimitation(0) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","HostMmuLimitation",err)
		}
	}
	
	guestMmuLimitationchoices :=[]int64 {
		1099511627776,
	}
	if len(guestMmuLimitationchoices) != 0 {
		if err = ap.setGuestMmuLimitation(guestMmuLimitationchoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","GuestMmuLimitation",err)
		}
	} else { 
		if err = ap.setGuestMmuLimitation(0) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","GuestMmuLimitation",err)
		}
	}
	
	mempoolMaxSizechoices :=[]int64 {
		1099511627776,
	}
	if len(mempoolMaxSizechoices) != 0 {
		if err = ap.setMempoolMaxSize(mempoolMaxSizechoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","MempoolMaxSize",err)
		}
	} else { 
		if err = ap.setMempoolMaxSize(0) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","MempoolMaxSize",err)
		}
	}
	
	mempoolFactorchoices :=[]int64 {
		8,
	}
	if len(mempoolFactorchoices) != 0 {
		if err = ap.setMempoolFactor(mempoolFactorchoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","MempoolFactor",err)
		}
	} else { 
		if err = ap.setMempoolFactor(0) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","MempoolFactor",err)
		}
	}
	
	processLimitationSizechoices :=[]int64 {
		42949672960,
	}
	if len(processLimitationSizechoices) != 0 {
		if err = ap.setProcessLimitationSize(processLimitationSizechoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","ProcessLimitationSize",err)
		}
	} else { 
		if err = ap.setProcessLimitationSize(0) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","ProcessLimitationSize",err)
		}
	}
	
	processLimitationBatchRowschoices :=[]int64 {
		42949672960,
	}
	if len(processLimitationBatchRowschoices) != 0 {
		if err = ap.setProcessLimitationBatchRows(processLimitationBatchRowschoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","ProcessLimitationBatchRows",err)
		}
	} else { 
		if err = ap.setProcessLimitationBatchRows(0) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","ProcessLimitationBatchRows",err)
		}
	}
	
	processLimitationBatchSizechoices :=[]int64 {
		0,
	}
	if len(processLimitationBatchSizechoices) != 0 {
		if err = ap.setProcessLimitationBatchSize(processLimitationBatchSizechoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","ProcessLimitationBatchSize",err)
		}
	} else { 
		if err = ap.setProcessLimitationBatchSize(0) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","ProcessLimitationBatchSize",err)
		}
	}
	
	processLimitationPartitionRowschoices :=[]int64 {
		42949672960,
	}
	if len(processLimitationPartitionRowschoices) != 0 {
		if err = ap.setProcessLimitationPartitionRows(processLimitationPartitionRowschoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","ProcessLimitationPartitionRows",err)
		}
	} else { 
		if err = ap.setProcessLimitationPartitionRows(0) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","ProcessLimitationPartitionRows",err)
		}
	}
	
	countOfRowsPerSendingToClientchoices :=[]int64 {
		10,
	}
	if len(countOfRowsPerSendingToClientchoices) != 0 {
		if err = ap.setCountOfRowsPerSendingToClient(countOfRowsPerSendingToClientchoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","CountOfRowsPerSendingToClient",err)
		}
	} else { 
		if err = ap.setCountOfRowsPerSendingToClient(0) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","CountOfRowsPerSendingToClient",err)
		}
	}
	
	periodOfEpochTimerchoices :=[]int64 {
		5,
	}
	if len(periodOfEpochTimerchoices) != 0 {
		if err = ap.setPeriodOfEpochTimer(periodOfEpochTimerchoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","PeriodOfEpochTimer",err)
		}
	} else { 
		if err = ap.setPeriodOfEpochTimer(0) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","PeriodOfEpochTimer",err)
		}
	}
	
	periodOfPersistencechoices :=[]int64 {
		20,
	}
	if len(periodOfPersistencechoices) != 0 {
		if err = ap.setPeriodOfPersistence(periodOfPersistencechoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","PeriodOfPersistence",err)
		}
	} else { 
		if err = ap.setPeriodOfPersistence(0) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","PeriodOfPersistence",err)
		}
	}
	
	periodOfDDLDeleteTimerchoices :=[]int64 {
		20,
	}
	if len(periodOfDDLDeleteTimerchoices) != 0 {
		if err = ap.setPeriodOfDDLDeleteTimer(periodOfDDLDeleteTimerchoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","PeriodOfDDLDeleteTimer",err)
		}
	} else { 
		if err = ap.setPeriodOfDDLDeleteTimer(0) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","PeriodOfDDLDeleteTimer",err)
		}
	}
	
	timeoutOfHeartbeatchoices :=[]int64 {
		20,
	}
	if len(timeoutOfHeartbeatchoices) != 0 {
		if err = ap.setTimeoutOfHeartbeat(timeoutOfHeartbeatchoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","TimeoutOfHeartbeat",err)
		}
	} else { 
		if err = ap.setTimeoutOfHeartbeat(0) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","TimeoutOfHeartbeat",err)
		}
	}
	
	rejectWhenHeartbeatFromPDLeaderIsTimeoutchoices :=[]bool {
		false,
	}
	if len(rejectWhenHeartbeatFromPDLeaderIsTimeoutchoices) != 0 {
		if err = ap.setRejectWhenHeartbeatFromPDLeaderIsTimeout(rejectWhenHeartbeatFromPDLeaderIsTimeoutchoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","RejectWhenHeartbeatFromPDLeaderIsTimeout",err)
		}
	} else { 
		if err = ap.setRejectWhenHeartbeatFromPDLeaderIsTimeout(false) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","RejectWhenHeartbeatFromPDLeaderIsTimeout",err)
		}
	}
	
	enableEpochLoggingchoices :=[]bool {
		false,
	}
	if len(enableEpochLoggingchoices) != 0 {
		if err = ap.setEnableEpochLogging(enableEpochLoggingchoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","EnableEpochLogging",err)
		}
	} else { 
		if err = ap.setEnableEpochLogging(false) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","EnableEpochLogging",err)
		}
	}
	
	recordTimeElapsedOfSqlRequestchoices :=[]bool {
		true,
	}
	if len(recordTimeElapsedOfSqlRequestchoices) != 0 {
		if err = ap.setRecordTimeElapsedOfSqlRequest(recordTimeElapsedOfSqlRequestchoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","RecordTimeElapsedOfSqlRequest",err)
		}
	} else { 
		if err = ap.setRecordTimeElapsedOfSqlRequest(false) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","RecordTimeElapsedOfSqlRequest",err)
		}
	}
	
	nodeIDchoices :=[]int64 {
		0,0,10,
	}
	if len(nodeIDchoices) != 0 {
		if err = ap.setNodeID(nodeIDchoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","NodeID",err)
		}
	} else { 
		if err = ap.setNodeID(0) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","NodeID",err)
		}
	}
	
	cubeDirPrefixchoices := []string {
		"./cube", 
	}
	if len(cubeDirPrefixchoices) != 0 {
		if err = ap.setCubeDirPrefix(cubeDirPrefixchoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","CubeDirPrefix",err)
		}
	} else {
		//empty string
		if err = ap.setCubeDirPrefix("") ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","CubeDirPrefix",err)
		}
	}
	
	prophetEmbedEtcdJoinAddrchoices := []string {
		"http://localhost:40000","http://127.0.0.1:40000", 
	}
	if len(prophetEmbedEtcdJoinAddrchoices) != 0 {
		if err = ap.setProphetEmbedEtcdJoinAddr(prophetEmbedEtcdJoinAddrchoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","ProphetEmbedEtcdJoinAddr",err)
		}
	} else {
		//empty string
		if err = ap.setProphetEmbedEtcdJoinAddr("") ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","ProphetEmbedEtcdJoinAddr",err)
		}
	}
	
	maxReplicaschoices :=[]int64 {
		1,1,1,
	}
	if len(maxReplicaschoices) != 0 {
		if err = ap.setMaxReplicas(maxReplicaschoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","MaxReplicas",err)
		}
	} else { 
		if err = ap.setMaxReplicas(0) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","MaxReplicas",err)
		}
	}
	
	lengthOfQueryPrintedchoices :=[]int64 {
		50,-1,10000,
	}
	if len(lengthOfQueryPrintedchoices) != 0 {
		if err = ap.setLengthOfQueryPrinted(lengthOfQueryPrintedchoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","LengthOfQueryPrinted",err)
		}
	} else { 
		if err = ap.setLengthOfQueryPrinted(0) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","LengthOfQueryPrinted",err)
		}
	}
	
	batchSizeInLoadDatachoices :=[]int64 {
		40000,10,100000,
	}
	if len(batchSizeInLoadDatachoices) != 0 {
		if err = ap.setBatchSizeInLoadData(batchSizeInLoadDatachoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","BatchSizeInLoadData",err)
		}
	} else { 
		if err = ap.setBatchSizeInLoadData(0) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","BatchSizeInLoadData",err)
		}
	}
	
	loadDataConcurrencyCountchoices :=[]int64 {
		16,1,16,
	}
	if len(loadDataConcurrencyCountchoices) != 0 {
		if err = ap.setLoadDataConcurrencyCount(loadDataConcurrencyCountchoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","LoadDataConcurrencyCount",err)
		}
	} else { 
		if err = ap.setLoadDataConcurrencyCount(0) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","LoadDataConcurrencyCount",err)
		}
	}
	
	cubeLogLevelchoices := []string {
		"error","info","debug","warning","warn","fatal", 
	}
	if len(cubeLogLevelchoices) != 0 {
		if err = ap.setCubeLogLevel(cubeLogLevelchoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","CubeLogLevel",err)
		}
	} else {
		//empty string
		if err = ap.setCubeLogLevel("") ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","CubeLogLevel",err)
		}
	}
	
	cubeMaxEntriesByteschoices :=[]int64 {
		314572800,
	}
	if len(cubeMaxEntriesByteschoices) != 0 {
		if err = ap.setCubeMaxEntriesBytes(cubeMaxEntriesByteschoices[0]) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","CubeMaxEntriesBytes",err)
		}
	} else { 
		if err = ap.setCubeMaxEntriesBytes(0) ; err != nil {
			return fmt.Errorf("set%s failed.error:%v","CubeMaxEntriesBytes",err)
		}
	}
	return nil
}

/**
Get the value of the parameter rootname
*/
func (ap * SystemVariables ) GetRootname() string {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.rootname
}

/**
Get the value of the parameter rootpassword
*/
func (ap * SystemVariables ) GetRootpassword() string {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.rootpassword
}

/**
Get the value of the parameter dumpuser
*/
func (ap * SystemVariables ) GetDumpuser() string {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.dumpuser
}

/**
Get the value of the parameter dumppassword
*/
func (ap * SystemVariables ) GetDumppassword() string {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.dumppassword
}

/**
Get the value of the parameter dumpdatabase
*/
func (ap * SystemVariables ) GetDumpdatabase() string {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.dumpdatabase
}

/**
Get the value of the parameter port
*/
func (ap * SystemVariables ) GetPort() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.port
}

/**
Get the value of the parameter host
*/
func (ap * SystemVariables ) GetHost() string {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.host
}

/**
Get the value of the parameter sendRow
*/
func (ap * SystemVariables ) GetSendRow() bool {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.sendRow
}

/**
Get the value of the parameter dumpEnv
*/
func (ap * SystemVariables ) GetDumpEnv() bool {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.dumpEnv
}

/**
Get the value of the parameter hostMmuLimitation
*/
func (ap * SystemVariables ) GetHostMmuLimitation() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.hostMmuLimitation
}

/**
Get the value of the parameter guestMmuLimitation
*/
func (ap * SystemVariables ) GetGuestMmuLimitation() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.guestMmuLimitation
}

/**
Get the value of the parameter mempoolMaxSize
*/
func (ap * SystemVariables ) GetMempoolMaxSize() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.mempoolMaxSize
}

/**
Get the value of the parameter mempoolFactor
*/
func (ap * SystemVariables ) GetMempoolFactor() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.mempoolFactor
}

/**
Get the value of the parameter processLimitationSize
*/
func (ap * SystemVariables ) GetProcessLimitationSize() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.processLimitationSize
}

/**
Get the value of the parameter processLimitationBatchRows
*/
func (ap * SystemVariables ) GetProcessLimitationBatchRows() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.processLimitationBatchRows
}

/**
Get the value of the parameter processLimitationBatchSize
*/
func (ap * SystemVariables ) GetProcessLimitationBatchSize() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.processLimitationBatchSize
}

/**
Get the value of the parameter processLimitationPartitionRows
*/
func (ap * SystemVariables ) GetProcessLimitationPartitionRows() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.processLimitationPartitionRows
}

/**
Get the value of the parameter countOfRowsPerSendingToClient
*/
func (ap * SystemVariables ) GetCountOfRowsPerSendingToClient() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.countOfRowsPerSendingToClient
}

/**
Get the value of the parameter periodOfEpochTimer
*/
func (ap * SystemVariables ) GetPeriodOfEpochTimer() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.periodOfEpochTimer
}

/**
Get the value of the parameter periodOfPersistence
*/
func (ap * SystemVariables ) GetPeriodOfPersistence() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.periodOfPersistence
}

/**
Get the value of the parameter periodOfDDLDeleteTimer
*/
func (ap * SystemVariables ) GetPeriodOfDDLDeleteTimer() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.periodOfDDLDeleteTimer
}

/**
Get the value of the parameter timeoutOfHeartbeat
*/
func (ap * SystemVariables ) GetTimeoutOfHeartbeat() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.timeoutOfHeartbeat
}

/**
Get the value of the parameter rejectWhenHeartbeatFromPDLeaderIsTimeout
*/
func (ap * SystemVariables ) GetRejectWhenHeartbeatFromPDLeaderIsTimeout() bool {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.rejectWhenHeartbeatFromPDLeaderIsTimeout
}

/**
Get the value of the parameter enableEpochLogging
*/
func (ap * SystemVariables ) GetEnableEpochLogging() bool {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.enableEpochLogging
}

/**
Get the value of the parameter recordTimeElapsedOfSqlRequest
*/
func (ap * SystemVariables ) GetRecordTimeElapsedOfSqlRequest() bool {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.recordTimeElapsedOfSqlRequest
}

/**
Get the value of the parameter nodeID
*/
func (ap * SystemVariables ) GetNodeID() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.nodeID
}

/**
Get the value of the parameter cubeDirPrefix
*/
func (ap * SystemVariables ) GetCubeDirPrefix() string {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.cubeDirPrefix
}

/**
Get the value of the parameter prophetEmbedEtcdJoinAddr
*/
func (ap * SystemVariables ) GetProphetEmbedEtcdJoinAddr() string {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.prophetEmbedEtcdJoinAddr
}

/**
Get the value of the parameter maxReplicas
*/
func (ap * SystemVariables ) GetMaxReplicas() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.maxReplicas
}

/**
Get the value of the parameter lengthOfQueryPrinted
*/
func (ap * SystemVariables ) GetLengthOfQueryPrinted() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.lengthOfQueryPrinted
}

/**
Get the value of the parameter batchSizeInLoadData
*/
func (ap * SystemVariables ) GetBatchSizeInLoadData() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.batchSizeInLoadData
}

/**
Get the value of the parameter loadDataConcurrencyCount
*/
func (ap * SystemVariables ) GetLoadDataConcurrencyCount() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.loadDataConcurrencyCount
}

/**
Get the value of the parameter cubeLogLevel
*/
func (ap * SystemVariables ) GetCubeLogLevel() string {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.cubeLogLevel
}

/**
Get the value of the parameter cubeMaxEntriesBytes
*/
func (ap * SystemVariables ) GetCubeMaxEntriesBytes() int64 {
	ap.rwlock.RLock()
	defer ap.rwlock.RUnlock()
	return ap.cubeMaxEntriesBytes
}


/**
Set the value of the parameter rootpassword
*/
func (ap * SystemVariables ) SetRootpassword(value string)error {
	return  ap.setRootpassword(value)
}

/**
Set the value of the parameter dumpdatabase
*/
func (ap * SystemVariables ) SetDumpdatabase(value string)error {
	return  ap.setDumpdatabase(value)
}

/**
Set the value of the parameter port
*/
func (ap * SystemVariables ) SetPort(value int64)error {
	return  ap.setPort(value)
}

/**
Set the value of the parameter host
*/
func (ap * SystemVariables ) SetHost(value string)error {
	return  ap.setHost(value)
}

/**
Set the value of the parameter sendRow
*/
func (ap * SystemVariables ) SetSendRow(value bool)error {
	return  ap.setSendRow(value)
}

/**
Set the value of the parameter dumpEnv
*/
func (ap * SystemVariables ) SetDumpEnv(value bool)error {
	return  ap.setDumpEnv(value)
}

/**
Set the value of the parameter hostMmuLimitation
*/
func (ap * SystemVariables ) SetHostMmuLimitation(value int64)error {
	return  ap.setHostMmuLimitation(value)
}

/**
Set the value of the parameter guestMmuLimitation
*/
func (ap * SystemVariables ) SetGuestMmuLimitation(value int64)error {
	return  ap.setGuestMmuLimitation(value)
}

/**
Set the value of the parameter mempoolMaxSize
*/
func (ap * SystemVariables ) SetMempoolMaxSize(value int64)error {
	return  ap.setMempoolMaxSize(value)
}

/**
Set the value of the parameter mempoolFactor
*/
func (ap * SystemVariables ) SetMempoolFactor(value int64)error {
	return  ap.setMempoolFactor(value)
}

/**
Set the value of the parameter processLimitationSize
*/
func (ap * SystemVariables ) SetProcessLimitationSize(value int64)error {
	return  ap.setProcessLimitationSize(value)
}

/**
Set the value of the parameter processLimitationBatchRows
*/
func (ap * SystemVariables ) SetProcessLimitationBatchRows(value int64)error {
	return  ap.setProcessLimitationBatchRows(value)
}

/**
Set the value of the parameter processLimitationBatchSize
*/
func (ap * SystemVariables ) SetProcessLimitationBatchSize(value int64)error {
	return  ap.setProcessLimitationBatchSize(value)
}

/**
Set the value of the parameter processLimitationPartitionRows
*/
func (ap * SystemVariables ) SetProcessLimitationPartitionRows(value int64)error {
	return  ap.setProcessLimitationPartitionRows(value)
}

/**
Set the value of the parameter countOfRowsPerSendingToClient
*/
func (ap * SystemVariables ) SetCountOfRowsPerSendingToClient(value int64)error {
	return  ap.setCountOfRowsPerSendingToClient(value)
}

/**
Set the value of the parameter periodOfEpochTimer
*/
func (ap * SystemVariables ) SetPeriodOfEpochTimer(value int64)error {
	return  ap.setPeriodOfEpochTimer(value)
}

/**
Set the value of the parameter periodOfPersistence
*/
func (ap * SystemVariables ) SetPeriodOfPersistence(value int64)error {
	return  ap.setPeriodOfPersistence(value)
}

/**
Set the value of the parameter periodOfDDLDeleteTimer
*/
func (ap * SystemVariables ) SetPeriodOfDDLDeleteTimer(value int64)error {
	return  ap.setPeriodOfDDLDeleteTimer(value)
}

/**
Set the value of the parameter timeoutOfHeartbeat
*/
func (ap * SystemVariables ) SetTimeoutOfHeartbeat(value int64)error {
	return  ap.setTimeoutOfHeartbeat(value)
}

/**
Set the value of the parameter rejectWhenHeartbeatFromPDLeaderIsTimeout
*/
func (ap * SystemVariables ) SetRejectWhenHeartbeatFromPDLeaderIsTimeout(value bool)error {
	return  ap.setRejectWhenHeartbeatFromPDLeaderIsTimeout(value)
}

/**
Set the value of the parameter enableEpochLogging
*/
func (ap * SystemVariables ) SetEnableEpochLogging(value bool)error {
	return  ap.setEnableEpochLogging(value)
}

/**
Set the value of the parameter recordTimeElapsedOfSqlRequest
*/
func (ap * SystemVariables ) SetRecordTimeElapsedOfSqlRequest(value bool)error {
	return  ap.setRecordTimeElapsedOfSqlRequest(value)
}

/**
Set the value of the parameter nodeID
*/
func (ap * SystemVariables ) SetNodeID(value int64)error {
	return  ap.setNodeID(value)
}

/**
Set the value of the parameter cubeDirPrefix
*/
func (ap * SystemVariables ) SetCubeDirPrefix(value string)error {
	return  ap.setCubeDirPrefix(value)
}

/**
Set the value of the parameter prophetEmbedEtcdJoinAddr
*/
func (ap * SystemVariables ) SetProphetEmbedEtcdJoinAddr(value string)error {
	return  ap.setProphetEmbedEtcdJoinAddr(value)
}

/**
Set the value of the parameter maxReplicas
*/
func (ap * SystemVariables ) SetMaxReplicas(value int64)error {
	return  ap.setMaxReplicas(value)
}

/**
Set the value of the parameter lengthOfQueryPrinted
*/
func (ap * SystemVariables ) SetLengthOfQueryPrinted(value int64)error {
	return  ap.setLengthOfQueryPrinted(value)
}

/**
Set the value of the parameter batchSizeInLoadData
*/
func (ap * SystemVariables ) SetBatchSizeInLoadData(value int64)error {
	return  ap.setBatchSizeInLoadData(value)
}

/**
Set the value of the parameter loadDataConcurrencyCount
*/
func (ap * SystemVariables ) SetLoadDataConcurrencyCount(value int64)error {
	return  ap.setLoadDataConcurrencyCount(value)
}

/**
Set the value of the parameter cubeLogLevel
*/
func (ap * SystemVariables ) SetCubeLogLevel(value string)error {
	return  ap.setCubeLogLevel(value)
}

/**
Set the value of the parameter cubeMaxEntriesBytes
*/
func (ap * SystemVariables ) SetCubeMaxEntriesBytes(value int64)error {
	return  ap.setCubeMaxEntriesBytes(value)
}

/**
Set the value of the parameter rootname
*/
func (ap * SystemVariables ) setRootname(value string)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
		choices :=[]string {
			"root",	
		}
		if len( choices ) != 0{
			if !isInSlice(value, choices){
				return fmt.Errorf("setRootname,the value %s is not in set %v",value,choices)
			}
		}//else means any string
	
	
	ap.rootname = value
	return nil
}

/**
Set the value of the parameter rootpassword
*/
func (ap * SystemVariables ) setRootpassword(value string)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
		choices :=[]string {
			"",	
		}
		if len( choices ) != 0{
			if !isInSlice(value, choices){
				return fmt.Errorf("setRootpassword,the value %s is not in set %v",value,choices)
			}
		}//else means any string
	
	
	ap.rootpassword = value
	return nil
}

/**
Set the value of the parameter dumpuser
*/
func (ap * SystemVariables ) setDumpuser(value string)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
		choices :=[]string {
			"dump",	
		}
		if len( choices ) != 0{
			if !isInSlice(value, choices){
				return fmt.Errorf("setDumpuser,the value %s is not in set %v",value,choices)
			}
		}//else means any string
	
	
	ap.dumpuser = value
	return nil
}

/**
Set the value of the parameter dumppassword
*/
func (ap * SystemVariables ) setDumppassword(value string)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
		choices :=[]string {
			"111",	
		}
		if len( choices ) != 0{
			if !isInSlice(value, choices){
				return fmt.Errorf("setDumppassword,the value %s is not in set %v",value,choices)
			}
		}//else means any string
	
	
	ap.dumppassword = value
	return nil
}

/**
Set the value of the parameter dumpdatabase
*/
func (ap * SystemVariables ) setDumpdatabase(value string)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
		choices :=[]string {
			"default",	
		}
		if len( choices ) != 0{
			if !isInSlice(value, choices){
				return fmt.Errorf("setDumpdatabase,the value %s is not in set %v",value,choices)
			}
		}//else means any string
	
	
	ap.dumpdatabase = value
	return nil
}

/**
Set the value of the parameter port
*/
func (ap * SystemVariables ) setPort(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
	
		choices :=[]int64 {
			6001,6001,6010,	
		}
		if !(value >= choices[1] && value <= choices[2]){
			return fmt.Errorf("setPort,the value %d is not in the range [%d,%d]",value,choices[1],choices[2])
		}
	
	
	ap.port = value
	return nil
}

/**
Set the value of the parameter host
*/
func (ap * SystemVariables ) setHost(value string)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
		choices :=[]string {
			"0.0.0.0","localhost","127.0.0.1",	
		}
		if len( choices ) != 0{
			if !isInSlice(value, choices){
				return fmt.Errorf("setHost,the value %s is not in set %v",value,choices)
			}
		}//else means any string
	
	
	ap.host = value
	return nil
}

/**
Set the value of the parameter sendRow
*/
func (ap * SystemVariables ) setSendRow(value bool)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	choices :=[]bool {
				
		}
		if len( choices ) != 0{
			if !isInSliceBool(value, choices){
				return fmt.Errorf("setSendRow,the value %t is not in set %v",value,choices)
			}
		}//else means any bool value: true or false
	
	
	ap.sendRow = value
	return nil
}

/**
Set the value of the parameter dumpEnv
*/
func (ap * SystemVariables ) setDumpEnv(value bool)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	choices :=[]bool {
				
		}
		if len( choices ) != 0{
			if !isInSliceBool(value, choices){
				return fmt.Errorf("setDumpEnv,the value %t is not in set %v",value,choices)
			}
		}//else means any bool value: true or false
	
	
	ap.dumpEnv = value
	return nil
}

/**
Set the value of the parameter hostMmuLimitation
*/
func (ap * SystemVariables ) setHostMmuLimitation(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
	
		choices :=[]int64 {
			1099511627776,	
		}
		if len( choices ) != 0{
			if !isInSliceInt64(value, choices){
				return fmt.Errorf("setHostMmuLimitation,the value %d is not in set %v",value,choices)
			}
		}//else means any int64
	
	
	ap.hostMmuLimitation = value
	return nil
}

/**
Set the value of the parameter guestMmuLimitation
*/
func (ap * SystemVariables ) setGuestMmuLimitation(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
	
		choices :=[]int64 {
			1099511627776,	
		}
		if len( choices ) != 0{
			if !isInSliceInt64(value, choices){
				return fmt.Errorf("setGuestMmuLimitation,the value %d is not in set %v",value,choices)
			}
		}//else means any int64
	
	
	ap.guestMmuLimitation = value
	return nil
}

/**
Set the value of the parameter mempoolMaxSize
*/
func (ap * SystemVariables ) setMempoolMaxSize(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
	
		choices :=[]int64 {
			1099511627776,	
		}
		if len( choices ) != 0{
			if !isInSliceInt64(value, choices){
				return fmt.Errorf("setMempoolMaxSize,the value %d is not in set %v",value,choices)
			}
		}//else means any int64
	
	
	ap.mempoolMaxSize = value
	return nil
}

/**
Set the value of the parameter mempoolFactor
*/
func (ap * SystemVariables ) setMempoolFactor(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
	
		choices :=[]int64 {
			8,	
		}
		if len( choices ) != 0{
			if !isInSliceInt64(value, choices){
				return fmt.Errorf("setMempoolFactor,the value %d is not in set %v",value,choices)
			}
		}//else means any int64
	
	
	ap.mempoolFactor = value
	return nil
}

/**
Set the value of the parameter processLimitationSize
*/
func (ap * SystemVariables ) setProcessLimitationSize(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
	
		choices :=[]int64 {
			42949672960,	
		}
		if len( choices ) != 0{
			if !isInSliceInt64(value, choices){
				return fmt.Errorf("setProcessLimitationSize,the value %d is not in set %v",value,choices)
			}
		}//else means any int64
	
	
	ap.processLimitationSize = value
	return nil
}

/**
Set the value of the parameter processLimitationBatchRows
*/
func (ap * SystemVariables ) setProcessLimitationBatchRows(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
	
		choices :=[]int64 {
			42949672960,	
		}
		if len( choices ) != 0{
			if !isInSliceInt64(value, choices){
				return fmt.Errorf("setProcessLimitationBatchRows,the value %d is not in set %v",value,choices)
			}
		}//else means any int64
	
	
	ap.processLimitationBatchRows = value
	return nil
}

/**
Set the value of the parameter processLimitationBatchSize
*/
func (ap * SystemVariables ) setProcessLimitationBatchSize(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
	
		choices :=[]int64 {
			0,	
		}
		if len( choices ) != 0{
			if !isInSliceInt64(value, choices){
				return fmt.Errorf("setProcessLimitationBatchSize,the value %d is not in set %v",value,choices)
			}
		}//else means any int64
	
	
	ap.processLimitationBatchSize = value
	return nil
}

/**
Set the value of the parameter processLimitationPartitionRows
*/
func (ap * SystemVariables ) setProcessLimitationPartitionRows(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
	
		choices :=[]int64 {
			42949672960,	
		}
		if len( choices ) != 0{
			if !isInSliceInt64(value, choices){
				return fmt.Errorf("setProcessLimitationPartitionRows,the value %d is not in set %v",value,choices)
			}
		}//else means any int64
	
	
	ap.processLimitationPartitionRows = value
	return nil
}

/**
Set the value of the parameter countOfRowsPerSendingToClient
*/
func (ap * SystemVariables ) setCountOfRowsPerSendingToClient(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
	
		choices :=[]int64 {
			10,	
		}
		if len( choices ) != 0{
			if !isInSliceInt64(value, choices){
				return fmt.Errorf("setCountOfRowsPerSendingToClient,the value %d is not in set %v",value,choices)
			}
		}//else means any int64
	
	
	ap.countOfRowsPerSendingToClient = value
	return nil
}

/**
Set the value of the parameter periodOfEpochTimer
*/
func (ap * SystemVariables ) setPeriodOfEpochTimer(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
	
		choices :=[]int64 {
			5,	
		}
		if len( choices ) != 0{
			if !isInSliceInt64(value, choices){
				return fmt.Errorf("setPeriodOfEpochTimer,the value %d is not in set %v",value,choices)
			}
		}//else means any int64
	
	
	ap.periodOfEpochTimer = value
	return nil
}

/**
Set the value of the parameter periodOfPersistence
*/
func (ap * SystemVariables ) setPeriodOfPersistence(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
	
		choices :=[]int64 {
			20,	
		}
		if len( choices ) != 0{
			if !isInSliceInt64(value, choices){
				return fmt.Errorf("setPeriodOfPersistence,the value %d is not in set %v",value,choices)
			}
		}//else means any int64
	
	
	ap.periodOfPersistence = value
	return nil
}

/**
Set the value of the parameter periodOfDDLDeleteTimer
*/
func (ap * SystemVariables ) setPeriodOfDDLDeleteTimer(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
	
		choices :=[]int64 {
			20,	
		}
		if len( choices ) != 0{
			if !isInSliceInt64(value, choices){
				return fmt.Errorf("setPeriodOfDDLDeleteTimer,the value %d is not in set %v",value,choices)
			}
		}//else means any int64
	
	
	ap.periodOfDDLDeleteTimer = value
	return nil
}

/**
Set the value of the parameter timeoutOfHeartbeat
*/
func (ap * SystemVariables ) setTimeoutOfHeartbeat(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
	
		choices :=[]int64 {
			20,	
		}
		if len( choices ) != 0{
			if !isInSliceInt64(value, choices){
				return fmt.Errorf("setTimeoutOfHeartbeat,the value %d is not in set %v",value,choices)
			}
		}//else means any int64
	
	
	ap.timeoutOfHeartbeat = value
	return nil
}

/**
Set the value of the parameter rejectWhenHeartbeatFromPDLeaderIsTimeout
*/
func (ap * SystemVariables ) setRejectWhenHeartbeatFromPDLeaderIsTimeout(value bool)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	choices :=[]bool {
			false,	
		}
		if len( choices ) != 0{
			if !isInSliceBool(value, choices){
				return fmt.Errorf("setRejectWhenHeartbeatFromPDLeaderIsTimeout,the value %t is not in set %v",value,choices)
			}
		}//else means any bool value: true or false
	
	
	ap.rejectWhenHeartbeatFromPDLeaderIsTimeout = value
	return nil
}

/**
Set the value of the parameter enableEpochLogging
*/
func (ap * SystemVariables ) setEnableEpochLogging(value bool)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	choices :=[]bool {
			false,	
		}
		if len( choices ) != 0{
			if !isInSliceBool(value, choices){
				return fmt.Errorf("setEnableEpochLogging,the value %t is not in set %v",value,choices)
			}
		}//else means any bool value: true or false
	
	
	ap.enableEpochLogging = value
	return nil
}

/**
Set the value of the parameter recordTimeElapsedOfSqlRequest
*/
func (ap * SystemVariables ) setRecordTimeElapsedOfSqlRequest(value bool)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	choices :=[]bool {
			true,	
		}
		if len( choices ) != 0{
			if !isInSliceBool(value, choices){
				return fmt.Errorf("setRecordTimeElapsedOfSqlRequest,the value %t is not in set %v",value,choices)
			}
		}//else means any bool value: true or false
	
	
	ap.recordTimeElapsedOfSqlRequest = value
	return nil
}

/**
Set the value of the parameter nodeID
*/
func (ap * SystemVariables ) setNodeID(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
	
		choices :=[]int64 {
			0,0,10,	
		}
		if !(value >= choices[1] && value <= choices[2]){
			return fmt.Errorf("setNodeID,the value %d is not in the range [%d,%d]",value,choices[1],choices[2])
		}
	
	
	ap.nodeID = value
	return nil
}

/**
Set the value of the parameter cubeDirPrefix
*/
func (ap * SystemVariables ) setCubeDirPrefix(value string)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
		choices :=[]string {
			"./cube",	
		}
		if len( choices ) != 0{
			if !isInSlice(value, choices){
				return fmt.Errorf("setCubeDirPrefix,the value %s is not in set %v",value,choices)
			}
		}//else means any string
	
	
	ap.cubeDirPrefix = value
	return nil
}

/**
Set the value of the parameter prophetEmbedEtcdJoinAddr
*/
func (ap * SystemVariables ) setProphetEmbedEtcdJoinAddr(value string)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
		choices :=[]string {
			"http://localhost:40000","http://127.0.0.1:40000",	
		}
		if len( choices ) != 0{
			if !isInSlice(value, choices){
				return fmt.Errorf("setProphetEmbedEtcdJoinAddr,the value %s is not in set %v",value,choices)
			}
		}//else means any string
	
	
	ap.prophetEmbedEtcdJoinAddr = value
	return nil
}

/**
Set the value of the parameter maxReplicas
*/
func (ap * SystemVariables ) setMaxReplicas(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
	
		choices :=[]int64 {
			1,1,1,	
		}
		if !(value >= choices[1] && value <= choices[2]){
			return fmt.Errorf("setMaxReplicas,the value %d is not in the range [%d,%d]",value,choices[1],choices[2])
		}
	
	
	ap.maxReplicas = value
	return nil
}

/**
Set the value of the parameter lengthOfQueryPrinted
*/
func (ap * SystemVariables ) setLengthOfQueryPrinted(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
	
		choices :=[]int64 {
			50,-1,10000,	
		}
		if !(value >= choices[1] && value <= choices[2]){
			return fmt.Errorf("setLengthOfQueryPrinted,the value %d is not in the range [%d,%d]",value,choices[1],choices[2])
		}
	
	
	ap.lengthOfQueryPrinted = value
	return nil
}

/**
Set the value of the parameter batchSizeInLoadData
*/
func (ap * SystemVariables ) setBatchSizeInLoadData(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
	
		choices :=[]int64 {
			40000,10,100000,	
		}
		if !(value >= choices[1] && value <= choices[2]){
			return fmt.Errorf("setBatchSizeInLoadData,the value %d is not in the range [%d,%d]",value,choices[1],choices[2])
		}
	
	
	ap.batchSizeInLoadData = value
	return nil
}

/**
Set the value of the parameter loadDataConcurrencyCount
*/
func (ap * SystemVariables ) setLoadDataConcurrencyCount(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
	
		choices :=[]int64 {
			16,1,16,	
		}
		if !(value >= choices[1] && value <= choices[2]){
			return fmt.Errorf("setLoadDataConcurrencyCount,the value %d is not in the range [%d,%d]",value,choices[1],choices[2])
		}
	
	
	ap.loadDataConcurrencyCount = value
	return nil
}

/**
Set the value of the parameter cubeLogLevel
*/
func (ap * SystemVariables ) setCubeLogLevel(value string)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
		choices :=[]string {
			"error","info","debug","warning","warn","fatal",	
		}
		if len( choices ) != 0{
			if !isInSlice(value, choices){
				return fmt.Errorf("setCubeLogLevel,the value %s is not in set %v",value,choices)
			}
		}//else means any string
	
	
	ap.cubeLogLevel = value
	return nil
}

/**
Set the value of the parameter cubeMaxEntriesBytes
*/
func (ap * SystemVariables ) setCubeMaxEntriesBytes(value int64)error {
	ap.rwlock.Lock()
	defer ap.rwlock.Unlock()
	
	
		choices :=[]int64 {
			314572800,	
		}
		if len( choices ) != 0{
			if !isInSliceInt64(value, choices){
				return fmt.Errorf("setCubeMaxEntriesBytes,the value %d is not in set %v",value,choices)
			}
		}//else means any int64
	
	
	ap.cubeMaxEntriesBytes = value
	return nil
}



/**
prepare something before anything else.
it is unsafe in multi-thread environment.
*/
func (config *varsConfig) prepareAnything(){
	if config.name2updatedFlags == nil {
		config.name2updatedFlags = make(map[string]bool)
	}
}

/**
reset update flags of configuration items
*/
func (config *varsConfig) resetUpdatedFlags(){
	config.rwlock.Lock()
	defer config.rwlock.Unlock()
	config.prepareAnything()
	config.name2updatedFlags["rootpassword"] = false
	config.name2updatedFlags["dumpdatabase"] = false
	config.name2updatedFlags["port"] = false
	config.name2updatedFlags["host"] = false
	config.name2updatedFlags["sendRow"] = false
	config.name2updatedFlags["dumpEnv"] = false
	config.name2updatedFlags["hostMmuLimitation"] = false
	config.name2updatedFlags["guestMmuLimitation"] = false
	config.name2updatedFlags["mempoolMaxSize"] = false
	config.name2updatedFlags["mempoolFactor"] = false
	config.name2updatedFlags["processLimitationSize"] = false
	config.name2updatedFlags["processLimitationBatchRows"] = false
	config.name2updatedFlags["processLimitationBatchSize"] = false
	config.name2updatedFlags["processLimitationPartitionRows"] = false
	config.name2updatedFlags["countOfRowsPerSendingToClient"] = false
	config.name2updatedFlags["periodOfEpochTimer"] = false
	config.name2updatedFlags["periodOfPersistence"] = false
	config.name2updatedFlags["periodOfDDLDeleteTimer"] = false
	config.name2updatedFlags["timeoutOfHeartbeat"] = false
	config.name2updatedFlags["rejectWhenHeartbeatFromPDLeaderIsTimeout"] = false
	config.name2updatedFlags["enableEpochLogging"] = false
	config.name2updatedFlags["recordTimeElapsedOfSqlRequest"] = false
	config.name2updatedFlags["nodeID"] = false
	config.name2updatedFlags["cubeDirPrefix"] = false
	config.name2updatedFlags["prophetEmbedEtcdJoinAddr"] = false
	config.name2updatedFlags["maxReplicas"] = false
	config.name2updatedFlags["lengthOfQueryPrinted"] = false
	config.name2updatedFlags["batchSizeInLoadData"] = false
	config.name2updatedFlags["loadDataConcurrencyCount"] = false
	config.name2updatedFlags["cubeLogLevel"] = false
	config.name2updatedFlags["cubeMaxEntriesBytes"] = false
}

/**
set update flag of configuration item
*/
func (config *varsConfig) setUpdatedFlag(name string,updated bool){
	config.rwlock.Lock()
	defer config.rwlock.Unlock()
	config.prepareAnything()
	config.name2updatedFlags[name] = updated
}

/**
get update flag of configuration item
*/
func (config *varsConfig) getUpdatedFlag(name string)bool{
	config.rwlock.RLock()
	defer config.rwlock.RUnlock()
	config.prepareAnything()
	return config.name2updatedFlags[name]
}

/**
Load parameters' values in the configuration string.
*/
func (config *varsConfig) LoadConfigurationFromString(input string) error {
	config.resetUpdatedFlags()

	metadata, err := toml.Decode(input, config);
	if err != nil {
		return err
	}else if failed := metadata.Undecoded() ; len(failed) > 0 {
		var failedItems []string
		for _, item := range failed {
			failedItems = append(failedItems, item.String())
		}
		return fmt.Errorf("decode failed %s. error:%v",failedItems,err)
	}

	for _,k := range metadata.Keys(){
		config.setUpdatedFlag(k[0],true)
	}

	return nil
}

/**
Load parameters' values in the configuration file.
*/
func (config *varsConfig) LoadConfigurationFromFile(fname string) error {
	config.resetUpdatedFlags()

	metadata, err := toml.DecodeFile(fname, config);
	if err != nil {
		return err
	}else if failed := metadata.Undecoded() ; len(failed) > 0 {
		var failedItems []string
		for _, item := range failed {
			failedItems = append(failedItems, item.String())
		}
		//return fmt.Errorf("decode failed %s. error:%v",failedItems,err)
	}

	for _,k := range metadata.Keys(){
		config.setUpdatedFlag(k[0],true)
	}

	return nil
}

/**
Update parameters' values with configuration.
*/
func (ap * SystemVariables ) UpdateParametersWithConfiguration(config *varsConfig)error{
	var err error
	if config.getUpdatedFlag("rootpassword"){
		if err = ap.setRootpassword(config.Rootpassword); err != nil{
			return fmt.Errorf("update parameter rootpassword failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("dumpdatabase"){
		if err = ap.setDumpdatabase(config.Dumpdatabase); err != nil{
			return fmt.Errorf("update parameter dumpdatabase failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("port"){
		if err = ap.setPort(config.Port); err != nil{
			return fmt.Errorf("update parameter port failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("host"){
		if err = ap.setHost(config.Host); err != nil{
			return fmt.Errorf("update parameter host failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("sendRow"){
		if err = ap.setSendRow(config.SendRow); err != nil{
			return fmt.Errorf("update parameter sendRow failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("dumpEnv"){
		if err = ap.setDumpEnv(config.DumpEnv); err != nil{
			return fmt.Errorf("update parameter dumpEnv failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("hostMmuLimitation"){
		if err = ap.setHostMmuLimitation(config.HostMmuLimitation); err != nil{
			return fmt.Errorf("update parameter hostMmuLimitation failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("guestMmuLimitation"){
		if err = ap.setGuestMmuLimitation(config.GuestMmuLimitation); err != nil{
			return fmt.Errorf("update parameter guestMmuLimitation failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("mempoolMaxSize"){
		if err = ap.setMempoolMaxSize(config.MempoolMaxSize); err != nil{
			return fmt.Errorf("update parameter mempoolMaxSize failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("mempoolFactor"){
		if err = ap.setMempoolFactor(config.MempoolFactor); err != nil{
			return fmt.Errorf("update parameter mempoolFactor failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("processLimitationSize"){
		if err = ap.setProcessLimitationSize(config.ProcessLimitationSize); err != nil{
			return fmt.Errorf("update parameter processLimitationSize failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("processLimitationBatchRows"){
		if err = ap.setProcessLimitationBatchRows(config.ProcessLimitationBatchRows); err != nil{
			return fmt.Errorf("update parameter processLimitationBatchRows failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("processLimitationBatchSize"){
		if err = ap.setProcessLimitationBatchSize(config.ProcessLimitationBatchSize); err != nil{
			return fmt.Errorf("update parameter processLimitationBatchSize failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("processLimitationPartitionRows"){
		if err = ap.setProcessLimitationPartitionRows(config.ProcessLimitationPartitionRows); err != nil{
			return fmt.Errorf("update parameter processLimitationPartitionRows failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("countOfRowsPerSendingToClient"){
		if err = ap.setCountOfRowsPerSendingToClient(config.CountOfRowsPerSendingToClient); err != nil{
			return fmt.Errorf("update parameter countOfRowsPerSendingToClient failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("periodOfEpochTimer"){
		if err = ap.setPeriodOfEpochTimer(config.PeriodOfEpochTimer); err != nil{
			return fmt.Errorf("update parameter periodOfEpochTimer failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("periodOfPersistence"){
		if err = ap.setPeriodOfPersistence(config.PeriodOfPersistence); err != nil{
			return fmt.Errorf("update parameter periodOfPersistence failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("periodOfDDLDeleteTimer"){
		if err = ap.setPeriodOfDDLDeleteTimer(config.PeriodOfDDLDeleteTimer); err != nil{
			return fmt.Errorf("update parameter periodOfDDLDeleteTimer failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("timeoutOfHeartbeat"){
		if err = ap.setTimeoutOfHeartbeat(config.TimeoutOfHeartbeat); err != nil{
			return fmt.Errorf("update parameter timeoutOfHeartbeat failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("rejectWhenHeartbeatFromPDLeaderIsTimeout"){
		if err = ap.setRejectWhenHeartbeatFromPDLeaderIsTimeout(config.RejectWhenHeartbeatFromPDLeaderIsTimeout); err != nil{
			return fmt.Errorf("update parameter rejectWhenHeartbeatFromPDLeaderIsTimeout failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("enableEpochLogging"){
		if err = ap.setEnableEpochLogging(config.EnableEpochLogging); err != nil{
			return fmt.Errorf("update parameter enableEpochLogging failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("recordTimeElapsedOfSqlRequest"){
		if err = ap.setRecordTimeElapsedOfSqlRequest(config.RecordTimeElapsedOfSqlRequest); err != nil{
			return fmt.Errorf("update parameter recordTimeElapsedOfSqlRequest failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("nodeID"){
		if err = ap.setNodeID(config.NodeID); err != nil{
			return fmt.Errorf("update parameter nodeID failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("cubeDirPrefix"){
		if err = ap.setCubeDirPrefix(config.CubeDirPrefix); err != nil{
			return fmt.Errorf("update parameter cubeDirPrefix failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("prophetEmbedEtcdJoinAddr"){
		if err = ap.setProphetEmbedEtcdJoinAddr(config.ProphetEmbedEtcdJoinAddr); err != nil{
			return fmt.Errorf("update parameter prophetEmbedEtcdJoinAddr failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("maxReplicas"){
		if err = ap.setMaxReplicas(config.MaxReplicas); err != nil{
			return fmt.Errorf("update parameter maxReplicas failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("lengthOfQueryPrinted"){
		if err = ap.setLengthOfQueryPrinted(config.LengthOfQueryPrinted); err != nil{
			return fmt.Errorf("update parameter lengthOfQueryPrinted failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("batchSizeInLoadData"){
		if err = ap.setBatchSizeInLoadData(config.BatchSizeInLoadData); err != nil{
			return fmt.Errorf("update parameter batchSizeInLoadData failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("loadDataConcurrencyCount"){
		if err = ap.setLoadDataConcurrencyCount(config.LoadDataConcurrencyCount); err != nil{
			return fmt.Errorf("update parameter loadDataConcurrencyCount failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("cubeLogLevel"){
		if err = ap.setCubeLogLevel(config.CubeLogLevel); err != nil{
			return fmt.Errorf("update parameter cubeLogLevel failed.error:%v",err)
		}
	}
	if config.getUpdatedFlag("cubeMaxEntriesBytes"){
		if err = ap.setCubeMaxEntriesBytes(config.CubeMaxEntriesBytes); err != nil{
			return fmt.Errorf("update parameter cubeMaxEntriesBytes failed.error:%v",err)
		}
	}
	return nil
}

/**
Load configuration from file into varsConfig.
Then update items into SystemVariables
*/
func LoadvarsConfigFromFile(filename string,params *SystemVariables) error{
	config := &varsConfig{}
	if err := config.LoadConfigurationFromFile(filename); err != nil{
		return err
	}

	if err := params.UpdateParametersWithConfiguration(config); err != nil{
		return err
	}
	return nil
}
