
// Code generated by tool; DO NOT EDIT.
package config

import (
	"sync"
	"testing"
)

func TestSystemVariables_LoadInitialValues(t *testing.T) {
	ap := &SystemVariables{}
	if err :=ap.LoadInitialValues(); err!=nil{
		t.Errorf("LoadInitialValues failed. error:%v",err)
	}
}

func isvarsConfigEqual(c1,c2 varsConfig) bool {





	if c1.Rootpassword != c2.Rootpassword {
		return false
	}







	if c1.Dumpdatabase != c2.Dumpdatabase {
		return false
	}







	if c1.SendRow != c2.SendRow {
		return false
	}



	if c1.DumpEnv != c2.DumpEnv {
		return false
	}



	if c1.HostMmuLimitation != c2.HostMmuLimitation {
		return false
	}



	if c1.GuestMmuLimitation != c2.GuestMmuLimitation {
		return false
	}



	if c1.MempoolMaxSize != c2.MempoolMaxSize {
		return false
	}



	if c1.MempoolFactor != c2.MempoolFactor {
		return false
	}



	if c1.ProcessLimitationSize != c2.ProcessLimitationSize {
		return false
	}



	if c1.ProcessLimitationBatchRows != c2.ProcessLimitationBatchRows {
		return false
	}



	if c1.ProcessLimitationBatchSize != c2.ProcessLimitationBatchSize {
		return false
	}



	if c1.ProcessLimitationPartitionRows != c2.ProcessLimitationPartitionRows {
		return false
	}



	if c1.CountOfRowsPerSendingToClient != c2.CountOfRowsPerSendingToClient {
		return false
	}



	if c1.PeriodOfEpochTimer != c2.PeriodOfEpochTimer {
		return false
	}



	if c1.PeriodOfPersistence != c2.PeriodOfPersistence {
		return false
	}



	if c1.PeriodOfDDLDeleteTimer != c2.PeriodOfDDLDeleteTimer {
		return false
	}



	if c1.TimeoutOfHeartbeat != c2.TimeoutOfHeartbeat {
		return false
	}



	return true
}

func Test_varsConfig_LoadConfigurationFromString(t *testing.T) {
	t1 := `



rootpassword= ""





dumpdatabase= "default"





sendRow= false

dumpEnv= false

hostMmuLimitation=1099511627776

guestMmuLimitation=1099511627776

mempoolMaxSize=1099511627776

mempoolFactor=8

processLimitationSize=42949672960

processLimitationBatchRows=42949672960

processLimitationBatchSize=0

processLimitationPartitionRows=42949672960

countOfRowsPerSendingToClient=10

periodOfEpochTimer=5

periodOfPersistence=20

periodOfDDLDeleteTimer=20

timeoutOfHeartbeat=20
		
`
	t1_config:=varsConfig{
		rwlock:            sync.RWMutex{},




Rootpassword: "" ,





Dumpdatabase: "default" ,





SendRow: false ,

DumpEnv: false ,

HostMmuLimitation:1099511627776,

GuestMmuLimitation:1099511627776,

MempoolMaxSize:1099511627776,

MempoolFactor:8,

ProcessLimitationSize:42949672960,

ProcessLimitationBatchRows:42949672960,

ProcessLimitationBatchSize:0,

ProcessLimitationPartitionRows:42949672960,

CountOfRowsPerSendingToClient:10,

PeriodOfEpochTimer:5,

PeriodOfPersistence:20,

PeriodOfDDLDeleteTimer:20,

TimeoutOfHeartbeat:20,
	

		name2updatedFlags: nil,
	}

	type args struct {
		input string
		config varsConfig
	}
	tests := []struct {
		name    string
		args    args
		wantErr bool
		wantErr2 bool
		wantErr3 bool
	}{
		{"t1",args{t1,t1_config},false,false,false},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ap := &SystemVariables{}
			if err := ap.LoadInitialValues(); err != nil{
				t.Errorf("LoadInitialValues failed.error %v",err)
			}
			config := &varsConfig{}
			if err := config.LoadConfigurationFromString(tt.args.input); (err != nil) != tt.wantErr {
				t.Errorf("LoadConfigurationFromString() error = %v, wantErr %v", err, tt.wantErr)
			}else if err != nil{
				return
			}

			if err := ap.UpdateParametersWithConfiguration(config); (err != nil) != tt.wantErr2{
				t.Errorf("UpdateParametersWithConfiguration failed. error:%v",err)
			}

			if ( isvarsConfigEqual(*config,tt.args.config) != true ) != tt.wantErr3{
				t.Errorf("Configuration are not equal. %v vs %v ",*config,tt.args.config)
				return
			}
		})
	}
}
