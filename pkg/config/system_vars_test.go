
// Code generated by tool; DO NOT EDIT.
package config

import (
	"sync"
	"testing"
)

func TestSystemVariables_LoadInitialValues(t *testing.T) {
	ap := &SystemVariables{}
	if err :=ap.LoadInitialValues(); err!=nil{
		t.Errorf("LoadInitialValues failed. error:%v",err)
	}
}

func isvarsConfigEqual(c1,c2 varsConfig) bool {





	if c1.Rootpassword != c2.Rootpassword {
		return false
	}







	if c1.Dumpdatabase != c2.Dumpdatabase {
		return false
	}







	return true
}

func Test_varsConfig_LoadConfigurationFromString(t *testing.T) {
	t1 := `



rootpassword= ""





dumpdatabase= "default"




		
`
	t1_config:=varsConfig{
		rwlock:            sync.RWMutex{},




Rootpassword: "" ,





Dumpdatabase: "default" ,




	

		name2updatedFlags: nil,
	}

	type args struct {
		input string
		config varsConfig
	}
	tests := []struct {
		name    string
		args    args
		wantErr bool
		wantErr2 bool
		wantErr3 bool
	}{
		{"t1",args{t1,t1_config},false,false,false},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ap := &SystemVariables{}
			if err := ap.LoadInitialValues(); err != nil{
				t.Errorf("LoadInitialValues failed.error %v",err)
			}
			config := &varsConfig{}
			if err := config.LoadConfigurationFromString(tt.args.input); (err != nil) != tt.wantErr {
				t.Errorf("LoadConfigurationFromString() error = %v, wantErr %v", err, tt.wantErr)
			}else if err != nil{
				return
			}

			if err := ap.UpdateParametersWithConfiguration(config); (err != nil) != tt.wantErr2{
				t.Errorf("UpdateParametersWithConfiguration failed. error:%v",err)
			}

			if ( isvarsConfigEqual(*config,tt.args.config) != true ) != tt.wantErr3{
				t.Errorf("Configuration are not equal. %v vs %v ",*config,tt.args.config)
				return
			}
		})
	}
}
