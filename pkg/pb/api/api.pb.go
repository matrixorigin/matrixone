// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api.proto

package api

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	plan "github.com/matrixorigin/matrixone/pkg/pb/plan"
	timestamp "github.com/matrixorigin/matrixone/pkg/pb/timestamp"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// types.type
type TypeID int32

const (
	TypeID_T_any  TypeID = 0
	TypeID_T_star TypeID = 1
	// bool family
	TypeID_T_bool TypeID = 10
	// numeric/integer family
	TypeID_T_int8    TypeID = 20
	TypeID_T_int16   TypeID = 21
	TypeID_T_int32   TypeID = 22
	TypeID_T_int64   TypeID = 23
	TypeID_T_int128  TypeID = 24
	TypeID_T_uint8   TypeID = 25
	TypeID_T_uint16  TypeID = 26
	TypeID_T_uint32  TypeID = 27
	TypeID_T_uint64  TypeID = 28
	TypeID_T_uint128 TypeID = 29
	// numeric/float family
	TypeID_T_float32 TypeID = 30
	TypeID_T_float64 TypeID = 31
	// numeric/decimals
	TypeID_T_decimal64  TypeID = 32
	TypeID_T_decimal128 TypeID = 33
	// date and time
	TypeID_T_date      TypeID = 50
	TypeID_T_time      TypeID = 51
	TypeID_T_datetime  TypeID = 52
	TypeID_T_timestamp TypeID = 53
	TypeID_T_interval  TypeID = 54
	// string family
	TypeID_T_char    TypeID = 60
	TypeID_T_varchar TypeID = 61
	TypeID_T_json    TypeID = 62
	// blobs
	TypeID_T_blob TypeID = 70
	// Transaction TS
	TypeID_T_TS TypeID = 100
	// system family
	TypeID_T_sel   TypeID = 200
	TypeID_T_tuple TypeID = 201
)

var TypeID_name = map[int32]string{
	0:   "T_any",
	1:   "T_star",
	10:  "T_bool",
	20:  "T_int8",
	21:  "T_int16",
	22:  "T_int32",
	23:  "T_int64",
	24:  "T_int128",
	25:  "T_uint8",
	26:  "T_uint16",
	27:  "T_uint32",
	28:  "T_uint64",
	29:  "T_uint128",
	30:  "T_float32",
	31:  "T_float64",
	32:  "T_decimal64",
	33:  "T_decimal128",
	50:  "T_date",
	51:  "T_time",
	52:  "T_datetime",
	53:  "T_timestamp",
	54:  "T_interval",
	60:  "T_char",
	61:  "T_varchar",
	62:  "T_json",
	70:  "T_blob",
	100: "T_TS",
	200: "T_sel",
	201: "T_tuple",
}

var TypeID_value = map[string]int32{
	"T_any":        0,
	"T_star":       1,
	"T_bool":       10,
	"T_int8":       20,
	"T_int16":      21,
	"T_int32":      22,
	"T_int64":      23,
	"T_int128":     24,
	"T_uint8":      25,
	"T_uint16":     26,
	"T_uint32":     27,
	"T_uint64":     28,
	"T_uint128":    29,
	"T_float32":    30,
	"T_float64":    31,
	"T_decimal64":  32,
	"T_decimal128": 33,
	"T_date":       50,
	"T_time":       51,
	"T_datetime":   52,
	"T_timestamp":  53,
	"T_interval":   54,
	"T_char":       60,
	"T_varchar":    61,
	"T_json":       62,
	"T_blob":       70,
	"T_TS":         100,
	"T_sel":        200,
	"T_tuple":      201,
}

func (x TypeID) String() string {
	return proto.EnumName(TypeID_name, int32(x))
}

func (TypeID) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}

type CmdType int32

const (
	CmdType_CmdBatch        CmdType = 0
	CmdType_CmdAppend       CmdType = 1
	CmdType_CmdMvccUpdate   CmdType = 2
	CmdType_CmdMetaEntry    CmdType = 3
	CmdType_CmdComposed     CmdType = 4
	CmdType_CmdCompactBlock CmdType = 5
	CmdType_CmdMergeBlocks  CmdType = 6
)

var CmdType_name = map[int32]string{
	0: "CmdBatch",
	1: "CmdAppend",
	2: "CmdMvccUpdate",
	3: "CmdMetaEntry",
	4: "CmdComposed",
	5: "CmdCompactBlock",
	6: "CmdMergeBlocks",
}

var CmdType_value = map[string]int32{
	"CmdBatch":        0,
	"CmdAppend":       1,
	"CmdMvccUpdate":   2,
	"CmdMetaEntry":    3,
	"CmdComposed":     4,
	"CmdCompactBlock": 5,
	"CmdMergeBlocks":  6,
}

func (x CmdType) String() string {
	return proto.EnumName(CmdType_name, int32(x))
}

func (CmdType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}

type EntryState int32

const (
	EntryState_ES_Appendable    EntryState = 0
	EntryState_ES_NotAppendable EntryState = 1
	EntryState_ES_Frozen        EntryState = 2
)

var EntryState_name = map[int32]string{
	0: "ES_Appendable",
	1: "ES_NotAppendable",
	2: "ES_Frozen",
}

var EntryState_value = map[string]int32{
	"ES_Appendable":    0,
	"ES_NotAppendable": 1,
	"ES_Frozen":        2,
}

func (x EntryState) String() string {
	return proto.EnumName(EntryState_name, int32(x))
}

func (EntryState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}

type Entry_EntryType int32

const (
	Entry_Insert Entry_EntryType = 0
	Entry_Delete Entry_EntryType = 1
)

var Entry_EntryType_name = map[int32]string{
	0: "Insert",
	1: "Delete",
}

var Entry_EntryType_value = map[string]int32{
	"Insert": 0,
	"Delete": 1,
}

func (x Entry_EntryType) String() string {
	return proto.EnumName(Entry_EntryType_name, int32(x))
}

func (Entry_EntryType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{45, 0}
}

type Type struct {
	Id                   TypeID   `protobuf:"varint,1,opt,name=id,proto3,enum=api.TypeID" json:"id,omitempty"`
	Nullable             bool     `protobuf:"varint,2,opt,name=nullable,proto3" json:"nullable,omitempty"`
	Width                int32    `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
	Precision            int32    `protobuf:"varint,4,opt,name=precision,proto3" json:"precision,omitempty"`
	Size                 int32    `protobuf:"varint,5,opt,name=size,proto3" json:"size,omitempty"`
	Scale                int32    `protobuf:"varint,6,opt,name=scale,proto3" json:"scale,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Type) Reset()         { *m = Type{} }
func (m *Type) String() string { return proto.CompactTextString(m) }
func (*Type) ProtoMessage()    {}
func (*Type) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{0}
}
func (m *Type) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Type) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Type.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Type) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Type.Merge(m, src)
}
func (m *Type) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Type) XXX_DiscardUnknown() {
	xxx_messageInfo_Type.DiscardUnknown(m)
}

var xxx_messageInfo_Type proto.InternalMessageInfo

func (m *Type) GetId() TypeID {
	if m != nil {
		return m.Id
	}
	return TypeID_T_any
}

func (m *Type) GetNullable() bool {
	if m != nil {
		return m.Nullable
	}
	return false
}

func (m *Type) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Type) GetPrecision() int32 {
	if m != nil {
		return m.Precision
	}
	return 0
}

func (m *Type) GetSize() int32 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *Type) GetScale() int32 {
	if m != nil {
		return m.Scale
	}
	return 0
}

type DBInfo struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	IsSys                bool     `protobuf:"varint,2,opt,name=is_sys,json=isSys,proto3" json:"is_sys,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DBInfo) Reset()         { *m = DBInfo{} }
func (m *DBInfo) String() string { return proto.CompactTextString(m) }
func (*DBInfo) ProtoMessage()    {}
func (*DBInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{1}
}
func (m *DBInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DBInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DBInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DBInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DBInfo.Merge(m, src)
}
func (m *DBInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DBInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DBInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DBInfo proto.InternalMessageInfo

func (m *DBInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DBInfo) GetIsSys() bool {
	if m != nil {
		return m.IsSys
	}
	return false
}

type DatabaseCmd struct {
	DbId uint64 `protobuf:"varint,1,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	Mask uint64 `protobuf:"varint,2,opt,name=mask,proto3" json:"mask,omitempty"`
	//creating database
	Create               *DBInfo              `protobuf:"bytes,3,opt,name=create,proto3" json:"create,omitempty"`
	TableCmds            map[uint64]*TableCmd `protobuf:"bytes,4,rep,name=table_cmds,json=tableCmds,proto3" json:"table_cmds,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Drop                 bool                 `protobuf:"varint,5,opt,name=drop,proto3" json:"drop,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *DatabaseCmd) Reset()         { *m = DatabaseCmd{} }
func (m *DatabaseCmd) String() string { return proto.CompactTextString(m) }
func (*DatabaseCmd) ProtoMessage()    {}
func (*DatabaseCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{2}
}
func (m *DatabaseCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseCmd.Merge(m, src)
}
func (m *DatabaseCmd) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DatabaseCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseCmd.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseCmd proto.InternalMessageInfo

func (m *DatabaseCmd) GetDbId() uint64 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *DatabaseCmd) GetMask() uint64 {
	if m != nil {
		return m.Mask
	}
	return 0
}

func (m *DatabaseCmd) GetCreate() *DBInfo {
	if m != nil {
		return m.Create
	}
	return nil
}

func (m *DatabaseCmd) GetTableCmds() map[uint64]*TableCmd {
	if m != nil {
		return m.TableCmds
	}
	return nil
}

func (m *DatabaseCmd) GetDrop() bool {
	if m != nil {
		return m.Drop
	}
	return false
}

type Location struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Offset               uint32   `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	Len                  uint32   `protobuf:"varint,3,opt,name=len,proto3" json:"len,omitempty"`
	Olen                 uint32   `protobuf:"varint,4,opt,name=olen,proto3" json:"olen,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Location) Reset()         { *m = Location{} }
func (m *Location) String() string { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()    {}
func (*Location) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{3}
}
func (m *Location) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Location) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Location.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Location) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Location.Merge(m, src)
}
func (m *Location) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Location) XXX_DiscardUnknown() {
	xxx_messageInfo_Location.DiscardUnknown(m)
}

var xxx_messageInfo_Location proto.InternalMessageInfo

func (m *Location) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Location) GetOffset() uint32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *Location) GetLen() uint32 {
	if m != nil {
		return m.Len
	}
	return 0
}

func (m *Location) GetOlen() uint32 {
	if m != nil {
		return m.Olen
	}
	return 0
}

type ZoneMap struct {
	Typ                  TypeID      `protobuf:"varint,1,opt,name=typ,proto3,enum=api.TypeID" json:"typ,omitempty"`
	Min                  *plan.Const `protobuf:"bytes,2,opt,name=min,proto3" json:"min,omitempty"`
	Max                  *plan.Const `protobuf:"bytes,3,opt,name=max,proto3" json:"max,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ZoneMap) Reset()         { *m = ZoneMap{} }
func (m *ZoneMap) String() string { return proto.CompactTextString(m) }
func (*ZoneMap) ProtoMessage()    {}
func (*ZoneMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{4}
}
func (m *ZoneMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZoneMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZoneMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZoneMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZoneMap.Merge(m, src)
}
func (m *ZoneMap) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ZoneMap) XXX_DiscardUnknown() {
	xxx_messageInfo_ZoneMap.DiscardUnknown(m)
}

var xxx_messageInfo_ZoneMap proto.InternalMessageInfo

func (m *ZoneMap) GetTyp() TypeID {
	if m != nil {
		return m.Typ
	}
	return TypeID_T_any
}

func (m *ZoneMap) GetMin() *plan.Const {
	if m != nil {
		return m.Min
	}
	return nil
}

func (m *ZoneMap) GetMax() *plan.Const {
	if m != nil {
		return m.Max
	}
	return nil
}

type ColumnMeta struct {
	Idx                  uint32    `protobuf:"varint,1,opt,name=idx,proto3" json:"idx,omitempty"`
	Zm                   *ZoneMap  `protobuf:"bytes,2,opt,name=zm,proto3" json:"zm,omitempty"`
	BfLocation           *Location `protobuf:"bytes,3,opt,name=bf_location,json=bfLocation,proto3" json:"bf_location,omitempty"`
	DataLocation         *Location `protobuf:"bytes,4,opt,name=data_location,json=dataLocation,proto3" json:"data_location,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ColumnMeta) Reset()         { *m = ColumnMeta{} }
func (m *ColumnMeta) String() string { return proto.CompactTextString(m) }
func (*ColumnMeta) ProtoMessage()    {}
func (*ColumnMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{5}
}
func (m *ColumnMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColumnMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColumnMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnMeta.Merge(m, src)
}
func (m *ColumnMeta) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ColumnMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnMeta.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnMeta proto.InternalMessageInfo

func (m *ColumnMeta) GetIdx() uint32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *ColumnMeta) GetZm() *ZoneMap {
	if m != nil {
		return m.Zm
	}
	return nil
}

func (m *ColumnMeta) GetBfLocation() *Location {
	if m != nil {
		return m.BfLocation
	}
	return nil
}

func (m *ColumnMeta) GetDataLocation() *Location {
	if m != nil {
		return m.DataLocation
	}
	return nil
}

type BlockMeta struct {
	ColunmCnt            uint32   `protobuf:"varint,1,opt,name=colunm_cnt,json=colunmCnt,proto3" json:"colunm_cnt,omitempty"`
	Alog                 uint32   `protobuf:"varint,2,opt,name=alog,proto3" json:"alog,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockMeta) Reset()         { *m = BlockMeta{} }
func (m *BlockMeta) String() string { return proto.CompactTextString(m) }
func (*BlockMeta) ProtoMessage()    {}
func (*BlockMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{6}
}
func (m *BlockMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockMeta.Merge(m, src)
}
func (m *BlockMeta) XXX_Size() int {
	return m.ProtoSize()
}
func (m *BlockMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockMeta.DiscardUnknown(m)
}

var xxx_messageInfo_BlockMeta proto.InternalMessageInfo

func (m *BlockMeta) GetColunmCnt() uint32 {
	if m != nil {
		return m.ColunmCnt
	}
	return 0
}

func (m *BlockMeta) GetAlog() uint32 {
	if m != nil {
		return m.Alog
	}
	return 0
}

type BlockInfo struct {
	BlockMeta            *BlockMeta    `protobuf:"bytes,1,opt,name=block_meta,json=blockMeta,proto3" json:"block_meta,omitempty"`
	ColumnsMeta          []*ColumnMeta `protobuf:"bytes,2,rep,name=columns_meta,json=columnsMeta,proto3" json:"columns_meta,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *BlockInfo) Reset()         { *m = BlockInfo{} }
func (m *BlockInfo) String() string { return proto.CompactTextString(m) }
func (*BlockInfo) ProtoMessage()    {}
func (*BlockInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{7}
}
func (m *BlockInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockInfo.Merge(m, src)
}
func (m *BlockInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *BlockInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BlockInfo proto.InternalMessageInfo

func (m *BlockInfo) GetBlockMeta() *BlockMeta {
	if m != nil {
		return m.BlockMeta
	}
	return nil
}

func (m *BlockInfo) GetColumnsMeta() []*ColumnMeta {
	if m != nil {
		return m.ColumnsMeta
	}
	return nil
}

type Vector struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Type                 *Type    `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	Nullable             bool     `protobuf:"varint,3,opt,name=nullable,proto3" json:"nullable,omitempty"`
	Nsp                  []byte   `protobuf:"bytes,4,opt,name=nsp,proto3" json:"nsp,omitempty"`
	IsConst              bool     `protobuf:"varint,5,opt,name=is_const,json=isConst,proto3" json:"is_const,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Vector) Reset()         { *m = Vector{} }
func (m *Vector) String() string { return proto.CompactTextString(m) }
func (*Vector) ProtoMessage()    {}
func (*Vector) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{8}
}
func (m *Vector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vector.Merge(m, src)
}
func (m *Vector) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Vector) XXX_DiscardUnknown() {
	xxx_messageInfo_Vector.DiscardUnknown(m)
}

var xxx_messageInfo_Vector proto.InternalMessageInfo

func (m *Vector) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Vector) GetType() *Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Vector) GetNullable() bool {
	if m != nil {
		return m.Nullable
	}
	return false
}

func (m *Vector) GetNsp() []byte {
	if m != nil {
		return m.Nsp
	}
	return nil
}

func (m *Vector) GetIsConst() bool {
	if m != nil {
		return m.IsConst
	}
	return false
}

type AppendInfo struct {
	//[]string
	Attrs []string `protobuf:"bytes,1,rep,name=attrs,proto3" json:"attrs,omitempty"`
	//[]Vector
	Vecs                 []*Vector `protobuf:"bytes,2,rep,name=vecs,proto3" json:"vecs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *AppendInfo) Reset()         { *m = AppendInfo{} }
func (m *AppendInfo) String() string { return proto.CompactTextString(m) }
func (*AppendInfo) ProtoMessage()    {}
func (*AppendInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{9}
}
func (m *AppendInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendInfo.Merge(m, src)
}
func (m *AppendInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AppendInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AppendInfo proto.InternalMessageInfo

func (m *AppendInfo) GetAttrs() []string {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *AppendInfo) GetVecs() []*Vector {
	if m != nil {
		return m.Vecs
	}
	return nil
}

type RowRange struct {
	Start                uint32   `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End                  uint32   `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RowRange) Reset()         { *m = RowRange{} }
func (m *RowRange) String() string { return proto.CompactTextString(m) }
func (*RowRange) ProtoMessage()    {}
func (*RowRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{10}
}
func (m *RowRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RowRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RowRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowRange.Merge(m, src)
}
func (m *RowRange) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RowRange) XXX_DiscardUnknown() {
	xxx_messageInfo_RowRange.DiscardUnknown(m)
}

var xxx_messageInfo_RowRange proto.InternalMessageInfo

func (m *RowRange) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *RowRange) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

type DeleteInfo struct {
	RangeRows            *DeleteInfo_DefType `protobuf:"bytes,1,opt,name=range_rows,json=rangeRows,proto3" json:"range_rows,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *DeleteInfo) Reset()         { *m = DeleteInfo{} }
func (m *DeleteInfo) String() string { return proto.CompactTextString(m) }
func (*DeleteInfo) ProtoMessage()    {}
func (*DeleteInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{11}
}
func (m *DeleteInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteInfo.Merge(m, src)
}
func (m *DeleteInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeleteInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteInfo proto.InternalMessageInfo

func (m *DeleteInfo) GetRangeRows() *DeleteInfo_DefType {
	if m != nil {
		return m.RangeRows
	}
	return nil
}

type DeleteInfo_DefType struct {
	// Types that are valid to be assigned to Def:
	//	*DeleteInfo_DefType_Range
	//	*DeleteInfo_DefType_Rows
	Def                  isDeleteInfo_DefType_Def `protobuf_oneof:"def"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *DeleteInfo_DefType) Reset()         { *m = DeleteInfo_DefType{} }
func (m *DeleteInfo_DefType) String() string { return proto.CompactTextString(m) }
func (*DeleteInfo_DefType) ProtoMessage()    {}
func (*DeleteInfo_DefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{11, 0}
}
func (m *DeleteInfo_DefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteInfo_DefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteInfo_DefType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteInfo_DefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteInfo_DefType.Merge(m, src)
}
func (m *DeleteInfo_DefType) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeleteInfo_DefType) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteInfo_DefType.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteInfo_DefType proto.InternalMessageInfo

type isDeleteInfo_DefType_Def interface {
	isDeleteInfo_DefType_Def()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type DeleteInfo_DefType_Range struct {
	Range *RowRange `protobuf:"bytes,1,opt,name=range,proto3,oneof" json:"range,omitempty"`
}
type DeleteInfo_DefType_Rows struct {
	Rows string `protobuf:"bytes,2,opt,name=rows,proto3,oneof" json:"rows,omitempty"`
}

func (*DeleteInfo_DefType_Range) isDeleteInfo_DefType_Def() {}
func (*DeleteInfo_DefType_Rows) isDeleteInfo_DefType_Def()  {}

func (m *DeleteInfo_DefType) GetDef() isDeleteInfo_DefType_Def {
	if m != nil {
		return m.Def
	}
	return nil
}

func (m *DeleteInfo_DefType) GetRange() *RowRange {
	if x, ok := m.GetDef().(*DeleteInfo_DefType_Range); ok {
		return x.Range
	}
	return nil
}

func (m *DeleteInfo_DefType) GetRows() string {
	if x, ok := m.GetDef().(*DeleteInfo_DefType_Rows); ok {
		return x.Rows
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DeleteInfo_DefType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DeleteInfo_DefType_Range)(nil),
		(*DeleteInfo_DefType_Rows)(nil),
	}
}

type BlockCmd struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	//bitmap
	Mask                 uint32      `protobuf:"varint,2,opt,name=mask,proto3" json:"mask,omitempty"`
	Create               *BlockInfo  `protobuf:"bytes,3,opt,name=create,proto3" json:"create,omitempty"`
	Append               *AppendInfo `protobuf:"bytes,4,opt,name=append,proto3" json:"append,omitempty"`
	Delete               *DeleteInfo `protobuf:"bytes,5,opt,name=delete,proto3" json:"delete,omitempty"`
	Drop                 bool        `protobuf:"varint,6,opt,name=drop,proto3" json:"drop,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *BlockCmd) Reset()         { *m = BlockCmd{} }
func (m *BlockCmd) String() string { return proto.CompactTextString(m) }
func (*BlockCmd) ProtoMessage()    {}
func (*BlockCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{12}
}
func (m *BlockCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockCmd.Merge(m, src)
}
func (m *BlockCmd) XXX_Size() int {
	return m.ProtoSize()
}
func (m *BlockCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockCmd.DiscardUnknown(m)
}

var xxx_messageInfo_BlockCmd proto.InternalMessageInfo

func (m *BlockCmd) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BlockCmd) GetMask() uint32 {
	if m != nil {
		return m.Mask
	}
	return 0
}

func (m *BlockCmd) GetCreate() *BlockInfo {
	if m != nil {
		return m.Create
	}
	return nil
}

func (m *BlockCmd) GetAppend() *AppendInfo {
	if m != nil {
		return m.Append
	}
	return nil
}

func (m *BlockCmd) GetDelete() *DeleteInfo {
	if m != nil {
		return m.Delete
	}
	return nil
}

func (m *BlockCmd) GetDrop() bool {
	if m != nil {
		return m.Drop
	}
	return false
}

type AccessInfo struct {
	TenantId             uint32               `protobuf:"varint,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	UserId               uint32               `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	RoleId               uint32               `protobuf:"varint,3,opt,name=role_id,json=roleId,proto3" json:"role_id,omitempty"`
	CreateAt             *timestamp.Timestamp `protobuf:"bytes,4,opt,name=create_at,json=createAt,proto3" json:"create_at,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *AccessInfo) Reset()         { *m = AccessInfo{} }
func (m *AccessInfo) String() string { return proto.CompactTextString(m) }
func (*AccessInfo) ProtoMessage()    {}
func (*AccessInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{13}
}
func (m *AccessInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessInfo.Merge(m, src)
}
func (m *AccessInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AccessInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AccessInfo proto.InternalMessageInfo

func (m *AccessInfo) GetTenantId() uint32 {
	if m != nil {
		return m.TenantId
	}
	return 0
}

func (m *AccessInfo) GetUserId() uint32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *AccessInfo) GetRoleId() uint32 {
	if m != nil {
		return m.RoleId
	}
	return 0
}

func (m *AccessInfo) GetCreateAt() *timestamp.Timestamp {
	if m != nil {
		return m.CreateAt
	}
	return nil
}

type ColDef struct {
	Name                 string        `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Idx                  int32         `protobuf:"varint,2,opt,name=idx,proto3" json:"idx,omitempty"`
	Type                 *Type         `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	Hidden               bool          `protobuf:"varint,4,opt,name=hidden,proto3" json:"hidden,omitempty"`
	PhyAddr              bool          `protobuf:"varint,5,opt,name=phy_addr,json=phyAddr,proto3" json:"phy_addr,omitempty"`
	NullAbility          bool          `protobuf:"varint,6,opt,name=null_ability,json=nullAbility,proto3" json:"null_ability,omitempty"`
	AutoIncrement        bool          `protobuf:"varint,7,opt,name=auto_increment,json=autoIncrement,proto3" json:"auto_increment,omitempty"`
	Primary              bool          `protobuf:"varint,8,opt,name=primary,proto3" json:"primary,omitempty"`
	SortIdx              int32         `protobuf:"varint,9,opt,name=sort_idx,json=sortIdx,proto3" json:"sort_idx,omitempty"`
	SortKey              bool          `protobuf:"varint,10,opt,name=sort_key,json=sortKey,proto3" json:"sort_key,omitempty"`
	Comment              string        `protobuf:"bytes,11,opt,name=comment,proto3" json:"comment,omitempty"`
	Default              *plan.Default `protobuf:"bytes,12,opt,name=default,proto3" json:"default,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ColDef) Reset()         { *m = ColDef{} }
func (m *ColDef) String() string { return proto.CompactTextString(m) }
func (*ColDef) ProtoMessage()    {}
func (*ColDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{14}
}
func (m *ColDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColDef.Merge(m, src)
}
func (m *ColDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ColDef) XXX_DiscardUnknown() {
	xxx_messageInfo_ColDef.DiscardUnknown(m)
}

var xxx_messageInfo_ColDef proto.InternalMessageInfo

func (m *ColDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ColDef) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *ColDef) GetType() *Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *ColDef) GetHidden() bool {
	if m != nil {
		return m.Hidden
	}
	return false
}

func (m *ColDef) GetPhyAddr() bool {
	if m != nil {
		return m.PhyAddr
	}
	return false
}

func (m *ColDef) GetNullAbility() bool {
	if m != nil {
		return m.NullAbility
	}
	return false
}

func (m *ColDef) GetAutoIncrement() bool {
	if m != nil {
		return m.AutoIncrement
	}
	return false
}

func (m *ColDef) GetPrimary() bool {
	if m != nil {
		return m.Primary
	}
	return false
}

func (m *ColDef) GetSortIdx() int32 {
	if m != nil {
		return m.SortIdx
	}
	return 0
}

func (m *ColDef) GetSortKey() bool {
	if m != nil {
		return m.SortKey
	}
	return false
}

func (m *ColDef) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *ColDef) GetDefault() *plan.Default {
	if m != nil {
		return m.Default
	}
	return nil
}

type TableDef struct {
	AcInfo *AccessInfo `protobuf:"bytes,1,opt,name=ac_info,json=acInfo,proto3" json:"ac_info,omitempty"`
	Name   string      `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	//[]ColDef?
	ColsDef              []*ColDef        `protobuf:"bytes,3,rep,name=cols_def,json=colsDef,proto3" json:"cols_def,omitempty"`
	NameIndex            map[string]int32 `protobuf:"bytes,4,rep,name=name_index,json=nameIndex,proto3" json:"name_index,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Comment              string           `protobuf:"bytes,5,opt,name=comment,proto3" json:"comment,omitempty"`
	RelKind              string           `protobuf:"bytes,6,opt,name=rel_kind,json=relKind,proto3" json:"rel_kind,omitempty"`
	CreateSql            string           `protobuf:"bytes,7,opt,name=create_sql,json=createSql,proto3" json:"create_sql,omitempty"`
	View                 string           `protobuf:"bytes,8,opt,name=view,proto3" json:"view,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *TableDef) Reset()         { *m = TableDef{} }
func (m *TableDef) String() string { return proto.CompactTextString(m) }
func (*TableDef) ProtoMessage()    {}
func (*TableDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{15}
}
func (m *TableDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDef.Merge(m, src)
}
func (m *TableDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableDef) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDef.DiscardUnknown(m)
}

var xxx_messageInfo_TableDef proto.InternalMessageInfo

func (m *TableDef) GetAcInfo() *AccessInfo {
	if m != nil {
		return m.AcInfo
	}
	return nil
}

func (m *TableDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TableDef) GetColsDef() []*ColDef {
	if m != nil {
		return m.ColsDef
	}
	return nil
}

func (m *TableDef) GetNameIndex() map[string]int32 {
	if m != nil {
		return m.NameIndex
	}
	return nil
}

func (m *TableDef) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *TableDef) GetRelKind() string {
	if m != nil {
		return m.RelKind
	}
	return ""
}

func (m *TableDef) GetCreateSql() string {
	if m != nil {
		return m.CreateSql
	}
	return ""
}

func (m *TableDef) GetView() string {
	if m != nil {
		return m.View
	}
	return ""
}

type TableCmd struct {
	Tid uint64 `protobuf:"varint,1,opt,name=tid,proto3" json:"tid,omitempty"`
	//bitmap
	Mask   uint64    `protobuf:"varint,2,opt,name=mask,proto3" json:"mask,omitempty"`
	Create *TableDef `protobuf:"bytes,3,opt,name=create,proto3" json:"create,omitempty"`
	//FIXME::transient block id is unique in CN's workspace.
	BlockCmds            map[uint64]*BlockCmd `protobuf:"bytes,4,rep,name=block_cmds,json=blockCmds,proto3" json:"block_cmds,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Drop                 bool                 `protobuf:"varint,5,opt,name=drop,proto3" json:"drop,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *TableCmd) Reset()         { *m = TableCmd{} }
func (m *TableCmd) String() string { return proto.CompactTextString(m) }
func (*TableCmd) ProtoMessage()    {}
func (*TableCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{16}
}
func (m *TableCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableCmd.Merge(m, src)
}
func (m *TableCmd) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_TableCmd.DiscardUnknown(m)
}

var xxx_messageInfo_TableCmd proto.InternalMessageInfo

func (m *TableCmd) GetTid() uint64 {
	if m != nil {
		return m.Tid
	}
	return 0
}

func (m *TableCmd) GetMask() uint64 {
	if m != nil {
		return m.Mask
	}
	return 0
}

func (m *TableCmd) GetCreate() *TableDef {
	if m != nil {
		return m.Create
	}
	return nil
}

func (m *TableCmd) GetBlockCmds() map[uint64]*BlockCmd {
	if m != nil {
		return m.BlockCmds
	}
	return nil
}

func (m *TableCmd) GetDrop() bool {
	if m != nil {
		return m.Drop
	}
	return false
}

type DatabaseID struct {
	Id                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DatabaseID) Reset()         { *m = DatabaseID{} }
func (m *DatabaseID) String() string { return proto.CompactTextString(m) }
func (*DatabaseID) ProtoMessage()    {}
func (*DatabaseID) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{17}
}
func (m *DatabaseID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseID.Merge(m, src)
}
func (m *DatabaseID) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DatabaseID) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseID.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseID proto.InternalMessageInfo

func (m *DatabaseID) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type TableID struct {
	TabId                uint64      `protobuf:"varint,1,opt,name=tab_id,json=tabId,proto3" json:"tab_id,omitempty"`
	DbId                 *DatabaseID `protobuf:"bytes,2,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *TableID) Reset()         { *m = TableID{} }
func (m *TableID) String() string { return proto.CompactTextString(m) }
func (*TableID) ProtoMessage()    {}
func (*TableID) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{18}
}
func (m *TableID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableID.Merge(m, src)
}
func (m *TableID) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableID) XXX_DiscardUnknown() {
	xxx_messageInfo_TableID.DiscardUnknown(m)
}

var xxx_messageInfo_TableID proto.InternalMessageInfo

func (m *TableID) GetTabId() uint64 {
	if m != nil {
		return m.TabId
	}
	return 0
}

func (m *TableID) GetDbId() *DatabaseID {
	if m != nil {
		return m.DbId
	}
	return nil
}

type SegmentID struct {
	SegId                uint64   `protobuf:"varint,1,opt,name=seg_id,json=segId,proto3" json:"seg_id,omitempty"`
	TabId                *TableID `protobuf:"bytes,2,opt,name=tab_id,json=tabId,proto3" json:"tab_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SegmentID) Reset()         { *m = SegmentID{} }
func (m *SegmentID) String() string { return proto.CompactTextString(m) }
func (*SegmentID) ProtoMessage()    {}
func (*SegmentID) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{19}
}
func (m *SegmentID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SegmentID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SegmentID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SegmentID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SegmentID.Merge(m, src)
}
func (m *SegmentID) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SegmentID) XXX_DiscardUnknown() {
	xxx_messageInfo_SegmentID.DiscardUnknown(m)
}

var xxx_messageInfo_SegmentID proto.InternalMessageInfo

func (m *SegmentID) GetSegId() uint64 {
	if m != nil {
		return m.SegId
	}
	return 0
}

func (m *SegmentID) GetTabId() *TableID {
	if m != nil {
		return m.TabId
	}
	return nil
}

type BlockID struct {
	BlockId              uint64     `protobuf:"varint,1,opt,name=block_id,json=blockId,proto3" json:"block_id,omitempty"`
	SegId                *SegmentID `protobuf:"bytes,2,opt,name=seg_id,json=segId,proto3" json:"seg_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *BlockID) Reset()         { *m = BlockID{} }
func (m *BlockID) String() string { return proto.CompactTextString(m) }
func (*BlockID) ProtoMessage()    {}
func (*BlockID) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{20}
}
func (m *BlockID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockID.Merge(m, src)
}
func (m *BlockID) XXX_Size() int {
	return m.ProtoSize()
}
func (m *BlockID) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockID.DiscardUnknown(m)
}

var xxx_messageInfo_BlockID proto.InternalMessageInfo

func (m *BlockID) GetBlockId() uint64 {
	if m != nil {
		return m.BlockId
	}
	return 0
}

func (m *BlockID) GetSegId() *SegmentID {
	if m != nil {
		return m.SegId
	}
	return nil
}

type TSRange struct {
	From                 *timestamp.Timestamp `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	To                   *timestamp.Timestamp `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *TSRange) Reset()         { *m = TSRange{} }
func (m *TSRange) String() string { return proto.CompactTextString(m) }
func (*TSRange) ProtoMessage()    {}
func (*TSRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{21}
}
func (m *TSRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TSRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TSRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TSRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TSRange.Merge(m, src)
}
func (m *TSRange) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TSRange) XXX_DiscardUnknown() {
	xxx_messageInfo_TSRange.DiscardUnknown(m)
}

var xxx_messageInfo_TSRange proto.InternalMessageInfo

func (m *TSRange) GetFrom() *timestamp.Timestamp {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *TSRange) GetTo() *timestamp.Timestamp {
	if m != nil {
		return m.To
	}
	return nil
}

type ScopeDesc struct {
	All bool `protobuf:"varint,1,opt,name=all,proto3" json:"all,omitempty"`
	//[]TableID?
	Tables               []*TableID `protobuf:"bytes,2,rep,name=tables,proto3" json:"tables,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ScopeDesc) Reset()         { *m = ScopeDesc{} }
func (m *ScopeDesc) String() string { return proto.CompactTextString(m) }
func (*ScopeDesc) ProtoMessage()    {}
func (*ScopeDesc) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{22}
}
func (m *ScopeDesc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScopeDesc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScopeDesc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScopeDesc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScopeDesc.Merge(m, src)
}
func (m *ScopeDesc) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ScopeDesc) XXX_DiscardUnknown() {
	xxx_messageInfo_ScopeDesc.DiscardUnknown(m)
}

var xxx_messageInfo_ScopeDesc proto.InternalMessageInfo

func (m *ScopeDesc) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

func (m *ScopeDesc) GetTables() []*TableID {
	if m != nil {
		return m.Tables
	}
	return nil
}

// CN pull the tail of redo logs from DN.
type SyncLogTailReq struct {
	CheckpointTs *timestamp.Timestamp `protobuf:"bytes,1,opt,name=checkpoint_ts,json=checkpointTs,proto3" json:"checkpoint_ts,omitempty"`
	Range        *TSRange             `protobuf:"bytes,2,opt,name=range,proto3" json:"range,omitempty"`
	//[]TableID
	Tables               []*TableID `protobuf:"bytes,3,rep,name=tables,proto3" json:"tables,omitempty"`
	All                  bool       `protobuf:"varint,4,opt,name=all,proto3" json:"all,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *SyncLogTailReq) Reset()         { *m = SyncLogTailReq{} }
func (m *SyncLogTailReq) String() string { return proto.CompactTextString(m) }
func (*SyncLogTailReq) ProtoMessage()    {}
func (*SyncLogTailReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{23}
}
func (m *SyncLogTailReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncLogTailReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncLogTailReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncLogTailReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncLogTailReq.Merge(m, src)
}
func (m *SyncLogTailReq) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SyncLogTailReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncLogTailReq.DiscardUnknown(m)
}

var xxx_messageInfo_SyncLogTailReq proto.InternalMessageInfo

func (m *SyncLogTailReq) GetCheckpointTs() *timestamp.Timestamp {
	if m != nil {
		return m.CheckpointTs
	}
	return nil
}

func (m *SyncLogTailReq) GetRange() *TSRange {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *SyncLogTailReq) GetTables() []*TableID {
	if m != nil {
		return m.Tables
	}
	return nil
}

func (m *SyncLogTailReq) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

type Batch struct {
	//[]string?
	Attrs []string `protobuf:"bytes,1,rep,name=attrs,proto3" json:"attrs,omitempty"`
	//[]Vector?
	Vecs                 []*Vector `protobuf:"bytes,2,rep,name=vecs,proto3" json:"vecs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Batch) Reset()         { *m = Batch{} }
func (m *Batch) String() string { return proto.CompactTextString(m) }
func (*Batch) ProtoMessage()    {}
func (*Batch) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{24}
}
func (m *Batch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Batch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Batch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Batch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Batch.Merge(m, src)
}
func (m *Batch) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Batch) XXX_DiscardUnknown() {
	xxx_messageInfo_Batch.DiscardUnknown(m)
}

var xxx_messageInfo_Batch proto.InternalMessageInfo

func (m *Batch) GetAttrs() []string {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *Batch) GetVecs() []*Vector {
	if m != nil {
		return m.Vecs
	}
	return nil
}

type AppendCtx struct {
	//reserved?
	Seq                  uint32   `protobuf:"varint,1,opt,name=seq,proto3" json:"seq,omitempty"`
	SrcOff               uint32   `protobuf:"varint,2,opt,name=src_off,json=srcOff,proto3" json:"src_off,omitempty"`
	SrcLen               uint32   `protobuf:"varint,3,opt,name=src_len,json=srcLen,proto3" json:"src_len,omitempty"`
	DbId                 uint64   `protobuf:"varint,4,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	Dest                 *BlockID `protobuf:"bytes,5,opt,name=dest,proto3" json:"dest,omitempty"`
	DestOff              uint32   `protobuf:"varint,6,opt,name=dest_off,json=destOff,proto3" json:"dest_off,omitempty"`
	DestLen              uint32   `protobuf:"varint,7,opt,name=dest_len,json=destLen,proto3" json:"dest_len,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AppendCtx) Reset()         { *m = AppendCtx{} }
func (m *AppendCtx) String() string { return proto.CompactTextString(m) }
func (*AppendCtx) ProtoMessage()    {}
func (*AppendCtx) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{25}
}
func (m *AppendCtx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendCtx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendCtx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendCtx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendCtx.Merge(m, src)
}
func (m *AppendCtx) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AppendCtx) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendCtx.DiscardUnknown(m)
}

var xxx_messageInfo_AppendCtx proto.InternalMessageInfo

func (m *AppendCtx) GetSeq() uint32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *AppendCtx) GetSrcOff() uint32 {
	if m != nil {
		return m.SrcOff
	}
	return 0
}

func (m *AppendCtx) GetSrcLen() uint32 {
	if m != nil {
		return m.SrcLen
	}
	return 0
}

func (m *AppendCtx) GetDbId() uint64 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *AppendCtx) GetDest() *BlockID {
	if m != nil {
		return m.Dest
	}
	return nil
}

func (m *AppendCtx) GetDestOff() uint32 {
	if m != nil {
		return m.DestOff
	}
	return 0
}

func (m *AppendCtx) GetDestLen() uint32 {
	if m != nil {
		return m.DestLen
	}
	return 0
}

// Append batch of data which comes from localsegment of table into multiple blocks.
type AppendCmd struct {
	//CmdAppend
	CmdType CmdType `protobuf:"varint,1,opt,name=cmd_type,json=cmdType,proto3,enum=api.CmdType" json:"cmd_type,omitempty"`
	//sub cmd sequence number in LSN entry.
	Csn uint32 `protobuf:"varint,2,opt,name=csn,proto3" json:"csn,omitempty"`
	Bat *Batch `protobuf:"bytes,3,opt,name=bat,proto3" json:"bat,omitempty"`
	//one batch could be appended into multiple blocks
	//[]AppendCtx
	Ctxs                 []*AppendCtx         `protobuf:"bytes,4,rep,name=ctxs,proto3" json:"ctxs,omitempty"`
	Ts                   *timestamp.Timestamp `protobuf:"bytes,5,opt,name=ts,proto3" json:"ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *AppendCmd) Reset()         { *m = AppendCmd{} }
func (m *AppendCmd) String() string { return proto.CompactTextString(m) }
func (*AppendCmd) ProtoMessage()    {}
func (*AppendCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{26}
}
func (m *AppendCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendCmd.Merge(m, src)
}
func (m *AppendCmd) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AppendCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendCmd.DiscardUnknown(m)
}

var xxx_messageInfo_AppendCmd proto.InternalMessageInfo

func (m *AppendCmd) GetCmdType() CmdType {
	if m != nil {
		return m.CmdType
	}
	return CmdType_CmdBatch
}

func (m *AppendCmd) GetCsn() uint32 {
	if m != nil {
		return m.Csn
	}
	return 0
}

func (m *AppendCmd) GetBat() *Batch {
	if m != nil {
		return m.Bat
	}
	return nil
}

func (m *AppendCmd) GetCtxs() []*AppendCtx {
	if m != nil {
		return m.Ctxs
	}
	return nil
}

func (m *AppendCmd) GetTs() *timestamp.Timestamp {
	if m != nil {
		return m.Ts
	}
	return nil
}

type AppendNode struct {
	BlockId              *BlockID             `protobuf:"bytes,1,opt,name=block_id,json=blockId,proto3" json:"block_id,omitempty"`
	StartRow             uint32               `protobuf:"varint,2,opt,name=start_row,json=startRow,proto3" json:"start_row,omitempty"`
	MaxRow               uint32               `protobuf:"varint,3,opt,name=max_row,json=maxRow,proto3" json:"max_row,omitempty"`
	CommitTs             *timestamp.Timestamp `protobuf:"bytes,4,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *AppendNode) Reset()         { *m = AppendNode{} }
func (m *AppendNode) String() string { return proto.CompactTextString(m) }
func (*AppendNode) ProtoMessage()    {}
func (*AppendNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{27}
}
func (m *AppendNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendNode.Merge(m, src)
}
func (m *AppendNode) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AppendNode) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendNode.DiscardUnknown(m)
}

var xxx_messageInfo_AppendNode proto.InternalMessageInfo

func (m *AppendNode) GetBlockId() *BlockID {
	if m != nil {
		return m.BlockId
	}
	return nil
}

func (m *AppendNode) GetStartRow() uint32 {
	if m != nil {
		return m.StartRow
	}
	return 0
}

func (m *AppendNode) GetMaxRow() uint32 {
	if m != nil {
		return m.MaxRow
	}
	return 0
}

func (m *AppendNode) GetCommitTs() *timestamp.Timestamp {
	if m != nil {
		return m.CommitTs
	}
	return nil
}

type DeleteNode struct {
	BlockId *BlockID `protobuf:"bytes,1,opt,name=block_id,json=blockId,proto3" json:"block_id,omitempty"`
	//rows bitmap,[]byte, too expensive?
	Mask                 string               `protobuf:"bytes,2,opt,name=mask,proto3" json:"mask,omitempty"`
	CommitTs             *timestamp.Timestamp `protobuf:"bytes,3,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *DeleteNode) Reset()         { *m = DeleteNode{} }
func (m *DeleteNode) String() string { return proto.CompactTextString(m) }
func (*DeleteNode) ProtoMessage()    {}
func (*DeleteNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{28}
}
func (m *DeleteNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteNode.Merge(m, src)
}
func (m *DeleteNode) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeleteNode) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteNode.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteNode proto.InternalMessageInfo

func (m *DeleteNode) GetBlockId() *BlockID {
	if m != nil {
		return m.BlockId
	}
	return nil
}

func (m *DeleteNode) GetMask() string {
	if m != nil {
		return m.Mask
	}
	return ""
}

func (m *DeleteNode) GetCommitTs() *timestamp.Timestamp {
	if m != nil {
		return m.CommitTs
	}
	return nil
}

type ColumnID struct {
	BlockId              *BlockID `protobuf:"bytes,1,opt,name=block_id,json=blockId,proto3" json:"block_id,omitempty"`
	ColIndex             uint32   `protobuf:"varint,2,opt,name=col_index,json=colIndex,proto3" json:"col_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ColumnID) Reset()         { *m = ColumnID{} }
func (m *ColumnID) String() string { return proto.CompactTextString(m) }
func (*ColumnID) ProtoMessage()    {}
func (*ColumnID) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{29}
}
func (m *ColumnID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColumnID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColumnID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnID.Merge(m, src)
}
func (m *ColumnID) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ColumnID) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnID.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnID proto.InternalMessageInfo

func (m *ColumnID) GetBlockId() *BlockID {
	if m != nil {
		return m.BlockId
	}
	return nil
}

func (m *ColumnID) GetColIndex() uint32 {
	if m != nil {
		return m.ColIndex
	}
	return 0
}

type ColunmUpdateNode struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ColunmUpdateNode) Reset()         { *m = ColunmUpdateNode{} }
func (m *ColunmUpdateNode) String() string { return proto.CompactTextString(m) }
func (*ColunmUpdateNode) ProtoMessage()    {}
func (*ColunmUpdateNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{30}
}
func (m *ColunmUpdateNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColunmUpdateNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColunmUpdateNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColunmUpdateNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColunmUpdateNode.Merge(m, src)
}
func (m *ColunmUpdateNode) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ColunmUpdateNode) XXX_DiscardUnknown() {
	xxx_messageInfo_ColunmUpdateNode.DiscardUnknown(m)
}

var xxx_messageInfo_ColunmUpdateNode proto.InternalMessageInfo

// update the mvcc info for a block
type MvccUpdateCmd struct {
	//CmdMvccUpdate
	CmdType CmdType  `protobuf:"varint,1,opt,name=cmd_type,json=cmdType,proto3,enum=api.CmdType" json:"cmd_type,omitempty"`
	Csn     uint32   `protobuf:"varint,2,opt,name=csn,proto3" json:"csn,omitempty"`
	DbId    uint64   `protobuf:"varint,3,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	BlockId *BlockID `protobuf:"bytes,4,opt,name=block_id,json=blockId,proto3" json:"block_id,omitempty"`
	//bitmap
	//uint32  mask = 4;
	//AppendNode append = 5;
	//DeleteNode del = 6;
	// ColumnUpdateNode update = 7;
	MvccNode             []*MvccUpdateCmd_MvccNodeType `protobuf:"bytes,5,rep,name=mvcc_node,json=mvccNode,proto3" json:"mvcc_node,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *MvccUpdateCmd) Reset()         { *m = MvccUpdateCmd{} }
func (m *MvccUpdateCmd) String() string { return proto.CompactTextString(m) }
func (*MvccUpdateCmd) ProtoMessage()    {}
func (*MvccUpdateCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{31}
}
func (m *MvccUpdateCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MvccUpdateCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MvccUpdateCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MvccUpdateCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MvccUpdateCmd.Merge(m, src)
}
func (m *MvccUpdateCmd) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MvccUpdateCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_MvccUpdateCmd.DiscardUnknown(m)
}

var xxx_messageInfo_MvccUpdateCmd proto.InternalMessageInfo

func (m *MvccUpdateCmd) GetCmdType() CmdType {
	if m != nil {
		return m.CmdType
	}
	return CmdType_CmdBatch
}

func (m *MvccUpdateCmd) GetCsn() uint32 {
	if m != nil {
		return m.Csn
	}
	return 0
}

func (m *MvccUpdateCmd) GetDbId() uint64 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *MvccUpdateCmd) GetBlockId() *BlockID {
	if m != nil {
		return m.BlockId
	}
	return nil
}

func (m *MvccUpdateCmd) GetMvccNode() []*MvccUpdateCmd_MvccNodeType {
	if m != nil {
		return m.MvccNode
	}
	return nil
}

type MvccUpdateCmd_MvccNodeType struct {
	// Types that are valid to be assigned to Def:
	//	*MvccUpdateCmd_MvccNodeType_AppendNode
	//	*MvccUpdateCmd_MvccNodeType_DeleteNode
	Def                  isMvccUpdateCmd_MvccNodeType_Def `protobuf_oneof:"def"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *MvccUpdateCmd_MvccNodeType) Reset()         { *m = MvccUpdateCmd_MvccNodeType{} }
func (m *MvccUpdateCmd_MvccNodeType) String() string { return proto.CompactTextString(m) }
func (*MvccUpdateCmd_MvccNodeType) ProtoMessage()    {}
func (*MvccUpdateCmd_MvccNodeType) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{31, 0}
}
func (m *MvccUpdateCmd_MvccNodeType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MvccUpdateCmd_MvccNodeType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MvccUpdateCmd_MvccNodeType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MvccUpdateCmd_MvccNodeType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MvccUpdateCmd_MvccNodeType.Merge(m, src)
}
func (m *MvccUpdateCmd_MvccNodeType) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MvccUpdateCmd_MvccNodeType) XXX_DiscardUnknown() {
	xxx_messageInfo_MvccUpdateCmd_MvccNodeType.DiscardUnknown(m)
}

var xxx_messageInfo_MvccUpdateCmd_MvccNodeType proto.InternalMessageInfo

type isMvccUpdateCmd_MvccNodeType_Def interface {
	isMvccUpdateCmd_MvccNodeType_Def()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type MvccUpdateCmd_MvccNodeType_AppendNode struct {
	AppendNode *AppendNode `protobuf:"bytes,1,opt,name=append_node,json=appendNode,proto3,oneof" json:"append_node,omitempty"`
}
type MvccUpdateCmd_MvccNodeType_DeleteNode struct {
	DeleteNode *DeleteNode `protobuf:"bytes,2,opt,name=delete_node,json=deleteNode,proto3,oneof" json:"delete_node,omitempty"`
}

func (*MvccUpdateCmd_MvccNodeType_AppendNode) isMvccUpdateCmd_MvccNodeType_Def() {}
func (*MvccUpdateCmd_MvccNodeType_DeleteNode) isMvccUpdateCmd_MvccNodeType_Def() {}

func (m *MvccUpdateCmd_MvccNodeType) GetDef() isMvccUpdateCmd_MvccNodeType_Def {
	if m != nil {
		return m.Def
	}
	return nil
}

func (m *MvccUpdateCmd_MvccNodeType) GetAppendNode() *AppendNode {
	if x, ok := m.GetDef().(*MvccUpdateCmd_MvccNodeType_AppendNode); ok {
		return x.AppendNode
	}
	return nil
}

func (m *MvccUpdateCmd_MvccNodeType) GetDeleteNode() *DeleteNode {
	if x, ok := m.GetDef().(*MvccUpdateCmd_MvccNodeType_DeleteNode); ok {
		return x.DeleteNode
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MvccUpdateCmd_MvccNodeType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MvccUpdateCmd_MvccNodeType_AppendNode)(nil),
		(*MvccUpdateCmd_MvccNodeType_DeleteNode)(nil),
	}
}

// FIXME::need to slim down ?
type UpdateNode struct {
	CreatedAt            *timestamp.Timestamp `protobuf:"bytes,1,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	DeletedAt            *timestamp.Timestamp `protobuf:"bytes,2,opt,name=deleted_at,json=deletedAt,proto3" json:"deleted_at,omitempty"`
	MetaLoc              string               `protobuf:"bytes,3,opt,name=meta_loc,json=metaLoc,proto3" json:"meta_loc,omitempty"`
	DeltaLoc             string               `protobuf:"bytes,4,opt,name=delta_loc,json=deltaLoc,proto3" json:"delta_loc,omitempty"`
	Start                *timestamp.Timestamp `protobuf:"bytes,5,opt,name=start,proto3" json:"start,omitempty"`
	End                  *timestamp.Timestamp `protobuf:"bytes,6,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *UpdateNode) Reset()         { *m = UpdateNode{} }
func (m *UpdateNode) String() string { return proto.CompactTextString(m) }
func (*UpdateNode) ProtoMessage()    {}
func (*UpdateNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{32}
}
func (m *UpdateNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateNode.Merge(m, src)
}
func (m *UpdateNode) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UpdateNode) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateNode.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateNode proto.InternalMessageInfo

func (m *UpdateNode) GetCreatedAt() *timestamp.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *UpdateNode) GetDeletedAt() *timestamp.Timestamp {
	if m != nil {
		return m.DeletedAt
	}
	return nil
}

func (m *UpdateNode) GetMetaLoc() string {
	if m != nil {
		return m.MetaLoc
	}
	return ""
}

func (m *UpdateNode) GetDeltaLoc() string {
	if m != nil {
		return m.DeltaLoc
	}
	return ""
}

func (m *UpdateNode) GetStart() *timestamp.Timestamp {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *UpdateNode) GetEnd() *timestamp.Timestamp {
	if m != nil {
		return m.End
	}
	return nil
}

type BaseEntry struct {
	Node                 *UpdateNode `protobuf:"bytes,1,opt,name=node,proto3" json:"node,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *BaseEntry) Reset()         { *m = BaseEntry{} }
func (m *BaseEntry) String() string { return proto.CompactTextString(m) }
func (*BaseEntry) ProtoMessage()    {}
func (*BaseEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{33}
}
func (m *BaseEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BaseEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BaseEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BaseEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BaseEntry.Merge(m, src)
}
func (m *BaseEntry) XXX_Size() int {
	return m.ProtoSize()
}
func (m *BaseEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_BaseEntry.DiscardUnknown(m)
}

var xxx_messageInfo_BaseEntry proto.InternalMessageInfo

func (m *BaseEntry) GetNode() *UpdateNode {
	if m != nil {
		return m.Node
	}
	return nil
}

type BlockEntry struct {
	Be                   *BaseEntry `protobuf:"bytes,1,opt,name=be,proto3" json:"be,omitempty"`
	BlockId              *BlockID   `protobuf:"bytes,2,opt,name=block_id,json=blockId,proto3" json:"block_id,omitempty"`
	BlockState           EntryState `protobuf:"varint,3,opt,name=block_state,json=blockState,proto3,enum=api.EntryState" json:"block_state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *BlockEntry) Reset()         { *m = BlockEntry{} }
func (m *BlockEntry) String() string { return proto.CompactTextString(m) }
func (*BlockEntry) ProtoMessage()    {}
func (*BlockEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{34}
}
func (m *BlockEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockEntry.Merge(m, src)
}
func (m *BlockEntry) XXX_Size() int {
	return m.ProtoSize()
}
func (m *BlockEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockEntry.DiscardUnknown(m)
}

var xxx_messageInfo_BlockEntry proto.InternalMessageInfo

func (m *BlockEntry) GetBe() *BaseEntry {
	if m != nil {
		return m.Be
	}
	return nil
}

func (m *BlockEntry) GetBlockId() *BlockID {
	if m != nil {
		return m.BlockId
	}
	return nil
}

func (m *BlockEntry) GetBlockState() EntryState {
	if m != nil {
		return m.BlockState
	}
	return EntryState_ES_Appendable
}

type SegmentEntry struct {
	Be                   *BaseEntry `protobuf:"bytes,1,opt,name=be,proto3" json:"be,omitempty"`
	SegId                *SegmentID `protobuf:"bytes,2,opt,name=seg_id,json=segId,proto3" json:"seg_id,omitempty"`
	SegState             EntryState `protobuf:"varint,3,opt,name=seg_state,json=segState,proto3,enum=api.EntryState" json:"seg_state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *SegmentEntry) Reset()         { *m = SegmentEntry{} }
func (m *SegmentEntry) String() string { return proto.CompactTextString(m) }
func (*SegmentEntry) ProtoMessage()    {}
func (*SegmentEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{35}
}
func (m *SegmentEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SegmentEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SegmentEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SegmentEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SegmentEntry.Merge(m, src)
}
func (m *SegmentEntry) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SegmentEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_SegmentEntry.DiscardUnknown(m)
}

var xxx_messageInfo_SegmentEntry proto.InternalMessageInfo

func (m *SegmentEntry) GetBe() *BaseEntry {
	if m != nil {
		return m.Be
	}
	return nil
}

func (m *SegmentEntry) GetSegId() *SegmentID {
	if m != nil {
		return m.SegId
	}
	return nil
}

func (m *SegmentEntry) GetSegState() EntryState {
	if m != nil {
		return m.SegState
	}
	return EntryState_ES_Appendable
}

type TableEntry struct {
	Be                   *BaseEntry `protobuf:"bytes,1,opt,name=be,proto3" json:"be,omitempty"`
	TabId                *TableID   `protobuf:"bytes,2,opt,name=tab_id,json=tabId,proto3" json:"tab_id,omitempty"`
	TabDef               *TableDef  `protobuf:"bytes,3,opt,name=tab_def,json=tabDef,proto3" json:"tab_def,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *TableEntry) Reset()         { *m = TableEntry{} }
func (m *TableEntry) String() string { return proto.CompactTextString(m) }
func (*TableEntry) ProtoMessage()    {}
func (*TableEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{36}
}
func (m *TableEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableEntry.Merge(m, src)
}
func (m *TableEntry) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_TableEntry.DiscardUnknown(m)
}

var xxx_messageInfo_TableEntry proto.InternalMessageInfo

func (m *TableEntry) GetBe() *BaseEntry {
	if m != nil {
		return m.Be
	}
	return nil
}

func (m *TableEntry) GetTabId() *TableID {
	if m != nil {
		return m.TabId
	}
	return nil
}

func (m *TableEntry) GetTabDef() *TableDef {
	if m != nil {
		return m.TabDef
	}
	return nil
}

type DatabaseEntry struct {
	Be                   *BaseEntry  `protobuf:"bytes,1,opt,name=be,proto3" json:"be,omitempty"`
	Name                 string      `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	DbId                 *DatabaseID `protobuf:"bytes,3,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	AcInfo               *AccessInfo `protobuf:"bytes,4,opt,name=ac_info,json=acInfo,proto3" json:"ac_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *DatabaseEntry) Reset()         { *m = DatabaseEntry{} }
func (m *DatabaseEntry) String() string { return proto.CompactTextString(m) }
func (*DatabaseEntry) ProtoMessage()    {}
func (*DatabaseEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{37}
}
func (m *DatabaseEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseEntry.Merge(m, src)
}
func (m *DatabaseEntry) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DatabaseEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseEntry.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseEntry proto.InternalMessageInfo

func (m *DatabaseEntry) GetBe() *BaseEntry {
	if m != nil {
		return m.Be
	}
	return nil
}

func (m *DatabaseEntry) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DatabaseEntry) GetDbId() *DatabaseID {
	if m != nil {
		return m.DbId
	}
	return nil
}

func (m *DatabaseEntry) GetAcInfo() *AccessInfo {
	if m != nil {
		return m.AcInfo
	}
	return nil
}

type EntryCmd struct {
	//CmdMetaEntry
	CmdType CmdType `protobuf:"varint,1,opt,name=cmd_type,json=cmdType,proto3,enum=api.CmdType" json:"cmd_type,omitempty"`
	Csn     uint32  `protobuf:"varint,2,opt,name=csn,proto3" json:"csn,omitempty"`
	//bitmask
	//uint32 mask = 2;
	Entry                *EntryCmd_EntryType `protobuf:"bytes,3,opt,name=entry,proto3" json:"entry,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *EntryCmd) Reset()         { *m = EntryCmd{} }
func (m *EntryCmd) String() string { return proto.CompactTextString(m) }
func (*EntryCmd) ProtoMessage()    {}
func (*EntryCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{38}
}
func (m *EntryCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntryCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntryCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EntryCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntryCmd.Merge(m, src)
}
func (m *EntryCmd) XXX_Size() int {
	return m.ProtoSize()
}
func (m *EntryCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_EntryCmd.DiscardUnknown(m)
}

var xxx_messageInfo_EntryCmd proto.InternalMessageInfo

func (m *EntryCmd) GetCmdType() CmdType {
	if m != nil {
		return m.CmdType
	}
	return CmdType_CmdBatch
}

func (m *EntryCmd) GetCsn() uint32 {
	if m != nil {
		return m.Csn
	}
	return 0
}

func (m *EntryCmd) GetEntry() *EntryCmd_EntryType {
	if m != nil {
		return m.Entry
	}
	return nil
}

type EntryCmd_EntryType struct {
	// Types that are valid to be assigned to Def:
	//	*EntryCmd_EntryType_BlockEntry
	//	*EntryCmd_EntryType_SegEntry
	//	*EntryCmd_EntryType_TabEntry
	//	*EntryCmd_EntryType_DbEntry
	Def                  isEntryCmd_EntryType_Def `protobuf_oneof:"def"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *EntryCmd_EntryType) Reset()         { *m = EntryCmd_EntryType{} }
func (m *EntryCmd_EntryType) String() string { return proto.CompactTextString(m) }
func (*EntryCmd_EntryType) ProtoMessage()    {}
func (*EntryCmd_EntryType) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{38, 0}
}
func (m *EntryCmd_EntryType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntryCmd_EntryType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntryCmd_EntryType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EntryCmd_EntryType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntryCmd_EntryType.Merge(m, src)
}
func (m *EntryCmd_EntryType) XXX_Size() int {
	return m.ProtoSize()
}
func (m *EntryCmd_EntryType) XXX_DiscardUnknown() {
	xxx_messageInfo_EntryCmd_EntryType.DiscardUnknown(m)
}

var xxx_messageInfo_EntryCmd_EntryType proto.InternalMessageInfo

type isEntryCmd_EntryType_Def interface {
	isEntryCmd_EntryType_Def()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type EntryCmd_EntryType_BlockEntry struct {
	BlockEntry *BlockEntry `protobuf:"bytes,1,opt,name=block_entry,json=blockEntry,proto3,oneof" json:"block_entry,omitempty"`
}
type EntryCmd_EntryType_SegEntry struct {
	SegEntry *SegmentEntry `protobuf:"bytes,2,opt,name=seg_entry,json=segEntry,proto3,oneof" json:"seg_entry,omitempty"`
}
type EntryCmd_EntryType_TabEntry struct {
	TabEntry *TableEntry `protobuf:"bytes,3,opt,name=tab_entry,json=tabEntry,proto3,oneof" json:"tab_entry,omitempty"`
}
type EntryCmd_EntryType_DbEntry struct {
	DbEntry *DatabaseEntry `protobuf:"bytes,4,opt,name=db_entry,json=dbEntry,proto3,oneof" json:"db_entry,omitempty"`
}

func (*EntryCmd_EntryType_BlockEntry) isEntryCmd_EntryType_Def() {}
func (*EntryCmd_EntryType_SegEntry) isEntryCmd_EntryType_Def()   {}
func (*EntryCmd_EntryType_TabEntry) isEntryCmd_EntryType_Def()   {}
func (*EntryCmd_EntryType_DbEntry) isEntryCmd_EntryType_Def()    {}

func (m *EntryCmd_EntryType) GetDef() isEntryCmd_EntryType_Def {
	if m != nil {
		return m.Def
	}
	return nil
}

func (m *EntryCmd_EntryType) GetBlockEntry() *BlockEntry {
	if x, ok := m.GetDef().(*EntryCmd_EntryType_BlockEntry); ok {
		return x.BlockEntry
	}
	return nil
}

func (m *EntryCmd_EntryType) GetSegEntry() *SegmentEntry {
	if x, ok := m.GetDef().(*EntryCmd_EntryType_SegEntry); ok {
		return x.SegEntry
	}
	return nil
}

func (m *EntryCmd_EntryType) GetTabEntry() *TableEntry {
	if x, ok := m.GetDef().(*EntryCmd_EntryType_TabEntry); ok {
		return x.TabEntry
	}
	return nil
}

func (m *EntryCmd_EntryType) GetDbEntry() *DatabaseEntry {
	if x, ok := m.GetDef().(*EntryCmd_EntryType_DbEntry); ok {
		return x.DbEntry
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*EntryCmd_EntryType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*EntryCmd_EntryType_BlockEntry)(nil),
		(*EntryCmd_EntryType_SegEntry)(nil),
		(*EntryCmd_EntryType_TabEntry)(nil),
		(*EntryCmd_EntryType_DbEntry)(nil),
	}
}

// commands for compaction and merge
type CompactBlockCmd struct {
	CmdType              CmdType  `protobuf:"varint,1,opt,name=cmd_type,json=cmdType,proto3,enum=api.CmdType" json:"cmd_type,omitempty"`
	Csn                  uint32   `protobuf:"varint,2,opt,name=csn,proto3" json:"csn,omitempty"`
	From                 *BlockID `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
	To                   *BlockID `protobuf:"bytes,4,opt,name=to,proto3" json:"to,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CompactBlockCmd) Reset()         { *m = CompactBlockCmd{} }
func (m *CompactBlockCmd) String() string { return proto.CompactTextString(m) }
func (*CompactBlockCmd) ProtoMessage()    {}
func (*CompactBlockCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{39}
}
func (m *CompactBlockCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactBlockCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactBlockCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactBlockCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactBlockCmd.Merge(m, src)
}
func (m *CompactBlockCmd) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CompactBlockCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactBlockCmd.DiscardUnknown(m)
}

var xxx_messageInfo_CompactBlockCmd proto.InternalMessageInfo

func (m *CompactBlockCmd) GetCmdType() CmdType {
	if m != nil {
		return m.CmdType
	}
	return CmdType_CmdBatch
}

func (m *CompactBlockCmd) GetCsn() uint32 {
	if m != nil {
		return m.Csn
	}
	return 0
}

func (m *CompactBlockCmd) GetFrom() *BlockID {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *CompactBlockCmd) GetTo() *BlockID {
	if m != nil {
		return m.To
	}
	return nil
}

type MergeBlocksCmd struct {
	CmdType CmdType `protobuf:"varint,1,opt,name=cmd_type,json=cmdType,proto3,enum=api.CmdType" json:"cmd_type,omitempty"`
	Csn     uint32  `protobuf:"varint,2,opt,name=csn,proto3" json:"csn,omitempty"`
	//[]SegmentID
	DroppedSegs []*SegmentID `protobuf:"bytes,3,rep,name=dropped_segs,json=droppedSegs,proto3" json:"dropped_segs,omitempty"`
	CreatedSegs []*SegmentID `protobuf:"bytes,4,rep,name=created_segs,json=createdSegs,proto3" json:"created_segs,omitempty"`
	DroppedBlks []*BlockID   `protobuf:"bytes,5,rep,name=dropped_blks,json=droppedBlks,proto3" json:"dropped_blks,omitempty"`
	CreatedBlks []*BlockID   `protobuf:"bytes,6,rep,name=created_blks,json=createdBlks,proto3" json:"created_blks,omitempty"`
	//[]uint32
	Mapping              []uint32 `protobuf:"varint,7,rep,packed,name=mapping,proto3" json:"mapping,omitempty"`
	FromAddr             []uint32 `protobuf:"varint,8,rep,packed,name=from_addr,json=fromAddr,proto3" json:"from_addr,omitempty"`
	ToAddr               []uint32 `protobuf:"varint,9,rep,packed,name=to_addr,json=toAddr,proto3" json:"to_addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MergeBlocksCmd) Reset()         { *m = MergeBlocksCmd{} }
func (m *MergeBlocksCmd) String() string { return proto.CompactTextString(m) }
func (*MergeBlocksCmd) ProtoMessage()    {}
func (*MergeBlocksCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{40}
}
func (m *MergeBlocksCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MergeBlocksCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MergeBlocksCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MergeBlocksCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MergeBlocksCmd.Merge(m, src)
}
func (m *MergeBlocksCmd) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MergeBlocksCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_MergeBlocksCmd.DiscardUnknown(m)
}

var xxx_messageInfo_MergeBlocksCmd proto.InternalMessageInfo

func (m *MergeBlocksCmd) GetCmdType() CmdType {
	if m != nil {
		return m.CmdType
	}
	return CmdType_CmdBatch
}

func (m *MergeBlocksCmd) GetCsn() uint32 {
	if m != nil {
		return m.Csn
	}
	return 0
}

func (m *MergeBlocksCmd) GetDroppedSegs() []*SegmentID {
	if m != nil {
		return m.DroppedSegs
	}
	return nil
}

func (m *MergeBlocksCmd) GetCreatedSegs() []*SegmentID {
	if m != nil {
		return m.CreatedSegs
	}
	return nil
}

func (m *MergeBlocksCmd) GetDroppedBlks() []*BlockID {
	if m != nil {
		return m.DroppedBlks
	}
	return nil
}

func (m *MergeBlocksCmd) GetCreatedBlks() []*BlockID {
	if m != nil {
		return m.CreatedBlks
	}
	return nil
}

func (m *MergeBlocksCmd) GetMapping() []uint32 {
	if m != nil {
		return m.Mapping
	}
	return nil
}

func (m *MergeBlocksCmd) GetFromAddr() []uint32 {
	if m != nil {
		return m.FromAddr
	}
	return nil
}

func (m *MergeBlocksCmd) GetToAddr() []uint32 {
	if m != nil {
		return m.ToAddr
	}
	return nil
}

type ComposedCmd struct {
	//CmdComposed
	CmdType CmdType `protobuf:"varint,1,opt,name=cmd_type,json=cmdType,proto3,enum=api.CmdType" json:"cmd_type,omitempty"`
	// Notice: 1. LSN is the Log sequence number of redo-log entry for one transaction.
	//         2. a redo-log entry is also a composed command ,it contains multiple sub commands.
	LSN                  uint32                    `protobuf:"varint,2,opt,name=LSN,proto3" json:"LSN,omitempty"`
	Cmds                 []*ComposedCmd_SubCmdType `protobuf:"bytes,3,rep,name=cmds,proto3" json:"cmds,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *ComposedCmd) Reset()         { *m = ComposedCmd{} }
func (m *ComposedCmd) String() string { return proto.CompactTextString(m) }
func (*ComposedCmd) ProtoMessage()    {}
func (*ComposedCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{41}
}
func (m *ComposedCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComposedCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComposedCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComposedCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComposedCmd.Merge(m, src)
}
func (m *ComposedCmd) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ComposedCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_ComposedCmd.DiscardUnknown(m)
}

var xxx_messageInfo_ComposedCmd proto.InternalMessageInfo

func (m *ComposedCmd) GetCmdType() CmdType {
	if m != nil {
		return m.CmdType
	}
	return CmdType_CmdBatch
}

func (m *ComposedCmd) GetLSN() uint32 {
	if m != nil {
		return m.LSN
	}
	return 0
}

func (m *ComposedCmd) GetCmds() []*ComposedCmd_SubCmdType {
	if m != nil {
		return m.Cmds
	}
	return nil
}

type ComposedCmd_SubCmdType struct {
	// Types that are valid to be assigned to Def:
	//	*ComposedCmd_SubCmdType_EntryCmd
	//	*ComposedCmd_SubCmdType_AppendCmd
	//	*ComposedCmd_SubCmdType_MvccCmd
	//	*ComposedCmd_SubCmdType_CompactCmd
	//	*ComposedCmd_SubCmdType_MergeblksCmd
	Def                  isComposedCmd_SubCmdType_Def `protobuf_oneof:"def"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *ComposedCmd_SubCmdType) Reset()         { *m = ComposedCmd_SubCmdType{} }
func (m *ComposedCmd_SubCmdType) String() string { return proto.CompactTextString(m) }
func (*ComposedCmd_SubCmdType) ProtoMessage()    {}
func (*ComposedCmd_SubCmdType) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{41, 0}
}
func (m *ComposedCmd_SubCmdType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComposedCmd_SubCmdType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComposedCmd_SubCmdType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComposedCmd_SubCmdType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComposedCmd_SubCmdType.Merge(m, src)
}
func (m *ComposedCmd_SubCmdType) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ComposedCmd_SubCmdType) XXX_DiscardUnknown() {
	xxx_messageInfo_ComposedCmd_SubCmdType.DiscardUnknown(m)
}

var xxx_messageInfo_ComposedCmd_SubCmdType proto.InternalMessageInfo

type isComposedCmd_SubCmdType_Def interface {
	isComposedCmd_SubCmdType_Def()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type ComposedCmd_SubCmdType_EntryCmd struct {
	EntryCmd *EntryCmd `protobuf:"bytes,1,opt,name=entry_cmd,json=entryCmd,proto3,oneof" json:"entry_cmd,omitempty"`
}
type ComposedCmd_SubCmdType_AppendCmd struct {
	AppendCmd *AppendCmd `protobuf:"bytes,2,opt,name=append_cmd,json=appendCmd,proto3,oneof" json:"append_cmd,omitempty"`
}
type ComposedCmd_SubCmdType_MvccCmd struct {
	MvccCmd *MvccUpdateCmd `protobuf:"bytes,3,opt,name=mvcc_cmd,json=mvccCmd,proto3,oneof" json:"mvcc_cmd,omitempty"`
}
type ComposedCmd_SubCmdType_CompactCmd struct {
	CompactCmd *CompactBlockCmd `protobuf:"bytes,4,opt,name=compact_cmd,json=compactCmd,proto3,oneof" json:"compact_cmd,omitempty"`
}
type ComposedCmd_SubCmdType_MergeblksCmd struct {
	MergeblksCmd *MergeBlocksCmd `protobuf:"bytes,5,opt,name=mergeblks_cmd,json=mergeblksCmd,proto3,oneof" json:"mergeblks_cmd,omitempty"`
}

func (*ComposedCmd_SubCmdType_EntryCmd) isComposedCmd_SubCmdType_Def()     {}
func (*ComposedCmd_SubCmdType_AppendCmd) isComposedCmd_SubCmdType_Def()    {}
func (*ComposedCmd_SubCmdType_MvccCmd) isComposedCmd_SubCmdType_Def()      {}
func (*ComposedCmd_SubCmdType_CompactCmd) isComposedCmd_SubCmdType_Def()   {}
func (*ComposedCmd_SubCmdType_MergeblksCmd) isComposedCmd_SubCmdType_Def() {}

func (m *ComposedCmd_SubCmdType) GetDef() isComposedCmd_SubCmdType_Def {
	if m != nil {
		return m.Def
	}
	return nil
}

func (m *ComposedCmd_SubCmdType) GetEntryCmd() *EntryCmd {
	if x, ok := m.GetDef().(*ComposedCmd_SubCmdType_EntryCmd); ok {
		return x.EntryCmd
	}
	return nil
}

func (m *ComposedCmd_SubCmdType) GetAppendCmd() *AppendCmd {
	if x, ok := m.GetDef().(*ComposedCmd_SubCmdType_AppendCmd); ok {
		return x.AppendCmd
	}
	return nil
}

func (m *ComposedCmd_SubCmdType) GetMvccCmd() *MvccUpdateCmd {
	if x, ok := m.GetDef().(*ComposedCmd_SubCmdType_MvccCmd); ok {
		return x.MvccCmd
	}
	return nil
}

func (m *ComposedCmd_SubCmdType) GetCompactCmd() *CompactBlockCmd {
	if x, ok := m.GetDef().(*ComposedCmd_SubCmdType_CompactCmd); ok {
		return x.CompactCmd
	}
	return nil
}

func (m *ComposedCmd_SubCmdType) GetMergeblksCmd() *MergeBlocksCmd {
	if x, ok := m.GetDef().(*ComposedCmd_SubCmdType_MergeblksCmd); ok {
		return x.MergeblksCmd
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ComposedCmd_SubCmdType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ComposedCmd_SubCmdType_EntryCmd)(nil),
		(*ComposedCmd_SubCmdType_AppendCmd)(nil),
		(*ComposedCmd_SubCmdType_MvccCmd)(nil),
		(*ComposedCmd_SubCmdType_CompactCmd)(nil),
		(*ComposedCmd_SubCmdType_MergeblksCmd)(nil),
	}
}

type BatchCommands struct {
	Desc  *TSRange   `protobuf:"bytes,1,opt,name=desc,proto3" json:"desc,omitempty"`
	Scope *ScopeDesc `protobuf:"bytes,2,opt,name=scope,proto3" json:"scope,omitempty"`
	//[]composedCmd
	//FIXME::the order of the ComposedCmd? use lsn ?
	Commands             []*ComposedCmd `protobuf:"bytes,3,rep,name=commands,proto3" json:"commands,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *BatchCommands) Reset()         { *m = BatchCommands{} }
func (m *BatchCommands) String() string { return proto.CompactTextString(m) }
func (*BatchCommands) ProtoMessage()    {}
func (*BatchCommands) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{42}
}
func (m *BatchCommands) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchCommands) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchCommands.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchCommands) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchCommands.Merge(m, src)
}
func (m *BatchCommands) XXX_Size() int {
	return m.ProtoSize()
}
func (m *BatchCommands) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchCommands.DiscardUnknown(m)
}

var xxx_messageInfo_BatchCommands proto.InternalMessageInfo

func (m *BatchCommands) GetDesc() *TSRange {
	if m != nil {
		return m.Desc
	}
	return nil
}

func (m *BatchCommands) GetScope() *ScopeDesc {
	if m != nil {
		return m.Scope
	}
	return nil
}

func (m *BatchCommands) GetCommands() []*ComposedCmd {
	if m != nil {
		return m.Commands
	}
	return nil
}

type SyncLogTailResp struct {
	//FIXME::??
	CheckpointTs *timestamp.Timestamp `protobuf:"bytes,1,opt,name=checkpoint_ts,json=checkpointTs,proto3" json:"checkpoint_ts,omitempty"`
	//[]Timestamp
	NewCheckpoints       []*timestamp.Timestamp `protobuf:"bytes,2,rep,name=new_checkpoints,json=newCheckpoints,proto3" json:"new_checkpoints,omitempty"`
	Commands             *BatchCommands         `protobuf:"bytes,3,opt,name=commands,proto3" json:"commands,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *SyncLogTailResp) Reset()         { *m = SyncLogTailResp{} }
func (m *SyncLogTailResp) String() string { return proto.CompactTextString(m) }
func (*SyncLogTailResp) ProtoMessage()    {}
func (*SyncLogTailResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{43}
}
func (m *SyncLogTailResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncLogTailResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncLogTailResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncLogTailResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncLogTailResp.Merge(m, src)
}
func (m *SyncLogTailResp) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SyncLogTailResp) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncLogTailResp.DiscardUnknown(m)
}

var xxx_messageInfo_SyncLogTailResp proto.InternalMessageInfo

func (m *SyncLogTailResp) GetCheckpointTs() *timestamp.Timestamp {
	if m != nil {
		return m.CheckpointTs
	}
	return nil
}

func (m *SyncLogTailResp) GetNewCheckpoints() []*timestamp.Timestamp {
	if m != nil {
		return m.NewCheckpoints
	}
	return nil
}

func (m *SyncLogTailResp) GetCommands() *BatchCommands {
	if m != nil {
		return m.Commands
	}
	return nil
}

type PrecommitWriteCmd struct {
	EntryList            []*Entry `protobuf:"bytes,1,rep,name=entry_list,json=entryList,proto3" json:"entry_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PrecommitWriteCmd) Reset()         { *m = PrecommitWriteCmd{} }
func (m *PrecommitWriteCmd) String() string { return proto.CompactTextString(m) }
func (*PrecommitWriteCmd) ProtoMessage()    {}
func (*PrecommitWriteCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{44}
}
func (m *PrecommitWriteCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrecommitWriteCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrecommitWriteCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrecommitWriteCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrecommitWriteCmd.Merge(m, src)
}
func (m *PrecommitWriteCmd) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PrecommitWriteCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_PrecommitWriteCmd.DiscardUnknown(m)
}

var xxx_messageInfo_PrecommitWriteCmd proto.InternalMessageInfo

func (m *PrecommitWriteCmd) GetEntryList() []*Entry {
	if m != nil {
		return m.EntryList
	}
	return nil
}

type Entry struct {
	EntryType            Entry_EntryType `protobuf:"varint,1,opt,name=entry_type,json=entryType,proto3,enum=api.Entry_EntryType" json:"entry_type,omitempty"`
	TableId              uint64          `protobuf:"varint,2,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	DatabaseId           uint64          `protobuf:"varint,3,opt,name=database_id,json=databaseId,proto3" json:"database_id,omitempty"`
	TableName            string          `protobuf:"bytes,4,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	DatabaseName         string          `protobuf:"bytes,5,opt,name=database_name,json=databaseName,proto3" json:"database_name,omitempty"`
	FileName             string          `protobuf:"bytes,6,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	BlockId              uint64          `protobuf:"varint,7,opt,name=block_id,json=blockId,proto3" json:"block_id,omitempty"`
	Block                *Batch          `protobuf:"bytes,8,opt,name=block,proto3" json:"block,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Entry) Reset()         { *m = Entry{} }
func (m *Entry) String() string { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()    {}
func (*Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_00212fb1f9d3bf1c, []int{45}
}
func (m *Entry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Entry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entry.Merge(m, src)
}
func (m *Entry) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_Entry proto.InternalMessageInfo

func (m *Entry) GetEntryType() Entry_EntryType {
	if m != nil {
		return m.EntryType
	}
	return Entry_Insert
}

func (m *Entry) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *Entry) GetDatabaseId() uint64 {
	if m != nil {
		return m.DatabaseId
	}
	return 0
}

func (m *Entry) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *Entry) GetDatabaseName() string {
	if m != nil {
		return m.DatabaseName
	}
	return ""
}

func (m *Entry) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *Entry) GetBlockId() uint64 {
	if m != nil {
		return m.BlockId
	}
	return 0
}

func (m *Entry) GetBlock() *Batch {
	if m != nil {
		return m.Block
	}
	return nil
}

func init() {
	proto.RegisterEnum("api.TypeID", TypeID_name, TypeID_value)
	proto.RegisterEnum("api.CmdType", CmdType_name, CmdType_value)
	proto.RegisterEnum("api.EntryState", EntryState_name, EntryState_value)
	proto.RegisterEnum("api.Entry_EntryType", Entry_EntryType_name, Entry_EntryType_value)
	proto.RegisterType((*Type)(nil), "api.Type")
	proto.RegisterType((*DBInfo)(nil), "api.DBInfo")
	proto.RegisterType((*DatabaseCmd)(nil), "api.DatabaseCmd")
	proto.RegisterMapType((map[uint64]*TableCmd)(nil), "api.DatabaseCmd.TableCmdsEntry")
	proto.RegisterType((*Location)(nil), "api.Location")
	proto.RegisterType((*ZoneMap)(nil), "api.ZoneMap")
	proto.RegisterType((*ColumnMeta)(nil), "api.ColumnMeta")
	proto.RegisterType((*BlockMeta)(nil), "api.BlockMeta")
	proto.RegisterType((*BlockInfo)(nil), "api.BlockInfo")
	proto.RegisterType((*Vector)(nil), "api.Vector")
	proto.RegisterType((*AppendInfo)(nil), "api.AppendInfo")
	proto.RegisterType((*RowRange)(nil), "api.RowRange")
	proto.RegisterType((*DeleteInfo)(nil), "api.DeleteInfo")
	proto.RegisterType((*DeleteInfo_DefType)(nil), "api.DeleteInfo.DefType")
	proto.RegisterType((*BlockCmd)(nil), "api.BlockCmd")
	proto.RegisterType((*AccessInfo)(nil), "api.AccessInfo")
	proto.RegisterType((*ColDef)(nil), "api.ColDef")
	proto.RegisterType((*TableDef)(nil), "api.TableDef")
	proto.RegisterMapType((map[string]int32)(nil), "api.TableDef.NameIndexEntry")
	proto.RegisterType((*TableCmd)(nil), "api.TableCmd")
	proto.RegisterMapType((map[uint64]*BlockCmd)(nil), "api.TableCmd.BlockCmdsEntry")
	proto.RegisterType((*DatabaseID)(nil), "api.DatabaseID")
	proto.RegisterType((*TableID)(nil), "api.TableID")
	proto.RegisterType((*SegmentID)(nil), "api.SegmentID")
	proto.RegisterType((*BlockID)(nil), "api.BlockID")
	proto.RegisterType((*TSRange)(nil), "api.TSRange")
	proto.RegisterType((*ScopeDesc)(nil), "api.ScopeDesc")
	proto.RegisterType((*SyncLogTailReq)(nil), "api.SyncLogTailReq")
	proto.RegisterType((*Batch)(nil), "api.Batch")
	proto.RegisterType((*AppendCtx)(nil), "api.AppendCtx")
	proto.RegisterType((*AppendCmd)(nil), "api.AppendCmd")
	proto.RegisterType((*AppendNode)(nil), "api.AppendNode")
	proto.RegisterType((*DeleteNode)(nil), "api.DeleteNode")
	proto.RegisterType((*ColumnID)(nil), "api.ColumnID")
	proto.RegisterType((*ColunmUpdateNode)(nil), "api.ColunmUpdateNode")
	proto.RegisterType((*MvccUpdateCmd)(nil), "api.MvccUpdateCmd")
	proto.RegisterType((*MvccUpdateCmd_MvccNodeType)(nil), "api.MvccUpdateCmd.MvccNodeType")
	proto.RegisterType((*UpdateNode)(nil), "api.UpdateNode")
	proto.RegisterType((*BaseEntry)(nil), "api.BaseEntry")
	proto.RegisterType((*BlockEntry)(nil), "api.BlockEntry")
	proto.RegisterType((*SegmentEntry)(nil), "api.SegmentEntry")
	proto.RegisterType((*TableEntry)(nil), "api.TableEntry")
	proto.RegisterType((*DatabaseEntry)(nil), "api.DatabaseEntry")
	proto.RegisterType((*EntryCmd)(nil), "api.EntryCmd")
	proto.RegisterType((*EntryCmd_EntryType)(nil), "api.EntryCmd.EntryType")
	proto.RegisterType((*CompactBlockCmd)(nil), "api.CompactBlockCmd")
	proto.RegisterType((*MergeBlocksCmd)(nil), "api.MergeBlocksCmd")
	proto.RegisterType((*ComposedCmd)(nil), "api.ComposedCmd")
	proto.RegisterType((*ComposedCmd_SubCmdType)(nil), "api.ComposedCmd.SubCmdType")
	proto.RegisterType((*BatchCommands)(nil), "api.BatchCommands")
	proto.RegisterType((*SyncLogTailResp)(nil), "api.SyncLogTailResp")
	proto.RegisterType((*PrecommitWriteCmd)(nil), "api.PrecommitWriteCmd")
	proto.RegisterType((*Entry)(nil), "api.Entry")
}

func init() { proto.RegisterFile("api.proto", fileDescriptor_00212fb1f9d3bf1c) }

var fileDescriptor_00212fb1f9d3bf1c = []byte{
	// 3134 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x59, 0xcd, 0x6f, 0x1c, 0xc7,
	0xb1, 0xe7, 0xec, 0xe7, 0x4c, 0xed, 0x2e, 0x39, 0x1e, 0xd3, 0xd6, 0x8a, 0xa2, 0x24, 0x7a, 0x24,
	0xcb, 0x7a, 0x82, 0x4d, 0xda, 0x94, 0x9e, 0x9e, 0x9e, 0x3f, 0x04, 0x48, 0x4b, 0xf9, 0x69, 0x21,
	0x4a, 0xcf, 0x18, 0xf2, 0xbd, 0x87, 0xe7, 0xcb, 0xa2, 0x77, 0xa6, 0x77, 0x39, 0xe1, 0x7c, 0xac,
	0x66, 0x9a, 0x22, 0x29, 0x24, 0x97, 0x24, 0x46, 0x2e, 0x41, 0x2e, 0xce, 0x21, 0x97, 0x04, 0xbe,
	0xe5, 0x96, 0x7f, 0xc0, 0xbe, 0x06, 0x70, 0x6e, 0x06, 0x72, 0xca, 0x21, 0x40, 0x60, 0xff, 0x0d,
	0xb9, 0xe5, 0x10, 0x54, 0x75, 0xf7, 0xcc, 0xac, 0x4c, 0x11, 0x72, 0x74, 0xda, 0xae, 0xae, 0xaa,
	0xae, 0xea, 0xea, 0xea, 0xaa, 0x5f, 0xcf, 0x82, 0xc5, 0x66, 0xe1, 0xfa, 0x2c, 0x4b, 0x45, 0xea,
	0xd4, 0xd9, 0x2c, 0x5c, 0x79, 0x67, 0x1a, 0x8a, 0xbd, 0x83, 0xf1, 0xba, 0x9f, 0xc6, 0x1b, 0xd3,
	0x74, 0x9a, 0x6e, 0x10, 0x6f, 0x7c, 0x30, 0x21, 0x8a, 0x08, 0x1a, 0x49, 0x9d, 0x95, 0x25, 0x11,
	0xc6, 0x3c, 0x17, 0x2c, 0x9e, 0xa9, 0x09, 0x98, 0x45, 0x2c, 0x91, 0x63, 0xf7, 0xb7, 0x06, 0x34,
	0x76, 0x8f, 0x67, 0xdc, 0x39, 0x07, 0xb5, 0x30, 0xe8, 0x1b, 0x6b, 0xc6, 0xd5, 0xc5, 0xcd, 0xce,
	0x3a, 0x5a, 0xc4, 0xe9, 0xe1, 0x96, 0x57, 0x0b, 0x03, 0x67, 0x05, 0xcc, 0xe4, 0x20, 0x8a, 0xd8,
	0x38, 0xe2, 0xfd, 0xda, 0x9a, 0x71, 0xd5, 0xf4, 0x0a, 0xda, 0x59, 0x86, 0xe6, 0x61, 0x18, 0x88,
	0xbd, 0x7e, 0x7d, 0xcd, 0xb8, 0xda, 0xf4, 0x24, 0xe1, 0xac, 0x82, 0x35, 0xcb, 0xb8, 0x1f, 0xe6,
	0x61, 0x9a, 0xf4, 0x1b, 0xc4, 0x29, 0x27, 0x1c, 0x07, 0x1a, 0x79, 0xf8, 0x94, 0xf7, 0x9b, 0xc4,
	0xa0, 0x31, 0xae, 0x93, 0xfb, 0x2c, 0xe2, 0xfd, 0x96, 0x5c, 0x87, 0x08, 0xf7, 0x3a, 0xb4, 0xb6,
	0xee, 0x0e, 0x93, 0x49, 0x8a, 0x3a, 0x09, 0x8b, 0x39, 0xb9, 0x68, 0x79, 0x34, 0x76, 0x5e, 0x83,
	0x56, 0x98, 0x8f, 0xf2, 0xe3, 0x5c, 0x79, 0xd5, 0x0c, 0xf3, 0x9d, 0xe3, 0xdc, 0xfd, 0x87, 0x01,
	0x9d, 0x2d, 0x26, 0xd8, 0x98, 0xe5, 0x7c, 0x10, 0x07, 0xce, 0xab, 0xd0, 0x0c, 0xc6, 0x23, 0xb5,
	0xbd, 0x86, 0xd7, 0x08, 0xc6, 0xc3, 0x00, 0xd7, 0x8b, 0x59, 0xbe, 0x4f, 0x9a, 0x0d, 0x8f, 0xc6,
	0xce, 0x25, 0x68, 0xf9, 0x19, 0x67, 0x82, 0xd3, 0x66, 0x3a, 0x2a, 0x10, 0xd2, 0x01, 0x4f, 0xb1,
	0x9c, 0xdb, 0x00, 0x02, 0x77, 0x3e, 0xf2, 0xe3, 0x20, 0xef, 0x37, 0xd6, 0xea, 0x57, 0x3b, 0x9b,
	0x17, 0xa5, 0x60, 0x69, 0x73, 0x7d, 0x17, 0x45, 0x06, 0x71, 0x90, 0xdf, 0x4b, 0x44, 0x76, 0xec,
	0x59, 0x42, 0xd3, 0x68, 0x38, 0xc8, 0xd2, 0x19, 0x6d, 0xde, 0xf4, 0x68, 0xbc, 0xf2, 0x00, 0x16,
	0xe7, 0x15, 0x1c, 0x1b, 0xea, 0xfb, 0xfc, 0x58, 0x79, 0x8c, 0x43, 0xe7, 0x12, 0x34, 0x9f, 0xb0,
	0xe8, 0x40, 0x9e, 0x40, 0x67, 0xb3, 0x27, 0x0f, 0x49, 0x69, 0x79, 0x92, 0xf7, 0x7e, 0xed, 0x96,
	0xe1, 0x7e, 0x0a, 0xe6, 0x76, 0xea, 0x33, 0x81, 0x91, 0xae, 0x2c, 0x63, 0xc9, 0x65, 0x5e, 0x87,
	0x56, 0x3a, 0x99, 0xe4, 0x5c, 0xd0, 0x3a, 0x3d, 0x4f, 0x51, 0x28, 0x19, 0xf1, 0x84, 0x36, 0xde,
	0xf3, 0x70, 0x88, 0x8e, 0xa6, 0x38, 0xd5, 0xa0, 0x29, 0x1a, 0xbb, 0x13, 0x68, 0x7f, 0x9a, 0x26,
	0xfc, 0x21, 0x9b, 0x39, 0xe7, 0xa1, 0x2e, 0x8e, 0x67, 0x27, 0xa5, 0x0c, 0xce, 0x23, 0x3b, 0x0e,
	0x13, 0xe5, 0x6c, 0x67, 0x9d, 0x72, 0x6e, 0x90, 0x26, 0xb9, 0xf0, 0x70, 0x9e, 0xd8, 0xec, 0xa8,
	0x88, 0xf3, 0x1c, 0x9b, 0x1d, 0xb9, 0x5f, 0x18, 0x00, 0x83, 0x34, 0x3a, 0x88, 0x93, 0x87, 0x5c,
	0x30, 0x74, 0x2e, 0x0c, 0x8e, 0xc8, 0x56, 0xcf, 0xc3, 0xa1, 0xb3, 0x0a, 0xb5, 0xa7, 0xb1, 0x5a,
	0xbd, 0x4b, 0xc6, 0x95, 0x5f, 0x5e, 0xed, 0x69, 0xec, 0xac, 0x43, 0x67, 0x3c, 0x19, 0x45, 0x2a,
	0x0a, 0xca, 0x8a, 0x8c, 0x98, 0x0e, 0x8d, 0x07, 0xe3, 0x49, 0x11, 0xa6, 0x4d, 0xe8, 0x05, 0x4c,
	0xb0, 0x52, 0xa3, 0x71, 0x92, 0x46, 0x17, 0x65, 0x34, 0xe5, 0xde, 0x06, 0xeb, 0x6e, 0x94, 0xfa,
	0xfb, 0xe4, 0xe0, 0x79, 0x00, 0x3f, 0x8d, 0x0e, 0x92, 0x78, 0xe4, 0x27, 0x42, 0xf9, 0x69, 0xc9,
	0x99, 0x41, 0x22, 0x30, 0x94, 0x2c, 0x4a, 0xa7, 0x2a, 0xe4, 0x34, 0x76, 0x13, 0xa5, 0x4f, 0xd9,
	0xfd, 0x0e, 0xc0, 0x18, 0x89, 0x51, 0xcc, 0x05, 0x23, 0xfd, 0xce, 0xe6, 0x22, 0x59, 0x2f, 0x6c,
	0x78, 0xd6, 0xb8, 0x30, 0xb7, 0x09, 0x5d, 0x9f, 0xa2, 0x93, 0x4b, 0x85, 0x1a, 0x65, 0xe1, 0x12,
	0x29, 0x94, 0x61, 0xf3, 0x3a, 0x4a, 0x08, 0x09, 0xf7, 0xe7, 0x06, 0xb4, 0xfe, 0x97, 0xfb, 0x22,
	0xcd, 0x28, 0x05, 0x99, 0xb2, 0xd3, 0xf5, 0x68, 0xec, 0x9c, 0x87, 0x86, 0x38, 0x9e, 0xe9, 0xec,
	0xb2, 0x8a, 0xf3, 0xf4, 0x68, 0x7a, 0xae, 0x04, 0xd4, 0x9f, 0x29, 0x01, 0x36, 0xd4, 0x93, 0x7c,
	0x46, 0x31, 0xeb, 0x7a, 0x38, 0x74, 0xce, 0x82, 0x19, 0xe6, 0x23, 0x1f, 0xcf, 0x53, 0xe5, 0x79,
	0x3b, 0xcc, 0xe9, 0x78, 0xdd, 0x01, 0xc0, 0x9d, 0xd9, 0x8c, 0x27, 0x01, 0xed, 0x7b, 0x19, 0x9a,
	0x4c, 0x88, 0x2c, 0xef, 0x1b, 0x6b, 0xf5, 0xab, 0x96, 0x27, 0x09, 0xe7, 0x22, 0x34, 0x9e, 0x70,
	0x3f, 0x57, 0xdb, 0x92, 0xb9, 0x25, 0x5d, 0xf7, 0x88, 0xe1, 0x6e, 0x82, 0xe9, 0xa5, 0x87, 0x1e,
	0x4b, 0xa6, 0xb2, 0x70, 0x08, 0x96, 0xe9, 0xa8, 0x4b, 0x02, 0x7d, 0xe2, 0x49, 0xa0, 0x02, 0x8e,
	0x43, 0xf7, 0x73, 0x03, 0x60, 0x8b, 0x47, 0x5c, 0x70, 0xb2, 0x7c, 0x13, 0x20, 0x43, 0xfd, 0x51,
	0x96, 0x1e, 0xe6, 0x2a, 0xe2, 0x67, 0xe4, 0x35, 0x2e, 0x84, 0xd6, 0xb7, 0xf8, 0x84, 0x62, 0x60,
	0x91, 0xa8, 0x97, 0x1e, 0xe6, 0x2b, 0x0f, 0xa1, 0xad, 0x66, 0x9d, 0x37, 0xa1, 0x49, 0xf3, 0x4a,
	0x5b, 0x66, 0x8b, 0xf6, 0xeb, 0xfe, 0x82, 0x27, 0xb9, 0xce, 0x32, 0x34, 0xc8, 0x06, 0xfa, 0x62,
	0xdd, 0x5f, 0xf0, 0x88, 0xba, 0xdb, 0x84, 0x7a, 0xc0, 0x27, 0xee, 0x57, 0x06, 0x98, 0x74, 0xc4,
	0x58, 0xa8, 0x16, 0x8b, 0x22, 0xdc, 0xa0, 0xba, 0x5b, 0xad, 0x51, 0x3d, 0x55, 0xa3, 0xae, 0x3c,
	0x53, 0xa3, 0x2a, 0x59, 0x32, 0x57, 0xa6, 0xde, 0x82, 0x16, 0xa3, 0x38, 0xab, 0x5c, 0x96, 0xc9,
	0x51, 0x86, 0xde, 0x53, 0x6c, 0x14, 0x0c, 0x68, 0xc7, 0x74, 0x52, 0x5a, 0xb0, 0x0c, 0x82, 0xa7,
	0xd8, 0x45, 0xe1, 0x6a, 0x95, 0x85, 0xcb, 0xfd, 0x95, 0x01, 0x70, 0xc7, 0xf7, 0x79, 0x9e, 0x53,
	0x50, 0xcf, 0x81, 0x25, 0x78, 0xc2, 0x12, 0xa1, 0xab, 0x6d, 0xcf, 0x33, 0xe5, 0xc4, 0x30, 0x70,
	0xce, 0x40, 0xfb, 0x20, 0xe7, 0x19, 0xb2, 0x54, 0xe9, 0x41, 0x52, 0x32, 0xb2, 0x34, 0xe2, 0xc8,
	0x90, 0xe5, 0xa7, 0x85, 0xe4, 0x30, 0x70, 0xde, 0x03, 0x4b, 0xee, 0x66, 0xc4, 0x84, 0xda, 0xc6,
	0xf2, 0x7a, 0xd9, 0xce, 0x76, 0xf5, 0xc8, 0x33, 0xa5, 0xd8, 0x1d, 0xe1, 0xfe, 0xb5, 0x06, 0xad,
	0x41, 0x1a, 0x6d, 0xf1, 0xc9, 0x89, 0x1d, 0x43, 0x15, 0x92, 0x1a, 0xf5, 0x18, 0x2a, 0x24, 0x3a,
	0xef, 0xeb, 0x27, 0xe7, 0xfd, 0xeb, 0xd0, 0xda, 0x0b, 0x83, 0x40, 0x95, 0x41, 0xd3, 0x53, 0x14,
	0x66, 0xf8, 0x6c, 0xef, 0x78, 0xc4, 0x82, 0x20, 0xd3, 0x19, 0x3e, 0xdb, 0x3b, 0xbe, 0x13, 0x04,
	0x99, 0xf3, 0x06, 0x74, 0xf1, 0x6a, 0x8c, 0xd8, 0x38, 0x8c, 0x42, 0x71, 0xac, 0xe2, 0xd5, 0xc1,
	0xb9, 0x3b, 0x72, 0xca, 0x79, 0x13, 0x16, 0xd9, 0x81, 0x48, 0x47, 0x61, 0xe2, 0x67, 0x3c, 0xe6,
	0x89, 0xe8, 0xb7, 0x49, 0xa8, 0x87, 0xb3, 0x43, 0x3d, 0xe9, 0xf4, 0xa1, 0x3d, 0xcb, 0xc2, 0x98,
	0x65, 0xc7, 0x7d, 0x53, 0xd9, 0x90, 0x24, 0x9a, 0xcf, 0xd3, 0x0c, 0xc3, 0x7c, 0xd4, 0xb7, 0x68,
	0x33, 0x6d, 0xa4, 0x87, 0xc1, 0x51, 0xc1, 0xc2, 0xba, 0x0f, 0x52, 0x0b, 0xe9, 0x07, 0xfc, 0x18,
	0xd7, 0xf3, 0xd3, 0x98, 0xec, 0x75, 0x28, 0x28, 0x9a, 0x74, 0xde, 0x82, 0x76, 0xc0, 0x27, 0xec,
	0x20, 0x12, 0xfd, 0xae, 0x4a, 0x66, 0x2a, 0xc9, 0x5b, 0x72, 0xd2, 0xd3, 0x5c, 0xf7, 0xcf, 0x35,
	0x30, 0xa9, 0xe9, 0x60, 0x84, 0xaf, 0x42, 0x9b, 0xf9, 0xa3, 0x30, 0x99, 0xa4, 0xea, 0x0a, 0xa8,
	0x24, 0x2b, 0x12, 0xc2, 0x6b, 0x31, 0x7f, 0xae, 0x7b, 0xd7, 0x2a, 0x67, 0x71, 0x05, 0x4c, 0x3f,
	0x8d, 0xf2, 0x51, 0xc0, 0x27, 0xfd, 0x7a, 0xe5, 0xa6, 0xcb, 0xe3, 0x43, 0xdf, 0xa2, 0x1c, 0xad,
	0x7c, 0x00, 0x80, 0xf2, 0xa3, 0x30, 0x09, 0xf8, 0x91, 0x6a, 0xb8, 0xab, 0x65, 0xf7, 0xdb, 0xe2,
	0x93, 0xf5, 0x47, 0x2c, 0xe6, 0x43, 0x64, 0xab, 0x6e, 0x9b, 0x68, 0xba, 0xba, 0xe5, 0xe6, 0xfc,
	0x96, 0xcf, 0x82, 0x99, 0xf1, 0x68, 0xb4, 0x1f, 0x26, 0x01, 0x1d, 0x91, 0xe5, 0xb5, 0x33, 0x1e,
	0x3d, 0x08, 0x93, 0x80, 0xaa, 0xb9, 0xcc, 0xbb, 0xfc, 0x71, 0x44, 0x47, 0x63, 0x79, 0x2a, 0x13,
	0x77, 0x1e, 0x47, 0xb8, 0x99, 0x27, 0x21, 0x3f, 0xa4, 0x33, 0xb1, 0x3c, 0x1a, 0xaf, 0x7c, 0x08,
	0x8b, 0xf3, 0x4e, 0x9c, 0xd0, 0x7a, 0x97, 0xab, 0x1d, 0xbc, 0x59, 0x6d, 0xd9, 0x7f, 0x37, 0x54,
	0x54, 0xb1, 0x0a, 0xd8, 0x50, 0x17, 0x45, 0x19, 0xc0, 0xe1, 0x89, 0x58, 0xe5, 0xcd, 0x67, 0xea,
	0x40, 0x6f, 0x2e, 0x22, 0x45, 0x19, 0xf8, 0x40, 0x37, 0x96, 0x0a, 0x5a, 0x59, 0x9d, 0x83, 0x0e,
	0xeb, 0xba, 0xfc, 0x68, 0xa8, 0x32, 0xd6, 0xf4, 0xf3, 0xa0, 0xca, 0xbc, 0xc2, 0x8b, 0x42, 0x15,
	0xad, 0x55, 0xdd, 0xf7, 0x2a, 0x80, 0x06, 0x4d, 0xc3, 0xad, 0x67, 0xcb, 0x9f, 0xfb, 0x31, 0xb4,
	0xc9, 0xc9, 0xe1, 0x16, 0x22, 0x3d, 0xc1, 0x2a, 0x18, 0xae, 0x29, 0x18, 0x82, 0xb8, 0xcb, 0x1a,
	0xd9, 0xd5, 0xaa, 0xa5, 0xab, 0x58, 0x51, 0x42, 0x3d, 0xf7, 0xbf, 0xc0, 0xda, 0xe1, 0x53, 0x3c,
	0x74, 0xb9, 0x52, 0xce, 0xa7, 0x95, 0x95, 0x72, 0x3e, 0x1d, 0x06, 0x08, 0xfd, 0x94, 0x81, 0x2a,
	0xa6, 0x50, 0xe6, 0x95, 0x39, 0xf7, 0x01, 0xb4, 0x65, 0xa1, 0xdd, 0xc2, 0xec, 0x91, 0x71, 0x2d,
	0x16, 0x6a, 0x13, 0x3d, 0x0c, 0xf0, 0x64, 0x94, 0x85, 0x5a, 0xa5, 0x42, 0x17, 0x1e, 0x28, 0x8b,
	0xee, 0xff, 0x43, 0x7b, 0x77, 0x47, 0xb6, 0xb0, 0xab, 0xd0, 0x98, 0x64, 0x69, 0xac, 0x2e, 0xd1,
	0xc9, 0x25, 0x8e, 0x24, 0x9c, 0xcb, 0x50, 0x13, 0xa9, 0x5a, 0xf7, 0x64, 0xb9, 0x9a, 0x48, 0xdd,
	0x01, 0x58, 0x3b, 0x7e, 0x3a, 0xe3, 0x5b, 0x3c, 0xf7, 0xf1, 0x78, 0x58, 0x14, 0xd1, 0xda, 0xa6,
	0x87, 0x43, 0xe7, 0x32, 0xed, 0x35, 0xe2, 0xba, 0xc1, 0xce, 0xef, 0x55, 0xf1, 0xdc, 0xdf, 0x1b,
	0xb0, 0xb8, 0x73, 0x9c, 0xf8, 0xdb, 0xe9, 0x74, 0x97, 0x85, 0x91, 0xc7, 0x1f, 0x3b, 0xff, 0x09,
	0x3d, 0x7f, 0x8f, 0xfb, 0xfb, 0xb3, 0x34, 0x4c, 0xc4, 0x48, 0xe4, 0xa7, 0x3a, 0xdc, 0x2d, 0x45,
	0x77, 0x73, 0xc7, 0xd5, 0xbd, 0x72, 0x2e, 0xbc, 0x72, 0xff, 0xba, 0x51, 0x96, 0x7e, 0xd5, 0x9f,
	0xef, 0x97, 0xde, 0x4f, 0xa3, 0xd8, 0x8f, 0x7b, 0x1b, 0x9a, 0x77, 0x99, 0xf0, 0xf7, 0xfe, 0x55,
	0x34, 0xf1, 0x95, 0x01, 0x96, 0x6c, 0x8c, 0x03, 0x71, 0x84, 0xeb, 0xe7, 0xfc, 0xb1, 0xc6, 0x9a,
	0x39, 0x7f, 0x8c, 0xfd, 0x29, 0xcf, 0xfc, 0x51, 0x3a, 0x99, 0xe8, 0xc6, 0x95, 0x67, 0xfe, 0x7f,
	0x4f, 0x26, 0x9a, 0x51, 0xe2, 0x66, 0x64, 0x6c, 0xf3, 0xa4, 0x7c, 0x71, 0x34, 0x2a, 0x2f, 0x8e,
	0x35, 0x68, 0x04, 0x5c, 0x01, 0x22, 0xbd, 0x39, 0x95, 0x4e, 0x1e, 0x71, 0x30, 0xa9, 0xf0, 0x97,
	0x2c, 0xb5, 0x68, 0xc1, 0x36, 0xd2, 0x68, 0x4a, 0xb3, 0xd0, 0x56, 0xbb, 0x64, 0x6d, 0xf3, 0xc4,
	0xfd, 0x43, 0xe9, 0x7e, 0x8c, 0xed, 0xdc, 0xf4, 0xe3, 0x60, 0x44, 0x3d, 0x4d, 0x62, 0x73, 0x69,
	0x69, 0x10, 0x07, 0xd4, 0xd6, 0xda, 0xbe, 0x1c, 0xe0, 0x3e, 0xfd, 0x3c, 0xd1, 0x08, 0xc9, 0xcf,
	0x13, 0x67, 0x15, 0xea, 0x63, 0x26, 0x54, 0x3d, 0x01, 0xe9, 0x1f, 0xc6, 0xd5, 0xc3, 0x69, 0xc7,
	0x85, 0x86, 0x2f, 0x8e, 0x74, 0x0d, 0x59, 0xac, 0xc0, 0x89, 0x81, 0x38, 0xf2, 0x88, 0x47, 0xe9,
	0x99, 0xab, 0x0d, 0x3e, 0x2f, 0x3d, 0x73, 0xf7, 0x77, 0x86, 0xc6, 0x80, 0x8f, 0xd2, 0x00, 0x91,
	0xca, 0xfc, 0x55, 0x7a, 0x36, 0x36, 0xc5, 0xc5, 0x3a, 0x07, 0x16, 0x81, 0x3b, 0x84, 0x6c, 0xca,
	0x6f, 0x93, 0x26, 0xbc, 0xf4, 0x10, 0xcf, 0x22, 0x66, 0x47, 0xc4, 0x52, 0x67, 0x11, 0xb3, 0x23,
	0x64, 0x20, 0x88, 0x48, 0xe3, 0x38, 0xa4, 0x84, 0x3d, 0x1d, 0x44, 0x90, 0xd8, 0x6e, 0xee, 0xfe,
	0x58, 0x23, 0xc5, 0x1f, 0xe6, 0x5f, 0xb5, 0x4c, 0x5b, 0xaa, 0x4c, 0xcf, 0x59, 0xaf, 0xbf, 0x90,
	0xf5, 0x4f, 0xc0, 0x94, 0x18, 0x7e, 0xb8, 0xf5, 0x83, 0x62, 0xe3, 0xa7, 0x91, 0xea, 0x91, 0x2a,
	0x36, 0x7e, 0x1a, 0x51, 0x3f, 0x72, 0x1d, 0xb0, 0x07, 0xf4, 0x16, 0xf9, 0x9f, 0x59, 0xc0, 0xe4,
	0xae, 0xdc, 0x3f, 0xd6, 0xa0, 0xf7, 0xf0, 0x89, 0xef, 0xcb, 0xa9, 0x97, 0xcc, 0x9c, 0x22, 0xdf,
	0xeb, 0x95, 0x7c, 0xaf, 0xfa, 0xde, 0x38, 0xcd, 0xf7, 0x0f, 0xc1, 0x8a, 0x9f, 0xf8, 0xfe, 0x28,
	0x49, 0x03, 0x04, 0xa1, 0xe5, 0x83, 0x7a, 0xce, 0x3f, 0xa2, 0xd0, 0x75, 0x72, 0xc6, 0x8c, 0x15,
	0xb5, 0xf2, 0x13, 0xe8, 0x56, 0x39, 0xce, 0x26, 0x74, 0x24, 0xb2, 0x95, 0xeb, 0x19, 0xdf, 0x43,
	0xbf, 0x28, 0x79, 0x7f, 0xc1, 0x03, 0x56, 0xa6, 0xe0, 0x26, 0x74, 0x24, 0xc8, 0x95, 0x3a, 0xb5,
	0xef, 0x01, 0x61, 0xad, 0x13, 0x14, 0x94, 0x06, 0xf0, 0x3f, 0xad, 0x01, 0x94, 0x61, 0x75, 0xae,
	0x6b, 0xe8, 0x10, 0x20, 0x66, 0x3d, 0xad, 0x3e, 0x2a, 0x40, 0x11, 0xdc, 0x11, 0xa8, 0x24, 0x17,
	0x26, 0xa5, 0xd3, 0xaa, 0xbb, 0xa5, 0xe4, 0xee, 0x50, 0xb1, 0xc0, 0xb7, 0x1f, 0xbe, 0x59, 0x29,
	0xec, 0x96, 0xd7, 0x46, 0x7a, 0x3b, 0xf5, 0x31, 0x19, 0x02, 0x1e, 0x29, 0x5e, 0x83, 0x78, 0x26,
	0x4d, 0x20, 0xf3, 0x9a, 0x7e, 0x2f, 0x9d, 0x76, 0x4d, 0xd5, 0x2b, 0xea, 0x8a, 0x7c, 0x45, 0xb5,
	0x4e, 0x91, 0xa4, 0xb7, 0xd5, 0xbb, 0x60, 0xdd, 0x65, 0x39, 0x97, 0x78, 0xe0, 0x12, 0x34, 0xbe,
	0x17, 0xf9, 0x32, 0x42, 0x1e, 0x31, 0xdd, 0x5f, 0x18, 0x00, 0x94, 0x08, 0x52, 0xe7, 0x02, 0xd4,
	0xc6, 0x7c, 0xfe, 0xdd, 0xab, 0xd7, 0xf3, 0x6a, 0xe3, 0xf9, 0x3b, 0x58, 0x3b, 0x2d, 0x97, 0xde,
	0x85, 0x8e, 0x14, 0xcc, 0x85, 0xc6, 0x46, 0x8b, 0xca, 0x07, 0x5a, 0x6d, 0x07, 0xa7, 0x3d, 0x89,
	0x89, 0x68, 0xec, 0xfe, 0xcc, 0x80, 0xae, 0x6a, 0xce, 0x2f, 0xe6, 0xcb, 0x8b, 0xf5, 0x77, 0xe7,
	0x6d, 0xb0, 0x50, 0xec, 0x54, 0x3f, 0xcc, 0x9c, 0x4f, 0xa5, 0x17, 0xc7, 0x00, 0xd4, 0xe8, 0x5e,
	0xcc, 0x85, 0x17, 0x41, 0x2b, 0xce, 0x15, 0x68, 0xa3, 0x90, 0x84, 0xd7, 0x27, 0x41, 0x44, 0xc1,
	0xc6, 0x5b, 0x7c, 0x82, 0x0f, 0xe3, 0x9e, 0xc6, 0x4c, 0x2f, 0x66, 0xfe, 0x24, 0x34, 0x7f, 0xb9,
	0x5a, 0x02, 0x9e, 0x07, 0xc5, 0xaa, 0x2f, 0x86, 0xc6, 0xa9, 0x2f, 0x06, 0xf7, 0x9b, 0x1a, 0x98,
	0x64, 0xf1, 0x25, 0x4b, 0xd3, 0x3b, 0xd0, 0xe4, 0xb8, 0x8c, 0xf2, 0xeb, 0x4c, 0x79, 0x04, 0x58,
	0x53, 0x68, 0x40, 0x4b, 0x48, 0xa9, 0x95, 0xbf, 0x18, 0x60, 0x15, 0x93, 0x58, 0x17, 0x64, 0x36,
	0xc9, 0x25, 0xaa, 0x19, 0x5d, 0x26, 0x2f, 0xd6, 0x85, 0x71, 0x99, 0xca, 0xef, 0xca, 0x73, 0x97,
	0x1a, 0xf2, 0x78, 0x5e, 0xa9, 0x66, 0x88, 0xd6, 0xc1, 0xb3, 0x97, 0x1a, 0xeb, 0x60, 0xe1, 0x41,
	0x55, 0xdd, 0x5c, 0x2a, 0x8f, 0xaa, 0x90, 0x17, 0x6c, 0x2c, 0xe5, 0x37, 0xc0, 0x0c, 0xb4, 0xb8,
	0x8c, 0xa2, 0x33, 0x17, 0x6d, 0xad, 0xd1, 0x0e, 0xa4, 0x82, 0x2e, 0x55, 0xbf, 0x34, 0x60, 0x69,
	0x90, 0xc6, 0x33, 0xe6, 0x8b, 0xe2, 0x93, 0xc3, 0x4b, 0x44, 0x76, 0x4d, 0xa1, 0xd6, 0xfa, 0x49,
	0x78, 0x86, 0xd0, 0xea, 0x2a, 0xa1, 0xd5, 0x93, 0x6a, 0x3f, 0xa2, 0xd4, 0xef, 0x6a, 0xb0, 0xf8,
	0x90, 0x67, 0x53, 0x4e, 0x93, 0xf9, 0x4b, 0x7a, 0xf3, 0x1e, 0x74, 0xf1, 0x7d, 0x32, 0xe3, 0xc1,
	0x28, 0xe7, 0x53, 0x0d, 0x21, 0x9f, 0xbd, 0x9b, 0x1d, 0x25, 0xb3, 0xc3, 0xa7, 0x39, 0xaa, 0xe8,
	0x5a, 0x4d, 0x2a, 0x8d, 0x93, 0x55, 0x94, 0x0c, 0xa9, 0x6c, 0x94, 0x56, 0xc6, 0xd1, 0x7e, 0xae,
	0xba, 0xd5, 0xfc, 0xde, 0xb4, 0x8d, 0xbb, 0xd1, 0x3e, 0x29, 0x68, 0x1b, 0xa4, 0xd0, 0x3a, 0x49,
	0x41, 0x49, 0x90, 0x42, 0x1f, 0x71, 0xcc, 0x6c, 0x16, 0x26, 0xd3, 0x7e, 0x7b, 0xad, 0x8e, 0x38,
	0x4f, 0x91, 0x58, 0xd5, 0x31, 0xaa, 0xf2, 0x9b, 0x83, 0x49, 0x3c, 0x13, 0x27, 0xe8, 0xa3, 0xc3,
	0x19, 0x68, 0x8b, 0x54, 0xb2, 0x2c, 0x62, 0xb5, 0x44, 0x8a, 0x0c, 0xf7, 0xd7, 0x75, 0xe8, 0xe0,
	0xa1, 0xa7, 0x39, 0xff, 0xc1, 0xf8, 0x70, 0x7b, 0xe7, 0x91, 0x0e, 0xf1, 0xf6, 0xce, 0x23, 0x67,
	0x03, 0x1a, 0xf4, 0x8a, 0x94, 0xa1, 0x3d, 0xa7, 0x1e, 0xeb, 0xc5, 0xd2, 0xeb, 0x3b, 0x07, 0x63,
	0xbd, 0x0a, 0x09, 0xae, 0xfc, 0xa6, 0x06, 0x50, 0x4e, 0x62, 0x45, 0xa4, 0xa4, 0xc5, 0xb7, 0xe8,
	0xdc, 0x37, 0x33, 0x7d, 0x1d, 0x31, 0xcb, 0xb9, 0xbe, 0xf3, 0x1b, 0xa0, 0x3a, 0x34, 0x89, 0x57,
	0x4b, 0x6d, 0x01, 0x76, 0xef, 0x2f, 0x78, 0x16, 0x2b, 0x90, 0xef, 0x06, 0x10, 0x28, 0x20, 0xf1,
	0x7a, 0xe5, 0x5a, 0xcc, 0xa1, 0x08, 0xbc, 0x16, 0x28, 0x85, 0x0a, 0xff, 0x01, 0x1d, 0x5f, 0x5e,
	0x07, 0xd2, 0xd1, 0xd8, 0x50, 0x6f, 0xab, 0x72, 0x4d, 0xf0, 0x8a, 0x2b, 0x51, 0x54, 0x7c, 0x1f,
	0x7a, 0x31, 0x26, 0x2e, 0x9e, 0x28, 0xa9, 0xca, 0x56, 0xfa, 0xaa, 0x34, 0x37, 0x97, 0xd2, 0xf7,
	0x17, 0xbc, 0x6e, 0x21, 0x3b, 0x88, 0x03, 0x7d, 0x17, 0x3f, 0x33, 0xa0, 0x47, 0xe0, 0x7a, 0x90,
	0xc6, 0x31, 0x4b, 0x82, 0x5c, 0x3d, 0x0f, 0xfc, 0x39, 0x98, 0xa7, 0x1f, 0x48, 0xc4, 0xc1, 0x12,
	0x9b, 0xe3, 0xb3, 0x6e, 0xbe, 0xef, 0xe8, 0x87, 0x9e, 0x27, 0x99, 0xce, 0xdb, 0x40, 0x50, 0x12,
	0xd7, 0x54, 0x27, 0x65, 0x3f, 0x7b, 0x52, 0x5e, 0x21, 0xe1, 0x7e, 0x69, 0xc0, 0xd2, 0xdc, 0x2b,
	0x2f, 0x9f, 0xbd, 0xcc, 0x33, 0xef, 0x23, 0x58, 0x4a, 0xf8, 0xe1, 0xa8, 0x9c, 0xd3, 0xcf, 0xae,
	0x93, 0x95, 0x17, 0x13, 0x7e, 0x38, 0x28, 0x65, 0x9d, 0xf5, 0x39, 0xdf, 0xcb, 0x23, 0x9c, 0x8b,
	0x54, 0xc5, 0xfb, 0xdb, 0xf0, 0xca, 0x27, 0x19, 0x97, 0xc8, 0xf9, 0xff, 0xb2, 0x50, 0xe2, 0xd8,
	0x7f, 0x03, 0x90, 0x69, 0x16, 0x85, 0xb9, 0xa0, 0xa7, 0xa0, 0x7e, 0xcd, 0xa8, 0x0f, 0x1c, 0xc4,
	0xdd, 0x0e, 0x73, 0xe1, 0x7e, 0x59, 0x83, 0xa6, 0xac, 0xa9, 0xd7, 0xb5, 0x52, 0xe5, 0x62, 0x2c,
	0x97, 0x4a, 0x95, 0x46, 0x21, 0xd5, 0x29, 0xa1, 0xcf, 0x82, 0x29, 0xff, 0x0a, 0x52, 0x8d, 0xb8,
	0xe1, 0xb5, 0x89, 0x1e, 0x06, 0xce, 0x45, 0xe8, 0x04, 0xaa, 0x1c, 0x97, 0xb8, 0x18, 0xf4, 0xd4,
	0x90, 0xbe, 0x31, 0x49, 0x5d, 0xea, 0xa4, 0x12, 0xa4, 0xc9, 0x7f, 0x89, 0x1e, 0x61, 0x3b, 0xbd,
	0x24, 0xff, 0x91, 0x20, 0x7d, 0x92, 0x90, 0x5f, 0xaf, 0xba, 0x7a, 0x92, 0x84, 0xb0, 0x22, 0x84,
	0x7a, 0x09, 0xf9, 0x0d, 0xcb, 0xc4, 0x09, 0x62, 0x56, 0xbf, 0x50, 0xb4, 0xe7, 0xbf, 0x50, 0xac,
	0x41, 0x93, 0x86, 0xf4, 0x05, 0x6b, 0xfe, 0xa9, 0x27, 0x19, 0xee, 0xa5, 0x6a, 0x17, 0x04, 0x68,
	0x0d, 0x93, 0x9c, 0x67, 0xc2, 0x5e, 0xc0, 0xb1, 0x44, 0xc4, 0xb6, 0x71, 0xed, 0xf3, 0x3a, 0xb4,
	0xe4, 0x5f, 0x3e, 0x8e, 0x05, 0xcd, 0xdd, 0x11, 0x4b, 0x8e, 0xa5, 0xc4, 0x2e, 0xa2, 0x9e, 0xcc,
	0x36, 0xe4, 0x78, 0x9c, 0xa6, 0x91, 0x0d, 0x72, 0x1c, 0x26, 0xe2, 0x96, 0xbd, 0xec, 0x74, 0xa0,
	0x4d, 0xe3, 0xf7, 0x6e, 0xda, 0xaf, 0x15, 0xc4, 0xf5, 0x4d, 0xfb, 0xf5, 0x82, 0xb8, 0x79, 0xc3,
	0x3e, 0xe3, 0x74, 0xc1, 0x94, 0x62, 0x9b, 0xb7, 0xec, 0xbe, 0x64, 0x1d, 0xd0, 0x0a, 0x67, 0x25,
	0xeb, 0x40, 0x2e, 0xb1, 0x52, 0x52, 0xd7, 0x37, 0xed, 0x73, 0x25, 0x75, 0xf3, 0x86, 0xbd, 0xea,
	0xf4, 0xc0, 0x52, 0x92, 0x9b, 0xb7, 0xec, 0xf3, 0x92, 0x9c, 0x44, 0x29, 0x43, 0xd9, 0x0b, 0x15,
	0xf2, 0xe6, 0x0d, 0xfb, 0xa2, 0xb3, 0x04, 0x9d, 0xdd, 0x51, 0xc0, 0xfd, 0x30, 0x66, 0xd1, 0xcd,
	0x1b, 0xf6, 0x9a, 0x63, 0x43, 0xb7, 0x98, 0xc0, 0x05, 0xde, 0x90, 0xfb, 0xc0, 0x6a, 0x62, 0x6f,
	0xca, 0x31, 0x26, 0xb6, 0x7d, 0xdd, 0x59, 0x04, 0x90, 0xf3, 0x44, 0xdf, 0x90, 0x4b, 0x15, 0x49,
	0x6f, 0xff, 0xbb, 0x14, 0x08, 0x13, 0xc1, 0xb3, 0x27, 0x2c, 0xb2, 0x6f, 0x4a, 0x65, 0x7f, 0x8f,
	0x65, 0xf6, 0x87, 0xd2, 0x8d, 0x27, 0x2c, 0x23, 0xf2, 0x23, 0xc9, 0xfa, 0x51, 0x9e, 0x26, 0xf6,
	0x6d, 0x15, 0xc3, 0x28, 0x1d, 0xdb, 0x1f, 0x3b, 0x26, 0x34, 0x76, 0x47, 0xbb, 0x3b, 0x76, 0xe0,
	0x00, 0x06, 0x3c, 0xe7, 0x91, 0xfd, 0xb5, 0xe1, 0x74, 0x31, 0x30, 0xe2, 0x60, 0x16, 0x71, 0xfb,
	0x4f, 0xc6, 0xb5, 0xcf, 0x0c, 0x68, 0xeb, 0x8a, 0xdb, 0x05, 0x13, 0x6b, 0x0e, 0x9e, 0xac, 0xbd,
	0x80, 0x46, 0x06, 0x71, 0x20, 0xab, 0xa7, 0x6d, 0x38, 0xaf, 0x40, 0x6f, 0x10, 0x07, 0x65, 0x75,
	0xb4, 0x6b, 0xb8, 0x5b, 0x9c, 0xe2, 0x82, 0xd1, 0xe9, 0xdb, 0x75, 0xdc, 0xc5, 0x20, 0x0e, 0x74,
	0xed, 0xb0, 0x1b, 0xce, 0xab, 0xb0, 0xa4, 0x26, 0x74, 0x7d, 0xb4, 0x9b, 0x8e, 0x03, 0x8b, 0xa4,
	0x57, 0x54, 0x3e, 0xbb, 0x75, 0x6d, 0x0b, 0xa0, 0x44, 0xba, 0x68, 0xec, 0xde, 0xce, 0x48, 0xda,
	0xc6, 0x24, 0xb7, 0x17, 0x9c, 0x65, 0xb0, 0xef, 0xed, 0x8c, 0x1e, 0xa5, 0xa2, 0x32, 0x6b, 0xa0,
	0x93, 0xf7, 0x76, 0x46, 0x1f, 0x67, 0xe9, 0x53, 0x9e, 0xd8, 0xb5, 0xbb, 0xb7, 0xbf, 0xfe, 0xf6,
	0x82, 0xf1, 0xcd, 0xb7, 0x17, 0x8c, 0xbf, 0x7d, 0x7b, 0x61, 0xe1, 0x8b, 0xef, 0x2e, 0x18, 0x9f,
	0xbe, 0x5d, 0xf9, 0xfb, 0x3b, 0x66, 0x22, 0x0b, 0x8f, 0xd2, 0x2c, 0x9c, 0x86, 0x89, 0x26, 0x12,
	0xbe, 0x31, 0xdb, 0x9f, 0x6e, 0xcc, 0xc6, 0x1b, 0x6c, 0x16, 0x8e, 0x5b, 0xf4, 0x3f, 0xf7, 0xf5,
	0x7f, 0x06, 0x00, 0x00, 0xff, 0xff, 0xb0, 0xd1, 0x75, 0xe0, 0x45, 0x1f, 0x00, 0x00,
}

func (m *Type) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Type) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Type) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Scale != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Scale))
		i--
		dAtA[i] = 0x30
	}
	if m.Size != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Size))
		i--
		dAtA[i] = 0x28
	}
	if m.Precision != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Precision))
		i--
		dAtA[i] = 0x20
	}
	if m.Width != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x18
	}
	if m.Nullable {
		i--
		if m.Nullable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DBInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DBInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DBInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsSys {
		i--
		if m.IsSys {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseCmd) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Drop {
		i--
		if m.Drop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.TableCmds) > 0 {
		for k := range m.TableCmds {
			v := m.TableCmds[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintApi(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Create != nil {
		{
			size, err := m.Create.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Mask != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mask))
		i--
		dAtA[i] = 0x10
	}
	if m.DbId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.DbId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Location) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Location) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Location) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Olen != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Olen))
		i--
		dAtA[i] = 0x20
	}
	if m.Len != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Len))
		i--
		dAtA[i] = 0x18
	}
	if m.Offset != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZoneMap) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZoneMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZoneMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Max != nil {
		{
			size, err := m.Max.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Min != nil {
		{
			size, err := m.Min.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Typ != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Typ))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnMeta) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DataLocation != nil {
		{
			size, err := m.DataLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.BfLocation != nil {
		{
			size, err := m.BfLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Zm != nil {
		{
			size, err := m.Zm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Idx != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Idx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockMeta) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Alog != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Alog))
		i--
		dAtA[i] = 0x10
	}
	if m.ColunmCnt != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ColunmCnt))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ColumnsMeta) > 0 {
		for iNdEx := len(m.ColumnsMeta) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ColumnsMeta[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BlockMeta != nil {
		{
			size, err := m.BlockMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Vector) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vector) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsConst {
		i--
		if m.IsConst {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Nsp) > 0 {
		i -= len(m.Nsp)
		copy(dAtA[i:], m.Nsp)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Nsp)))
		i--
		dAtA[i] = 0x22
	}
	if m.Nullable {
		i--
		if m.Nullable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Type != nil {
		{
			size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppendInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Vecs) > 0 {
		for iNdEx := len(m.Vecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Vecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Attrs) > 0 {
		for iNdEx := len(m.Attrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Attrs[iNdEx])
			copy(dAtA[i:], m.Attrs[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.Attrs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RowRange) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.End != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RangeRows != nil {
		{
			size, err := m.RangeRows.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteInfo_DefType) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteInfo_DefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteInfo_DefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Def != nil {
		{
			size := m.Def.ProtoSize()
			i -= size
			if _, err := m.Def.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeleteInfo_DefType_Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteInfo_DefType_Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Range != nil {
		{
			size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DeleteInfo_DefType_Rows) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteInfo_DefType_Rows) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Rows)
	copy(dAtA[i:], m.Rows)
	i = encodeVarintApi(dAtA, i, uint64(len(m.Rows)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *BlockCmd) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Drop {
		i--
		if m.Drop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Delete != nil {
		{
			size, err := m.Delete.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Append != nil {
		{
			size, err := m.Append.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Create != nil {
		{
			size, err := m.Create.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Mask != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mask))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AccessInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CreateAt != nil {
		{
			size, err := m.CreateAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.RoleId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.RoleId))
		i--
		dAtA[i] = 0x18
	}
	if m.UserId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if m.TenantId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TenantId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Default != nil {
		{
			size, err := m.Default.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x5a
	}
	if m.SortKey {
		i--
		if m.SortKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.SortIdx != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SortIdx))
		i--
		dAtA[i] = 0x48
	}
	if m.Primary {
		i--
		if m.Primary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.AutoIncrement {
		i--
		if m.AutoIncrement {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.NullAbility {
		i--
		if m.NullAbility {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.PhyAddr {
		i--
		if m.PhyAddr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Hidden {
		i--
		if m.Hidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Type != nil {
		{
			size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Idx != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Idx))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.View) > 0 {
		i -= len(m.View)
		copy(dAtA[i:], m.View)
		i = encodeVarintApi(dAtA, i, uint64(len(m.View)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.CreateSql) > 0 {
		i -= len(m.CreateSql)
		copy(dAtA[i:], m.CreateSql)
		i = encodeVarintApi(dAtA, i, uint64(len(m.CreateSql)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.RelKind) > 0 {
		i -= len(m.RelKind)
		copy(dAtA[i:], m.RelKind)
		i = encodeVarintApi(dAtA, i, uint64(len(m.RelKind)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NameIndex) > 0 {
		for k := range m.NameIndex {
			v := m.NameIndex[k]
			baseI := i
			i = encodeVarintApi(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ColsDef) > 0 {
		for iNdEx := len(m.ColsDef) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ColsDef[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.AcInfo != nil {
		{
			size, err := m.AcInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableCmd) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Drop {
		i--
		if m.Drop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.BlockCmds) > 0 {
		for k := range m.BlockCmds {
			v := m.BlockCmds[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintApi(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Create != nil {
		{
			size, err := m.Create.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Mask != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Mask))
		i--
		dAtA[i] = 0x10
	}
	if m.Tid != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Tid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseID) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseID) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableID) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableID) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DbId != nil {
		{
			size, err := m.DbId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TabId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TabId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SegmentID) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SegmentID) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SegmentID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TabId != nil {
		{
			size, err := m.TabId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SegId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SegId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockID) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockID) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SegId != nil {
		{
			size, err := m.SegId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BlockId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.BlockId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TSRange) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TSRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TSRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.To != nil {
		{
			size, err := m.To.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.From != nil {
		{
			size, err := m.From.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScopeDesc) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScopeDesc) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScopeDesc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tables) > 0 {
		for iNdEx := len(m.Tables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.All {
		i--
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncLogTailReq) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncLogTailReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncLogTailReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.All {
		i--
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Tables) > 0 {
		for iNdEx := len(m.Tables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Range != nil {
		{
			size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CheckpointTs != nil {
		{
			size, err := m.CheckpointTs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Batch) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Batch) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Batch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Vecs) > 0 {
		for iNdEx := len(m.Vecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Vecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Attrs) > 0 {
		for iNdEx := len(m.Attrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Attrs[iNdEx])
			copy(dAtA[i:], m.Attrs[iNdEx])
			i = encodeVarintApi(dAtA, i, uint64(len(m.Attrs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AppendCtx) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendCtx) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendCtx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DestLen != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.DestLen))
		i--
		dAtA[i] = 0x38
	}
	if m.DestOff != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.DestOff))
		i--
		dAtA[i] = 0x30
	}
	if m.Dest != nil {
		{
			size, err := m.Dest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DbId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.DbId))
		i--
		dAtA[i] = 0x20
	}
	if m.SrcLen != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SrcLen))
		i--
		dAtA[i] = 0x18
	}
	if m.SrcOff != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SrcOff))
		i--
		dAtA[i] = 0x10
	}
	if m.Seq != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppendCmd) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Ts != nil {
		{
			size, err := m.Ts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Ctxs) > 0 {
		for iNdEx := len(m.Ctxs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ctxs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Bat != nil {
		{
			size, err := m.Bat.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Csn != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Csn))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.CmdType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppendNode) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CommitTs != nil {
		{
			size, err := m.CommitTs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.MaxRow != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.MaxRow))
		i--
		dAtA[i] = 0x18
	}
	if m.StartRow != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.StartRow))
		i--
		dAtA[i] = 0x10
	}
	if m.BlockId != nil {
		{
			size, err := m.BlockId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteNode) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CommitTs != nil {
		{
			size, err := m.CommitTs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Mask) > 0 {
		i -= len(m.Mask)
		copy(dAtA[i:], m.Mask)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Mask)))
		i--
		dAtA[i] = 0x12
	}
	if m.BlockId != nil {
		{
			size, err := m.BlockId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ColumnID) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnID) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ColIndex != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.ColIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.BlockId != nil {
		{
			size, err := m.BlockId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ColunmUpdateNode) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColunmUpdateNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColunmUpdateNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *MvccUpdateCmd) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MvccUpdateCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MvccUpdateCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MvccNode) > 0 {
		for iNdEx := len(m.MvccNode) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MvccNode[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.BlockId != nil {
		{
			size, err := m.BlockId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.DbId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.DbId))
		i--
		dAtA[i] = 0x18
	}
	if m.Csn != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Csn))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.CmdType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MvccUpdateCmd_MvccNodeType) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MvccUpdateCmd_MvccNodeType) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MvccUpdateCmd_MvccNodeType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Def != nil {
		{
			size := m.Def.ProtoSize()
			i -= size
			if _, err := m.Def.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MvccUpdateCmd_MvccNodeType_AppendNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MvccUpdateCmd_MvccNodeType_AppendNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AppendNode != nil {
		{
			size, err := m.AppendNode.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *MvccUpdateCmd_MvccNodeType_DeleteNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MvccUpdateCmd_MvccNodeType_DeleteNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeleteNode != nil {
		{
			size, err := m.DeleteNode.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *UpdateNode) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.End != nil {
		{
			size, err := m.End.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Start != nil {
		{
			size, err := m.Start.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DeltaLoc) > 0 {
		i -= len(m.DeltaLoc)
		copy(dAtA[i:], m.DeltaLoc)
		i = encodeVarintApi(dAtA, i, uint64(len(m.DeltaLoc)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MetaLoc) > 0 {
		i -= len(m.MetaLoc)
		copy(dAtA[i:], m.MetaLoc)
		i = encodeVarintApi(dAtA, i, uint64(len(m.MetaLoc)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DeletedAt != nil {
		{
			size, err := m.DeletedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BaseEntry) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaseEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BaseEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Node != nil {
		{
			size, err := m.Node.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockEntry) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BlockState != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.BlockState))
		i--
		dAtA[i] = 0x18
	}
	if m.BlockId != nil {
		{
			size, err := m.BlockId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Be != nil {
		{
			size, err := m.Be.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SegmentEntry) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SegmentEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SegmentEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SegState != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.SegState))
		i--
		dAtA[i] = 0x18
	}
	if m.SegId != nil {
		{
			size, err := m.SegId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Be != nil {
		{
			size, err := m.Be.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableEntry) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TabDef != nil {
		{
			size, err := m.TabDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TabId != nil {
		{
			size, err := m.TabId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Be != nil {
		{
			size, err := m.Be.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseEntry) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AcInfo != nil {
		{
			size, err := m.AcInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.DbId != nil {
		{
			size, err := m.DbId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Be != nil {
		{
			size, err := m.Be.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EntryCmd) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntryCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntryCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Entry != nil {
		{
			size, err := m.Entry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Csn != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Csn))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.CmdType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EntryCmd_EntryType) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntryCmd_EntryType) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntryCmd_EntryType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Def != nil {
		{
			size := m.Def.ProtoSize()
			i -= size
			if _, err := m.Def.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *EntryCmd_EntryType_BlockEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntryCmd_EntryType_BlockEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BlockEntry != nil {
		{
			size, err := m.BlockEntry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *EntryCmd_EntryType_SegEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntryCmd_EntryType_SegEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SegEntry != nil {
		{
			size, err := m.SegEntry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *EntryCmd_EntryType_TabEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntryCmd_EntryType_TabEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TabEntry != nil {
		{
			size, err := m.TabEntry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *EntryCmd_EntryType_DbEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntryCmd_EntryType_DbEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DbEntry != nil {
		{
			size, err := m.DbEntry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CompactBlockCmd) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactBlockCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactBlockCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.To != nil {
		{
			size, err := m.To.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.From != nil {
		{
			size, err := m.From.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Csn != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Csn))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.CmdType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MergeBlocksCmd) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MergeBlocksCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MergeBlocksCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ToAddr) > 0 {
		dAtA62 := make([]byte, len(m.ToAddr)*10)
		var j61 int
		for _, num := range m.ToAddr {
			for num >= 1<<7 {
				dAtA62[j61] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j61++
			}
			dAtA62[j61] = uint8(num)
			j61++
		}
		i -= j61
		copy(dAtA[i:], dAtA62[:j61])
		i = encodeVarintApi(dAtA, i, uint64(j61))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.FromAddr) > 0 {
		dAtA64 := make([]byte, len(m.FromAddr)*10)
		var j63 int
		for _, num := range m.FromAddr {
			for num >= 1<<7 {
				dAtA64[j63] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j63++
			}
			dAtA64[j63] = uint8(num)
			j63++
		}
		i -= j63
		copy(dAtA[i:], dAtA64[:j63])
		i = encodeVarintApi(dAtA, i, uint64(j63))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Mapping) > 0 {
		dAtA66 := make([]byte, len(m.Mapping)*10)
		var j65 int
		for _, num := range m.Mapping {
			for num >= 1<<7 {
				dAtA66[j65] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j65++
			}
			dAtA66[j65] = uint8(num)
			j65++
		}
		i -= j65
		copy(dAtA[i:], dAtA66[:j65])
		i = encodeVarintApi(dAtA, i, uint64(j65))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CreatedBlks) > 0 {
		for iNdEx := len(m.CreatedBlks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CreatedBlks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.DroppedBlks) > 0 {
		for iNdEx := len(m.DroppedBlks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DroppedBlks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.CreatedSegs) > 0 {
		for iNdEx := len(m.CreatedSegs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CreatedSegs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.DroppedSegs) > 0 {
		for iNdEx := len(m.DroppedSegs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DroppedSegs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Csn != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.Csn))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.CmdType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ComposedCmd) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComposedCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComposedCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cmds) > 0 {
		for iNdEx := len(m.Cmds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cmds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.LSN != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.LSN))
		i--
		dAtA[i] = 0x10
	}
	if m.CmdType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.CmdType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ComposedCmd_SubCmdType) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComposedCmd_SubCmdType) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComposedCmd_SubCmdType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Def != nil {
		{
			size := m.Def.ProtoSize()
			i -= size
			if _, err := m.Def.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ComposedCmd_SubCmdType_EntryCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComposedCmd_SubCmdType_EntryCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EntryCmd != nil {
		{
			size, err := m.EntryCmd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ComposedCmd_SubCmdType_AppendCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComposedCmd_SubCmdType_AppendCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AppendCmd != nil {
		{
			size, err := m.AppendCmd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ComposedCmd_SubCmdType_MvccCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComposedCmd_SubCmdType_MvccCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MvccCmd != nil {
		{
			size, err := m.MvccCmd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ComposedCmd_SubCmdType_CompactCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComposedCmd_SubCmdType_CompactCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CompactCmd != nil {
		{
			size, err := m.CompactCmd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ComposedCmd_SubCmdType_MergeblksCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComposedCmd_SubCmdType_MergeblksCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MergeblksCmd != nil {
		{
			size, err := m.MergeblksCmd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *BatchCommands) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchCommands) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchCommands) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Commands) > 0 {
		for iNdEx := len(m.Commands) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Commands[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Scope != nil {
		{
			size, err := m.Scope.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Desc != nil {
		{
			size, err := m.Desc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SyncLogTailResp) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncLogTailResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncLogTailResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Commands != nil {
		{
			size, err := m.Commands.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NewCheckpoints) > 0 {
		for iNdEx := len(m.NewCheckpoints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NewCheckpoints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.CheckpointTs != nil {
		{
			size, err := m.CheckpointTs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PrecommitWriteCmd) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrecommitWriteCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrecommitWriteCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EntryList) > 0 {
		for iNdEx := len(m.EntryList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EntryList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Entry) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entry) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.BlockId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.BlockId))
		i--
		dAtA[i] = 0x38
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DatabaseName) > 0 {
		i -= len(m.DatabaseName)
		copy(dAtA[i:], m.DatabaseName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.DatabaseName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintApi(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x22
	}
	if m.DatabaseId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.DatabaseId))
		i--
		dAtA[i] = 0x18
	}
	if m.TableId != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x10
	}
	if m.EntryType != 0 {
		i = encodeVarintApi(dAtA, i, uint64(m.EntryType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Type) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.Nullable {
		n += 2
	}
	if m.Width != 0 {
		n += 1 + sovApi(uint64(m.Width))
	}
	if m.Precision != 0 {
		n += 1 + sovApi(uint64(m.Precision))
	}
	if m.Size != 0 {
		n += 1 + sovApi(uint64(m.Size))
	}
	if m.Scale != 0 {
		n += 1 + sovApi(uint64(m.Scale))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DBInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.IsSys {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseCmd) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DbId != 0 {
		n += 1 + sovApi(uint64(m.DbId))
	}
	if m.Mask != 0 {
		n += 1 + sovApi(uint64(m.Mask))
	}
	if m.Create != nil {
		l = m.Create.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.TableCmds) > 0 {
		for k, v := range m.TableCmds {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.ProtoSize()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.Drop {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Location) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovApi(uint64(m.Offset))
	}
	if m.Len != 0 {
		n += 1 + sovApi(uint64(m.Len))
	}
	if m.Olen != 0 {
		n += 1 + sovApi(uint64(m.Olen))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZoneMap) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Typ != 0 {
		n += 1 + sovApi(uint64(m.Typ))
	}
	if m.Min != nil {
		l = m.Min.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Max != nil {
		l = m.Max.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColumnMeta) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Idx != 0 {
		n += 1 + sovApi(uint64(m.Idx))
	}
	if m.Zm != nil {
		l = m.Zm.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BfLocation != nil {
		l = m.BfLocation.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.DataLocation != nil {
		l = m.DataLocation.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockMeta) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColunmCnt != 0 {
		n += 1 + sovApi(uint64(m.ColunmCnt))
	}
	if m.Alog != 0 {
		n += 1 + sovApi(uint64(m.Alog))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockMeta != nil {
		l = m.BlockMeta.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.ColumnsMeta) > 0 {
		for _, e := range m.ColumnsMeta {
			l = e.ProtoSize()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Vector) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Type != nil {
		l = m.Type.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Nullable {
		n += 2
	}
	l = len(m.Nsp)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.IsConst {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppendInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attrs) > 0 {
		for _, s := range m.Attrs {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.Vecs) > 0 {
		for _, e := range m.Vecs {
			l = e.ProtoSize()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RowRange) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovApi(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovApi(uint64(m.End))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeRows != nil {
		l = m.RangeRows.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteInfo_DefType) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Def != nil {
		n += m.Def.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteInfo_DefType_Range) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *DeleteInfo_DefType_Rows) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Rows)
	n += 1 + l + sovApi(uint64(l))
	return n
}
func (m *BlockCmd) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.Mask != 0 {
		n += 1 + sovApi(uint64(m.Mask))
	}
	if m.Create != nil {
		l = m.Create.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Append != nil {
		l = m.Append.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Delete != nil {
		l = m.Delete.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Drop {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TenantId != 0 {
		n += 1 + sovApi(uint64(m.TenantId))
	}
	if m.UserId != 0 {
		n += 1 + sovApi(uint64(m.UserId))
	}
	if m.RoleId != 0 {
		n += 1 + sovApi(uint64(m.RoleId))
	}
	if m.CreateAt != nil {
		l = m.CreateAt.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Idx != 0 {
		n += 1 + sovApi(uint64(m.Idx))
	}
	if m.Type != nil {
		l = m.Type.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Hidden {
		n += 2
	}
	if m.PhyAddr {
		n += 2
	}
	if m.NullAbility {
		n += 2
	}
	if m.AutoIncrement {
		n += 2
	}
	if m.Primary {
		n += 2
	}
	if m.SortIdx != 0 {
		n += 1 + sovApi(uint64(m.SortIdx))
	}
	if m.SortKey {
		n += 2
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Default != nil {
		l = m.Default.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AcInfo != nil {
		l = m.AcInfo.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.ColsDef) > 0 {
		for _, e := range m.ColsDef {
			l = e.ProtoSize()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.NameIndex) > 0 {
		for k, v := range m.NameIndex {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + sovApi(uint64(v))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.RelKind)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.CreateSql)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.View)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableCmd) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tid != 0 {
		n += 1 + sovApi(uint64(m.Tid))
	}
	if m.Mask != 0 {
		n += 1 + sovApi(uint64(m.Mask))
	}
	if m.Create != nil {
		l = m.Create.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.BlockCmds) > 0 {
		for k, v := range m.BlockCmds {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.ProtoSize()
				l += 1 + sovApi(uint64(l))
			}
			mapEntrySize := 1 + sovApi(uint64(k)) + l
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.Drop {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseID) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovApi(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableID) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TabId != 0 {
		n += 1 + sovApi(uint64(m.TabId))
	}
	if m.DbId != nil {
		l = m.DbId.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SegmentID) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SegId != 0 {
		n += 1 + sovApi(uint64(m.SegId))
	}
	if m.TabId != nil {
		l = m.TabId.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockID) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockId != 0 {
		n += 1 + sovApi(uint64(m.BlockId))
	}
	if m.SegId != nil {
		l = m.SegId.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TSRange) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != nil {
		l = m.From.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.To != nil {
		l = m.To.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScopeDesc) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.All {
		n += 2
	}
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.ProtoSize()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SyncLogTailReq) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckpointTs != nil {
		l = m.CheckpointTs.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Range != nil {
		l = m.Range.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.ProtoSize()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.All {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Batch) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attrs) > 0 {
		for _, s := range m.Attrs {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.Vecs) > 0 {
		for _, e := range m.Vecs {
			l = e.ProtoSize()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppendCtx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovApi(uint64(m.Seq))
	}
	if m.SrcOff != 0 {
		n += 1 + sovApi(uint64(m.SrcOff))
	}
	if m.SrcLen != 0 {
		n += 1 + sovApi(uint64(m.SrcLen))
	}
	if m.DbId != 0 {
		n += 1 + sovApi(uint64(m.DbId))
	}
	if m.Dest != nil {
		l = m.Dest.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.DestOff != 0 {
		n += 1 + sovApi(uint64(m.DestOff))
	}
	if m.DestLen != 0 {
		n += 1 + sovApi(uint64(m.DestLen))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppendCmd) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdType != 0 {
		n += 1 + sovApi(uint64(m.CmdType))
	}
	if m.Csn != 0 {
		n += 1 + sovApi(uint64(m.Csn))
	}
	if m.Bat != nil {
		l = m.Bat.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Ctxs) > 0 {
		for _, e := range m.Ctxs {
			l = e.ProtoSize()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Ts != nil {
		l = m.Ts.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppendNode) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockId != nil {
		l = m.BlockId.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.StartRow != 0 {
		n += 1 + sovApi(uint64(m.StartRow))
	}
	if m.MaxRow != 0 {
		n += 1 + sovApi(uint64(m.MaxRow))
	}
	if m.CommitTs != nil {
		l = m.CommitTs.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteNode) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockId != nil {
		l = m.BlockId.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Mask)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.CommitTs != nil {
		l = m.CommitTs.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColumnID) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockId != nil {
		l = m.BlockId.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.ColIndex != 0 {
		n += 1 + sovApi(uint64(m.ColIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColunmUpdateNode) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MvccUpdateCmd) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdType != 0 {
		n += 1 + sovApi(uint64(m.CmdType))
	}
	if m.Csn != 0 {
		n += 1 + sovApi(uint64(m.Csn))
	}
	if m.DbId != 0 {
		n += 1 + sovApi(uint64(m.DbId))
	}
	if m.BlockId != nil {
		l = m.BlockId.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.MvccNode) > 0 {
		for _, e := range m.MvccNode {
			l = e.ProtoSize()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MvccUpdateCmd_MvccNodeType) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Def != nil {
		n += m.Def.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MvccUpdateCmd_MvccNodeType_AppendNode) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppendNode != nil {
		l = m.AppendNode.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *MvccUpdateCmd_MvccNodeType_DeleteNode) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeleteNode != nil {
		l = m.DeleteNode.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *UpdateNode) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreatedAt != nil {
		l = m.CreatedAt.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.DeletedAt != nil {
		l = m.DeletedAt.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.MetaLoc)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.DeltaLoc)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Start != nil {
		l = m.Start.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.End != nil {
		l = m.End.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BaseEntry) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != nil {
		l = m.Node.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockEntry) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Be != nil {
		l = m.Be.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BlockId != nil {
		l = m.BlockId.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BlockState != 0 {
		n += 1 + sovApi(uint64(m.BlockState))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SegmentEntry) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Be != nil {
		l = m.Be.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.SegId != nil {
		l = m.SegId.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.SegState != 0 {
		n += 1 + sovApi(uint64(m.SegState))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableEntry) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Be != nil {
		l = m.Be.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.TabId != nil {
		l = m.TabId.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.TabDef != nil {
		l = m.TabDef.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseEntry) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Be != nil {
		l = m.Be.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.DbId != nil {
		l = m.DbId.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.AcInfo != nil {
		l = m.AcInfo.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EntryCmd) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdType != 0 {
		n += 1 + sovApi(uint64(m.CmdType))
	}
	if m.Csn != 0 {
		n += 1 + sovApi(uint64(m.Csn))
	}
	if m.Entry != nil {
		l = m.Entry.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EntryCmd_EntryType) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Def != nil {
		n += m.Def.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EntryCmd_EntryType_BlockEntry) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockEntry != nil {
		l = m.BlockEntry.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *EntryCmd_EntryType_SegEntry) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SegEntry != nil {
		l = m.SegEntry.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *EntryCmd_EntryType_TabEntry) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TabEntry != nil {
		l = m.TabEntry.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *EntryCmd_EntryType_DbEntry) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DbEntry != nil {
		l = m.DbEntry.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *CompactBlockCmd) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdType != 0 {
		n += 1 + sovApi(uint64(m.CmdType))
	}
	if m.Csn != 0 {
		n += 1 + sovApi(uint64(m.Csn))
	}
	if m.From != nil {
		l = m.From.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.To != nil {
		l = m.To.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MergeBlocksCmd) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdType != 0 {
		n += 1 + sovApi(uint64(m.CmdType))
	}
	if m.Csn != 0 {
		n += 1 + sovApi(uint64(m.Csn))
	}
	if len(m.DroppedSegs) > 0 {
		for _, e := range m.DroppedSegs {
			l = e.ProtoSize()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.CreatedSegs) > 0 {
		for _, e := range m.CreatedSegs {
			l = e.ProtoSize()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.DroppedBlks) > 0 {
		for _, e := range m.DroppedBlks {
			l = e.ProtoSize()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.CreatedBlks) > 0 {
		for _, e := range m.CreatedBlks {
			l = e.ProtoSize()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.Mapping) > 0 {
		l = 0
		for _, e := range m.Mapping {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.FromAddr) > 0 {
		l = 0
		for _, e := range m.FromAddr {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if len(m.ToAddr) > 0 {
		l = 0
		for _, e := range m.ToAddr {
			l += sovApi(uint64(e))
		}
		n += 1 + sovApi(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComposedCmd) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdType != 0 {
		n += 1 + sovApi(uint64(m.CmdType))
	}
	if m.LSN != 0 {
		n += 1 + sovApi(uint64(m.LSN))
	}
	if len(m.Cmds) > 0 {
		for _, e := range m.Cmds {
			l = e.ProtoSize()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComposedCmd_SubCmdType) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Def != nil {
		n += m.Def.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComposedCmd_SubCmdType_EntryCmd) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntryCmd != nil {
		l = m.EntryCmd.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ComposedCmd_SubCmdType_AppendCmd) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppendCmd != nil {
		l = m.AppendCmd.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ComposedCmd_SubCmdType_MvccCmd) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MvccCmd != nil {
		l = m.MvccCmd.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ComposedCmd_SubCmdType_CompactCmd) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompactCmd != nil {
		l = m.CompactCmd.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *ComposedCmd_SubCmdType_MergeblksCmd) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MergeblksCmd != nil {
		l = m.MergeblksCmd.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}
func (m *BatchCommands) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Desc != nil {
		l = m.Desc.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Scope != nil {
		l = m.Scope.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Commands) > 0 {
		for _, e := range m.Commands {
			l = e.ProtoSize()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SyncLogTailResp) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckpointTs != nil {
		l = m.CheckpointTs.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.NewCheckpoints) > 0 {
		for _, e := range m.NewCheckpoints {
			l = e.ProtoSize()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Commands != nil {
		l = m.Commands.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrecommitWriteCmd) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EntryList) > 0 {
		for _, e := range m.EntryList {
			l = e.ProtoSize()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Entry) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntryType != 0 {
		n += 1 + sovApi(uint64(m.EntryType))
	}
	if m.TableId != 0 {
		n += 1 + sovApi(uint64(m.TableId))
	}
	if m.DatabaseId != 0 {
		n += 1 + sovApi(uint64(m.DatabaseId))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.DatabaseName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.BlockId != 0 {
		n += 1 + sovApi(uint64(m.BlockId))
	}
	if m.Block != nil {
		l = m.Block.ProtoSize()
		n += 1 + l + sovApi(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Type) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= TypeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nullable = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precision", wireType)
			}
			m.Precision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Precision |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size", wireType)
			}
			m.Size = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			m.Scale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scale |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DBInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DBInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DBInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSys", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSys = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			m.DbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mask", wireType)
			}
			m.Mask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mask |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Create", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Create == nil {
				m.Create = &DBInfo{}
			}
			if err := m.Create.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableCmds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableCmds == nil {
				m.TableCmds = make(map[uint64]*TableCmd)
			}
			var mapkey uint64
			var mapvalue *TableCmd
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &TableCmd{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TableCmds[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Drop = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			m.Len = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Len |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Olen", wireType)
			}
			m.Olen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Olen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZoneMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZoneMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZoneMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			m.Typ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typ |= TypeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Min == nil {
				m.Min = &plan.Const{}
			}
			if err := m.Min.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Max == nil {
				m.Max = &plan.Const{}
			}
			if err := m.Max.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Zm == nil {
				m.Zm = &ZoneMap{}
			}
			if err := m.Zm.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BfLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BfLocation == nil {
				m.BfLocation = &Location{}
			}
			if err := m.BfLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataLocation == nil {
				m.DataLocation = &Location{}
			}
			if err := m.DataLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColunmCnt", wireType)
			}
			m.ColunmCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColunmCnt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alog", wireType)
			}
			m.Alog = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alog |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockMeta == nil {
				m.BlockMeta = &BlockMeta{}
			}
			if err := m.BlockMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnsMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnsMeta = append(m.ColumnsMeta, &ColumnMeta{})
			if err := m.ColumnsMeta[len(m.ColumnsMeta)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &Type{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nullable = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nsp", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nsp = append(m.Nsp[:0], dAtA[iNdEx:postIndex]...)
			if m.Nsp == nil {
				m.Nsp = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsConst", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsConst = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attrs = append(m.Attrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vecs = append(m.Vecs, &Vector{})
			if err := m.Vecs[len(m.Vecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeRows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RangeRows == nil {
				m.RangeRows = &DeleteInfo_DefType{}
			}
			if err := m.RangeRows.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteInfo_DefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RowRange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Def = &DeleteInfo_DefType_Range{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Def = &DeleteInfo_DefType_Rows{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mask", wireType)
			}
			m.Mask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mask |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Create", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Create == nil {
				m.Create = &BlockInfo{}
			}
			if err := m.Create.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Append", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Append == nil {
				m.Append = &AppendInfo{}
			}
			if err := m.Append.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delete == nil {
				m.Delete = &DeleteInfo{}
			}
			if err := m.Delete.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Drop = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			m.TenantId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleId", wireType)
			}
			m.RoleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoleId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateAt == nil {
				m.CreateAt = &timestamp.Timestamp{}
			}
			if err := m.CreateAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &Type{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hidden = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhyAddr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PhyAddr = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullAbility", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NullAbility = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoIncrement", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoIncrement = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Primary = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortIdx", wireType)
			}
			m.SortIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SortIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SortKey = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Default == nil {
				m.Default = &plan.Default{}
			}
			if err := m.Default.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AcInfo == nil {
				m.AcInfo = &AccessInfo{}
			}
			if err := m.AcInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColsDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColsDef = append(m.ColsDef, &ColDef{})
			if err := m.ColsDef[len(m.ColsDef)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NameIndex == nil {
				m.NameIndex = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NameIndex[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateSql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreateSql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.View = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tid", wireType)
			}
			m.Tid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mask", wireType)
			}
			m.Mask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mask |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Create", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Create == nil {
				m.Create = &TableDef{}
			}
			if err := m.Create.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockCmds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockCmds == nil {
				m.BlockCmds = make(map[uint64]*BlockCmd)
			}
			var mapkey uint64
			var mapvalue *BlockCmd
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &BlockCmd{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BlockCmds[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Drop = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabId", wireType)
			}
			m.TabId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DbId == nil {
				m.DbId = &DatabaseID{}
			}
			if err := m.DbId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SegmentID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SegmentID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SegmentID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegId", wireType)
			}
			m.SegId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TabId == nil {
				m.TabId = &TableID{}
			}
			if err := m.TabId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockId", wireType)
			}
			m.BlockId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SegId == nil {
				m.SegId = &SegmentID{}
			}
			if err := m.SegId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TSRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TSRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TSRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &timestamp.Timestamp{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.To == nil {
				m.To = &timestamp.Timestamp{}
			}
			if err := m.To.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScopeDesc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScopeDesc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScopeDesc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, &TableID{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncLogTailReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncLogTailReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncLogTailReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckpointTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CheckpointTs == nil {
				m.CheckpointTs = &timestamp.Timestamp{}
			}
			if err := m.CheckpointTs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &TSRange{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, &TableID{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Batch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Batch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Batch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attrs = append(m.Attrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vecs = append(m.Vecs, &Vector{})
			if err := m.Vecs[len(m.Vecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendCtx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendCtx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendCtx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcOff", wireType)
			}
			m.SrcOff = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcOff |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcLen", wireType)
			}
			m.SrcLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcLen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			m.DbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dest == nil {
				m.Dest = &BlockID{}
			}
			if err := m.Dest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestOff", wireType)
			}
			m.DestOff = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestOff |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestLen", wireType)
			}
			m.DestLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestLen |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdType", wireType)
			}
			m.CmdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdType |= CmdType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Csn", wireType)
			}
			m.Csn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Csn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bat == nil {
				m.Bat = &Batch{}
			}
			if err := m.Bat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctxs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ctxs = append(m.Ctxs, &AppendCtx{})
			if err := m.Ctxs[len(m.Ctxs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ts == nil {
				m.Ts = &timestamp.Timestamp{}
			}
			if err := m.Ts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockId == nil {
				m.BlockId = &BlockID{}
			}
			if err := m.BlockId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartRow", wireType)
			}
			m.StartRow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartRow |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRow", wireType)
			}
			m.MaxRow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRow |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommitTs == nil {
				m.CommitTs = &timestamp.Timestamp{}
			}
			if err := m.CommitTs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockId == nil {
				m.BlockId = &BlockID{}
			}
			if err := m.BlockId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mask", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mask = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommitTs == nil {
				m.CommitTs = &timestamp.Timestamp{}
			}
			if err := m.CommitTs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockId == nil {
				m.BlockId = &BlockID{}
			}
			if err := m.BlockId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColIndex", wireType)
			}
			m.ColIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColunmUpdateNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColunmUpdateNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColunmUpdateNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MvccUpdateCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MvccUpdateCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MvccUpdateCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdType", wireType)
			}
			m.CmdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdType |= CmdType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Csn", wireType)
			}
			m.Csn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Csn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			m.DbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockId == nil {
				m.BlockId = &BlockID{}
			}
			if err := m.BlockId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MvccNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MvccNode = append(m.MvccNode, &MvccUpdateCmd_MvccNodeType{})
			if err := m.MvccNode[len(m.MvccNode)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MvccUpdateCmd_MvccNodeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MvccNodeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MvccNodeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppendNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppendNode{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Def = &MvccUpdateCmd_MvccNodeType_AppendNode{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteNode{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Def = &MvccUpdateCmd_MvccNodeType_DeleteNode{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &timestamp.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeletedAt == nil {
				m.DeletedAt = &timestamp.Timestamp{}
			}
			if err := m.DeletedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaLoc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaLoc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaLoc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeltaLoc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &timestamp.Timestamp{}
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &timestamp.Timestamp{}
			}
			if err := m.End.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaseEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaseEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaseEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &UpdateNode{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Be", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Be == nil {
				m.Be = &BaseEntry{}
			}
			if err := m.Be.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockId == nil {
				m.BlockId = &BlockID{}
			}
			if err := m.BlockId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockState", wireType)
			}
			m.BlockState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockState |= EntryState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SegmentEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SegmentEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SegmentEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Be", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Be == nil {
				m.Be = &BaseEntry{}
			}
			if err := m.Be.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SegId == nil {
				m.SegId = &SegmentID{}
			}
			if err := m.SegId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegState", wireType)
			}
			m.SegState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegState |= EntryState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Be", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Be == nil {
				m.Be = &BaseEntry{}
			}
			if err := m.Be.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TabId == nil {
				m.TabId = &TableID{}
			}
			if err := m.TabId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TabDef == nil {
				m.TabDef = &TableDef{}
			}
			if err := m.TabDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Be", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Be == nil {
				m.Be = &BaseEntry{}
			}
			if err := m.Be.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DbId == nil {
				m.DbId = &DatabaseID{}
			}
			if err := m.DbId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AcInfo == nil {
				m.AcInfo = &AccessInfo{}
			}
			if err := m.AcInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntryCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntryCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntryCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdType", wireType)
			}
			m.CmdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdType |= CmdType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Csn", wireType)
			}
			m.Csn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Csn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entry == nil {
				m.Entry = &EntryCmd_EntryType{}
			}
			if err := m.Entry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntryCmd_EntryType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntryType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntryType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockEntry{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Def = &EntryCmd_EntryType_BlockEntry{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SegmentEntry{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Def = &EntryCmd_EntryType_SegEntry{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TableEntry{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Def = &EntryCmd_EntryType_TabEntry{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DatabaseEntry{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Def = &EntryCmd_EntryType_DbEntry{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactBlockCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactBlockCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactBlockCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdType", wireType)
			}
			m.CmdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdType |= CmdType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Csn", wireType)
			}
			m.Csn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Csn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &BlockID{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.To == nil {
				m.To = &BlockID{}
			}
			if err := m.To.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MergeBlocksCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MergeBlocksCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MergeBlocksCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdType", wireType)
			}
			m.CmdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdType |= CmdType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Csn", wireType)
			}
			m.Csn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Csn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedSegs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DroppedSegs = append(m.DroppedSegs, &SegmentID{})
			if err := m.DroppedSegs[len(m.DroppedSegs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedSegs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedSegs = append(m.CreatedSegs, &SegmentID{})
			if err := m.CreatedSegs[len(m.CreatedSegs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedBlks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DroppedBlks = append(m.DroppedBlks, &BlockID{})
			if err := m.DroppedBlks[len(m.DroppedBlks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedBlks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedBlks = append(m.CreatedBlks, &BlockID{})
			if err := m.CreatedBlks[len(m.CreatedBlks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Mapping = append(m.Mapping, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Mapping) == 0 {
					m.Mapping = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Mapping = append(m.Mapping, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Mapping", wireType)
			}
		case 8:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FromAddr = append(m.FromAddr, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FromAddr) == 0 {
					m.FromAddr = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FromAddr = append(m.FromAddr, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddr", wireType)
			}
		case 9:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ToAddr = append(m.ToAddr, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ToAddr) == 0 {
					m.ToAddr = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ToAddr = append(m.ToAddr, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddr", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComposedCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComposedCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComposedCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdType", wireType)
			}
			m.CmdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdType |= CmdType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LSN", wireType)
			}
			m.LSN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LSN |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmds = append(m.Cmds, &ComposedCmd_SubCmdType{})
			if err := m.Cmds[len(m.Cmds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComposedCmd_SubCmdType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubCmdType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubCmdType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryCmd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EntryCmd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Def = &ComposedCmd_SubCmdType_EntryCmd{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppendCmd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppendCmd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Def = &ComposedCmd_SubCmdType_AppendCmd{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MvccCmd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MvccUpdateCmd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Def = &ComposedCmd_SubCmdType_MvccCmd{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactCmd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CompactBlockCmd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Def = &ComposedCmd_SubCmdType_CompactCmd{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergeblksCmd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MergeBlocksCmd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Def = &ComposedCmd_SubCmdType_MergeblksCmd{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchCommands) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchCommands: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchCommands: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Desc == nil {
				m.Desc = &TSRange{}
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scope == nil {
				m.Scope = &ScopeDesc{}
			}
			if err := m.Scope.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commands", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commands = append(m.Commands, &ComposedCmd{})
			if err := m.Commands[len(m.Commands)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncLogTailResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncLogTailResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncLogTailResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckpointTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CheckpointTs == nil {
				m.CheckpointTs = &timestamp.Timestamp{}
			}
			if err := m.CheckpointTs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewCheckpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewCheckpoints = append(m.NewCheckpoints, &timestamp.Timestamp{})
			if err := m.NewCheckpoints[len(m.NewCheckpoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commands", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commands == nil {
				m.Commands = &BatchCommands{}
			}
			if err := m.Commands.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrecommitWriteCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrecommitWriteCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrecommitWriteCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntryList = append(m.EntryList, &Entry{})
			if err := m.EntryList[len(m.EntryList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryType", wireType)
			}
			m.EntryType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryType |= Entry_EntryType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseId", wireType)
			}
			m.DatabaseId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatabaseName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockId", wireType)
			}
			m.BlockId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &Batch{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApi = fmt.Errorf("proto: unexpected end of group")
)
