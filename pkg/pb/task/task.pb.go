// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: task.proto

package task

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TaskStatus task status
type TaskStatus int32

const (
	// Create is the state of waiting to be scheduled.
	TaskStatus_Created TaskStatus = 0
	// Running is running state. Task is assigned to a CN node and is running
	TaskStatus_Running TaskStatus = 1
	// Completed the task has been completed.
	TaskStatus_Completed TaskStatus = 2
)

var TaskStatus_name = map[int32]string{
	0: "Created",
	1: "Running",
	2: "Completed",
}

var TaskStatus_value = map[string]int32{
	"Created":   0,
	"Running":   1,
	"Completed": 2,
}

func (x TaskStatus) String() string {
	return proto.EnumName(TaskStatus_name, int32(x))
}

func (TaskStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ce5d8dd45b4a91ff, []int{0}
}

// TaskCode task code
type TaskCode int32

const (
	// TestOnly reserved for testing.
	TaskCode_TestOnly TaskCode = 0
	// SystemInit system init task
	TaskCode_SystemInit TaskCode = 1
	// MetricLogMerge handle metric/log exported data merge task
	TaskCode_MetricLogMerge TaskCode = 2
	// MetricStorageUsage handle metric server_storage_usage collection
	TaskCode_MetricStorageUsage TaskCode = 3
)

var TaskCode_name = map[int32]string{
	0: "TestOnly",
	1: "SystemInit",
	2: "MetricLogMerge",
	3: "MetricStorageUsage",
}

var TaskCode_value = map[string]int32{
	"TestOnly":           0,
	"SystemInit":         1,
	"MetricLogMerge":     2,
	"MetricStorageUsage": 3,
}

func (x TaskCode) String() string {
	return proto.EnumName(TaskCode_name, int32(x))
}

func (TaskCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ce5d8dd45b4a91ff, []int{1}
}

// ResultCode result code
type ResultCode int32

const (
	// Success success
	ResultCode_Success ResultCode = 0
	// Failed failed
	ResultCode_Failed ResultCode = 1
)

var ResultCode_name = map[int32]string{
	0: "Success",
	1: "Failed",
}

var ResultCode_value = map[string]int32{
	"Success": 0,
	"Failed":  1,
}

func (x ResultCode) String() string {
	return proto.EnumName(ResultCode_name, int32(x))
}

func (ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ce5d8dd45b4a91ff, []int{2}
}

// TaskMetadata is a task metadata abstraction that can be scheduled for execution at any CN node.
type TaskMetadata struct {
	// ID task id, global unique
	ID string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// Executor used to select a particular task executor to run a task
	Executor TaskCode `protobuf:"varint,2,opt,name=Executor,proto3,enum=task.TaskCode" json:"Executor,omitempty"`
	// Context context needed to run the task
	Context []byte `protobuf:"bytes,3,opt,name=Context,proto3" json:"Context,omitempty"`
	// Options options for execute task
	Options              TaskOptions `protobuf:"bytes,4,opt,name=Options,proto3" json:"Options"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *TaskMetadata) Reset()         { *m = TaskMetadata{} }
func (m *TaskMetadata) String() string { return proto.CompactTextString(m) }
func (*TaskMetadata) ProtoMessage()    {}
func (*TaskMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce5d8dd45b4a91ff, []int{0}
}
func (m *TaskMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskMetadata.Merge(m, src)
}
func (m *TaskMetadata) XXX_Size() int {
	return m.Size()
}
func (m *TaskMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_TaskMetadata proto.InternalMessageInfo

func (m *TaskMetadata) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *TaskMetadata) GetExecutor() TaskCode {
	if m != nil {
		return m.Executor
	}
	return TaskCode_TestOnly
}

func (m *TaskMetadata) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *TaskMetadata) GetOptions() TaskOptions {
	if m != nil {
		return m.Options
	}
	return TaskOptions{}
}

// TaskOptions task options
type TaskOptions struct {
	// MaxRetryTimes 0 means disable retry
	MaxRetryTimes uint32 `protobuf:"varint,1,opt,name=MaxRetryTimes,proto3" json:"MaxRetryTimes,omitempty"`
	// RetryInterval retry interval
	RetryInterval int64 `protobuf:"varint,2,opt,name=RetryInterval,proto3" json:"RetryInterval,omitempty"`
	// DelayDuration delay duration. Controls how long a task is delayed before it is scheduled for
	// execution.
	DelayDuration int64 `protobuf:"varint,3,opt,name=DelayDuration,proto3" json:"DelayDuration,omitempty"`
	// Concurrency is the max number of a task running at the same time. 0 means no limits.
	Concurrency          uint32   `protobuf:"varint,4,opt,name=Concurrency,proto3" json:"Concurrency,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TaskOptions) Reset()         { *m = TaskOptions{} }
func (m *TaskOptions) String() string { return proto.CompactTextString(m) }
func (*TaskOptions) ProtoMessage()    {}
func (*TaskOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce5d8dd45b4a91ff, []int{1}
}
func (m *TaskOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskOptions.Merge(m, src)
}
func (m *TaskOptions) XXX_Size() int {
	return m.Size()
}
func (m *TaskOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskOptions.DiscardUnknown(m)
}

var xxx_messageInfo_TaskOptions proto.InternalMessageInfo

func (m *TaskOptions) GetMaxRetryTimes() uint32 {
	if m != nil {
		return m.MaxRetryTimes
	}
	return 0
}

func (m *TaskOptions) GetRetryInterval() int64 {
	if m != nil {
		return m.RetryInterval
	}
	return 0
}

func (m *TaskOptions) GetDelayDuration() int64 {
	if m != nil {
		return m.DelayDuration
	}
	return 0
}

func (m *TaskOptions) GetConcurrency() uint32 {
	if m != nil {
		return m.Concurrency
	}
	return 0
}

// ExecuteResult task execute result
type ExecuteResult struct {
	// Code result code
	Code ResultCode `protobuf:"varint,1,opt,name=Code,proto3,enum=task.ResultCode" json:"Code,omitempty"`
	// Error error message
	Error                string   `protobuf:"bytes,2,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExecuteResult) Reset()         { *m = ExecuteResult{} }
func (m *ExecuteResult) String() string { return proto.CompactTextString(m) }
func (*ExecuteResult) ProtoMessage()    {}
func (*ExecuteResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce5d8dd45b4a91ff, []int{2}
}
func (m *ExecuteResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteResult.Merge(m, src)
}
func (m *ExecuteResult) XXX_Size() int {
	return m.Size()
}
func (m *ExecuteResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteResult.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteResult proto.InternalMessageInfo

func (m *ExecuteResult) GetCode() ResultCode {
	if m != nil {
		return m.Code
	}
	return ResultCode_Success
}

func (m *ExecuteResult) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// Task task execute info.
type Task struct {
	ID uint64 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// TaskMetadata task metadata
	Metadata TaskMetadata `protobuf:"bytes,2,opt,name=Metadata,proto3" json:"Metadata"`
	// ParentTaskID used to record the parent task of the current task
	ParentTaskID string `protobuf:"bytes,3,opt,name=ParentTaskID,proto3" json:"ParentTaskID,omitempty"`
	// TaskStatus task status
	Status TaskStatus `protobuf:"varint,4,opt,name=Status,proto3,enum=task.TaskStatus" json:"Status,omitempty"`
	// TaskRunner is the UUID of the CN node which the task run is assigned to
	TaskRunner string `protobuf:"bytes,5,opt,name=TaskRunner,proto3" json:"TaskRunner,omitempty"`
	// Epoch indicates how many times the current task is scheduled, the first time it is scheduled
	// is 1. Each time it is scheduled, Epoch++.
	Epoch uint32 `protobuf:"varint,6,opt,name=Epoch,proto3" json:"Epoch,omitempty"`
	// LastHeartbeat time of the last heartbeat reported by TaskRunner. Unix timestamp in ms
	LastHeartbeat int64 `protobuf:"varint,7,opt,name=LastHeartbeat,proto3" json:"LastHeartbeat,omitempty"`
	// CreateAt time of the task created. Unix timestamp in ms
	CreateAt int64 `protobuf:"varint,8,opt,name=CreateAt,proto3" json:"CreateAt,omitempty"`
	// CompletedAt time of the task completed. Unix timestamp in ms
	CompletedAt int64 `protobuf:"varint,9,opt,name=CompletedAt,proto3" json:"CompletedAt,omitempty"`
	// ExecuteResult execute result
	ExecuteResult        *ExecuteResult `protobuf:"bytes,10,opt,name=ExecuteResult,proto3" json:"ExecuteResult,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Task) Reset()         { *m = Task{} }
func (m *Task) String() string { return proto.CompactTextString(m) }
func (*Task) ProtoMessage()    {}
func (*Task) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce5d8dd45b4a91ff, []int{3}
}
func (m *Task) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Task) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Task.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Task) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Task.Merge(m, src)
}
func (m *Task) XXX_Size() int {
	return m.Size()
}
func (m *Task) XXX_DiscardUnknown() {
	xxx_messageInfo_Task.DiscardUnknown(m)
}

var xxx_messageInfo_Task proto.InternalMessageInfo

func (m *Task) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Task) GetMetadata() TaskMetadata {
	if m != nil {
		return m.Metadata
	}
	return TaskMetadata{}
}

func (m *Task) GetParentTaskID() string {
	if m != nil {
		return m.ParentTaskID
	}
	return ""
}

func (m *Task) GetStatus() TaskStatus {
	if m != nil {
		return m.Status
	}
	return TaskStatus_Created
}

func (m *Task) GetTaskRunner() string {
	if m != nil {
		return m.TaskRunner
	}
	return ""
}

func (m *Task) GetEpoch() uint32 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *Task) GetLastHeartbeat() int64 {
	if m != nil {
		return m.LastHeartbeat
	}
	return 0
}

func (m *Task) GetCreateAt() int64 {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *Task) GetCompletedAt() int64 {
	if m != nil {
		return m.CompletedAt
	}
	return 0
}

func (m *Task) GetExecuteResult() *ExecuteResult {
	if m != nil {
		return m.ExecuteResult
	}
	return nil
}

// CronTask task execute info.
type CronTask struct {
	ID uint64 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// TaskMetadata task metadata
	Metadata TaskMetadata `protobuf:"bytes,2,opt,name=Metadata,proto3" json:"Metadata"`
	// CronExpr cron expr
	CronExpr string `protobuf:"bytes,3,opt,name=CronExpr,proto3" json:"CronExpr,omitempty"`
	// NextTime the next time it should be scheduled for execution. Unix timestamp in ms
	NextTime int64 `protobuf:"varint,4,opt,name=NextTime,proto3" json:"NextTime,omitempty"`
	// TriggerTimes the number of times it was triggered
	TriggerTimes uint64 `protobuf:"varint,5,opt,name=TriggerTimes,proto3" json:"TriggerTimes,omitempty"`
	// CreateAt time of the cron task created. Unix timestamp in ms
	CreateAt int64 `protobuf:"varint,6,opt,name=CreateAt,proto3" json:"CreateAt,omitempty"`
	// CreateAt time of the cron task created. Unix timestamp in ms
	UpdateAt             int64    `protobuf:"varint,7,opt,name=UpdateAt,proto3" json:"UpdateAt,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CronTask) Reset()         { *m = CronTask{} }
func (m *CronTask) String() string { return proto.CompactTextString(m) }
func (*CronTask) ProtoMessage()    {}
func (*CronTask) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce5d8dd45b4a91ff, []int{4}
}
func (m *CronTask) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CronTask) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CronTask.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CronTask) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CronTask.Merge(m, src)
}
func (m *CronTask) XXX_Size() int {
	return m.Size()
}
func (m *CronTask) XXX_DiscardUnknown() {
	xxx_messageInfo_CronTask.DiscardUnknown(m)
}

var xxx_messageInfo_CronTask proto.InternalMessageInfo

func (m *CronTask) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *CronTask) GetMetadata() TaskMetadata {
	if m != nil {
		return m.Metadata
	}
	return TaskMetadata{}
}

func (m *CronTask) GetCronExpr() string {
	if m != nil {
		return m.CronExpr
	}
	return ""
}

func (m *CronTask) GetNextTime() int64 {
	if m != nil {
		return m.NextTime
	}
	return 0
}

func (m *CronTask) GetTriggerTimes() uint64 {
	if m != nil {
		return m.TriggerTimes
	}
	return 0
}

func (m *CronTask) GetCreateAt() int64 {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *CronTask) GetUpdateAt() int64 {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

func init() {
	proto.RegisterEnum("task.TaskStatus", TaskStatus_name, TaskStatus_value)
	proto.RegisterEnum("task.TaskCode", TaskCode_name, TaskCode_value)
	proto.RegisterEnum("task.ResultCode", ResultCode_name, ResultCode_value)
	proto.RegisterType((*TaskMetadata)(nil), "task.TaskMetadata")
	proto.RegisterType((*TaskOptions)(nil), "task.TaskOptions")
	proto.RegisterType((*ExecuteResult)(nil), "task.ExecuteResult")
	proto.RegisterType((*Task)(nil), "task.Task")
	proto.RegisterType((*CronTask)(nil), "task.CronTask")
}

func init() { proto.RegisterFile("task.proto", fileDescriptor_ce5d8dd45b4a91ff) }

var fileDescriptor_ce5d8dd45b4a91ff = []byte{
	// 680 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0xcd, 0x6e, 0xda, 0x4c,
	0x14, 0x65, 0x80, 0xf0, 0x73, 0xf9, 0x91, 0xbf, 0xf9, 0x3e, 0x7d, 0xb2, 0x58, 0x50, 0x84, 0x52,
	0x09, 0x21, 0x35, 0xa8, 0xb4, 0x5d, 0x74, 0x55, 0x25, 0x90, 0xaa, 0xa8, 0xa1, 0xa9, 0x06, 0xb2,
	0xe9, 0x6e, 0x30, 0xb7, 0x8e, 0x15, 0xf0, 0x58, 0xe3, 0x71, 0x05, 0x4f, 0xd2, 0x75, 0xdf, 0x26,
	0xcb, 0x3c, 0x41, 0xd5, 0x46, 0xdd, 0xf7, 0x15, 0xaa, 0x99, 0x01, 0x07, 0x67, 0xdd, 0x9d, 0xcf,
	0x39, 0x77, 0xee, 0xdc, 0x7b, 0x8e, 0x6d, 0x00, 0xc5, 0xe3, 0x9b, 0x93, 0x48, 0x0a, 0x25, 0x68,
	0x51, 0x3f, 0xb7, 0x9e, 0xf9, 0x81, 0xba, 0x4e, 0x16, 0x27, 0x9e, 0x58, 0x0f, 0x7c, 0xe1, 0x8b,
	0x81, 0x11, 0x17, 0xc9, 0x67, 0x83, 0x0c, 0x30, 0x4f, 0xf6, 0x50, 0xf7, 0x2b, 0x81, 0xfa, 0x9c,
	0xc7, 0x37, 0x53, 0x54, 0x7c, 0xc9, 0x15, 0xa7, 0x4d, 0xc8, 0x4f, 0xc6, 0x2e, 0xe9, 0x90, 0x5e,
	0x95, 0xe5, 0x27, 0x63, 0xda, 0x87, 0xca, 0xf9, 0x06, 0xbd, 0x44, 0x09, 0xe9, 0xe6, 0x3b, 0xa4,
	0xd7, 0x1c, 0x36, 0x4f, 0xcc, 0xa5, 0xfa, 0xd4, 0x48, 0x2c, 0x91, 0xa5, 0x3a, 0x75, 0xa1, 0x3c,
	0x12, 0xa1, 0xc2, 0x8d, 0x72, 0x0b, 0x1d, 0xd2, 0xab, 0xb3, 0x3d, 0xa4, 0xcf, 0xa1, 0x7c, 0x19,
	0xa9, 0x40, 0x84, 0xb1, 0x5b, 0xec, 0x90, 0x5e, 0x6d, 0xf8, 0xcf, 0x43, 0x93, 0x9d, 0x70, 0x56,
	0xbc, 0xfd, 0xfe, 0x24, 0xc7, 0xf6, 0x75, 0xdd, 0x6f, 0x04, 0x6a, 0x07, 0x32, 0x3d, 0x86, 0xc6,
	0x94, 0x6f, 0x18, 0x2a, 0xb9, 0x9d, 0x07, 0x6b, 0x8c, 0xcd, 0x8c, 0x0d, 0x96, 0x25, 0x75, 0x95,
	0x41, 0x93, 0x50, 0xa1, 0xfc, 0xc2, 0x57, 0x66, 0xe6, 0x02, 0xcb, 0x92, 0xba, 0x6a, 0x8c, 0x2b,
	0xbe, 0x1d, 0x27, 0x92, 0xeb, 0xee, 0x66, 0xdc, 0x02, 0xcb, 0x92, 0xb4, 0x03, 0xb5, 0x91, 0x08,
	0xbd, 0x44, 0x4a, 0x0c, 0xbd, 0xad, 0x19, 0xbc, 0xc1, 0x0e, 0xa9, 0xee, 0x7b, 0x68, 0xd8, 0xe5,
	0x91, 0x61, 0x9c, 0xac, 0x14, 0x3d, 0x86, 0xa2, 0xf6, 0xc4, 0xcc, 0xd6, 0x1c, 0x3a, 0x76, 0x49,
	0xab, 0x19, 0xaf, 0x8c, 0x4a, 0xff, 0x83, 0xa3, 0x73, 0x29, 0x77, 0x86, 0x56, 0x99, 0x05, 0xdd,
	0xdf, 0x79, 0x28, 0xea, 0x85, 0x0f, 0x22, 0x28, 0x9a, 0x08, 0x5e, 0x42, 0x65, 0x1f, 0x8f, 0x39,
	0x51, 0x1b, 0xd2, 0x07, 0xf7, 0xf6, 0xca, 0xce, 0xbe, 0xb4, 0x92, 0x76, 0xa1, 0xfe, 0x91, 0x4b,
	0x0c, 0x95, 0xae, 0x9a, 0x8c, 0xcd, 0x8a, 0x55, 0x96, 0xe1, 0x68, 0x0f, 0x4a, 0x33, 0xc5, 0x55,
	0x62, 0x53, 0x49, 0x07, 0xd6, 0xaa, 0xe5, 0xd9, 0x4e, 0xa7, 0x6d, 0x00, 0xcd, 0xb2, 0x24, 0x0c,
	0x51, 0xba, 0x47, 0xa6, 0xd7, 0x01, 0x63, 0x56, 0x8a, 0x84, 0x77, 0xed, 0x96, 0x8c, 0x4b, 0x16,
	0x68, 0x9f, 0x2f, 0x78, 0xac, 0xde, 0x21, 0x97, 0x6a, 0x81, 0x5c, 0xb9, 0x65, 0xeb, 0x73, 0x86,
	0xa4, 0x2d, 0xa8, 0x8c, 0x24, 0x72, 0x85, 0xa7, 0xca, 0xad, 0x98, 0x82, 0x14, 0xdb, 0x0c, 0xd6,
	0xd1, 0x0a, 0x15, 0x2e, 0x4f, 0x95, 0x5b, 0x35, 0xf2, 0x21, 0x45, 0x5f, 0x3f, 0xca, 0xc0, 0x05,
	0x63, 0xd1, 0xbf, 0x76, 0x95, 0x8c, 0xc4, 0xb2, 0x95, 0xdd, 0x5f, 0x44, 0xdf, 0x2c, 0xc2, 0xbf,
	0xe8, 0x7a, 0xcb, 0x76, 0x3c, 0xdf, 0x44, 0x72, 0xe7, 0x78, 0x8a, 0xb5, 0xf6, 0x01, 0x37, 0x4a,
	0xbf, 0xa8, 0xc6, 0xef, 0x02, 0x4b, 0xb1, 0x4e, 0x6b, 0x2e, 0x03, 0xdf, 0x47, 0x69, 0x5f, 0xee,
	0x23, 0x33, 0x47, 0x86, 0xcb, 0xf8, 0x54, 0x7a, 0xe4, 0x53, 0x0b, 0x2a, 0x57, 0xd1, 0xd2, 0x6a,
	0xd6, 0xe4, 0x14, 0xf7, 0x5f, 0xd9, 0xec, 0x76, 0x49, 0xd6, 0xa0, 0x6c, 0x4f, 0x2d, 0x9d, 0x9c,
	0x06, 0x3a, 0xc0, 0x20, 0xf4, 0x1d, 0x42, 0x1b, 0x50, 0x4d, 0x8d, 0x75, 0xf2, 0xfd, 0x39, 0x54,
	0xf6, 0xdf, 0x38, 0xad, 0x43, 0x65, 0x8e, 0xb1, 0xba, 0x0c, 0x57, 0x5b, 0x27, 0x47, 0x9b, 0x00,
	0xb3, 0x6d, 0xac, 0x70, 0x3d, 0x09, 0x03, 0xe5, 0x10, 0x4a, 0xa1, 0x39, 0x45, 0x25, 0x03, 0xef,
	0x42, 0xf8, 0x53, 0x94, 0x3e, 0x3a, 0x79, 0xfa, 0x3f, 0x50, 0xcb, 0xcd, 0x94, 0x90, 0xdc, 0xc7,
	0xab, 0x98, 0xfb, 0xe8, 0x14, 0xfa, 0x4f, 0x01, 0x1e, 0xbe, 0x07, 0x7d, 0xff, 0x2c, 0xf1, 0x3c,
	0x8c, 0x63, 0x27, 0x47, 0x01, 0x4a, 0x6f, 0x79, 0xb0, 0xc2, 0xa5, 0x43, 0xce, 0xde, 0xdc, 0xfd,
	0x6c, 0x93, 0xdb, 0xfb, 0x36, 0xb9, 0xbb, 0x6f, 0x93, 0x1f, 0xf7, 0x6d, 0xf2, 0xe9, 0xf0, 0xc7,
	0xb6, 0xe6, 0x4a, 0x06, 0x1b, 0x21, 0x03, 0x3f, 0x08, 0xf7, 0x20, 0xc4, 0x41, 0x74, 0xe3, 0x0f,
	0xa2, 0xc5, 0x40, 0xa7, 0xb4, 0x28, 0x99, 0xff, 0xdb, 0x8b, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff,
	0xbd, 0x41, 0x97, 0x03, 0x22, 0x05, 0x00, 0x00,
}

func (m *TaskMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTask(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Context) > 0 {
		i -= len(m.Context)
		copy(dAtA[i:], m.Context)
		i = encodeVarintTask(dAtA, i, uint64(len(m.Context)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Executor != 0 {
		i = encodeVarintTask(dAtA, i, uint64(m.Executor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintTask(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TaskOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Concurrency != 0 {
		i = encodeVarintTask(dAtA, i, uint64(m.Concurrency))
		i--
		dAtA[i] = 0x20
	}
	if m.DelayDuration != 0 {
		i = encodeVarintTask(dAtA, i, uint64(m.DelayDuration))
		i--
		dAtA[i] = 0x18
	}
	if m.RetryInterval != 0 {
		i = encodeVarintTask(dAtA, i, uint64(m.RetryInterval))
		i--
		dAtA[i] = 0x10
	}
	if m.MaxRetryTimes != 0 {
		i = encodeVarintTask(dAtA, i, uint64(m.MaxRetryTimes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecuteResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintTask(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintTask(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Task) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Task) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Task) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExecuteResult != nil {
		{
			size, err := m.ExecuteResult.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTask(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.CompletedAt != 0 {
		i = encodeVarintTask(dAtA, i, uint64(m.CompletedAt))
		i--
		dAtA[i] = 0x48
	}
	if m.CreateAt != 0 {
		i = encodeVarintTask(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x40
	}
	if m.LastHeartbeat != 0 {
		i = encodeVarintTask(dAtA, i, uint64(m.LastHeartbeat))
		i--
		dAtA[i] = 0x38
	}
	if m.Epoch != 0 {
		i = encodeVarintTask(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x30
	}
	if len(m.TaskRunner) > 0 {
		i -= len(m.TaskRunner)
		copy(dAtA[i:], m.TaskRunner)
		i = encodeVarintTask(dAtA, i, uint64(len(m.TaskRunner)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != 0 {
		i = encodeVarintTask(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ParentTaskID) > 0 {
		i -= len(m.ParentTaskID)
		copy(dAtA[i:], m.ParentTaskID)
		i = encodeVarintTask(dAtA, i, uint64(len(m.ParentTaskID)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTask(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.ID != 0 {
		i = encodeVarintTask(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CronTask) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CronTask) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CronTask) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UpdateAt != 0 {
		i = encodeVarintTask(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x38
	}
	if m.CreateAt != 0 {
		i = encodeVarintTask(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x30
	}
	if m.TriggerTimes != 0 {
		i = encodeVarintTask(dAtA, i, uint64(m.TriggerTimes))
		i--
		dAtA[i] = 0x28
	}
	if m.NextTime != 0 {
		i = encodeVarintTask(dAtA, i, uint64(m.NextTime))
		i--
		dAtA[i] = 0x20
	}
	if len(m.CronExpr) > 0 {
		i -= len(m.CronExpr)
		copy(dAtA[i:], m.CronExpr)
		i = encodeVarintTask(dAtA, i, uint64(len(m.CronExpr)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTask(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.ID != 0 {
		i = encodeVarintTask(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTask(dAtA []byte, offset int, v uint64) int {
	offset -= sovTask(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TaskMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovTask(uint64(l))
	}
	if m.Executor != 0 {
		n += 1 + sovTask(uint64(m.Executor))
	}
	l = len(m.Context)
	if l > 0 {
		n += 1 + l + sovTask(uint64(l))
	}
	l = m.Options.Size()
	n += 1 + l + sovTask(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TaskOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxRetryTimes != 0 {
		n += 1 + sovTask(uint64(m.MaxRetryTimes))
	}
	if m.RetryInterval != 0 {
		n += 1 + sovTask(uint64(m.RetryInterval))
	}
	if m.DelayDuration != 0 {
		n += 1 + sovTask(uint64(m.DelayDuration))
	}
	if m.Concurrency != 0 {
		n += 1 + sovTask(uint64(m.Concurrency))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovTask(uint64(m.Code))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovTask(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Task) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovTask(uint64(m.ID))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTask(uint64(l))
	l = len(m.ParentTaskID)
	if l > 0 {
		n += 1 + l + sovTask(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTask(uint64(m.Status))
	}
	l = len(m.TaskRunner)
	if l > 0 {
		n += 1 + l + sovTask(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovTask(uint64(m.Epoch))
	}
	if m.LastHeartbeat != 0 {
		n += 1 + sovTask(uint64(m.LastHeartbeat))
	}
	if m.CreateAt != 0 {
		n += 1 + sovTask(uint64(m.CreateAt))
	}
	if m.CompletedAt != 0 {
		n += 1 + sovTask(uint64(m.CompletedAt))
	}
	if m.ExecuteResult != nil {
		l = m.ExecuteResult.Size()
		n += 1 + l + sovTask(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CronTask) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovTask(uint64(m.ID))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTask(uint64(l))
	l = len(m.CronExpr)
	if l > 0 {
		n += 1 + l + sovTask(uint64(l))
	}
	if m.NextTime != 0 {
		n += 1 + sovTask(uint64(m.NextTime))
	}
	if m.TriggerTimes != 0 {
		n += 1 + sovTask(uint64(m.TriggerTimes))
	}
	if m.CreateAt != 0 {
		n += 1 + sovTask(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 1 + sovTask(uint64(m.UpdateAt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTask(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTask(x uint64) (n int) {
	return sovTask(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TaskMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTask
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTask
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executor", wireType)
			}
			m.Executor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Executor |= TaskCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTask
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = append(m.Context[:0], dAtA[iNdEx:postIndex]...)
			if m.Context == nil {
				m.Context = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTask
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTask(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTask
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTask
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRetryTimes", wireType)
			}
			m.MaxRetryTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRetryTimes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryInterval", wireType)
			}
			m.RetryInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetryInterval |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayDuration", wireType)
			}
			m.DelayDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelayDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Concurrency", wireType)
			}
			m.Concurrency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Concurrency |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTask(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTask
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTask
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= ResultCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTask
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTask(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTask
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Task) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTask
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Task: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Task: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTask
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentTaskID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTask
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentTaskID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TaskStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskRunner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTask
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskRunner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeartbeat", wireType)
			}
			m.LastHeartbeat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastHeartbeat |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedAt", wireType)
			}
			m.CompletedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecuteResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTask
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecuteResult == nil {
				m.ExecuteResult = &ExecuteResult{}
			}
			if err := m.ExecuteResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTask(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTask
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CronTask) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTask
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CronTask: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CronTask: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTask
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CronExpr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTask
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTask
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CronExpr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextTime", wireType)
			}
			m.NextTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerTimes", wireType)
			}
			m.TriggerTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TriggerTimes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTask
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTask(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTask
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTask(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTask
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTask
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTask
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTask
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTask
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTask
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTask        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTask          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTask = fmt.Errorf("proto: unexpected end of group")
)
