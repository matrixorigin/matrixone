// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: txn.proto

package txn

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	metadata "github.com/matrixorigin/matrixone/pkg/pb/metadata"
	timestamp "github.com/matrixorigin/matrixone/pkg/pb/timestamp"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// TxnStatus transaction status
type TxnStatus int32

const (
	// Active is the state of transaction creation, in this state, can execute the
	// transaction Read/Write/Commit/Rollback.
	TxnStatus_Active TxnStatus = 0
	// Prepared for distributed transactions across DNs, a 2pc commit is performed,
	// and the prepared status means that the transaction on a DN was executed
	// successfully in the first phase.
	//
	// Note that this status needs to be logged to the LogService. Once the first
	// phase of a transaction is successful, data cannot be lost.
	TxnStatus_Prepared TxnStatus = 1
	// Committing for distributed transactions across DNs, once all DNs have completed
	// the first phase, the transaction enters the Committing state and initiates an
	// asynchronous process to handle the commit of temporary data.
	//
	// Note that when all DNs involved are in the prepared state, the distributed
	// transaction can be considered committed because all data has been written
	// successfully. The subsequent Committing process just explicitly converts these
	// writes into committed data.
	//
	// Note that the state exists only in memory and is not persisted to the LogService.
	// It can be restored through the Prepared state, if all(DN).Status == Prepared.
	TxnStatus_Committing TxnStatus = 2
	// Committed after the Committing phase has transformed all DN data involved into
	// committed data, the status of the distributed transaction is explicitly recorded
	// as Committed.
	//
	// Note that this status needs to be logged to the LogService
	TxnStatus_Committed TxnStatus = 3
	// Aborting a client initiating a Rollback call or a distributed transaction that has
	// any error in the first phase will enter the Aborting state. This state starts an
	// asynchronous task to clean up the temporary data written by the transaction.
	//
	// Note that the state exists only in memory and is not persisted to the LogService.
	// It can be restored through the Prepared state, if Any(DN).Status != Prepared.
	TxnStatus_Aborting TxnStatus = 4
	// Aborted after the Aborting phase, all data involved in the DN is cleaned up and
	// the transaction status is explicitly recorded as Aborted.
	//
	// Note that this status needs to be logged to the LogService
	TxnStatus_Aborted TxnStatus = 5
)

var TxnStatus_name = map[int32]string{
	0: "Active",
	1: "Prepared",
	2: "Committing",
	3: "Committed",
	4: "Aborting",
	5: "Aborted",
}

var TxnStatus_value = map[string]int32{
	"Active":     0,
	"Prepared":   1,
	"Committing": 2,
	"Committed":  3,
	"Aborting":   4,
	"Aborted":    5,
}

func (x TxnStatus) String() string {
	return proto.EnumName(TxnStatus_name, int32(x))
}

func (TxnStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{0}
}

// TxnMeta transaction metadata
type TxnMeta struct {
	// ID transaction id, generated at the CN node at the time of transaction creation,
	// globally unique.
	ID []byte `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Status transaction status
	Status TxnStatus `protobuf:"varint,2,opt,name=status,proto3,enum=txn.TxnStatus" json:"status,omitempty"`
	// SnapshotTS transaction read timestamp, generated at the CN node at the time of
	// transaction creation. All data.TS < txn.SnapshotTS is visible for the current
	// transaction.
	SnapshotTS           timestamp.Timestamp `protobuf:"bytes,3,opt,name=snapshotTS,proto3" json:"snapshotTS"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TxnMeta) Reset()         { *m = TxnMeta{} }
func (m *TxnMeta) String() string { return proto.CompactTextString(m) }
func (*TxnMeta) ProtoMessage()    {}
func (*TxnMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{0}
}
func (m *TxnMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnMeta.Merge(m, src)
}
func (m *TxnMeta) XXX_Size() int {
	return m.Size()
}
func (m *TxnMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnMeta.DiscardUnknown(m)
}

var xxx_messageInfo_TxnMeta proto.InternalMessageInfo

func (m *TxnMeta) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *TxnMeta) GetStatus() TxnStatus {
	if m != nil {
		return m.Status
	}
	return TxnStatus_Active
}

func (m *TxnMeta) GetSnapshotTS() timestamp.Timestamp {
	if m != nil {
		return m.SnapshotTS
	}
	return timestamp.Timestamp{}
}

// TxnError all explicit errors in transaction operations.
type TxnError struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnError) Reset()         { *m = TxnError{} }
func (m *TxnError) String() string { return proto.CompactTextString(m) }
func (*TxnError) ProtoMessage()    {}
func (*TxnError) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{1}
}
func (m *TxnError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnError.Merge(m, src)
}
func (m *TxnError) XXX_Size() int {
	return m.Size()
}
func (m *TxnError) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnError.DiscardUnknown(m)
}

var xxx_messageInfo_TxnError proto.InternalMessageInfo

// DNOpRequest transaction request, CN -> DN.
type DNOpRequest struct {
	// OpCode request operation type
	OpCode uint32 `protobuf:"varint,1,opt,name=opCode,proto3" json:"opCode,omitempty"`
	// Payload the content of the request, TxnClient does not perceive the exact
	// format and content
	Payload []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	// Target target to which the request was sent
	Target               *metadata.DN `protobuf:"bytes,3,opt,name=target,proto3" json:"target,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *DNOpRequest) Reset()         { *m = DNOpRequest{} }
func (m *DNOpRequest) String() string { return proto.CompactTextString(m) }
func (*DNOpRequest) ProtoMessage()    {}
func (*DNOpRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{2}
}
func (m *DNOpRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DNOpRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DNOpRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DNOpRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNOpRequest.Merge(m, src)
}
func (m *DNOpRequest) XXX_Size() int {
	return m.Size()
}
func (m *DNOpRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DNOpRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DNOpRequest proto.InternalMessageInfo

func (m *DNOpRequest) GetOpCode() uint32 {
	if m != nil {
		return m.OpCode
	}
	return 0
}

func (m *DNOpRequest) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *DNOpRequest) GetTarget() *metadata.DN {
	if m != nil {
		return m.Target
	}
	return nil
}

// DNOpResponse transaction response, DN -> CN. A request corresponds to a response.
type DNOpResponse struct {
	// Payload response payload
	Payload              []byte   `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DNOpResponse) Reset()         { *m = DNOpResponse{} }
func (m *DNOpResponse) String() string { return proto.CompactTextString(m) }
func (*DNOpResponse) ProtoMessage()    {}
func (*DNOpResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{3}
}
func (m *DNOpResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DNOpResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DNOpResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DNOpResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNOpResponse.Merge(m, src)
}
func (m *DNOpResponse) XXX_Size() int {
	return m.Size()
}
func (m *DNOpResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DNOpResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DNOpResponse proto.InternalMessageInfo

func (m *DNOpResponse) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func init() {
	proto.RegisterEnum("txn.TxnStatus", TxnStatus_name, TxnStatus_value)
	proto.RegisterType((*TxnMeta)(nil), "txn.TxnMeta")
	proto.RegisterType((*TxnError)(nil), "txn.TxnError")
	proto.RegisterType((*DNOpRequest)(nil), "txn.DNOpRequest")
	proto.RegisterType((*DNOpResponse)(nil), "txn.DNOpResponse")
}

func init() { proto.RegisterFile("txn.proto", fileDescriptor_4f782e76b37adb9a) }

var fileDescriptor_4f782e76b37adb9a = []byte{
	// 394 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x54, 0x91, 0xc1, 0x6e, 0xd4, 0x30,
	0x10, 0x86, 0xeb, 0x6c, 0xc9, 0x76, 0x67, 0xd3, 0x25, 0xb2, 0x50, 0xb5, 0xea, 0x61, 0xbb, 0x8a,
	0x10, 0x8a, 0x10, 0x24, 0x52, 0xb9, 0xf5, 0xd6, 0xed, 0x72, 0xe0, 0x40, 0x41, 0x69, 0x4e, 0x5c,
	0x90, 0x53, 0x9b, 0xd4, 0x82, 0xd8, 0xc6, 0x9e, 0xa0, 0xf0, 0x00, 0xbc, 0x5b, 0x8f, 0x3c, 0x41,
	0x85, 0xf2, 0x24, 0xa8, 0xde, 0x6c, 0xdb, 0xbd, 0xcd, 0x37, 0xff, 0x78, 0xfc, 0x8f, 0x7e, 0x98,
	0x60, 0xa7, 0x32, 0x63, 0x35, 0x6a, 0x3a, 0xc2, 0x4e, 0x1d, 0xbf, 0xad, 0x25, 0xde, 0xb4, 0x55,
	0x76, 0xad, 0x9b, 0xbc, 0xd6, 0xb5, 0xce, 0xbd, 0x56, 0xb5, 0xdf, 0x3c, 0x79, 0xf0, 0xd5, 0xe6,
	0xcd, 0xf1, 0x73, 0x94, 0x8d, 0x70, 0xc8, 0x1a, 0x33, 0x34, 0x66, 0x8d, 0x40, 0xc6, 0x19, 0xb2,
	0x0d, 0x27, 0x7f, 0x08, 0x8c, 0xcb, 0x4e, 0x7d, 0x14, 0xc8, 0xe8, 0x11, 0x04, 0x92, 0xcf, 0xc9,
	0x92, 0xa4, 0xd1, 0x2a, 0xec, 0xef, 0x4e, 0x82, 0x0f, 0xeb, 0x22, 0x90, 0x9c, 0xbe, 0x82, 0xd0,
	0x21, 0xc3, 0xd6, 0xcd, 0x83, 0x25, 0x49, 0x67, 0xa7, 0xb3, 0xec, 0xde, 0x54, 0xd9, 0xa9, 0x2b,
	0xdf, 0x2d, 0x06, 0x95, 0x9e, 0x01, 0x38, 0xc5, 0x8c, 0xbb, 0xd1, 0x58, 0x5e, 0xcd, 0x47, 0x4b,
	0x92, 0x4e, 0x4f, 0x5f, 0x64, 0x8f, 0x0e, 0xca, 0x6d, 0xb5, 0xda, 0xbf, 0xbd, 0x3b, 0xd9, 0x2b,
	0x9e, 0x4c, 0x27, 0x00, 0x07, 0x65, 0xa7, 0xde, 0x5b, 0xab, 0x6d, 0x22, 0x60, 0xba, 0xbe, 0xfc,
	0x64, 0x0a, 0xf1, 0xb3, 0x15, 0x0e, 0xe9, 0x11, 0x84, 0xda, 0x5c, 0x68, 0x2e, 0xbc, 0xb5, 0xc3,
	0x62, 0x20, 0x3a, 0x87, 0xb1, 0x61, 0xbf, 0x7f, 0x68, 0xc6, 0xbd, 0xaf, 0xa8, 0xd8, 0x22, 0x7d,
	0x09, 0x21, 0x32, 0x5b, 0x0b, 0x1c, 0x4c, 0x44, 0xd9, 0xc3, 0xd5, 0xeb, 0xcb, 0x62, 0xd0, 0x92,
	0x14, 0xa2, 0xcd, 0x37, 0xce, 0x68, 0xe5, 0x76, 0xf6, 0x91, 0x9d, 0x7d, 0xaf, 0xbf, 0xc2, 0xe4,
	0xe1, 0x5a, 0x0a, 0x10, 0x9e, 0x5f, 0xa3, 0xfc, 0x25, 0xe2, 0x3d, 0x1a, 0xc1, 0xc1, 0x67, 0x2b,
	0x0c, 0xb3, 0x82, 0xc7, 0x84, 0xce, 0x00, 0x2e, 0x74, 0xd3, 0x48, 0x44, 0xa9, 0xea, 0x38, 0xa0,
	0x87, 0x30, 0x19, 0x58, 0xf0, 0x78, 0x74, 0x3f, 0x7c, 0x5e, 0x69, 0xeb, 0xc5, 0x7d, 0x3a, 0x85,
	0xb1, 0x27, 0xc1, 0xe3, 0x67, 0xab, 0xb3, 0xdb, 0x7e, 0x41, 0xfe, 0xf6, 0x0b, 0xf2, 0xaf, 0x5f,
	0x90, 0x2f, 0x6f, 0x9e, 0x64, 0xdc, 0x30, 0xb4, 0xb2, 0xd3, 0x56, 0xd6, 0x52, 0x6d, 0x41, 0x89,
	0xdc, 0x7c, 0xaf, 0x73, 0x53, 0xe5, 0xd8, 0xa9, 0x2a, 0xf4, 0x41, 0xbe, 0xfb, 0x1f, 0x00, 0x00,
	0xff, 0xff, 0x21, 0xd3, 0xef, 0x4f, 0x2a, 0x02, 0x00, 0x00,
}

func (m *TxnMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Status))
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTxn(dAtA, i, uint64(m.SnapshotTS.Size()))
	n1, err := m.SnapshotTS.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DNOpRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNOpRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.OpCode))
	}
	if len(m.Payload) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxn(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	if m.Target != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Target.Size()))
		n2, err := m.Target.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DNOpResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNOpResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintTxn(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TxnMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTxn(uint64(m.Status))
	}
	l = m.SnapshotTS.Size()
	n += 1 + l + sovTxn(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DNOpRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OpCode != 0 {
		n += 1 + sovTxn(uint64(m.OpCode))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DNOpResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTxn(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTxn(x uint64) (n int) {
	return sovTxn(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TxnMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TxnStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotTS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SnapshotTS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNOpRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNOpRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNOpRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpCode", wireType)
			}
			m.OpCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &metadata.DN{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNOpResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNOpResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNOpResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTxn(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTxn
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthTxn
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTxn
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTxn(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthTxn
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTxn = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTxn   = fmt.Errorf("proto: integer overflow")
)
