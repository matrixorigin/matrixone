// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: txn.proto

package txn

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	metadata "github.com/matrixorigin/matrixone/pkg/pb/metadata"
	timestamp "github.com/matrixorigin/matrixone/pkg/pb/timestamp"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// TxnStatus transaction status
type TxnStatus int32

const (
	// Active is the state of transaction creation, in this state, can execute the
	// transaction Read/Write/Commit/Rollback.
	TxnStatus_Active TxnStatus = 0
	// Prepared for distributed transactions across DNs, a 2pc commit is performed,
	// and the prepared status means that the transaction on a DN was executed
	// successfully in the first phase.
	//
	// Note that this status needs to be saved to the LogService. Once the first
	// phase of a transaction is successful, data cannot be lost.
	TxnStatus_Prepared TxnStatus = 1
	// Committing for distributed transactions across DNs, once all DNs have completed
	// the first phase, the transaction enters the Committing state and initiates an
	// asynchronous process to handle the commit of temporary data.
	//
	// Note that when all DNs involved are in the prepared state, the distributed
	// transaction can be considered committed because all data has been written
	// successfully. The subsequent Committing process just explicitly converts these
	// writes into committed data.
	//
	// Note that the state exists only in memory and is not persisted to the LogService.
	// It can be restored through the Prepared state, if all(DN).Status == Prepared.
	TxnStatus_Committing TxnStatus = 2
	// Committed after the Committing phase has transformed all DN data involved into
	// committed data, the status of the distributed transaction is explicitly recorded
	// as Committed.
	//
	// Note that this status needs to be saved to the LogService
	TxnStatus_Committed TxnStatus = 3
	// Aborting a client initiating a Rollback call or a distributed transaction that has
	// any error in the first phase will enter the Aborting state. This state starts an
	// asynchronous task to clean up the temporary data written by the transaction.
	//
	// Note that the state exists only in memory and is not persisted to the LogService.
	// It can be restored through the Prepared state, if Any(DN).Status != Prepared.
	TxnStatus_Aborting TxnStatus = 4
	// Aborted after the Aborting phase, all data involved in the DN is cleaned up and
	// the transaction status is explicitly recorded as Aborted.
	//
	// Note that this status needs to be saved to the LogService
	TxnStatus_Aborted TxnStatus = 5
)

var TxnStatus_name = map[int32]string{
	0: "Active",
	1: "Prepared",
	2: "Committing",
	3: "Committed",
	4: "Aborting",
	5: "Aborted",
}

var TxnStatus_value = map[string]int32{
	"Active":     0,
	"Prepared":   1,
	"Committing": 2,
	"Committed":  3,
	"Aborting":   4,
	"Aborted":    5,
}

func (x TxnStatus) String() string {
	return proto.EnumName(TxnStatus_name, int32(x))
}

func (TxnStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{0}
}

// TxnMethod transaction operations
type TxnMethod int32

const (
	// Read transaction read
	TxnMethod_Read TxnMethod = 0
	// Write transaction write
	TxnMethod_Write TxnMethod = 1
	// Commit commit transaction
	TxnMethod_Commit TxnMethod = 2
	// Rollback rollback transaction
	TxnMethod_Rollback TxnMethod = 3
	// Prepare when DN(Coordinator) receives a commit request from CN, it sends a prepare to
	// each DN(DNShard)
	TxnMethod_Prepare TxnMethod = 4
	// GetStatus query the status of a transaction on a DN. When a DN encounters a transaction
	// in the Prepared state, it needs to go to the DN(Coordinator) to query the status of the
	// current transaction. When a DN encounters a transaction in the Prepared state during the
	// recover, it needs to query the status of the transaction on each DN(DNShard) to determine
	// if the transaction is committed.
	TxnMethod_GetStatus TxnMethod = 5
	// CommitDNShard after the 2pc transaction is committed, the temporary data on each DN needs
	// to be explicitly converted to committed data.
	TxnMethod_CommitDNShard TxnMethod = 6
	// RollbackDNShard after the 2pc transaction is aborted, the temporary data on each DN needs
	// to cleanup.
	TxnMethod_RollbackDNShard TxnMethod = 7
)

var TxnMethod_name = map[int32]string{
	0: "Read",
	1: "Write",
	2: "Commit",
	3: "Rollback",
	4: "Prepare",
	5: "GetStatus",
	6: "CommitDNShard",
	7: "RollbackDNShard",
}

var TxnMethod_value = map[string]int32{
	"Read":            0,
	"Write":           1,
	"Commit":          2,
	"Rollback":        3,
	"Prepare":         4,
	"GetStatus":       5,
	"CommitDNShard":   6,
	"RollbackDNShard": 7,
}

func (x TxnMethod) String() string {
	return proto.EnumName(TxnMethod_name, int32(x))
}

func (TxnMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{1}
}

// TxnMeta transaction metadata
type TxnMeta struct {
	// ID transaction id, generated at the CN node at the time of transaction creation,
	// globally unique.
	ID []byte `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// Status transaction status
	Status TxnStatus `protobuf:"varint,2,opt,name=Status,proto3,enum=txn.TxnStatus" json:"Status,omitempty"`
	// SnapshotTS transaction read timestamp, generated at the CN node at the time of
	// transaction creation. All data.TS < txn.SnapshotTS is visible for the current
	// transaction.
	SnapshotTS timestamp.Timestamp `protobuf:"bytes,3,opt,name=SnapshotTS,proto3" json:"SnapshotTS"`
	// PreparedTS timestamp to complete the first phase of a 2pc commit transaction.
	PreparedTS *timestamp.Timestamp `protobuf:"bytes,4,opt,name=PreparedTS,proto3" json:"PreparedTS,omitempty"`
	// CommitTS transaction commit timestamp. For a 2pc transaction, commitTS = max(preparedTS).
	CommitTS *timestamp.Timestamp `protobuf:"bytes,5,opt,name=CommitTS,proto3" json:"CommitTS,omitempty"`
	// Coordinator the coordinator DN. CN uses the first DN of the transaction operation
	// as the Coordinator.
	Coordinator          *metadata.DNShard `protobuf:"bytes,6,opt,name=Coordinator,proto3" json:"Coordinator,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TxnMeta) Reset()         { *m = TxnMeta{} }
func (m *TxnMeta) String() string { return proto.CompactTextString(m) }
func (*TxnMeta) ProtoMessage()    {}
func (*TxnMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{0}
}
func (m *TxnMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnMeta.Merge(m, src)
}
func (m *TxnMeta) XXX_Size() int {
	return m.Size()
}
func (m *TxnMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnMeta.DiscardUnknown(m)
}

var xxx_messageInfo_TxnMeta proto.InternalMessageInfo

func (m *TxnMeta) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *TxnMeta) GetStatus() TxnStatus {
	if m != nil {
		return m.Status
	}
	return TxnStatus_Active
}

func (m *TxnMeta) GetSnapshotTS() timestamp.Timestamp {
	if m != nil {
		return m.SnapshotTS
	}
	return timestamp.Timestamp{}
}

func (m *TxnMeta) GetPreparedTS() *timestamp.Timestamp {
	if m != nil {
		return m.PreparedTS
	}
	return nil
}

func (m *TxnMeta) GetCommitTS() *timestamp.Timestamp {
	if m != nil {
		return m.CommitTS
	}
	return nil
}

func (m *TxnMeta) GetCoordinator() *metadata.DNShard {
	if m != nil {
		return m.Coordinator
	}
	return nil
}

// CNTxnSnapshot snapshot of the cn txn operation.
type CNTxnSnapshot struct {
	// ID txn id
	Txn TxnMeta `protobuf:"bytes,1,opt,name=Txn,proto3" json:"Txn"`
	// DNShards DNs for which data has been written in the current transaction
	DNShards []metadata.DNShard `protobuf:"bytes,2,rep,name=DNShards,proto3" json:"DNShards"`
	// ReadyOnly txn options
	ReadyOnly bool `protobuf:"varint,3,opt,name=ReadyOnly,proto3" json:"ReadyOnly,omitempty"`
	// EnableCacheWrite txn options
	EnableCacheWrite bool `protobuf:"varint,4,opt,name=EnableCacheWrite,proto3" json:"EnableCacheWrite,omitempty"`
	// Disable1PCOpt txn options
	Disable1PCOpt        bool     `protobuf:"varint,5,opt,name=Disable1PCOpt,proto3" json:"Disable1PCOpt,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CNTxnSnapshot) Reset()         { *m = CNTxnSnapshot{} }
func (m *CNTxnSnapshot) String() string { return proto.CompactTextString(m) }
func (*CNTxnSnapshot) ProtoMessage()    {}
func (*CNTxnSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{1}
}
func (m *CNTxnSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNTxnSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNTxnSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNTxnSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNTxnSnapshot.Merge(m, src)
}
func (m *CNTxnSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *CNTxnSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_CNTxnSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_CNTxnSnapshot proto.InternalMessageInfo

func (m *CNTxnSnapshot) GetTxn() TxnMeta {
	if m != nil {
		return m.Txn
	}
	return TxnMeta{}
}

func (m *CNTxnSnapshot) GetDNShards() []metadata.DNShard {
	if m != nil {
		return m.DNShards
	}
	return nil
}

func (m *CNTxnSnapshot) GetReadyOnly() bool {
	if m != nil {
		return m.ReadyOnly
	}
	return false
}

func (m *CNTxnSnapshot) GetEnableCacheWrite() bool {
	if m != nil {
		return m.EnableCacheWrite
	}
	return false
}

func (m *CNTxnSnapshot) GetDisable1PCOpt() bool {
	if m != nil {
		return m.Disable1PCOpt
	}
	return false
}

// CNOpRequest cn read/write request, CN -> DN. If data is written to more than one DN (>1) in a
// single transaction, then the transaction becomes a 2pc transaction.
type CNOpRequest struct {
	// OpCode request operation type
	OpCode uint32 `protobuf:"varint,1,opt,name=OpCode,proto3" json:"OpCode,omitempty"`
	// Payload the content of the request, TxnClient does not perceive the exact
	// format and content
	Payload []byte `protobuf:"bytes,2,opt,name=Payload,proto3" json:"Payload,omitempty"`
	// Target target to which the request was sent
	Target               metadata.DNShard `protobuf:"bytes,3,opt,name=Target,proto3" json:"Target"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *CNOpRequest) Reset()         { *m = CNOpRequest{} }
func (m *CNOpRequest) String() string { return proto.CompactTextString(m) }
func (*CNOpRequest) ProtoMessage()    {}
func (*CNOpRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{2}
}
func (m *CNOpRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNOpRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNOpRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNOpRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNOpRequest.Merge(m, src)
}
func (m *CNOpRequest) XXX_Size() int {
	return m.Size()
}
func (m *CNOpRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CNOpRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CNOpRequest proto.InternalMessageInfo

func (m *CNOpRequest) GetOpCode() uint32 {
	if m != nil {
		return m.OpCode
	}
	return 0
}

func (m *CNOpRequest) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *CNOpRequest) GetTarget() metadata.DNShard {
	if m != nil {
		return m.Target
	}
	return metadata.DNShard{}
}

// CNOpResponse cn read/write response, DN -> CN. A request corresponds to a response.
type CNOpResponse struct {
	// Payload response payload
	Payload              []byte   `protobuf:"bytes,1,opt,name=Payload,proto3" json:"Payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CNOpResponse) Reset()         { *m = CNOpResponse{} }
func (m *CNOpResponse) String() string { return proto.CompactTextString(m) }
func (*CNOpResponse) ProtoMessage()    {}
func (*CNOpResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{3}
}
func (m *CNOpResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNOpResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNOpResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNOpResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNOpResponse.Merge(m, src)
}
func (m *CNOpResponse) XXX_Size() int {
	return m.Size()
}
func (m *CNOpResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CNOpResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CNOpResponse proto.InternalMessageInfo

func (m *CNOpResponse) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

// TxnRequest transaction request. All requests for the transaction are made using TxnRequest, so that
// the codec and logical processing of the RPC can be unified. Specific requests are selected according
// to TxnMethod.
//
// Request flow of TxnRequest as below:
// 1. CN -> DN (TxnMethod.Read, TxnMethod.Write, TxnMethod.Commit, TxnMethod.Rollback)
// 2. DN -> DN (TxnMethod.Prepare, TxnMethod.GetStatus, TxnMethod.CommitDNShard, TxnMethod.RollbackDNShard)
type TxnRequest struct {
	// Txn transaction metadata
	Txn TxnMeta `protobuf:"bytes,1,opt,name=Txn,proto3" json:"Txn"`
	// TxnMethod TxnRequest opCode, select the Request defined below according to TxnMethod.
	Method TxnMethod `protobuf:"varint,2,opt,name=Method,proto3,enum=txn.TxnMethod" json:"Method,omitempty"`
	// Flag request flag
	Flag uint32 `protobuf:"varint,3,opt,name=Flag,proto3" json:"Flag,omitempty"`
	// CNOpRequest corresponds to TxnMethod.Read, TxnMethod.Write
	CNRequest *CNOpRequest `protobuf:"bytes,4,opt,name=CNRequest,proto3" json:"CNRequest,omitempty"`
	// TxnCommitRequest corresponds to TxnMethod.Commit
	CommitRequest *TxnCommitRequest `protobuf:"bytes,5,opt,name=CommitRequest,proto3" json:"CommitRequest,omitempty"`
	// TxnRollbackRequest corresponds to TxnMethod.Rollback
	RollbackRequest *TxnRollbackRequest `protobuf:"bytes,6,opt,name=RollbackRequest,proto3" json:"RollbackRequest,omitempty"`
	// TxnPrepareRequest corresponds to TxnMethod.Prepare
	PrepareRequest *TxnPrepareRequest `protobuf:"bytes,7,opt,name=PrepareRequest,proto3" json:"PrepareRequest,omitempty"`
	// TxnGetStatusRequest corresponds to TxnMethod.GetStatus
	GetStatusRequest *TxnGetStatusRequest `protobuf:"bytes,8,opt,name=GetStatusRequest,proto3" json:"GetStatusRequest,omitempty"`
	// TxnCommitDNShardRequest corresponds to TxnMethod.CommitDNShard
	CommitDNShardRequest *TxnCommitDNShardRequest `protobuf:"bytes,9,opt,name=CommitDNShardRequest,proto3" json:"CommitDNShardRequest,omitempty"`
	// TxnRollbackDNShardRequest corresponds to TxnMethod.RollbackDNShard
	RollbackDNShardRequest *TxnRollbackDNShardRequest `protobuf:"bytes,10,opt,name=RollbackDNShardRequest,proto3" json:"RollbackDNShardRequest,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                   `json:"-"`
	XXX_unrecognized       []byte                     `json:"-"`
	XXX_sizecache          int32                      `json:"-"`
}

func (m *TxnRequest) Reset()         { *m = TxnRequest{} }
func (m *TxnRequest) String() string { return proto.CompactTextString(m) }
func (*TxnRequest) ProtoMessage()    {}
func (*TxnRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{4}
}
func (m *TxnRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnRequest.Merge(m, src)
}
func (m *TxnRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxnRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxnRequest proto.InternalMessageInfo

func (m *TxnRequest) GetTxn() TxnMeta {
	if m != nil {
		return m.Txn
	}
	return TxnMeta{}
}

func (m *TxnRequest) GetMethod() TxnMethod {
	if m != nil {
		return m.Method
	}
	return TxnMethod_Read
}

func (m *TxnRequest) GetFlag() uint32 {
	if m != nil {
		return m.Flag
	}
	return 0
}

func (m *TxnRequest) GetCNRequest() *CNOpRequest {
	if m != nil {
		return m.CNRequest
	}
	return nil
}

func (m *TxnRequest) GetCommitRequest() *TxnCommitRequest {
	if m != nil {
		return m.CommitRequest
	}
	return nil
}

func (m *TxnRequest) GetRollbackRequest() *TxnRollbackRequest {
	if m != nil {
		return m.RollbackRequest
	}
	return nil
}

func (m *TxnRequest) GetPrepareRequest() *TxnPrepareRequest {
	if m != nil {
		return m.PrepareRequest
	}
	return nil
}

func (m *TxnRequest) GetGetStatusRequest() *TxnGetStatusRequest {
	if m != nil {
		return m.GetStatusRequest
	}
	return nil
}

func (m *TxnRequest) GetCommitDNShardRequest() *TxnCommitDNShardRequest {
	if m != nil {
		return m.CommitDNShardRequest
	}
	return nil
}

func (m *TxnRequest) GetRollbackDNShardRequest() *TxnRollbackDNShardRequest {
	if m != nil {
		return m.RollbackDNShardRequest
	}
	return nil
}

// TxnResponse response of TxnRequest.
type TxnResponse struct {
	// Txn transaction metadata. TxnResponse.TxnMeta and TxnRequest.TxnMeta may differ
	// in that the node initiating the TxnRequest needs to process the returned TxnMeta,
	// e.g. to determine whether the transaction is Aborted by the status of the returned
	// TxnMeta.
	Txn *TxnMeta `protobuf:"bytes,1,opt,name=Txn,proto3" json:"Txn,omitempty"`
	// TxnMethod same as TxnRequest.TxnMethod
	Method TxnMethod `protobuf:"varint,2,opt,name=Method,proto3,enum=txn.TxnMethod" json:"Method,omitempty"`
	// Flag request flag, same as the corresponding request
	Flag uint32 `protobuf:"varint,3,opt,name=Flag,proto3" json:"Flag,omitempty"`
	// TxnError explicit error
	TxnError *TxnError `protobuf:"bytes,4,opt,name=TxnError,proto3" json:"TxnError,omitempty"`
	// CNOpResponse corresponds to TxnMethod.Read, TxnMethod.Write response
	CNOpResponse *CNOpResponse `protobuf:"bytes,5,opt,name=CNOpResponse,proto3" json:"CNOpResponse,omitempty"`
	// TxnCommitResponse corresponds to TxnMethod.Commit response
	CommitResponse *TxnCommitResponse `protobuf:"bytes,6,opt,name=CommitResponse,proto3" json:"CommitResponse,omitempty"`
	// TxnRollbackResponse corresponds to TxnMethod.Rollback response
	RollbackResponse *TxnRollbackResponse `protobuf:"bytes,7,opt,name=RollbackResponse,proto3" json:"RollbackResponse,omitempty"`
	// TxnPrepareResponse corresponds to TxnMethod.Prepare response
	PrepareResponse *TxnPrepareResponse `protobuf:"bytes,8,opt,name=PrepareResponse,proto3" json:"PrepareResponse,omitempty"`
	// TxnGetStatusResponse corresponds to TxnMethod.GetStatus response
	GetStatusResponse *TxnGetStatusResponse `protobuf:"bytes,9,opt,name=GetStatusResponse,proto3" json:"GetStatusResponse,omitempty"`
	// TxnCommitDNShardResponse corresponds to TxnMethod.CommitDNShard response
	CommitDNShardResponse *TxnCommitDNShardResponse `protobuf:"bytes,10,opt,name=CommitDNShardResponse,proto3" json:"CommitDNShardResponse,omitempty"`
	// TxnRollbackDNShardResponse corresponds to TxnMethod.RollbackDNShard response
	RollbackDNShardResponse *TxnRollbackDNShardResponse `protobuf:"bytes,11,opt,name=RollbackDNShardResponse,proto3" json:"RollbackDNShardResponse,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}                    `json:"-"`
	XXX_unrecognized        []byte                      `json:"-"`
	XXX_sizecache           int32                       `json:"-"`
}

func (m *TxnResponse) Reset()         { *m = TxnResponse{} }
func (m *TxnResponse) String() string { return proto.CompactTextString(m) }
func (*TxnResponse) ProtoMessage()    {}
func (*TxnResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{5}
}
func (m *TxnResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnResponse.Merge(m, src)
}
func (m *TxnResponse) XXX_Size() int {
	return m.Size()
}
func (m *TxnResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TxnResponse proto.InternalMessageInfo

func (m *TxnResponse) GetTxn() *TxnMeta {
	if m != nil {
		return m.Txn
	}
	return nil
}

func (m *TxnResponse) GetMethod() TxnMethod {
	if m != nil {
		return m.Method
	}
	return TxnMethod_Read
}

func (m *TxnResponse) GetFlag() uint32 {
	if m != nil {
		return m.Flag
	}
	return 0
}

func (m *TxnResponse) GetTxnError() *TxnError {
	if m != nil {
		return m.TxnError
	}
	return nil
}

func (m *TxnResponse) GetCNOpResponse() *CNOpResponse {
	if m != nil {
		return m.CNOpResponse
	}
	return nil
}

func (m *TxnResponse) GetCommitResponse() *TxnCommitResponse {
	if m != nil {
		return m.CommitResponse
	}
	return nil
}

func (m *TxnResponse) GetRollbackResponse() *TxnRollbackResponse {
	if m != nil {
		return m.RollbackResponse
	}
	return nil
}

func (m *TxnResponse) GetPrepareResponse() *TxnPrepareResponse {
	if m != nil {
		return m.PrepareResponse
	}
	return nil
}

func (m *TxnResponse) GetGetStatusResponse() *TxnGetStatusResponse {
	if m != nil {
		return m.GetStatusResponse
	}
	return nil
}

func (m *TxnResponse) GetCommitDNShardResponse() *TxnCommitDNShardResponse {
	if m != nil {
		return m.CommitDNShardResponse
	}
	return nil
}

func (m *TxnResponse) GetRollbackDNShardResponse() *TxnRollbackDNShardResponse {
	if m != nil {
		return m.RollbackDNShardResponse
	}
	return nil
}

// TxnCommitRequest CN sent the commit request to coordinator DN.
type TxnCommitRequest struct {
	// DNShards DNs for which data has been written in the current transaction.
	// The first DN is the coordinator of the transaction.
	DNShards             []metadata.DNShard `protobuf:"bytes,1,rep,name=DNShards,proto3" json:"DNShards"`
	Disable1PCOpt        bool               `protobuf:"varint,2,opt,name=disable1PCOpt,proto3" json:"disable1PCOpt,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TxnCommitRequest) Reset()         { *m = TxnCommitRequest{} }
func (m *TxnCommitRequest) String() string { return proto.CompactTextString(m) }
func (*TxnCommitRequest) ProtoMessage()    {}
func (*TxnCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{6}
}
func (m *TxnCommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnCommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnCommitRequest.Merge(m, src)
}
func (m *TxnCommitRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxnCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxnCommitRequest proto.InternalMessageInfo

func (m *TxnCommitRequest) GetDNShards() []metadata.DNShard {
	if m != nil {
		return m.DNShards
	}
	return nil
}

func (m *TxnCommitRequest) GetDisable1PCOpt() bool {
	if m != nil {
		return m.Disable1PCOpt
	}
	return false
}

// TxnCommitResponse response of TxnCommitRequest.
type TxnCommitResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnCommitResponse) Reset()         { *m = TxnCommitResponse{} }
func (m *TxnCommitResponse) String() string { return proto.CompactTextString(m) }
func (*TxnCommitResponse) ProtoMessage()    {}
func (*TxnCommitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{7}
}
func (m *TxnCommitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnCommitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnCommitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnCommitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnCommitResponse.Merge(m, src)
}
func (m *TxnCommitResponse) XXX_Size() int {
	return m.Size()
}
func (m *TxnCommitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnCommitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TxnCommitResponse proto.InternalMessageInfo

// TxnCommitRequest CN sent the rollback request to coordinator DN.
type TxnRollbackRequest struct {
	// DNShards DNs for which data has been written in the current transaction.
	DNShards             []metadata.DNShard `protobuf:"bytes,1,rep,name=DNShards,proto3" json:"DNShards"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TxnRollbackRequest) Reset()         { *m = TxnRollbackRequest{} }
func (m *TxnRollbackRequest) String() string { return proto.CompactTextString(m) }
func (*TxnRollbackRequest) ProtoMessage()    {}
func (*TxnRollbackRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{8}
}
func (m *TxnRollbackRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnRollbackRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnRollbackRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnRollbackRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnRollbackRequest.Merge(m, src)
}
func (m *TxnRollbackRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxnRollbackRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnRollbackRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxnRollbackRequest proto.InternalMessageInfo

func (m *TxnRollbackRequest) GetDNShards() []metadata.DNShard {
	if m != nil {
		return m.DNShards
	}
	return nil
}

// TxnRollbackResponse response of TxnRollbackRequest.
type TxnRollbackResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnRollbackResponse) Reset()         { *m = TxnRollbackResponse{} }
func (m *TxnRollbackResponse) String() string { return proto.CompactTextString(m) }
func (*TxnRollbackResponse) ProtoMessage()    {}
func (*TxnRollbackResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{9}
}
func (m *TxnRollbackResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnRollbackResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnRollbackResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnRollbackResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnRollbackResponse.Merge(m, src)
}
func (m *TxnRollbackResponse) XXX_Size() int {
	return m.Size()
}
func (m *TxnRollbackResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnRollbackResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TxnRollbackResponse proto.InternalMessageInfo

// TxnPrepareRequest when a DN(coordinator) receives a Commit request from a CN, if
// more than one DN is involved, the 2PC commit process is enabled and the first phase
// is to send prepare requests to all DNs.
type TxnPrepareRequest struct {
	// DNShard prepare DN
	DNShard *metadata.DNShard `protobuf:"bytes,1,opt,name=DNShard,proto3" json:"DNShard,omitempty"`
	// DNShards if the DNShard is the coordinator DN, DNShards is not empty,
	// otherwise is empty. The coordinator DN needs to write the DNShards and prepare
	// data together atomically to the LogService. So during error recovery we can use
	// the coordinator DN to find all the DNs involved in the transaction to commit or
	// rollback the transaction.
	DNShards             []metadata.DNShard `protobuf:"bytes,2,rep,name=DNShards,proto3" json:"DNShards"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TxnPrepareRequest) Reset()         { *m = TxnPrepareRequest{} }
func (m *TxnPrepareRequest) String() string { return proto.CompactTextString(m) }
func (*TxnPrepareRequest) ProtoMessage()    {}
func (*TxnPrepareRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{10}
}
func (m *TxnPrepareRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnPrepareRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnPrepareRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnPrepareRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnPrepareRequest.Merge(m, src)
}
func (m *TxnPrepareRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxnPrepareRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnPrepareRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxnPrepareRequest proto.InternalMessageInfo

func (m *TxnPrepareRequest) GetDNShard() *metadata.DNShard {
	if m != nil {
		return m.DNShard
	}
	return nil
}

func (m *TxnPrepareRequest) GetDNShards() []metadata.DNShard {
	if m != nil {
		return m.DNShards
	}
	return nil
}

// TxnPrepareResponse response of TxnPrepareRequest
type TxnPrepareResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnPrepareResponse) Reset()         { *m = TxnPrepareResponse{} }
func (m *TxnPrepareResponse) String() string { return proto.CompactTextString(m) }
func (*TxnPrepareResponse) ProtoMessage()    {}
func (*TxnPrepareResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{11}
}
func (m *TxnPrepareResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnPrepareResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnPrepareResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnPrepareResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnPrepareResponse.Merge(m, src)
}
func (m *TxnPrepareResponse) XXX_Size() int {
	return m.Size()
}
func (m *TxnPrepareResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnPrepareResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TxnPrepareResponse proto.InternalMessageInfo

// TxnGetStatusRequest query the status of a transaction on DN
type TxnGetStatusRequest struct {
	// DNShard target DN
	DNShard              *metadata.DNShard `protobuf:"bytes,1,opt,name=DNShard,proto3" json:"DNShard,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TxnGetStatusRequest) Reset()         { *m = TxnGetStatusRequest{} }
func (m *TxnGetStatusRequest) String() string { return proto.CompactTextString(m) }
func (*TxnGetStatusRequest) ProtoMessage()    {}
func (*TxnGetStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{12}
}
func (m *TxnGetStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnGetStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnGetStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnGetStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnGetStatusRequest.Merge(m, src)
}
func (m *TxnGetStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxnGetStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnGetStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxnGetStatusRequest proto.InternalMessageInfo

func (m *TxnGetStatusRequest) GetDNShard() *metadata.DNShard {
	if m != nil {
		return m.DNShard
	}
	return nil
}

// TxnGetStatusResponse response of TxnGetStatusRequest
type TxnGetStatusResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnGetStatusResponse) Reset()         { *m = TxnGetStatusResponse{} }
func (m *TxnGetStatusResponse) String() string { return proto.CompactTextString(m) }
func (*TxnGetStatusResponse) ProtoMessage()    {}
func (*TxnGetStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{13}
}
func (m *TxnGetStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnGetStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnGetStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnGetStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnGetStatusResponse.Merge(m, src)
}
func (m *TxnGetStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *TxnGetStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnGetStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TxnGetStatusResponse proto.InternalMessageInfo

// TxnCommitDNShardRequest commit txn on DNShard. Data needs to be written to the
// LogService.
type TxnCommitDNShardRequest struct {
	// DNShard target DN
	DNShard              *metadata.DNShard `protobuf:"bytes,1,opt,name=DNShard,proto3" json:"DNShard,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TxnCommitDNShardRequest) Reset()         { *m = TxnCommitDNShardRequest{} }
func (m *TxnCommitDNShardRequest) String() string { return proto.CompactTextString(m) }
func (*TxnCommitDNShardRequest) ProtoMessage()    {}
func (*TxnCommitDNShardRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{14}
}
func (m *TxnCommitDNShardRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnCommitDNShardRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnCommitDNShardRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnCommitDNShardRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnCommitDNShardRequest.Merge(m, src)
}
func (m *TxnCommitDNShardRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxnCommitDNShardRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnCommitDNShardRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxnCommitDNShardRequest proto.InternalMessageInfo

func (m *TxnCommitDNShardRequest) GetDNShard() *metadata.DNShard {
	if m != nil {
		return m.DNShard
	}
	return nil
}

// TxnCommitDNShardResponse response of TxnCommitDNShardRequest
type TxnCommitDNShardResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnCommitDNShardResponse) Reset()         { *m = TxnCommitDNShardResponse{} }
func (m *TxnCommitDNShardResponse) String() string { return proto.CompactTextString(m) }
func (*TxnCommitDNShardResponse) ProtoMessage()    {}
func (*TxnCommitDNShardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{15}
}
func (m *TxnCommitDNShardResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnCommitDNShardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnCommitDNShardResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnCommitDNShardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnCommitDNShardResponse.Merge(m, src)
}
func (m *TxnCommitDNShardResponse) XXX_Size() int {
	return m.Size()
}
func (m *TxnCommitDNShardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnCommitDNShardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TxnCommitDNShardResponse proto.InternalMessageInfo

// TxnCommitDNShardRequest rollback txn on DNShard
type TxnRollbackDNShardRequest struct {
	// DNShard target DN
	DNShard              *metadata.DNShard `protobuf:"bytes,1,opt,name=DNShard,proto3" json:"DNShard,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TxnRollbackDNShardRequest) Reset()         { *m = TxnRollbackDNShardRequest{} }
func (m *TxnRollbackDNShardRequest) String() string { return proto.CompactTextString(m) }
func (*TxnRollbackDNShardRequest) ProtoMessage()    {}
func (*TxnRollbackDNShardRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{16}
}
func (m *TxnRollbackDNShardRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnRollbackDNShardRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnRollbackDNShardRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnRollbackDNShardRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnRollbackDNShardRequest.Merge(m, src)
}
func (m *TxnRollbackDNShardRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxnRollbackDNShardRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnRollbackDNShardRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxnRollbackDNShardRequest proto.InternalMessageInfo

func (m *TxnRollbackDNShardRequest) GetDNShard() *metadata.DNShard {
	if m != nil {
		return m.DNShard
	}
	return nil
}

// TxnRollbackDNShardResponse response of TxnRollbackDNShardRequest
type TxnRollbackDNShardResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnRollbackDNShardResponse) Reset()         { *m = TxnRollbackDNShardResponse{} }
func (m *TxnRollbackDNShardResponse) String() string { return proto.CompactTextString(m) }
func (*TxnRollbackDNShardResponse) ProtoMessage()    {}
func (*TxnRollbackDNShardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{17}
}
func (m *TxnRollbackDNShardResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnRollbackDNShardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnRollbackDNShardResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnRollbackDNShardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnRollbackDNShardResponse.Merge(m, src)
}
func (m *TxnRollbackDNShardResponse) XXX_Size() int {
	return m.Size()
}
func (m *TxnRollbackDNShardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnRollbackDNShardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TxnRollbackDNShardResponse proto.InternalMessageInfo

// TxnError all explicit errors in transaction operations.
type TxnError struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnError) Reset()         { *m = TxnError{} }
func (m *TxnError) String() string { return proto.CompactTextString(m) }
func (*TxnError) ProtoMessage()    {}
func (*TxnError) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{18}
}
func (m *TxnError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnError.Merge(m, src)
}
func (m *TxnError) XXX_Size() int {
	return m.Size()
}
func (m *TxnError) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnError.DiscardUnknown(m)
}

var xxx_messageInfo_TxnError proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("txn.TxnStatus", TxnStatus_name, TxnStatus_value)
	proto.RegisterEnum("txn.TxnMethod", TxnMethod_name, TxnMethod_value)
	proto.RegisterType((*TxnMeta)(nil), "txn.TxnMeta")
	proto.RegisterType((*CNTxnSnapshot)(nil), "txn.CNTxnSnapshot")
	proto.RegisterType((*CNOpRequest)(nil), "txn.CNOpRequest")
	proto.RegisterType((*CNOpResponse)(nil), "txn.CNOpResponse")
	proto.RegisterType((*TxnRequest)(nil), "txn.TxnRequest")
	proto.RegisterType((*TxnResponse)(nil), "txn.TxnResponse")
	proto.RegisterType((*TxnCommitRequest)(nil), "txn.TxnCommitRequest")
	proto.RegisterType((*TxnCommitResponse)(nil), "txn.TxnCommitResponse")
	proto.RegisterType((*TxnRollbackRequest)(nil), "txn.TxnRollbackRequest")
	proto.RegisterType((*TxnRollbackResponse)(nil), "txn.TxnRollbackResponse")
	proto.RegisterType((*TxnPrepareRequest)(nil), "txn.TxnPrepareRequest")
	proto.RegisterType((*TxnPrepareResponse)(nil), "txn.TxnPrepareResponse")
	proto.RegisterType((*TxnGetStatusRequest)(nil), "txn.TxnGetStatusRequest")
	proto.RegisterType((*TxnGetStatusResponse)(nil), "txn.TxnGetStatusResponse")
	proto.RegisterType((*TxnCommitDNShardRequest)(nil), "txn.TxnCommitDNShardRequest")
	proto.RegisterType((*TxnCommitDNShardResponse)(nil), "txn.TxnCommitDNShardResponse")
	proto.RegisterType((*TxnRollbackDNShardRequest)(nil), "txn.TxnRollbackDNShardRequest")
	proto.RegisterType((*TxnRollbackDNShardResponse)(nil), "txn.TxnRollbackDNShardResponse")
	proto.RegisterType((*TxnError)(nil), "txn.TxnError")
}

func init() { proto.RegisterFile("txn.proto", fileDescriptor_4f782e76b37adb9a) }

var fileDescriptor_4f782e76b37adb9a = []byte{
	// 1022 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0xae, 0xf3, 0xeb, 0x9c, 0xfc, 0xac, 0x73, 0xfa, 0x97, 0xad, 0x4a, 0xb6, 0xb2, 0xaa, 0x55,
	0x29, 0x90, 0x40, 0x0b, 0x37, 0x20, 0x55, 0x6a, 0x93, 0xdd, 0xa5, 0x17, 0xdb, 0x56, 0x93, 0x08,
	0x04, 0x37, 0x68, 0x52, 0x0f, 0x89, 0xb5, 0x89, 0x6d, 0x9c, 0x09, 0x72, 0x6f, 0x78, 0x03, 0x5e,
	0x80, 0x27, 0xda, 0x2b, 0xb4, 0xd7, 0x5c, 0x20, 0xe8, 0x93, 0x20, 0x8f, 0x67, 0x92, 0xd8, 0x89,
	0xd1, 0xb6, 0x7b, 0xe7, 0x39, 0xe7, 0x7c, 0xdf, 0x39, 0x73, 0xfc, 0xcd, 0x99, 0x81, 0x12, 0x0f,
	0x9c, 0x96, 0xe7, 0xbb, 0xdc, 0xc5, 0x2c, 0x0f, 0x9c, 0xbd, 0xcf, 0x86, 0x36, 0x1f, 0xcd, 0x06,
	0xad, 0x5b, 0x77, 0xd2, 0x1e, 0xba, 0x43, 0xb7, 0x2d, 0x7c, 0x83, 0xd9, 0xcf, 0x62, 0x25, 0x16,
	0xe2, 0x2b, 0xc2, 0xec, 0x3d, 0xe1, 0xf6, 0x84, 0x4d, 0x39, 0x9d, 0x78, 0xd2, 0x50, 0x9b, 0x30,
	0x4e, 0x2d, 0xca, 0x69, 0xb4, 0x36, 0xff, 0xc8, 0x40, 0xb1, 0x1f, 0x38, 0xaf, 0x19, 0xa7, 0x58,
	0x83, 0xcc, 0x65, 0xb7, 0xa1, 0x1d, 0x68, 0x47, 0x15, 0x92, 0xb9, 0xec, 0xe2, 0x73, 0x28, 0xf4,
	0x38, 0xe5, 0xb3, 0x69, 0x23, 0x73, 0xa0, 0x1d, 0xd5, 0x4e, 0x6a, 0xad, 0xb0, 0x98, 0x7e, 0xe0,
	0x44, 0x56, 0x22, 0xbd, 0xf8, 0x35, 0x40, 0xcf, 0xa1, 0xde, 0x74, 0xe4, 0xf2, 0x7e, 0xaf, 0x91,
	0x3d, 0xd0, 0x8e, 0xca, 0x27, 0x5b, 0xad, 0x45, 0xe6, 0xbe, 0xfa, 0xba, 0xc8, 0xbd, 0xfd, 0xfb,
	0xd9, 0x06, 0x59, 0x8a, 0xc6, 0x2f, 0x01, 0x6e, 0x7c, 0xe6, 0x51, 0x9f, 0x59, 0xfd, 0x5e, 0x23,
	0x97, 0x8e, 0x25, 0x4b, 0x71, 0xf8, 0x39, 0xe8, 0x1d, 0x77, 0x32, 0xb1, 0xc3, 0x7c, 0xf9, 0xff,
	0xc1, 0xcc, 0xa3, 0xf0, 0x14, 0xca, 0x1d, 0xd7, 0xf5, 0x2d, 0xdb, 0xa1, 0xdc, 0xf5, 0x1b, 0x05,
	0x01, 0xaa, 0xb7, 0xe6, 0xdd, 0xe8, 0x5e, 0xf5, 0x46, 0xd4, 0xb7, 0xc8, 0x72, 0x94, 0xf9, 0x97,
	0x06, 0xd5, 0xce, 0x55, 0xb8, 0x61, 0x59, 0x30, 0x1e, 0x42, 0xb6, 0x1f, 0x38, 0xa2, 0x47, 0xe5,
	0x93, 0x8a, 0xea, 0x47, 0xd8, 0x3d, 0xb9, 0xb7, 0xd0, 0x8d, 0xa7, 0xa0, 0x4b, 0xbe, 0xb0, 0x75,
	0xd9, 0xb5, 0x99, 0x64, 0xfc, 0x3c, 0x10, 0xf7, 0xa1, 0x44, 0x18, 0xb5, 0xee, 0xae, 0x9d, 0xf1,
	0x9d, 0x68, 0xa2, 0x4e, 0x16, 0x06, 0x3c, 0x06, 0xe3, 0x85, 0x43, 0x07, 0x63, 0xd6, 0xa1, 0xb7,
	0x23, 0xf6, 0xbd, 0x6f, 0x73, 0x26, 0xba, 0xa5, 0x93, 0x15, 0x3b, 0x1e, 0x42, 0xb5, 0x6b, 0x4f,
	0x43, 0xe3, 0x17, 0x37, 0x9d, 0x6b, 0x8f, 0x8b, 0x16, 0xe9, 0x24, 0x6e, 0x34, 0x3d, 0x28, 0x77,
	0xae, 0xae, 0x3d, 0xc2, 0x7e, 0x99, 0xb1, 0x29, 0xc7, 0x1d, 0x28, 0x5c, 0x7b, 0x1d, 0xd7, 0x62,
	0x62, 0x73, 0x55, 0x22, 0x57, 0xd8, 0x80, 0xe2, 0x0d, 0xbd, 0x1b, 0xbb, 0xd4, 0x12, 0x2a, 0xa8,
	0x10, 0xb5, 0xc4, 0x36, 0x14, 0xfa, 0xd4, 0x1f, 0x32, 0x2e, 0x7f, 0x79, 0xea, 0x1e, 0x65, 0x98,
	0x79, 0x04, 0x95, 0x28, 0xe3, 0xd4, 0x73, 0x9d, 0x69, 0x8c, 0x5a, 0x8b, 0x51, 0x9b, 0x7f, 0xe6,
	0x00, 0xfa, 0x81, 0xa3, 0x6a, 0x7b, 0xbf, 0xae, 0x3f, 0x87, 0xc2, 0x6b, 0xc6, 0x47, 0xae, 0x95,
	0x94, 0x6b, 0x64, 0x25, 0xd2, 0x8b, 0x08, 0xb9, 0x97, 0x63, 0x3a, 0x14, 0x55, 0x57, 0x89, 0xf8,
	0xc6, 0x16, 0x94, 0x3a, 0x57, 0x32, 0x9d, 0x54, 0xa1, 0x21, 0xe0, 0x4b, 0x2d, 0x22, 0x8b, 0x10,
	0xfc, 0x06, 0xaa, 0x91, 0xb4, 0x14, 0x26, 0x52, 0xe1, 0xb6, 0x4a, 0x19, 0x73, 0x92, 0x78, 0x2c,
	0x9e, 0xc3, 0x13, 0xe2, 0x8e, 0xc7, 0x03, 0x7a, 0xfb, 0x46, 0xc1, 0x23, 0x3d, 0xee, 0x2a, 0x78,
	0xc2, 0x4d, 0x92, 0xf1, 0x78, 0x06, 0x35, 0x79, 0x1c, 0x14, 0x43, 0x51, 0x30, 0xec, 0x28, 0x86,
	0xb8, 0x97, 0x24, 0xa2, 0xb1, 0x0b, 0xc6, 0x2b, 0xc6, 0xe5, 0x39, 0x96, 0x0c, 0xba, 0x60, 0x68,
	0x28, 0x86, 0xa4, 0x9f, 0xac, 0x20, 0xf0, 0x06, 0xb6, 0xa2, 0x9d, 0xa9, 0xd3, 0x23, 0x99, 0x4a,
	0x82, 0x69, 0x3f, 0xde, 0x8c, 0x78, 0x0c, 0x59, 0x8b, 0xc4, 0xef, 0x60, 0x47, 0x6d, 0x35, 0xc1,
	0x09, 0x82, 0xb3, 0x99, 0xec, 0x50, 0x82, 0x35, 0x05, 0x6d, 0xfe, 0x9e, 0x87, 0xb2, 0x10, 0x94,
	0x94, 0x5e, 0x33, 0x55, 0x51, 0x1f, 0xae, 0xa5, 0x8f, 0x41, 0xef, 0x07, 0xce, 0x0b, 0xdf, 0x77,
	0x7d, 0x29, 0xa5, 0xaa, 0x42, 0x0b, 0x23, 0x99, 0xbb, 0xf1, 0xab, 0xf8, 0x89, 0x90, 0x2a, 0xaa,
	0x2f, 0x29, 0x2f, 0x72, 0x90, 0xf8, 0xc1, 0x39, 0x83, 0x9a, 0x52, 0x94, 0x04, 0x16, 0xe2, 0x7f,
	0x3f, 0xee, 0x25, 0x89, 0xe8, 0xf0, 0xef, 0x2f, 0x04, 0x25, 0x19, 0x8a, 0xf1, 0xbf, 0x9f, 0xf4,
	0x93, 0x15, 0x44, 0x28, 0xe3, 0xb9, 0xaa, 0x24, 0x89, 0x1e, 0x97, 0x71, 0xc2, 0x4d, 0x92, 0xf1,
	0xf8, 0x0a, 0xea, 0x4b, 0xa2, 0x92, 0x24, 0x91, 0x7a, 0x9e, 0xae, 0xd1, 0xa1, 0xa4, 0x59, 0xc5,
	0x60, 0x0f, 0xb6, 0x13, 0x7a, 0x92, 0x64, 0x91, 0x6c, 0x3e, 0x4a, 0x91, 0xa2, 0x24, 0x5c, 0x8f,
	0xc5, 0x1f, 0x60, 0x77, 0x45, 0x4e, 0x92, 0xb6, 0x2c, 0x68, 0x9f, 0xa5, 0xaa, 0x51, 0x12, 0xa7,
	0xe1, 0xcd, 0x09, 0x18, 0xc9, 0x29, 0x11, 0xbb, 0x35, 0xb4, 0xf7, 0xbd, 0x35, 0x0e, 0xa1, 0x6a,
	0xc5, 0x66, 0x7d, 0x26, 0x9a, 0xf5, 0x31, 0xa3, 0xb9, 0x09, 0xf5, 0x15, 0x55, 0x98, 0x97, 0x80,
	0xab, 0xa3, 0xe6, 0x51, 0x55, 0x98, 0xdb, 0xb0, 0xb9, 0x46, 0x33, 0xe6, 0x4c, 0xa4, 0x4d, 0x8c,
	0x9e, 0x4f, 0xa0, 0x28, 0x71, 0xf2, 0xf8, 0xad, 0xb9, 0x85, 0x55, 0xc4, 0xa3, 0x6e, 0x52, 0x73,
	0x4b, 0x6c, 0x2c, 0xa1, 0x35, 0xf3, 0x42, 0xd4, 0xb8, 0x32, 0xc3, 0x1e, 0x52, 0x8e, 0xb9, 0x03,
	0x5b, 0xeb, 0x14, 0x69, 0xbe, 0x84, 0xdd, 0x94, 0x39, 0xf7, 0x30, 0xfe, 0x3d, 0x68, 0xa4, 0x89,
	0xd4, 0xfc, 0x16, 0x9e, 0xa6, 0xce, 0xbd, 0x87, 0x65, 0xd9, 0x87, 0xbd, 0x74, 0xcd, 0x9a, 0xb0,
	0x18, 0x5f, 0xc7, 0x3f, 0x41, 0x69, 0xfe, 0xdc, 0x43, 0x80, 0xc2, 0xf9, 0x2d, 0xb7, 0x7f, 0x65,
	0xc6, 0x06, 0x56, 0x40, 0x57, 0xcf, 0x31, 0x43, 0xc3, 0x1a, 0x40, 0x54, 0x33, 0xb7, 0x9d, 0xa1,
	0x91, 0xc1, 0x2a, 0x94, 0xe4, 0x9a, 0x59, 0x46, 0x36, 0x0c, 0x3e, 0x1f, 0xb8, 0xbe, 0x70, 0xe6,
	0xb0, 0x0c, 0x45, 0xb1, 0x62, 0x96, 0x91, 0x3f, 0xfe, 0x4d, 0x24, 0x90, 0xc3, 0x54, 0x87, 0x5c,
	0xf8, 0xe0, 0x31, 0x36, 0xb0, 0x04, 0x79, 0xf1, 0x94, 0x31, 0xb4, 0x30, 0x6b, 0xc4, 0x65, 0x64,
	0x42, 0x22, 0x55, 0xb5, 0x91, 0x0d, 0x89, 0x64, 0x0d, 0x46, 0x2e, 0x4c, 0x39, 0xff, 0x2d, 0x46,
	0x1e, 0xeb, 0xea, 0x7e, 0x96, 0xbb, 0x33, 0x0a, 0xb8, 0xb9, 0xb8, 0x75, 0x95, 0xb1, 0x78, 0x71,
	0xf6, 0xee, 0xdf, 0xa6, 0xf6, 0xf6, 0xbe, 0xa9, 0xbd, 0xbb, 0x6f, 0x6a, 0xff, 0xdc, 0x37, 0xb5,
	0x1f, 0x3f, 0x5d, 0x7a, 0x60, 0x4f, 0x28, 0xf7, 0xed, 0xc0, 0xf5, 0xed, 0xa1, 0xed, 0xa8, 0x85,
	0xc3, 0xda, 0xde, 0x9b, 0x61, 0xdb, 0x1b, 0xb4, 0x79, 0xe0, 0x0c, 0x0a, 0xe2, 0x15, 0x7d, 0xfa,
	0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xfd, 0x17, 0x85, 0x86, 0xa7, 0x0b, 0x00, 0x00,
}

func (m *TxnMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Status))
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTxn(dAtA, i, uint64(m.SnapshotTS.Size()))
	n1, err := m.SnapshotTS.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if m.PreparedTS != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.PreparedTS.Size()))
		n2, err := m.PreparedTS.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.CommitTS != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.CommitTS.Size()))
		n3, err := m.CommitTS.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Coordinator != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Coordinator.Size()))
		n4, err := m.Coordinator.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CNTxnSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNTxnSnapshot) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTxn(dAtA, i, uint64(m.Txn.Size()))
	n5, err := m.Txn.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if len(m.DNShards) > 0 {
		for _, msg := range m.DNShards {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTxn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ReadyOnly {
		dAtA[i] = 0x18
		i++
		if m.ReadyOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EnableCacheWrite {
		dAtA[i] = 0x20
		i++
		if m.EnableCacheWrite {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Disable1PCOpt {
		dAtA[i] = 0x28
		i++
		if m.Disable1PCOpt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CNOpRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNOpRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.OpCode))
	}
	if len(m.Payload) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxn(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTxn(dAtA, i, uint64(m.Target.Size()))
	n6, err := m.Target.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CNOpResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNOpResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTxn(dAtA, i, uint64(m.Txn.Size()))
	n7, err := m.Txn.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if m.Method != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Method))
	}
	if m.Flag != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Flag))
	}
	if m.CNRequest != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.CNRequest.Size()))
		n8, err := m.CNRequest.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.CommitRequest != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.CommitRequest.Size()))
		n9, err := m.CommitRequest.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.RollbackRequest != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.RollbackRequest.Size()))
		n10, err := m.RollbackRequest.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.PrepareRequest != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.PrepareRequest.Size()))
		n11, err := m.PrepareRequest.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.GetStatusRequest != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.GetStatusRequest.Size()))
		n12, err := m.GetStatusRequest.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.CommitDNShardRequest != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.CommitDNShardRequest.Size()))
		n13, err := m.CommitDNShardRequest.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.RollbackDNShardRequest != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.RollbackDNShardRequest.Size()))
		n14, err := m.RollbackDNShardRequest.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Txn != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Txn.Size()))
		n15, err := m.Txn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Method != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Method))
	}
	if m.Flag != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.Flag))
	}
	if m.TxnError != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.TxnError.Size()))
		n16, err := m.TxnError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.CNOpResponse != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.CNOpResponse.Size()))
		n17, err := m.CNOpResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.CommitResponse != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.CommitResponse.Size()))
		n18, err := m.CommitResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.RollbackResponse != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.RollbackResponse.Size()))
		n19, err := m.RollbackResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.PrepareResponse != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.PrepareResponse.Size()))
		n20, err := m.PrepareResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.GetStatusResponse != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.GetStatusResponse.Size()))
		n21, err := m.GetStatusResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.CommitDNShardResponse != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.CommitDNShardResponse.Size()))
		n22, err := m.CommitDNShardResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.RollbackDNShardResponse != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.RollbackDNShardResponse.Size()))
		n23, err := m.RollbackDNShardResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DNShards) > 0 {
		for _, msg := range m.DNShards {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTxn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Disable1PCOpt {
		dAtA[i] = 0x10
		i++
		if m.Disable1PCOpt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnCommitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnCommitResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnRollbackRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnRollbackRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DNShards) > 0 {
		for _, msg := range m.DNShards {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTxn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnRollbackResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnRollbackResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnPrepareRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnPrepareRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DNShard != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.DNShard.Size()))
		n24, err := m.DNShard.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if len(m.DNShards) > 0 {
		for _, msg := range m.DNShards {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTxn(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnPrepareResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnPrepareResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnGetStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnGetStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DNShard != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.DNShard.Size()))
		n25, err := m.DNShard.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnGetStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnGetStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnCommitDNShardRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnCommitDNShardRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DNShard != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.DNShard.Size()))
		n26, err := m.DNShard.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnCommitDNShardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnCommitDNShardResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnRollbackDNShardRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnRollbackDNShardRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DNShard != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxn(dAtA, i, uint64(m.DNShard.Size()))
		n27, err := m.DNShard.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnRollbackDNShardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnRollbackDNShardResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintTxn(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TxnMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTxn(uint64(m.Status))
	}
	l = m.SnapshotTS.Size()
	n += 1 + l + sovTxn(uint64(l))
	if m.PreparedTS != nil {
		l = m.PreparedTS.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.CommitTS != nil {
		l = m.CommitTS.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Coordinator != nil {
		l = m.Coordinator.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CNTxnSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Txn.Size()
	n += 1 + l + sovTxn(uint64(l))
	if len(m.DNShards) > 0 {
		for _, e := range m.DNShards {
			l = e.Size()
			n += 1 + l + sovTxn(uint64(l))
		}
	}
	if m.ReadyOnly {
		n += 2
	}
	if m.EnableCacheWrite {
		n += 2
	}
	if m.Disable1PCOpt {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CNOpRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OpCode != 0 {
		n += 1 + sovTxn(uint64(m.OpCode))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	l = m.Target.Size()
	n += 1 + l + sovTxn(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CNOpResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Txn.Size()
	n += 1 + l + sovTxn(uint64(l))
	if m.Method != 0 {
		n += 1 + sovTxn(uint64(m.Method))
	}
	if m.Flag != 0 {
		n += 1 + sovTxn(uint64(m.Flag))
	}
	if m.CNRequest != nil {
		l = m.CNRequest.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.CommitRequest != nil {
		l = m.CommitRequest.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.RollbackRequest != nil {
		l = m.RollbackRequest.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.PrepareRequest != nil {
		l = m.PrepareRequest.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.GetStatusRequest != nil {
		l = m.GetStatusRequest.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.CommitDNShardRequest != nil {
		l = m.CommitDNShardRequest.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.RollbackDNShardRequest != nil {
		l = m.RollbackDNShardRequest.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Txn != nil {
		l = m.Txn.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Method != 0 {
		n += 1 + sovTxn(uint64(m.Method))
	}
	if m.Flag != 0 {
		n += 1 + sovTxn(uint64(m.Flag))
	}
	if m.TxnError != nil {
		l = m.TxnError.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.CNOpResponse != nil {
		l = m.CNOpResponse.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.CommitResponse != nil {
		l = m.CommitResponse.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.RollbackResponse != nil {
		l = m.RollbackResponse.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.PrepareResponse != nil {
		l = m.PrepareResponse.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.GetStatusResponse != nil {
		l = m.GetStatusResponse.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.CommitDNShardResponse != nil {
		l = m.CommitDNShardResponse.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.RollbackDNShardResponse != nil {
		l = m.RollbackDNShardResponse.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnCommitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DNShards) > 0 {
		for _, e := range m.DNShards {
			l = e.Size()
			n += 1 + l + sovTxn(uint64(l))
		}
	}
	if m.Disable1PCOpt {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnCommitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnRollbackRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DNShards) > 0 {
		for _, e := range m.DNShards {
			l = e.Size()
			n += 1 + l + sovTxn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnRollbackResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnPrepareRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DNShard != nil {
		l = m.DNShard.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if len(m.DNShards) > 0 {
		for _, e := range m.DNShards {
			l = e.Size()
			n += 1 + l + sovTxn(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnPrepareResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnGetStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DNShard != nil {
		l = m.DNShard.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnGetStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnCommitDNShardRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DNShard != nil {
		l = m.DNShard.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnCommitDNShardResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnRollbackDNShardRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DNShard != nil {
		l = m.DNShard.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnRollbackDNShardResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTxn(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTxn(x uint64) (n int) {
	return sovTxn(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TxnMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TxnStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotTS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SnapshotTS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparedTS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreparedTS == nil {
				m.PreparedTS = &timestamp.Timestamp{}
			}
			if err := m.PreparedTS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommitTS == nil {
				m.CommitTS = &timestamp.Timestamp{}
			}
			if err := m.CommitTS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coordinator == nil {
				m.Coordinator = &metadata.DNShard{}
			}
			if err := m.Coordinator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNTxnSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNTxnSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNTxnSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DNShards = append(m.DNShards, metadata.DNShard{})
			if err := m.DNShards[len(m.DNShards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadyOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadyOnly = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableCacheWrite", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableCacheWrite = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable1PCOpt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable1PCOpt = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNOpRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNOpRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNOpRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpCode", wireType)
			}
			m.OpCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNOpResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNOpResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNOpResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			m.Method = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Method |= TxnMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CNRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CNRequest == nil {
				m.CNRequest = &CNOpRequest{}
			}
			if err := m.CNRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommitRequest == nil {
				m.CommitRequest = &TxnCommitRequest{}
			}
			if err := m.CommitRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RollbackRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RollbackRequest == nil {
				m.RollbackRequest = &TxnRollbackRequest{}
			}
			if err := m.RollbackRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrepareRequest == nil {
				m.PrepareRequest = &TxnPrepareRequest{}
			}
			if err := m.PrepareRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetStatusRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetStatusRequest == nil {
				m.GetStatusRequest = &TxnGetStatusRequest{}
			}
			if err := m.GetStatusRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitDNShardRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommitDNShardRequest == nil {
				m.CommitDNShardRequest = &TxnCommitDNShardRequest{}
			}
			if err := m.CommitDNShardRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RollbackDNShardRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RollbackDNShardRequest == nil {
				m.RollbackDNShardRequest = &TxnRollbackDNShardRequest{}
			}
			if err := m.RollbackDNShardRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Txn == nil {
				m.Txn = &TxnMeta{}
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			m.Method = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Method |= TxnMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxnError == nil {
				m.TxnError = &TxnError{}
			}
			if err := m.TxnError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CNOpResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CNOpResponse == nil {
				m.CNOpResponse = &CNOpResponse{}
			}
			if err := m.CNOpResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommitResponse == nil {
				m.CommitResponse = &TxnCommitResponse{}
			}
			if err := m.CommitResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RollbackResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RollbackResponse == nil {
				m.RollbackResponse = &TxnRollbackResponse{}
			}
			if err := m.RollbackResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrepareResponse == nil {
				m.PrepareResponse = &TxnPrepareResponse{}
			}
			if err := m.PrepareResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetStatusResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetStatusResponse == nil {
				m.GetStatusResponse = &TxnGetStatusResponse{}
			}
			if err := m.GetStatusResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitDNShardResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommitDNShardResponse == nil {
				m.CommitDNShardResponse = &TxnCommitDNShardResponse{}
			}
			if err := m.CommitDNShardResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RollbackDNShardResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RollbackDNShardResponse == nil {
				m.RollbackDNShardResponse = &TxnRollbackDNShardResponse{}
			}
			if err := m.RollbackDNShardResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DNShards = append(m.DNShards, metadata.DNShard{})
			if err := m.DNShards[len(m.DNShards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable1PCOpt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable1PCOpt = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnCommitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnCommitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnCommitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnRollbackRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnRollbackRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnRollbackRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DNShards = append(m.DNShards, metadata.DNShard{})
			if err := m.DNShards[len(m.DNShards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnRollbackResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnRollbackResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnRollbackResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnPrepareRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnPrepareRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnPrepareRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNShard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DNShard == nil {
				m.DNShard = &metadata.DNShard{}
			}
			if err := m.DNShard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DNShards = append(m.DNShards, metadata.DNShard{})
			if err := m.DNShards[len(m.DNShards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnPrepareResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnPrepareResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnPrepareResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnGetStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnGetStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnGetStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNShard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DNShard == nil {
				m.DNShard = &metadata.DNShard{}
			}
			if err := m.DNShard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnGetStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnGetStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnGetStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnCommitDNShardRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnCommitDNShardRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnCommitDNShardRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNShard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DNShard == nil {
				m.DNShard = &metadata.DNShard{}
			}
			if err := m.DNShard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnCommitDNShardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnCommitDNShardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnCommitDNShardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnRollbackDNShardRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnRollbackDNShardRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnRollbackDNShardRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNShard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DNShard == nil {
				m.DNShard = &metadata.DNShard{}
			}
			if err := m.DNShard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnRollbackDNShardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnRollbackDNShardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnRollbackDNShardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTxn(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTxn
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthTxn
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTxn
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTxn(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthTxn
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTxn = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTxn   = fmt.Errorf("proto: integer overflow")
)
