// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: txn.proto

package txn

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	lock "github.com/matrixorigin/matrixone/pkg/pb/lock"
	metadata "github.com/matrixorigin/matrixone/pkg/pb/metadata"
	timestamp "github.com/matrixorigin/matrixone/pkg/pb/timestamp"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TxnIsolation txn txn isolation
type TxnIsolation int32

const (
	// SI snapshot isolation
	TxnIsolation_SI TxnIsolation = 0
	// RC read committed
	TxnIsolation_RC TxnIsolation = 1
)

var TxnIsolation_name = map[int32]string{
	0: "SI",
	1: "RC",
}

var TxnIsolation_value = map[string]int32{
	"SI": 0,
	"RC": 1,
}

func (x TxnIsolation) String() string {
	return proto.EnumName(TxnIsolation_name, int32(x))
}

func (TxnIsolation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{0}
}

// TxnMode txn mode
type TxnMode int32

const (
	// Optimistic check conflict on commit.
	TxnMode_Optimistic TxnMode = 0
	// Pessimistic check conflict every write
	TxnMode_Pessimistic TxnMode = 1
)

var TxnMode_name = map[int32]string{
	0: "Optimistic",
	1: "Pessimistic",
}

var TxnMode_value = map[string]int32{
	"Optimistic":  0,
	"Pessimistic": 1,
}

func (x TxnMode) String() string {
	return proto.EnumName(TxnMode_name, int32(x))
}

func (TxnMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{1}
}

// TxnStatus transaction status
type TxnStatus int32

const (
	// Active is the state of transaction creation, in this state, can execute the
	// transaction Read/Write/Commit/Rollback.
	TxnStatus_Active TxnStatus = 0
	// Prepared for distributed transactions across TNs, a 2pc commit is performed,
	// and the prepared status means that the transaction on a TN was executed
	// successfully in the first phase.
	//
	// Note that this status needs to be saved to the LogService. Once the first
	// phase of a transaction is successful, data cannot be lost.
	TxnStatus_Prepared TxnStatus = 1
	// Committing for distributed transactions across TNs, once all TNs have completed
	// the first phase, the transaction enters the Committing state and initiates an
	// asynchronous process to handle the commit of temporary data.
	//
	// Note that when all TNs involved are in the prepared state, the distributed
	// transaction can be considered committed because all data has been written
	// successfully. The subsequent Committing process just explicitly converts these
	// writes into committed data.
	//
	// Note that the state exists only in memory and is not persisted to the LogService.
	// It can be restored through the Prepared state, if all(TN).Status == Prepared.
	TxnStatus_Committing TxnStatus = 2
	// Committed after the Committing phase has transformed all TN data involved into
	// committed data, the status of the distributed transaction is explicitly recorded
	// as Committed.
	//
	// Note that this status needs to be saved to the LogService
	TxnStatus_Committed TxnStatus = 3
	// Aborting a client initiating a Rollback call or a distributed transaction that has
	// any error in the first phase will enter the Aborting state. This state starts an
	// asynchronous task to clean up the temporary data written by the transaction.
	//
	// Note that the state exists only in memory and is not persisted to the LogService.
	// It can be restored through the Prepared state, if Any(TN).Status != Prepared.
	TxnStatus_Aborting TxnStatus = 4
	// Aborted after the Aborting phase, all data involved in the TN is cleaned up and
	// the transaction status is explicitly recorded as Aborted.
	//
	// Note that this status needs to be saved to the LogService
	TxnStatus_Aborted TxnStatus = 5
)

var TxnStatus_name = map[int32]string{
	0: "Active",
	1: "Prepared",
	2: "Committing",
	3: "Committed",
	4: "Aborting",
	5: "Aborted",
}

var TxnStatus_value = map[string]int32{
	"Active":     0,
	"Prepared":   1,
	"Committing": 2,
	"Committed":  3,
	"Aborting":   4,
	"Aborted":    5,
}

func (x TxnStatus) String() string {
	return proto.EnumName(TxnStatus_name, int32(x))
}

func (TxnStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{2}
}

// TxnMethod transaction operations
type TxnMethod int32

const (
	// Read transaction read
	TxnMethod_Read TxnMethod = 0
	// Write transaction write
	TxnMethod_Write TxnMethod = 1
	// Commit commit transaction
	TxnMethod_Commit TxnMethod = 2
	// Rollback rollback transaction
	TxnMethod_Rollback TxnMethod = 3
	// Prepare when TN(Coordinator) receives a commit request from CN, it sends a prepare to
	// each TN(TNShard)
	TxnMethod_Prepare TxnMethod = 4
	// GetStatus query the status of a transaction on a TN. When a TN encounters a transaction
	// in the Prepared state, it needs to go to the TN(Coordinator) to query the status of the
	// current transaction. When a TN encounters a transaction in the Prepared state during the
	// recover, it needs to query the status of the transaction on each TN(TNShard) to determine
	// if the transaction is committed.
	TxnMethod_GetStatus TxnMethod = 5
	// CommitTNShard after the 2pc transaction is committed, the temporary data on each TN needs
	// to be explicitly converted to committed data.
	TxnMethod_CommitTNShard TxnMethod = 6
	// RollbackTNShard after the 2pc transaction is aborted, the temporary data on each TN needs
	// to cleanup.
	TxnMethod_RollbackTNShard TxnMethod = 7
	// RemoveMedata Remove metadata for transactions on TNShard. For a 2pc distributed transaction,
	// after all participating TNShards have Prepared successfully, the asynchronous commit process
	// starts, sending CommitTNShard requests to all participating TNShards in parallel. After each
	// TNShard has processed the CommitTNShard, the metadata of the transaction cannot be deleted
	// immediately, otherwise when the transaction coordinator node is down and restarted, the commit
	// status of the transaction cannot be determined in the recovery process, as it is possible that
	// some participating TNShards cannot find the transaction information.
	//
	// TODO: needs to work with TAE's log compaction, not currently supported.
	TxnMethod_RemoveMedata TxnMethod = 8
	// DEBUG used to send debug request from cn to tn, and received response from tn to cn
	TxnMethod_DEBUG TxnMethod = 9
)

var TxnMethod_name = map[int32]string{
	0: "Read",
	1: "Write",
	2: "Commit",
	3: "Rollback",
	4: "Prepare",
	5: "GetStatus",
	6: "CommitTNShard",
	7: "RollbackTNShard",
	8: "RemoveMedata",
	9: "DEBUG",
}

var TxnMethod_value = map[string]int32{
	"Read":            0,
	"Write":           1,
	"Commit":          2,
	"Rollback":        3,
	"Prepare":         4,
	"GetStatus":       5,
	"CommitTNShard":   6,
	"RollbackTNShard": 7,
	"RemoveMedata":    8,
	"DEBUG":           9,
}

func (x TxnMethod) String() string {
	return proto.EnumName(TxnMethod_name, int32(x))
}

func (TxnMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{3}
}

// TxnMeta transaction metadata
type TxnMeta struct {
	// ID transaction id, generated at the CN node at the time of transaction creation,
	// globally unique.
	ID []byte `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// Status transaction status
	Status TxnStatus `protobuf:"varint,2,opt,name=Status,proto3,enum=txn.TxnStatus" json:"Status,omitempty"`
	// SnapshotTS transaction read timestamp, generated at the CN node at the time of
	// transaction creation. All data.TS < txn.SnapshotTS is visible for the current
	// transaction.
	SnapshotTS timestamp.Timestamp `protobuf:"bytes,3,opt,name=SnapshotTS,proto3" json:"SnapshotTS"`
	// PreparedTS timestamp to complete the first phase of a 2pc commit transaction.
	PreparedTS timestamp.Timestamp `protobuf:"bytes,4,opt,name=PreparedTS,proto3" json:"PreparedTS"`
	// CommitTS transaction commit timestamp. For a 2pc transaction, commitTS = max(preparedTS).
	CommitTS timestamp.Timestamp `protobuf:"bytes,5,opt,name=CommitTS,proto3" json:"CommitTS"`
	// TNShards all TNShards that have written data. The first TN is the coordinator of the
	// transaction
	TNShards []metadata.TNShard `protobuf:"bytes,6,rep,name=TNShards,proto3" json:"TNShards"`
	// LockTables For pessimistic transactions, LockTables record the bind metadata of the
	// LockTable corresponding to the successful locking of the current transaction. This data
	// is committed to the TN at Commit time, and the TN will check once if these bindings have
	// changed, and if they have, the transaction will be rolled back.
	LockTables []lock.LockTable `protobuf:"bytes,7,rep,name=LockTables,proto3" json:"LockTables"`
	// TxnMode txn mode
	Mode TxnMode `protobuf:"varint,8,opt,name=Mode,proto3,enum=txn.TxnMode" json:"Mode,omitempty"`
	// TxnIsolation isolation
	Isolation TxnIsolation `protobuf:"varint,9,opt,name=Isolation,proto3,enum=txn.TxnIsolation" json:"Isolation,omitempty"`
	// Mirror is mirror is true, means the current txn is not created on current node.
	Mirror bool `protobuf:"varint,10,opt,name=Mirror,proto3" json:"Mirror,omitempty"`
	// LockService lock service's service address. Empty if is not pessimistic txn.
	LockService          string   `protobuf:"bytes,11,opt,name=LockService,proto3" json:"LockService,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnMeta) Reset()         { *m = TxnMeta{} }
func (m *TxnMeta) String() string { return proto.CompactTextString(m) }
func (*TxnMeta) ProtoMessage()    {}
func (*TxnMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{0}
}
func (m *TxnMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnMeta.Merge(m, src)
}
func (m *TxnMeta) XXX_Size() int {
	return m.Size()
}
func (m *TxnMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnMeta.DiscardUnknown(m)
}

var xxx_messageInfo_TxnMeta proto.InternalMessageInfo

func (m *TxnMeta) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *TxnMeta) GetStatus() TxnStatus {
	if m != nil {
		return m.Status
	}
	return TxnStatus_Active
}

func (m *TxnMeta) GetSnapshotTS() timestamp.Timestamp {
	if m != nil {
		return m.SnapshotTS
	}
	return timestamp.Timestamp{}
}

func (m *TxnMeta) GetPreparedTS() timestamp.Timestamp {
	if m != nil {
		return m.PreparedTS
	}
	return timestamp.Timestamp{}
}

func (m *TxnMeta) GetCommitTS() timestamp.Timestamp {
	if m != nil {
		return m.CommitTS
	}
	return timestamp.Timestamp{}
}

func (m *TxnMeta) GetTNShards() []metadata.TNShard {
	if m != nil {
		return m.TNShards
	}
	return nil
}

func (m *TxnMeta) GetLockTables() []lock.LockTable {
	if m != nil {
		return m.LockTables
	}
	return nil
}

func (m *TxnMeta) GetMode() TxnMode {
	if m != nil {
		return m.Mode
	}
	return TxnMode_Optimistic
}

func (m *TxnMeta) GetIsolation() TxnIsolation {
	if m != nil {
		return m.Isolation
	}
	return TxnIsolation_SI
}

func (m *TxnMeta) GetMirror() bool {
	if m != nil {
		return m.Mirror
	}
	return false
}

func (m *TxnMeta) GetLockService() string {
	if m != nil {
		return m.LockService
	}
	return ""
}

// CNTxnSnapshot snapshot of the cn txn operation.
type CNTxnSnapshot struct {
	// ID txn id
	Txn TxnMeta `protobuf:"bytes,1,opt,name=Txn,proto3" json:"Txn"`
	// Deprecated: use TxnOptions
	ReadyOnly bool `protobuf:"varint,2,opt,name=ReadyOnly,proto3" json:"ReadyOnly,omitempty"`
	// Deprecated: use TxnOptions
	EnableCacheWrite bool `protobuf:"varint,3,opt,name=EnableCacheWrite,proto3" json:"EnableCacheWrite,omitempty"`
	// Deprecated: use TxnOptions
	Disable1PCOpt        bool             `protobuf:"varint,4,opt,name=Disable1PCOpt,proto3" json:"Disable1PCOpt,omitempty"`
	LockTables           []lock.LockTable `protobuf:"bytes,5,rep,name=LockTables,proto3" json:"LockTables"`
	Options              TxnOptions       `protobuf:"bytes,6,opt,name=Options,proto3" json:"Options"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *CNTxnSnapshot) Reset()         { *m = CNTxnSnapshot{} }
func (m *CNTxnSnapshot) String() string { return proto.CompactTextString(m) }
func (*CNTxnSnapshot) ProtoMessage()    {}
func (*CNTxnSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{1}
}
func (m *CNTxnSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNTxnSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNTxnSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNTxnSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNTxnSnapshot.Merge(m, src)
}
func (m *CNTxnSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *CNTxnSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_CNTxnSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_CNTxnSnapshot proto.InternalMessageInfo

func (m *CNTxnSnapshot) GetTxn() TxnMeta {
	if m != nil {
		return m.Txn
	}
	return TxnMeta{}
}

func (m *CNTxnSnapshot) GetReadyOnly() bool {
	if m != nil {
		return m.ReadyOnly
	}
	return false
}

func (m *CNTxnSnapshot) GetEnableCacheWrite() bool {
	if m != nil {
		return m.EnableCacheWrite
	}
	return false
}

func (m *CNTxnSnapshot) GetDisable1PCOpt() bool {
	if m != nil {
		return m.Disable1PCOpt
	}
	return false
}

func (m *CNTxnSnapshot) GetLockTables() []lock.LockTable {
	if m != nil {
		return m.LockTables
	}
	return nil
}

func (m *CNTxnSnapshot) GetOptions() TxnOptions {
	if m != nil {
		return m.Options
	}
	return TxnOptions{}
}

// CNOpRequest cn read/write request, CN -> TN. If data is written to more than one TN (>1) in a
// single transaction, then the transaction becomes a 2pc transaction.
type CNOpRequest struct {
	// OpCode request operation type
	OpCode uint32 `protobuf:"varint,1,opt,name=OpCode,proto3" json:"OpCode,omitempty"`
	// Payload the content of the request, TxnClient does not perceive the exact
	// format and content
	Payload []byte `protobuf:"bytes,2,opt,name=Payload,proto3" json:"Payload,omitempty"`
	// Target target to which the request was sent
	Target               metadata.TNShard `protobuf:"bytes,3,opt,name=Target,proto3" json:"Target"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *CNOpRequest) Reset()         { *m = CNOpRequest{} }
func (m *CNOpRequest) String() string { return proto.CompactTextString(m) }
func (*CNOpRequest) ProtoMessage()    {}
func (*CNOpRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{2}
}
func (m *CNOpRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNOpRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNOpRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNOpRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNOpRequest.Merge(m, src)
}
func (m *CNOpRequest) XXX_Size() int {
	return m.Size()
}
func (m *CNOpRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CNOpRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CNOpRequest proto.InternalMessageInfo

func (m *CNOpRequest) GetOpCode() uint32 {
	if m != nil {
		return m.OpCode
	}
	return 0
}

func (m *CNOpRequest) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *CNOpRequest) GetTarget() metadata.TNShard {
	if m != nil {
		return m.Target
	}
	return metadata.TNShard{}
}

// CNOpResponse cn read/write response, TN -> CN. A request corresponds to a response.
type CNOpResponse struct {
	// Payload response payload
	Payload              []byte   `protobuf:"bytes,1,opt,name=Payload,proto3" json:"Payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CNOpResponse) Reset()         { *m = CNOpResponse{} }
func (m *CNOpResponse) String() string { return proto.CompactTextString(m) }
func (*CNOpResponse) ProtoMessage()    {}
func (*CNOpResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{3}
}
func (m *CNOpResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CNOpResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CNOpResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CNOpResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CNOpResponse.Merge(m, src)
}
func (m *CNOpResponse) XXX_Size() int {
	return m.Size()
}
func (m *CNOpResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CNOpResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CNOpResponse proto.InternalMessageInfo

func (m *CNOpResponse) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

// TxnRequest transaction request. All requests for the transaction are made using TxnRequest, so that
// the codec and logical processing of the RPC can be unified. Specific requests are selected according
// to TxnMethod.
//
// Request flow of TxnRequest as below:
//  1. CN -> TN (TxnMethod.Read, TxnMethod.Write, TxnMethod.Commit, TxnMethod.Rollback)
//  2. TN -> TN (TxnMethod.Prepare, TxnMethod.GetStatus, TxnMethod.CommitTNShard, TxnMethod.RollbackTNShard,
//     TxnMethod.RemoveMetadata)
type TxnRequest struct {
	// RequestID request id
	RequestID uint64 `protobuf:"varint,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	// Txn transaction metadata
	Txn TxnMeta `protobuf:"bytes,2,opt,name=Txn,proto3" json:"Txn"`
	// TxnMethod TxnRequest opCode, select the Request defined below according to TxnMethod.
	Method TxnMethod `protobuf:"varint,3,opt,name=Method,proto3,enum=txn.TxnMethod" json:"Method,omitempty"`
	// Flag request flag
	Flag uint32 `protobuf:"varint,4,opt,name=Flag,proto3" json:"Flag,omitempty"`
	// CNOpRequest corresponds to TxnMethod.Read, TxnMethod.Write
	CNRequest *CNOpRequest `protobuf:"bytes,5,opt,name=CNRequest,proto3" json:"CNRequest,omitempty"`
	// TxnCommitRequest corresponds to TxnMethod.Commit
	CommitRequest *TxnCommitRequest `protobuf:"bytes,6,opt,name=CommitRequest,proto3" json:"CommitRequest,omitempty"`
	// TxnRollbackRequest corresponds to TxnMethod.Rollback
	RollbackRequest *TxnRollbackRequest `protobuf:"bytes,7,opt,name=RollbackRequest,proto3" json:"RollbackRequest,omitempty"`
	// TxnPrepareRequest corresponds to TxnMethod.Prepare
	PrepareRequest *TxnPrepareRequest `protobuf:"bytes,8,opt,name=PrepareRequest,proto3" json:"PrepareRequest,omitempty"`
	// TxnGetStatusRequest corresponds to TxnMethod.GetStatus
	GetStatusRequest *TxnGetStatusRequest `protobuf:"bytes,9,opt,name=GetStatusRequest,proto3" json:"GetStatusRequest,omitempty"`
	// TxnCommitTNShardRequest corresponds to TxnMethod.CommitTNShard
	CommitTNShardRequest *TxnCommitTNShardRequest `protobuf:"bytes,10,opt,name=CommitTNShardRequest,proto3" json:"CommitTNShardRequest,omitempty"`
	// TxnRollbackTNShardRequest corresponds to TxnMethod.RollbackTNShard
	RollbackTNShardRequest *TxnRollbackTNShardRequest `protobuf:"bytes,11,opt,name=RollbackTNShardRequest,proto3" json:"RollbackTNShardRequest,omitempty"`
	// TxnRemoveMetadataRequest  corresponds to TxnMethod.RemoveMetadata
	RemoveMetadata *TxnRemoveMetadataRequest `protobuf:"bytes,12,opt,name=RemoveMetadata,proto3" json:"RemoveMetadata,omitempty"`
	// TxnRequestOptions request options
	Options              *TxnRequestOptions `protobuf:"bytes,13,opt,name=Options,proto3" json:"Options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TxnRequest) Reset()         { *m = TxnRequest{} }
func (m *TxnRequest) String() string { return proto.CompactTextString(m) }
func (*TxnRequest) ProtoMessage()    {}
func (*TxnRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{4}
}
func (m *TxnRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnRequest.Merge(m, src)
}
func (m *TxnRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxnRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxnRequest proto.InternalMessageInfo

func (m *TxnRequest) GetRequestID() uint64 {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *TxnRequest) GetTxn() TxnMeta {
	if m != nil {
		return m.Txn
	}
	return TxnMeta{}
}

func (m *TxnRequest) GetMethod() TxnMethod {
	if m != nil {
		return m.Method
	}
	return TxnMethod_Read
}

func (m *TxnRequest) GetFlag() uint32 {
	if m != nil {
		return m.Flag
	}
	return 0
}

func (m *TxnRequest) GetCNRequest() *CNOpRequest {
	if m != nil {
		return m.CNRequest
	}
	return nil
}

func (m *TxnRequest) GetCommitRequest() *TxnCommitRequest {
	if m != nil {
		return m.CommitRequest
	}
	return nil
}

func (m *TxnRequest) GetRollbackRequest() *TxnRollbackRequest {
	if m != nil {
		return m.RollbackRequest
	}
	return nil
}

func (m *TxnRequest) GetPrepareRequest() *TxnPrepareRequest {
	if m != nil {
		return m.PrepareRequest
	}
	return nil
}

func (m *TxnRequest) GetGetStatusRequest() *TxnGetStatusRequest {
	if m != nil {
		return m.GetStatusRequest
	}
	return nil
}

func (m *TxnRequest) GetCommitTNShardRequest() *TxnCommitTNShardRequest {
	if m != nil {
		return m.CommitTNShardRequest
	}
	return nil
}

func (m *TxnRequest) GetRollbackTNShardRequest() *TxnRollbackTNShardRequest {
	if m != nil {
		return m.RollbackTNShardRequest
	}
	return nil
}

func (m *TxnRequest) GetRemoveMetadata() *TxnRemoveMetadataRequest {
	if m != nil {
		return m.RemoveMetadata
	}
	return nil
}

func (m *TxnRequest) GetOptions() *TxnRequestOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// TxnRequestOptions txn options
type TxnRequestOptions struct {
	// RetryCodes when TN processes TxnRequest and encounters the specified error, it needs to retry
	// on the server side. Only read and write can retry.
	RetryCodes []int32 `protobuf:"varint,1,rep,packed,name=RetryCodes,proto3" json:"RetryCodes,omitempty"`
	// RetryInterval retry interval, default is 100ms.
	RetryInterval        int64    `protobuf:"varint,2,opt,name=RetryInterval,proto3" json:"RetryInterval,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnRequestOptions) Reset()         { *m = TxnRequestOptions{} }
func (m *TxnRequestOptions) String() string { return proto.CompactTextString(m) }
func (*TxnRequestOptions) ProtoMessage()    {}
func (*TxnRequestOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{5}
}
func (m *TxnRequestOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnRequestOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnRequestOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnRequestOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnRequestOptions.Merge(m, src)
}
func (m *TxnRequestOptions) XXX_Size() int {
	return m.Size()
}
func (m *TxnRequestOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnRequestOptions.DiscardUnknown(m)
}

var xxx_messageInfo_TxnRequestOptions proto.InternalMessageInfo

func (m *TxnRequestOptions) GetRetryCodes() []int32 {
	if m != nil {
		return m.RetryCodes
	}
	return nil
}

func (m *TxnRequestOptions) GetRetryInterval() int64 {
	if m != nil {
		return m.RetryInterval
	}
	return 0
}

// TxnResponse response of TxnRequest.
type TxnResponse struct {
	// RequestID corresponding request id
	RequestID uint64 `protobuf:"varint,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	// Txn transaction metadata. TxnResponse.TxnMeta and TxnRequest.TxnMeta may differ
	// in that the node initiating the TxnRequest needs to process the returned TxnMeta,
	// e.g. to determine whether the transaction is Aborted by the status of the returned
	// TxnMeta.
	Txn *TxnMeta `protobuf:"bytes,2,opt,name=Txn,proto3" json:"Txn,omitempty"`
	// TxnMethod same as TxnRequest.TxnMethod
	Method TxnMethod `protobuf:"varint,3,opt,name=Method,proto3,enum=txn.TxnMethod" json:"Method,omitempty"`
	// Flag request flag, same as the corresponding request
	Flag uint32 `protobuf:"varint,4,opt,name=Flag,proto3" json:"Flag,omitempty"`
	// TxnError explicit error
	TxnError *TxnError `protobuf:"bytes,5,opt,name=TxnError,proto3" json:"TxnError,omitempty"`
	// CNOpResponse corresponds to TxnMethod.Read, TxnMethod.Write response
	CNOpResponse *CNOpResponse `protobuf:"bytes,6,opt,name=CNOpResponse,proto3" json:"CNOpResponse,omitempty"`
	// TxnCommitResponse corresponds to TxnMethod.Commit response
	CommitResponse *TxnCommitResponse `protobuf:"bytes,7,opt,name=CommitResponse,proto3" json:"CommitResponse,omitempty"`
	// TxnRollbackResponse corresponds to TxnMethod.Rollback response
	RollbackResponse *TxnRollbackResponse `protobuf:"bytes,8,opt,name=RollbackResponse,proto3" json:"RollbackResponse,omitempty"`
	// TxnPrepareResponse corresponds to TxnMethod.Prepare response
	PrepareResponse *TxnPrepareResponse `protobuf:"bytes,9,opt,name=PrepareResponse,proto3" json:"PrepareResponse,omitempty"`
	// TxnGetStatusResponse corresponds to TxnMethod.GetStatus response
	GetStatusResponse *TxnGetStatusResponse `protobuf:"bytes,10,opt,name=GetStatusResponse,proto3" json:"GetStatusResponse,omitempty"`
	// TxnCommitTNShardResponse corresponds to TxnMethod.CommitTNShard response
	CommitTNShardResponse *TxnCommitTNShardResponse `protobuf:"bytes,11,opt,name=CommitTNShardResponse,proto3" json:"CommitTNShardResponse,omitempty"`
	// TxnRollbackTNShardResponse corresponds to TxnMethod.RollbackTNShard response
	RollbackTNShardResponse *TxnRollbackTNShardResponse `protobuf:"bytes,12,opt,name=RollbackTNShardResponse,proto3" json:"RollbackTNShardResponse,omitempty"`
	// TxnRemoveMetadataResponse  corresponds to TxnMethod.RemoveMetadata
	RemoveMetadata       *TxnRemoveMetadataResponse `protobuf:"bytes,13,opt,name=RemoveMetadata,proto3" json:"RemoveMetadata,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *TxnResponse) Reset()         { *m = TxnResponse{} }
func (m *TxnResponse) String() string { return proto.CompactTextString(m) }
func (*TxnResponse) ProtoMessage()    {}
func (*TxnResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{6}
}
func (m *TxnResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnResponse.Merge(m, src)
}
func (m *TxnResponse) XXX_Size() int {
	return m.Size()
}
func (m *TxnResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TxnResponse proto.InternalMessageInfo

func (m *TxnResponse) GetRequestID() uint64 {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *TxnResponse) GetTxn() *TxnMeta {
	if m != nil {
		return m.Txn
	}
	return nil
}

func (m *TxnResponse) GetMethod() TxnMethod {
	if m != nil {
		return m.Method
	}
	return TxnMethod_Read
}

func (m *TxnResponse) GetFlag() uint32 {
	if m != nil {
		return m.Flag
	}
	return 0
}

func (m *TxnResponse) GetTxnError() *TxnError {
	if m != nil {
		return m.TxnError
	}
	return nil
}

func (m *TxnResponse) GetCNOpResponse() *CNOpResponse {
	if m != nil {
		return m.CNOpResponse
	}
	return nil
}

func (m *TxnResponse) GetCommitResponse() *TxnCommitResponse {
	if m != nil {
		return m.CommitResponse
	}
	return nil
}

func (m *TxnResponse) GetRollbackResponse() *TxnRollbackResponse {
	if m != nil {
		return m.RollbackResponse
	}
	return nil
}

func (m *TxnResponse) GetPrepareResponse() *TxnPrepareResponse {
	if m != nil {
		return m.PrepareResponse
	}
	return nil
}

func (m *TxnResponse) GetGetStatusResponse() *TxnGetStatusResponse {
	if m != nil {
		return m.GetStatusResponse
	}
	return nil
}

func (m *TxnResponse) GetCommitTNShardResponse() *TxnCommitTNShardResponse {
	if m != nil {
		return m.CommitTNShardResponse
	}
	return nil
}

func (m *TxnResponse) GetRollbackTNShardResponse() *TxnRollbackTNShardResponse {
	if m != nil {
		return m.RollbackTNShardResponse
	}
	return nil
}

func (m *TxnResponse) GetRemoveMetadata() *TxnRemoveMetadataResponse {
	if m != nil {
		return m.RemoveMetadata
	}
	return nil
}

// TxnCommitRequest CN sent the commit request to coordinator TN.
type TxnCommitRequest struct {
	Payload              []*TxnRequest `protobuf:"bytes,1,rep,name=Payload,proto3" json:"Payload,omitempty"`
	Disable1PCOpt        bool          `protobuf:"varint,2,opt,name=Disable1PCOpt,proto3" json:"Disable1PCOpt,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TxnCommitRequest) Reset()         { *m = TxnCommitRequest{} }
func (m *TxnCommitRequest) String() string { return proto.CompactTextString(m) }
func (*TxnCommitRequest) ProtoMessage()    {}
func (*TxnCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{7}
}
func (m *TxnCommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnCommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnCommitRequest.Merge(m, src)
}
func (m *TxnCommitRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxnCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxnCommitRequest proto.InternalMessageInfo

func (m *TxnCommitRequest) GetPayload() []*TxnRequest {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *TxnCommitRequest) GetDisable1PCOpt() bool {
	if m != nil {
		return m.Disable1PCOpt
	}
	return false
}

// TxnCommitResponse response of TxnCommitRequest.
type TxnCommitResponse struct {
	InvalidLockTables    []uint64 `protobuf:"varint,1,rep,packed,name=InvalidLockTables,proto3" json:"InvalidLockTables,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnCommitResponse) Reset()         { *m = TxnCommitResponse{} }
func (m *TxnCommitResponse) String() string { return proto.CompactTextString(m) }
func (*TxnCommitResponse) ProtoMessage()    {}
func (*TxnCommitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{8}
}
func (m *TxnCommitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnCommitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnCommitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnCommitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnCommitResponse.Merge(m, src)
}
func (m *TxnCommitResponse) XXX_Size() int {
	return m.Size()
}
func (m *TxnCommitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnCommitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TxnCommitResponse proto.InternalMessageInfo

func (m *TxnCommitResponse) GetInvalidLockTables() []uint64 {
	if m != nil {
		return m.InvalidLockTables
	}
	return nil
}

// TxnCommitRequest CN sent the rollback request to coordinator TN.
type TxnRollbackRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnRollbackRequest) Reset()         { *m = TxnRollbackRequest{} }
func (m *TxnRollbackRequest) String() string { return proto.CompactTextString(m) }
func (*TxnRollbackRequest) ProtoMessage()    {}
func (*TxnRollbackRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{9}
}
func (m *TxnRollbackRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnRollbackRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnRollbackRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnRollbackRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnRollbackRequest.Merge(m, src)
}
func (m *TxnRollbackRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxnRollbackRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnRollbackRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxnRollbackRequest proto.InternalMessageInfo

// TxnRollbackResponse response of TxnRollbackRequest.
type TxnRollbackResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnRollbackResponse) Reset()         { *m = TxnRollbackResponse{} }
func (m *TxnRollbackResponse) String() string { return proto.CompactTextString(m) }
func (*TxnRollbackResponse) ProtoMessage()    {}
func (*TxnRollbackResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{10}
}
func (m *TxnRollbackResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnRollbackResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnRollbackResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnRollbackResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnRollbackResponse.Merge(m, src)
}
func (m *TxnRollbackResponse) XXX_Size() int {
	return m.Size()
}
func (m *TxnRollbackResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnRollbackResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TxnRollbackResponse proto.InternalMessageInfo

// TxnPrepareRequest when a TN(coordinator) receives a Commit request from a CN, if
// more than one TN is involved, the 2PC commit process is enabled and the first phase
// is to send prepare requests to all TNs.
type TxnPrepareRequest struct {
	// TNShard prepare TN
	TNShard              metadata.TNShard `protobuf:"bytes,1,opt,name=TNShard,proto3" json:"TNShard"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *TxnPrepareRequest) Reset()         { *m = TxnPrepareRequest{} }
func (m *TxnPrepareRequest) String() string { return proto.CompactTextString(m) }
func (*TxnPrepareRequest) ProtoMessage()    {}
func (*TxnPrepareRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{11}
}
func (m *TxnPrepareRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnPrepareRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnPrepareRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnPrepareRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnPrepareRequest.Merge(m, src)
}
func (m *TxnPrepareRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxnPrepareRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnPrepareRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxnPrepareRequest proto.InternalMessageInfo

func (m *TxnPrepareRequest) GetTNShard() metadata.TNShard {
	if m != nil {
		return m.TNShard
	}
	return metadata.TNShard{}
}

// TxnPrepareResponse response of TxnPrepareRequest
type TxnPrepareResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnPrepareResponse) Reset()         { *m = TxnPrepareResponse{} }
func (m *TxnPrepareResponse) String() string { return proto.CompactTextString(m) }
func (*TxnPrepareResponse) ProtoMessage()    {}
func (*TxnPrepareResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{12}
}
func (m *TxnPrepareResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnPrepareResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnPrepareResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnPrepareResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnPrepareResponse.Merge(m, src)
}
func (m *TxnPrepareResponse) XXX_Size() int {
	return m.Size()
}
func (m *TxnPrepareResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnPrepareResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TxnPrepareResponse proto.InternalMessageInfo

// TxnGetStatusRequest query the status of a transaction on TN
type TxnGetStatusRequest struct {
	// TNShard target TN
	TNShard              metadata.TNShard `protobuf:"bytes,1,opt,name=TNShard,proto3" json:"TNShard"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *TxnGetStatusRequest) Reset()         { *m = TxnGetStatusRequest{} }
func (m *TxnGetStatusRequest) String() string { return proto.CompactTextString(m) }
func (*TxnGetStatusRequest) ProtoMessage()    {}
func (*TxnGetStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{13}
}
func (m *TxnGetStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnGetStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnGetStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnGetStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnGetStatusRequest.Merge(m, src)
}
func (m *TxnGetStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxnGetStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnGetStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxnGetStatusRequest proto.InternalMessageInfo

func (m *TxnGetStatusRequest) GetTNShard() metadata.TNShard {
	if m != nil {
		return m.TNShard
	}
	return metadata.TNShard{}
}

// TxnGetStatusResponse response of TxnGetStatusRequest
type TxnGetStatusResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnGetStatusResponse) Reset()         { *m = TxnGetStatusResponse{} }
func (m *TxnGetStatusResponse) String() string { return proto.CompactTextString(m) }
func (*TxnGetStatusResponse) ProtoMessage()    {}
func (*TxnGetStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{14}
}
func (m *TxnGetStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnGetStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnGetStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnGetStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnGetStatusResponse.Merge(m, src)
}
func (m *TxnGetStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *TxnGetStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnGetStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TxnGetStatusResponse proto.InternalMessageInfo

// TxnCommitTNShardRequest commit txn on TNShard. Data needs to be written to the
// LogService.
type TxnCommitTNShardRequest struct {
	// TNShard target TN
	TNShard              metadata.TNShard `protobuf:"bytes,1,opt,name=TNShard,proto3" json:"TNShard"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *TxnCommitTNShardRequest) Reset()         { *m = TxnCommitTNShardRequest{} }
func (m *TxnCommitTNShardRequest) String() string { return proto.CompactTextString(m) }
func (*TxnCommitTNShardRequest) ProtoMessage()    {}
func (*TxnCommitTNShardRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{15}
}
func (m *TxnCommitTNShardRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnCommitTNShardRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnCommitTNShardRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnCommitTNShardRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnCommitTNShardRequest.Merge(m, src)
}
func (m *TxnCommitTNShardRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxnCommitTNShardRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnCommitTNShardRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxnCommitTNShardRequest proto.InternalMessageInfo

func (m *TxnCommitTNShardRequest) GetTNShard() metadata.TNShard {
	if m != nil {
		return m.TNShard
	}
	return metadata.TNShard{}
}

// TxnCommitTNShardResponse response of TxnCommitTNShardRequest
type TxnCommitTNShardResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnCommitTNShardResponse) Reset()         { *m = TxnCommitTNShardResponse{} }
func (m *TxnCommitTNShardResponse) String() string { return proto.CompactTextString(m) }
func (*TxnCommitTNShardResponse) ProtoMessage()    {}
func (*TxnCommitTNShardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{16}
}
func (m *TxnCommitTNShardResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnCommitTNShardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnCommitTNShardResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnCommitTNShardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnCommitTNShardResponse.Merge(m, src)
}
func (m *TxnCommitTNShardResponse) XXX_Size() int {
	return m.Size()
}
func (m *TxnCommitTNShardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnCommitTNShardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TxnCommitTNShardResponse proto.InternalMessageInfo

// TxnRollbackTNShardRequest rollback txn on TNShard
type TxnRollbackTNShardRequest struct {
	// TNShard target TN
	TNShard              metadata.TNShard `protobuf:"bytes,1,opt,name=TNShard,proto3" json:"TNShard"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *TxnRollbackTNShardRequest) Reset()         { *m = TxnRollbackTNShardRequest{} }
func (m *TxnRollbackTNShardRequest) String() string { return proto.CompactTextString(m) }
func (*TxnRollbackTNShardRequest) ProtoMessage()    {}
func (*TxnRollbackTNShardRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{17}
}
func (m *TxnRollbackTNShardRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnRollbackTNShardRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnRollbackTNShardRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnRollbackTNShardRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnRollbackTNShardRequest.Merge(m, src)
}
func (m *TxnRollbackTNShardRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxnRollbackTNShardRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnRollbackTNShardRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxnRollbackTNShardRequest proto.InternalMessageInfo

func (m *TxnRollbackTNShardRequest) GetTNShard() metadata.TNShard {
	if m != nil {
		return m.TNShard
	}
	return metadata.TNShard{}
}

// TxnRollbackTNShardResponse response of TxnRollbackTNShardRequest
type TxnRollbackTNShardResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnRollbackTNShardResponse) Reset()         { *m = TxnRollbackTNShardResponse{} }
func (m *TxnRollbackTNShardResponse) String() string { return proto.CompactTextString(m) }
func (*TxnRollbackTNShardResponse) ProtoMessage()    {}
func (*TxnRollbackTNShardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{18}
}
func (m *TxnRollbackTNShardResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnRollbackTNShardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnRollbackTNShardResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnRollbackTNShardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnRollbackTNShardResponse.Merge(m, src)
}
func (m *TxnRollbackTNShardResponse) XXX_Size() int {
	return m.Size()
}
func (m *TxnRollbackTNShardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnRollbackTNShardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TxnRollbackTNShardResponse proto.InternalMessageInfo

// TxnRemoveMetadataRequest remove txn metadata on TNShard
type TxnRemoveMetadataRequest struct {
	// TNShard target TN
	TNShard              metadata.TNShard `protobuf:"bytes,1,opt,name=TNShard,proto3" json:"TNShard"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *TxnRemoveMetadataRequest) Reset()         { *m = TxnRemoveMetadataRequest{} }
func (m *TxnRemoveMetadataRequest) String() string { return proto.CompactTextString(m) }
func (*TxnRemoveMetadataRequest) ProtoMessage()    {}
func (*TxnRemoveMetadataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{19}
}
func (m *TxnRemoveMetadataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnRemoveMetadataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnRemoveMetadataRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnRemoveMetadataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnRemoveMetadataRequest.Merge(m, src)
}
func (m *TxnRemoveMetadataRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxnRemoveMetadataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnRemoveMetadataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxnRemoveMetadataRequest proto.InternalMessageInfo

func (m *TxnRemoveMetadataRequest) GetTNShard() metadata.TNShard {
	if m != nil {
		return m.TNShard
	}
	return metadata.TNShard{}
}

// TxnRemoveMetadataResponse response of TxnRemoveMetadataRequest
type TxnRemoveMetadataResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnRemoveMetadataResponse) Reset()         { *m = TxnRemoveMetadataResponse{} }
func (m *TxnRemoveMetadataResponse) String() string { return proto.CompactTextString(m) }
func (*TxnRemoveMetadataResponse) ProtoMessage()    {}
func (*TxnRemoveMetadataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{20}
}
func (m *TxnRemoveMetadataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnRemoveMetadataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnRemoveMetadataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnRemoveMetadataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnRemoveMetadataResponse.Merge(m, src)
}
func (m *TxnRemoveMetadataResponse) XXX_Size() int {
	return m.Size()
}
func (m *TxnRemoveMetadataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnRemoveMetadataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TxnRemoveMetadataResponse proto.InternalMessageInfo

// TxnError all explicit errors in transaction operations.
type TxnError struct {
	// Code moerr code, used to special error handle without unmarshal moerr
	Code uint32 `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	// Error we use this field to send moerr from tn to cn. Set with
	// moerr.MarshalBinary, and use moerr.UnmarshalBinary to restore
	// moerr.
	Error []byte `protobuf:"bytes,2,opt,name=Error,proto3" json:"Error,omitempty"`
	// TxnErrCode is a internal err code in the txn framework and used to indicate
	// what transaction operation failed. Usually this value is the same as the value
	// of Code, except for the error returned by the interface call to TxnStorage.
	// Because the types of errors returned by TxnStorage's interface are unknown to the
	// transaction framework, it is necessary to use a code for the interface call to uniformly
	// replace these error codes.
	TxnErrCode           uint32   `protobuf:"varint,3,opt,name=TxnErrCode,proto3" json:"TxnErrCode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnError) Reset()         { *m = TxnError{} }
func (m *TxnError) String() string { return proto.CompactTextString(m) }
func (*TxnError) ProtoMessage()    {}
func (*TxnError) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{21}
}
func (m *TxnError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnError.Merge(m, src)
}
func (m *TxnError) XXX_Size() int {
	return m.Size()
}
func (m *TxnError) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnError.DiscardUnknown(m)
}

var xxx_messageInfo_TxnError proto.InternalMessageInfo

func (m *TxnError) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *TxnError) GetError() []byte {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *TxnError) GetTxnErrCode() uint32 {
	if m != nil {
		return m.TxnErrCode
	}
	return 0
}

type TxnOptions struct {
	Features             uint32          `protobuf:"varint,1,opt,name=Features,proto3" json:"Features,omitempty"`
	CN                   string          `protobuf:"bytes,2,opt,name=CN,proto3" json:"CN,omitempty"`
	SessionID            string          `protobuf:"bytes,3,opt,name=SessionID,proto3" json:"SessionID,omitempty"`
	AccountID            uint32          `protobuf:"varint,4,opt,name=AccountID,proto3" json:"AccountID,omitempty"`
	ConnectionID         uint32          `protobuf:"varint,5,opt,name=ConnectionID,proto3" json:"ConnectionID,omitempty"`
	UserName             string          `protobuf:"bytes,6,opt,name=UserName,proto3" json:"UserName,omitempty"`
	SkipLockTables       []uint64        `protobuf:"varint,7,rep,packed,name=SkipLockTables,proto3" json:"SkipLockTables,omitempty"`
	SkipLockTableModes   []lock.LockMode `protobuf:"varint,8,rep,packed,name=SkipLockTableModes,proto3,enum=lock.LockMode" json:"SkipLockTableModes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *TxnOptions) Reset()         { *m = TxnOptions{} }
func (m *TxnOptions) String() string { return proto.CompactTextString(m) }
func (*TxnOptions) ProtoMessage()    {}
func (*TxnOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f782e76b37adb9a, []int{22}
}
func (m *TxnOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnOptions.Merge(m, src)
}
func (m *TxnOptions) XXX_Size() int {
	return m.Size()
}
func (m *TxnOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnOptions.DiscardUnknown(m)
}

var xxx_messageInfo_TxnOptions proto.InternalMessageInfo

func (m *TxnOptions) GetFeatures() uint32 {
	if m != nil {
		return m.Features
	}
	return 0
}

func (m *TxnOptions) GetCN() string {
	if m != nil {
		return m.CN
	}
	return ""
}

func (m *TxnOptions) GetSessionID() string {
	if m != nil {
		return m.SessionID
	}
	return ""
}

func (m *TxnOptions) GetAccountID() uint32 {
	if m != nil {
		return m.AccountID
	}
	return 0
}

func (m *TxnOptions) GetConnectionID() uint32 {
	if m != nil {
		return m.ConnectionID
	}
	return 0
}

func (m *TxnOptions) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *TxnOptions) GetSkipLockTables() []uint64 {
	if m != nil {
		return m.SkipLockTables
	}
	return nil
}

func (m *TxnOptions) GetSkipLockTableModes() []lock.LockMode {
	if m != nil {
		return m.SkipLockTableModes
	}
	return nil
}

func init() {
	proto.RegisterEnum("txn.TxnIsolation", TxnIsolation_name, TxnIsolation_value)
	proto.RegisterEnum("txn.TxnMode", TxnMode_name, TxnMode_value)
	proto.RegisterEnum("txn.TxnStatus", TxnStatus_name, TxnStatus_value)
	proto.RegisterEnum("txn.TxnMethod", TxnMethod_name, TxnMethod_value)
	proto.RegisterType((*TxnMeta)(nil), "txn.TxnMeta")
	proto.RegisterType((*CNTxnSnapshot)(nil), "txn.CNTxnSnapshot")
	proto.RegisterType((*CNOpRequest)(nil), "txn.CNOpRequest")
	proto.RegisterType((*CNOpResponse)(nil), "txn.CNOpResponse")
	proto.RegisterType((*TxnRequest)(nil), "txn.TxnRequest")
	proto.RegisterType((*TxnRequestOptions)(nil), "txn.TxnRequestOptions")
	proto.RegisterType((*TxnResponse)(nil), "txn.TxnResponse")
	proto.RegisterType((*TxnCommitRequest)(nil), "txn.TxnCommitRequest")
	proto.RegisterType((*TxnCommitResponse)(nil), "txn.TxnCommitResponse")
	proto.RegisterType((*TxnRollbackRequest)(nil), "txn.TxnRollbackRequest")
	proto.RegisterType((*TxnRollbackResponse)(nil), "txn.TxnRollbackResponse")
	proto.RegisterType((*TxnPrepareRequest)(nil), "txn.TxnPrepareRequest")
	proto.RegisterType((*TxnPrepareResponse)(nil), "txn.TxnPrepareResponse")
	proto.RegisterType((*TxnGetStatusRequest)(nil), "txn.TxnGetStatusRequest")
	proto.RegisterType((*TxnGetStatusResponse)(nil), "txn.TxnGetStatusResponse")
	proto.RegisterType((*TxnCommitTNShardRequest)(nil), "txn.TxnCommitTNShardRequest")
	proto.RegisterType((*TxnCommitTNShardResponse)(nil), "txn.TxnCommitTNShardResponse")
	proto.RegisterType((*TxnRollbackTNShardRequest)(nil), "txn.TxnRollbackTNShardRequest")
	proto.RegisterType((*TxnRollbackTNShardResponse)(nil), "txn.TxnRollbackTNShardResponse")
	proto.RegisterType((*TxnRemoveMetadataRequest)(nil), "txn.TxnRemoveMetadataRequest")
	proto.RegisterType((*TxnRemoveMetadataResponse)(nil), "txn.TxnRemoveMetadataResponse")
	proto.RegisterType((*TxnError)(nil), "txn.TxnError")
	proto.RegisterType((*TxnOptions)(nil), "txn.TxnOptions")
}

func init() { proto.RegisterFile("txn.proto", fileDescriptor_4f782e76b37adb9a) }

var fileDescriptor_4f782e76b37adb9a = []byte{
	// 1456 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0xdd, 0x6e, 0xdb, 0x36,
	0x14, 0x8e, 0xfc, 0x2b, 0x1d, 0xff, 0x44, 0x66, 0xd3, 0x54, 0xcd, 0x3a, 0xd7, 0x10, 0x8a, 0xc2,
	0x0d, 0x3a, 0x7b, 0x6d, 0xd1, 0x5d, 0x6c, 0x40, 0x80, 0xd4, 0x49, 0x3a, 0x03, 0xb5, 0x13, 0xd0,
	0xee, 0x86, 0xee, 0x66, 0x90, 0x6d, 0xce, 0x11, 0x62, 0x4b, 0x9e, 0xc4, 0x04, 0xce, 0x43, 0xec,
	0x09, 0xb6, 0x07, 0xea, 0x65, 0x9f, 0x60, 0xd8, 0x02, 0xec, 0x66, 0xb7, 0x7b, 0x81, 0x81, 0x14,
	0xa9, 0x3f, 0xdb, 0xed, 0x90, 0x5d, 0x59, 0x3c, 0x3f, 0xdf, 0xa1, 0x0f, 0xcf, 0x77, 0x0e, 0x09,
	0x1a, 0x5d, 0x3a, 0xad, 0x85, 0xe7, 0x52, 0x17, 0x65, 0xe9, 0xd2, 0xd9, 0xfb, 0x62, 0x6a, 0xd3,
	0xf3, 0xcb, 0x51, 0x6b, 0xec, 0xce, 0xdb, 0x53, 0x77, 0xea, 0xb6, 0xb9, 0x6e, 0x74, 0xf9, 0x13,
	0x5f, 0xf1, 0x05, 0xff, 0x0a, 0x7c, 0xf6, 0xb6, 0xa9, 0x3d, 0x27, 0x3e, 0xb5, 0xe6, 0x0b, 0x21,
	0xa8, 0xce, 0x09, 0xb5, 0x26, 0x16, 0xb5, 0xc4, 0x1a, 0x66, 0xee, 0xf8, 0x22, 0xf8, 0x36, 0xff,
	0xce, 0x42, 0x71, 0xb8, 0x74, 0x7a, 0x84, 0x5a, 0xa8, 0x0a, 0x99, 0xee, 0x91, 0xa1, 0x34, 0x94,
	0x66, 0x19, 0x67, 0xba, 0x47, 0xe8, 0x31, 0x14, 0x06, 0xd4, 0xa2, 0x97, 0xbe, 0x91, 0x69, 0x28,
	0xcd, 0xea, 0xf3, 0x6a, 0x8b, 0x6d, 0x6c, 0xb8, 0x74, 0x02, 0x29, 0x16, 0x5a, 0xf4, 0x35, 0xc0,
	0xc0, 0xb1, 0x16, 0xfe, 0xb9, 0x4b, 0x87, 0x03, 0x23, 0xdb, 0x50, 0x9a, 0xa5, 0xe7, 0x3b, 0xad,
	0x68, 0x17, 0x43, 0xf9, 0xf5, 0x2a, 0xf7, 0xfe, 0xf7, 0x87, 0x5b, 0x38, 0x66, 0xcd, 0x7c, 0xcf,
	0x3c, 0xb2, 0xb0, 0x3c, 0x32, 0x19, 0x0e, 0x8c, 0xdc, 0xa7, 0x7d, 0x23, 0x6b, 0xf4, 0x15, 0xa8,
	0x1d, 0x77, 0x3e, 0xb7, 0x59, 0xd4, 0xfc, 0x27, 0x3d, 0x43, 0x5b, 0xf4, 0x02, 0xd4, 0x61, 0x7f,
	0x70, 0x6e, 0x79, 0x13, 0xdf, 0x28, 0x34, 0xb2, 0xcd, 0xd2, 0xf3, 0x5a, 0x2b, 0x4c, 0x91, 0xd0,
	0x48, 0x27, 0x69, 0x88, 0x5e, 0x02, 0xbc, 0x71, 0xc7, 0x17, 0x43, 0x6b, 0x34, 0x23, 0xbe, 0x51,
	0xe4, 0x6e, 0xdb, 0x2d, 0x9e, 0xc9, 0x50, 0x2e, 0xf7, 0x18, 0x19, 0xa2, 0x06, 0xe4, 0x7a, 0xee,
	0x84, 0x18, 0x2a, 0xcf, 0x60, 0x59, 0x66, 0x90, 0xc9, 0x30, 0xd7, 0xa0, 0x36, 0x68, 0x5d, 0xdf,
	0x9d, 0x59, 0xd4, 0x76, 0x1d, 0x43, 0xe3, 0x66, 0x35, 0x69, 0x16, 0x2a, 0x70, 0x64, 0x83, 0x76,
	0xa1, 0xd0, 0xb3, 0x3d, 0xcf, 0xf5, 0x0c, 0x68, 0x28, 0x4d, 0x15, 0x8b, 0x15, 0x6a, 0x40, 0x89,
	0x05, 0x1e, 0x10, 0xef, 0xca, 0x1e, 0x13, 0xa3, 0xd4, 0x50, 0x9a, 0x1a, 0x8e, 0x8b, 0xcc, 0x5f,
	0x32, 0x50, 0xe9, 0xf4, 0xd9, 0x01, 0x8a, 0x03, 0x40, 0x8f, 0x20, 0x3b, 0x5c, 0x3a, 0xfc, 0xcc,
	0x4b, 0xb1, 0xdd, 0x11, 0x6a, 0x89, 0xff, 0xc2, 0xd4, 0xe8, 0x01, 0x68, 0x98, 0x58, 0x93, 0xeb,
	0x53, 0x67, 0x76, 0xcd, 0x6b, 0x41, 0xc5, 0x91, 0x00, 0xed, 0x83, 0x7e, 0xec, 0xb0, 0x7f, 0xdb,
	0xb1, 0xc6, 0xe7, 0xe4, 0x7b, 0xcf, 0xa6, 0x84, 0x17, 0x81, 0x8a, 0x57, 0xe4, 0xe8, 0x11, 0x54,
	0x8e, 0x6c, 0x9f, 0x09, 0x9f, 0x9d, 0x75, 0x4e, 0x17, 0x94, 0x9f, 0xb8, 0x8a, 0x93, 0xc2, 0x54,
	0xae, 0xf3, 0xff, 0x35, 0xd7, 0x6d, 0x28, 0x9e, 0x2e, 0x58, 0x8a, 0xd8, 0xb1, 0x2a, 0xdc, 0x47,
	0xfc, 0x21, 0x21, 0x16, 0x3e, 0xd2, 0xca, 0x5c, 0x40, 0xa9, 0xd3, 0x3f, 0x5d, 0x60, 0xf2, 0xf3,
	0x25, 0xf1, 0x29, 0x4b, 0xec, 0xe9, 0xa2, 0xc3, 0x4e, 0x8b, 0xe5, 0xa3, 0x82, 0xc5, 0x0a, 0x19,
	0x50, 0x3c, 0xb3, 0xae, 0x67, 0xae, 0x35, 0xe1, 0x7f, 0xbe, 0x8c, 0xe5, 0x12, 0xb5, 0xa1, 0x30,
	0xb4, 0xbc, 0x29, 0xa1, 0xa2, 0xea, 0x37, 0xd6, 0x91, 0x30, 0x33, 0x9b, 0x50, 0x0e, 0x22, 0xfa,
	0x0b, 0xd7, 0xf1, 0x13, 0xd0, 0x4a, 0x02, 0xda, 0xfc, 0x2b, 0x0f, 0x30, 0x5c, 0x3a, 0x72, 0x6f,
	0xfc, 0x08, 0xf8, 0xa7, 0xa0, 0x68, 0x0e, 0x47, 0x02, 0x79, 0x8c, 0x99, 0x8f, 0x1f, 0xe3, 0x63,
	0x28, 0xf4, 0x08, 0x3d, 0x77, 0x27, 0x7c, 0xb7, 0x31, 0x3e, 0x07, 0x52, 0x2c, 0xb4, 0x08, 0x41,
	0xee, 0x64, 0x66, 0x4d, 0xf9, 0xd9, 0x54, 0x30, 0xff, 0x46, 0x2d, 0xd0, 0x3a, 0x7d, 0x11, 0x50,
	0x90, 0x4d, 0xe7, 0xee, 0xb1, 0x04, 0xe2, 0xc8, 0x04, 0x7d, 0x03, 0x95, 0x80, 0x6f, 0xd2, 0x27,
	0x38, 0x91, 0xbb, 0x32, 0x64, 0x42, 0x89, 0x93, 0xb6, 0xe8, 0x10, 0xb6, 0xb1, 0x3b, 0x9b, 0x8d,
	0xac, 0xf1, 0x85, 0x74, 0x2f, 0x72, 0xf7, 0x7b, 0xd2, 0x3d, 0xa5, 0xc6, 0x69, 0x7b, 0x74, 0x00,
	0x55, 0xd1, 0x29, 0x24, 0x82, 0xca, 0x11, 0x76, 0x25, 0x42, 0x52, 0x8b, 0x53, 0xd6, 0xe8, 0x08,
	0xf4, 0xd7, 0x84, 0x8a, 0x46, 0x27, 0x10, 0x34, 0x8e, 0x60, 0x48, 0x84, 0xb4, 0x1e, 0xaf, 0x78,
	0xa0, 0x33, 0xd8, 0x11, 0x5d, 0x27, 0xa8, 0x06, 0x89, 0x04, 0x1c, 0xe9, 0x41, 0x32, 0x19, 0x49,
	0x1b, 0xbc, 0xd6, 0x13, 0x7d, 0x07, 0xbb, 0xf2, 0xaf, 0xa6, 0x30, 0x4b, 0x1c, 0xb3, 0x9e, 0xce,
	0x50, 0x0a, 0x75, 0x83, 0x37, 0x3a, 0x86, 0x2a, 0x26, 0x73, 0xf7, 0x8a, 0xf4, 0x44, 0x01, 0x1b,
	0x65, 0x8e, 0xf7, 0x79, 0x88, 0x97, 0xd0, 0x86, 0x69, 0x4b, 0x8a, 0xd1, 0x97, 0x11, 0x05, 0x2b,
	0xc9, 0x7c, 0x0b, 0x0f, 0xa1, 0x8d, 0x38, 0xf8, 0x0e, 0x6a, 0x2b, 0x5a, 0x54, 0x07, 0xc0, 0x84,
	0x7a, 0xd7, 0x8c, 0x7e, 0xbe, 0xa1, 0x34, 0xb2, 0xcd, 0x3c, 0x8e, 0x49, 0x58, 0x1b, 0xe1, 0xab,
	0xae, 0x43, 0x89, 0x77, 0x65, 0xcd, 0x78, 0xe5, 0x67, 0x71, 0x52, 0x68, 0xfe, 0x93, 0x87, 0x12,
	0xc7, 0x16, 0x64, 0xfb, 0x38, 0x87, 0xea, 0x1b, 0x39, 0xf4, 0xff, 0xd9, 0xf3, 0x04, 0xd4, 0xe1,
	0xd2, 0x39, 0xe6, 0x4d, 0x3b, 0x20, 0x4f, 0x45, 0x7a, 0x73, 0x21, 0x0e, 0xd5, 0xe8, 0x65, 0xb2,
	0x43, 0x08, 0xde, 0xd4, 0x62, 0x5c, 0x0b, 0x14, 0x38, 0xd9, 0x48, 0x0e, 0xa0, 0x2a, 0x39, 0x24,
	0x1c, 0x8b, 0xc9, 0xfc, 0x27, 0xb5, 0x38, 0x65, 0xcd, 0xea, 0x3d, 0xa2, 0x90, 0x40, 0x50, 0x93,
	0xf5, 0x9e, 0xd6, 0xe3, 0x15, 0x0f, 0x46, 0xdc, 0x90, 0x47, 0x02, 0x44, 0x4b, 0x12, 0x37, 0xa5,
	0xc6, 0x69, 0x7b, 0xf4, 0x1a, 0x6a, 0x31, 0x1a, 0x09, 0x90, 0x80, 0x2f, 0xf7, 0xd7, 0x30, 0x4f,
	0xc0, 0xac, 0xfa, 0xa0, 0x01, 0xdc, 0x4d, 0x31, 0x48, 0x80, 0x95, 0x92, 0x85, 0xbd, 0xd6, 0x08,
	0xaf, 0xf7, 0x45, 0xef, 0xe0, 0xde, 0x0a, 0x81, 0x04, 0x6c, 0xc0, 0x97, 0x87, 0x1b, 0xf9, 0x27,
	0x80, 0x37, 0xf9, 0xa3, 0x93, 0x15, 0x06, 0x56, 0x52, 0x8c, 0x4e, 0x31, 0x50, 0x9e, 0x64, 0x52,
	0x6e, 0x8e, 0x41, 0x4f, 0xf7, 0x57, 0xf4, 0x24, 0x3e, 0x66, 0xb2, 0xf1, 0xc9, 0x28, 0x89, 0x1c,
	0x8e, 0xb4, 0x95, 0x09, 0x9d, 0x59, 0x33, 0xa1, 0xcd, 0x43, 0xce, 0xda, 0x54, 0x0d, 0x3d, 0x85,
	0x5a, 0xd7, 0xb9, 0xb2, 0x66, 0xf6, 0x24, 0x36, 0xbd, 0x59, 0xbc, 0x1c, 0x5e, 0x55, 0x98, 0x3b,
	0x80, 0x56, 0x1b, 0xb9, 0x79, 0x17, 0xee, 0xac, 0x29, 0x35, 0xf3, 0x84, 0xc7, 0x4b, 0xf5, 0xe8,
	0x67, 0x50, 0x14, 0x49, 0x14, 0x17, 0x98, 0x8d, 0xe3, 0x57, 0xda, 0x89, 0xa0, 0xa9, 0x9a, 0x33,
	0xbf, 0xe5, 0x41, 0x57, 0xba, 0xf7, 0x2d, 0xf0, 0x77, 0x61, 0x67, 0x5d, 0x7d, 0x9a, 0x6f, 0xe0,
	0xde, 0x86, 0x3e, 0x7f, 0x9b, 0x28, 0x7b, 0x60, 0x6c, 0x2a, 0x5c, 0xb3, 0x0f, 0xf7, 0x37, 0x76,
	0xff, 0xdb, 0xc4, 0x7a, 0x00, 0x7b, 0x9b, 0xab, 0xd9, 0xec, 0xf1, 0x9d, 0xac, 0x9d, 0x0d, 0xb7,
	0x09, 0xf6, 0x59, 0xb0, 0xf9, 0xb5, 0x85, 0x6e, 0x0e, 0xa3, 0x26, 0xca, 0x9a, 0x6c, 0xec, 0xa2,
	0xc6, 0xbf, 0xd1, 0x0e, 0xe4, 0x83, 0x0e, 0x1b, 0x5c, 0xd2, 0x82, 0x05, 0x1b, 0x25, 0x81, 0x17,
	0xb7, 0xcf, 0x72, 0xfb, 0x98, 0xc4, 0xfc, 0x2d, 0xc3, 0x0d, 0xe4, 0xe4, 0xd9, 0x03, 0xf5, 0x84,
	0x58, 0xf4, 0xd2, 0xe3, 0xa5, 0xcb, 0x8c, 0xc3, 0x35, 0x7b, 0x1f, 0x75, 0xfa, 0x1c, 0x5d, 0xc3,
	0x99, 0x4e, 0x9f, 0xcd, 0x93, 0x01, 0xf1, 0x7d, 0xdb, 0x75, 0xba, 0x47, 0x1c, 0x59, 0xc3, 0x91,
	0x80, 0x69, 0x0f, 0xc7, 0x63, 0xf7, 0xd2, 0x61, 0xd3, 0x26, 0x18, 0x06, 0x91, 0x00, 0x99, 0x50,
	0xee, 0xb8, 0x8e, 0x43, 0xc6, 0x34, 0x70, 0xcf, 0x73, 0x83, 0x84, 0x8c, 0xed, 0xe5, 0xad, 0x4f,
	0xbc, 0xbe, 0x35, 0x0f, 0xc6, 0x80, 0x86, 0xc3, 0x35, 0x7a, 0x0c, 0xd5, 0xc1, 0x85, 0xbd, 0x48,
	0x3d, 0x49, 0x72, 0x38, 0x25, 0x45, 0x07, 0x80, 0x12, 0x92, 0x1e, 0x9f, 0xa8, 0x6a, 0x23, 0xcb,
	0x27, 0x58, 0x78, 0xa5, 0xe6, 0xef, 0x91, 0x35, 0x96, 0xfb, 0x75, 0x28, 0xc7, 0xdf, 0x21, 0xa8,
	0x00, 0x99, 0x41, 0x57, 0xdf, 0x62, 0xbf, 0xb8, 0xa3, 0x2b, 0xfb, 0xfb, 0xc1, 0xf3, 0x91, 0xe5,
	0xbf, 0x0a, 0xc0, 0xb2, 0x38, 0xb7, 0x7d, 0x6a, 0x8f, 0xf5, 0x2d, 0xb4, 0x0d, 0xa5, 0x33, 0x96,
	0x0d, 0x21, 0x50, 0xf6, 0x7f, 0x04, 0x2d, 0x7c, 0x3c, 0x22, 0x80, 0xc2, 0xe1, 0x98, 0xda, 0x57,
	0x44, 0xdf, 0x42, 0x65, 0x50, 0xe5, 0xb3, 0x4e, 0x57, 0x18, 0x4e, 0x50, 0xda, 0xd4, 0x76, 0xa6,
	0x7a, 0x06, 0x55, 0x40, 0x13, 0x6b, 0x32, 0xd1, 0xb3, 0xcc, 0xf8, 0x70, 0xe4, 0x7a, 0x5c, 0x99,
	0x43, 0x25, 0x28, 0xf2, 0x15, 0x99, 0xe8, 0xf9, 0xfd, 0x5f, 0x15, 0x1e, 0x41, 0x0c, 0x62, 0x15,
	0x72, 0xec, 0x91, 0xa2, 0x6f, 0x21, 0x0d, 0xf2, 0xfc, 0xf9, 0xa1, 0x2b, 0x2c, 0x6c, 0x00, 0xa6,
	0x67, 0x18, 0x92, 0xac, 0x6b, 0x3d, 0xcb, 0x90, 0xc4, 0x26, 0xf4, 0x1c, 0x8b, 0x19, 0x92, 0x58,
	0xcf, 0xa3, 0x9a, 0xbc, 0xcd, 0x8a, 0x42, 0xd5, 0x0b, 0xe8, 0x4e, 0x74, 0x47, 0x95, 0xc2, 0x22,
	0xd2, 0xa1, 0x2c, 0x8b, 0x97, 0x95, 0xae, 0xae, 0xb2, 0xd0, 0x47, 0xc7, 0xaf, 0xde, 0xbe, 0xd6,
	0xb5, 0x57, 0x07, 0x1f, 0xfe, 0xac, 0x2b, 0xef, 0x6f, 0xea, 0xca, 0x87, 0x9b, 0xba, 0xf2, 0xc7,
	0x4d, 0x5d, 0xf9, 0xe1, 0x69, 0xec, 0x61, 0x3f, 0xb7, 0xa8, 0x67, 0x2f, 0x5d, 0xcf, 0x9e, 0xda,
	0x8e, 0x5c, 0x38, 0xa4, 0xbd, 0xb8, 0x98, 0xb6, 0x17, 0xa3, 0x36, 0x5d, 0x3a, 0xa3, 0x02, 0x7f,
	0xb1, 0xbf, 0xf8, 0x37, 0x00, 0x00, 0xff, 0xff, 0x29, 0xcf, 0x6c, 0x39, 0x1f, 0x10, 0x00, 0x00,
}

func (m *TxnMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LockService) > 0 {
		i -= len(m.LockService)
		copy(dAtA[i:], m.LockService)
		i = encodeVarintTxn(dAtA, i, uint64(len(m.LockService)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Mirror {
		i--
		if m.Mirror {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Isolation != 0 {
		i = encodeVarintTxn(dAtA, i, uint64(m.Isolation))
		i--
		dAtA[i] = 0x48
	}
	if m.Mode != 0 {
		i = encodeVarintTxn(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x40
	}
	if len(m.LockTables) > 0 {
		for iNdEx := len(m.LockTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LockTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTxn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.TNShards) > 0 {
		for iNdEx := len(m.TNShards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TNShards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTxn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	{
		size, err := m.CommitTS.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTxn(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.PreparedTS.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTxn(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.SnapshotTS.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTxn(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Status != 0 {
		i = encodeVarintTxn(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintTxn(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CNTxnSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNTxnSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNTxnSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTxn(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.LockTables) > 0 {
		for iNdEx := len(m.LockTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LockTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTxn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Disable1PCOpt {
		i--
		if m.Disable1PCOpt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.EnableCacheWrite {
		i--
		if m.EnableCacheWrite {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ReadyOnly {
		i--
		if m.ReadyOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTxn(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CNOpRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNOpRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNOpRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Target.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTxn(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintTxn(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if m.OpCode != 0 {
		i = encodeVarintTxn(dAtA, i, uint64(m.OpCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CNOpResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CNOpResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CNOpResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintTxn(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxnRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTxn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.RemoveMetadata != nil {
		{
			size, err := m.RemoveMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTxn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.RollbackTNShardRequest != nil {
		{
			size, err := m.RollbackTNShardRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTxn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.CommitTNShardRequest != nil {
		{
			size, err := m.CommitTNShardRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTxn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.GetStatusRequest != nil {
		{
			size, err := m.GetStatusRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTxn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.PrepareRequest != nil {
		{
			size, err := m.PrepareRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTxn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.RollbackRequest != nil {
		{
			size, err := m.RollbackRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTxn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.CommitRequest != nil {
		{
			size, err := m.CommitRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTxn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.CNRequest != nil {
		{
			size, err := m.CNRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTxn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Flag != 0 {
		i = encodeVarintTxn(dAtA, i, uint64(m.Flag))
		i--
		dAtA[i] = 0x20
	}
	if m.Method != 0 {
		i = encodeVarintTxn(dAtA, i, uint64(m.Method))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTxn(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.RequestID != 0 {
		i = encodeVarintTxn(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TxnRequestOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnRequestOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnRequestOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RetryInterval != 0 {
		i = encodeVarintTxn(dAtA, i, uint64(m.RetryInterval))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RetryCodes) > 0 {
		dAtA18 := make([]byte, len(m.RetryCodes)*10)
		var j17 int
		for _, num1 := range m.RetryCodes {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA18[:j17])
		i = encodeVarintTxn(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxnResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RemoveMetadata != nil {
		{
			size, err := m.RemoveMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTxn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.RollbackTNShardResponse != nil {
		{
			size, err := m.RollbackTNShardResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTxn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.CommitTNShardResponse != nil {
		{
			size, err := m.CommitTNShardResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTxn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.GetStatusResponse != nil {
		{
			size, err := m.GetStatusResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTxn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.PrepareResponse != nil {
		{
			size, err := m.PrepareResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTxn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.RollbackResponse != nil {
		{
			size, err := m.RollbackResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTxn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.CommitResponse != nil {
		{
			size, err := m.CommitResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTxn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.CNOpResponse != nil {
		{
			size, err := m.CNOpResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTxn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.TxnError != nil {
		{
			size, err := m.TxnError.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTxn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Flag != 0 {
		i = encodeVarintTxn(dAtA, i, uint64(m.Flag))
		i--
		dAtA[i] = 0x20
	}
	if m.Method != 0 {
		i = encodeVarintTxn(dAtA, i, uint64(m.Method))
		i--
		dAtA[i] = 0x18
	}
	if m.Txn != nil {
		{
			size, err := m.Txn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTxn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.RequestID != 0 {
		i = encodeVarintTxn(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TxnCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnCommitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Disable1PCOpt {
		i--
		if m.Disable1PCOpt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Payload) > 0 {
		for iNdEx := len(m.Payload) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Payload[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTxn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TxnCommitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnCommitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnCommitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.InvalidLockTables) > 0 {
		dAtA30 := make([]byte, len(m.InvalidLockTables)*10)
		var j29 int
		for _, num := range m.InvalidLockTables {
			for num >= 1<<7 {
				dAtA30[j29] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j29++
			}
			dAtA30[j29] = uint8(num)
			j29++
		}
		i -= j29
		copy(dAtA[i:], dAtA30[:j29])
		i = encodeVarintTxn(dAtA, i, uint64(j29))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxnRollbackRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnRollbackRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnRollbackRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *TxnRollbackResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnRollbackResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnRollbackResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *TxnPrepareRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnPrepareRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnPrepareRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.TNShard.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTxn(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TxnPrepareResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnPrepareResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnPrepareResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *TxnGetStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnGetStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnGetStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.TNShard.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTxn(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TxnGetStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnGetStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnGetStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *TxnCommitTNShardRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnCommitTNShardRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnCommitTNShardRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.TNShard.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTxn(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TxnCommitTNShardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnCommitTNShardResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnCommitTNShardResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *TxnRollbackTNShardRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnRollbackTNShardRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnRollbackTNShardRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.TNShard.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTxn(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TxnRollbackTNShardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnRollbackTNShardResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnRollbackTNShardResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *TxnRemoveMetadataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnRemoveMetadataRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnRemoveMetadataRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.TNShard.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTxn(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TxnRemoveMetadataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnRemoveMetadataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnRemoveMetadataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *TxnError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TxnErrCode != 0 {
		i = encodeVarintTxn(dAtA, i, uint64(m.TxnErrCode))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintTxn(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintTxn(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TxnOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SkipLockTableModes) > 0 {
		dAtA37 := make([]byte, len(m.SkipLockTableModes)*10)
		var j36 int
		for _, num := range m.SkipLockTableModes {
			for num >= 1<<7 {
				dAtA37[j36] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j36++
			}
			dAtA37[j36] = uint8(num)
			j36++
		}
		i -= j36
		copy(dAtA[i:], dAtA37[:j36])
		i = encodeVarintTxn(dAtA, i, uint64(j36))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SkipLockTables) > 0 {
		dAtA39 := make([]byte, len(m.SkipLockTables)*10)
		var j38 int
		for _, num := range m.SkipLockTables {
			for num >= 1<<7 {
				dAtA39[j38] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j38++
			}
			dAtA39[j38] = uint8(num)
			j38++
		}
		i -= j38
		copy(dAtA[i:], dAtA39[:j38])
		i = encodeVarintTxn(dAtA, i, uint64(j38))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintTxn(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x32
	}
	if m.ConnectionID != 0 {
		i = encodeVarintTxn(dAtA, i, uint64(m.ConnectionID))
		i--
		dAtA[i] = 0x28
	}
	if m.AccountID != 0 {
		i = encodeVarintTxn(dAtA, i, uint64(m.AccountID))
		i--
		dAtA[i] = 0x20
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintTxn(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CN) > 0 {
		i -= len(m.CN)
		copy(dAtA[i:], m.CN)
		i = encodeVarintTxn(dAtA, i, uint64(len(m.CN)))
		i--
		dAtA[i] = 0x12
	}
	if m.Features != 0 {
		i = encodeVarintTxn(dAtA, i, uint64(m.Features))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTxn(dAtA []byte, offset int, v uint64) int {
	offset -= sovTxn(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TxnMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTxn(uint64(m.Status))
	}
	l = m.SnapshotTS.Size()
	n += 1 + l + sovTxn(uint64(l))
	l = m.PreparedTS.Size()
	n += 1 + l + sovTxn(uint64(l))
	l = m.CommitTS.Size()
	n += 1 + l + sovTxn(uint64(l))
	if len(m.TNShards) > 0 {
		for _, e := range m.TNShards {
			l = e.Size()
			n += 1 + l + sovTxn(uint64(l))
		}
	}
	if len(m.LockTables) > 0 {
		for _, e := range m.LockTables {
			l = e.Size()
			n += 1 + l + sovTxn(uint64(l))
		}
	}
	if m.Mode != 0 {
		n += 1 + sovTxn(uint64(m.Mode))
	}
	if m.Isolation != 0 {
		n += 1 + sovTxn(uint64(m.Isolation))
	}
	if m.Mirror {
		n += 2
	}
	l = len(m.LockService)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CNTxnSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Txn.Size()
	n += 1 + l + sovTxn(uint64(l))
	if m.ReadyOnly {
		n += 2
	}
	if m.EnableCacheWrite {
		n += 2
	}
	if m.Disable1PCOpt {
		n += 2
	}
	if len(m.LockTables) > 0 {
		for _, e := range m.LockTables {
			l = e.Size()
			n += 1 + l + sovTxn(uint64(l))
		}
	}
	l = m.Options.Size()
	n += 1 + l + sovTxn(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CNOpRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OpCode != 0 {
		n += 1 + sovTxn(uint64(m.OpCode))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	l = m.Target.Size()
	n += 1 + l + sovTxn(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CNOpResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestID != 0 {
		n += 1 + sovTxn(uint64(m.RequestID))
	}
	l = m.Txn.Size()
	n += 1 + l + sovTxn(uint64(l))
	if m.Method != 0 {
		n += 1 + sovTxn(uint64(m.Method))
	}
	if m.Flag != 0 {
		n += 1 + sovTxn(uint64(m.Flag))
	}
	if m.CNRequest != nil {
		l = m.CNRequest.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.CommitRequest != nil {
		l = m.CommitRequest.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.RollbackRequest != nil {
		l = m.RollbackRequest.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.PrepareRequest != nil {
		l = m.PrepareRequest.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.GetStatusRequest != nil {
		l = m.GetStatusRequest.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.CommitTNShardRequest != nil {
		l = m.CommitTNShardRequest.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.RollbackTNShardRequest != nil {
		l = m.RollbackTNShardRequest.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.RemoveMetadata != nil {
		l = m.RemoveMetadata.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnRequestOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RetryCodes) > 0 {
		l = 0
		for _, e := range m.RetryCodes {
			l += sovTxn(uint64(e))
		}
		n += 1 + sovTxn(uint64(l)) + l
	}
	if m.RetryInterval != 0 {
		n += 1 + sovTxn(uint64(m.RetryInterval))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestID != 0 {
		n += 1 + sovTxn(uint64(m.RequestID))
	}
	if m.Txn != nil {
		l = m.Txn.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.Method != 0 {
		n += 1 + sovTxn(uint64(m.Method))
	}
	if m.Flag != 0 {
		n += 1 + sovTxn(uint64(m.Flag))
	}
	if m.TxnError != nil {
		l = m.TxnError.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.CNOpResponse != nil {
		l = m.CNOpResponse.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.CommitResponse != nil {
		l = m.CommitResponse.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.RollbackResponse != nil {
		l = m.RollbackResponse.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.PrepareResponse != nil {
		l = m.PrepareResponse.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.GetStatusResponse != nil {
		l = m.GetStatusResponse.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.CommitTNShardResponse != nil {
		l = m.CommitTNShardResponse.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.RollbackTNShardResponse != nil {
		l = m.RollbackTNShardResponse.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.RemoveMetadata != nil {
		l = m.RemoveMetadata.Size()
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnCommitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Payload) > 0 {
		for _, e := range m.Payload {
			l = e.Size()
			n += 1 + l + sovTxn(uint64(l))
		}
	}
	if m.Disable1PCOpt {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnCommitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.InvalidLockTables) > 0 {
		l = 0
		for _, e := range m.InvalidLockTables {
			l += sovTxn(uint64(e))
		}
		n += 1 + sovTxn(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnRollbackRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnRollbackResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnPrepareRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TNShard.Size()
	n += 1 + l + sovTxn(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnPrepareResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnGetStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TNShard.Size()
	n += 1 + l + sovTxn(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnGetStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnCommitTNShardRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TNShard.Size()
	n += 1 + l + sovTxn(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnCommitTNShardResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnRollbackTNShardRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TNShard.Size()
	n += 1 + l + sovTxn(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnRollbackTNShardResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnRemoveMetadataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TNShard.Size()
	n += 1 + l + sovTxn(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnRemoveMetadataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovTxn(uint64(m.Code))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.TxnErrCode != 0 {
		n += 1 + sovTxn(uint64(m.TxnErrCode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Features != 0 {
		n += 1 + sovTxn(uint64(m.Features))
	}
	l = len(m.CN)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if m.AccountID != 0 {
		n += 1 + sovTxn(uint64(m.AccountID))
	}
	if m.ConnectionID != 0 {
		n += 1 + sovTxn(uint64(m.ConnectionID))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovTxn(uint64(l))
	}
	if len(m.SkipLockTables) > 0 {
		l = 0
		for _, e := range m.SkipLockTables {
			l += sovTxn(uint64(e))
		}
		n += 1 + sovTxn(uint64(l)) + l
	}
	if len(m.SkipLockTableModes) > 0 {
		l = 0
		for _, e := range m.SkipLockTableModes {
			l += sovTxn(uint64(e))
		}
		n += 1 + sovTxn(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTxn(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTxn(x uint64) (n int) {
	return sovTxn(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TxnMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TxnStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotTS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SnapshotTS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparedTS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PreparedTS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommitTS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TNShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TNShards = append(m.TNShards, metadata.TNShard{})
			if err := m.TNShards[len(m.TNShards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockTables = append(m.LockTables, lock.LockTable{})
			if err := m.LockTables[len(m.LockTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= TxnMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isolation", wireType)
			}
			m.Isolation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Isolation |= TxnIsolation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mirror", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mirror = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockService", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockService = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNTxnSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNTxnSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNTxnSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadyOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadyOnly = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableCacheWrite", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableCacheWrite = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable1PCOpt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable1PCOpt = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockTables = append(m.LockTables, lock.LockTable{})
			if err := m.LockTables[len(m.LockTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNOpRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNOpRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNOpRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpCode", wireType)
			}
			m.OpCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CNOpResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CNOpResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CNOpResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			m.Method = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Method |= TxnMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CNRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CNRequest == nil {
				m.CNRequest = &CNOpRequest{}
			}
			if err := m.CNRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommitRequest == nil {
				m.CommitRequest = &TxnCommitRequest{}
			}
			if err := m.CommitRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RollbackRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RollbackRequest == nil {
				m.RollbackRequest = &TxnRollbackRequest{}
			}
			if err := m.RollbackRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrepareRequest == nil {
				m.PrepareRequest = &TxnPrepareRequest{}
			}
			if err := m.PrepareRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetStatusRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetStatusRequest == nil {
				m.GetStatusRequest = &TxnGetStatusRequest{}
			}
			if err := m.GetStatusRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTNShardRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommitTNShardRequest == nil {
				m.CommitTNShardRequest = &TxnCommitTNShardRequest{}
			}
			if err := m.CommitTNShardRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RollbackTNShardRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RollbackTNShardRequest == nil {
				m.RollbackTNShardRequest = &TxnRollbackTNShardRequest{}
			}
			if err := m.RollbackTNShardRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoveMetadata == nil {
				m.RemoveMetadata = &TxnRemoveMetadataRequest{}
			}
			if err := m.RemoveMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &TxnRequestOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnRequestOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnRequestOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnRequestOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTxn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RetryCodes = append(m.RetryCodes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTxn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTxn
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTxn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RetryCodes) == 0 {
					m.RetryCodes = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTxn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RetryCodes = append(m.RetryCodes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryCodes", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryInterval", wireType)
			}
			m.RetryInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetryInterval |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Txn == nil {
				m.Txn = &TxnMeta{}
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			m.Method = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Method |= TxnMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxnError == nil {
				m.TxnError = &TxnError{}
			}
			if err := m.TxnError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CNOpResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CNOpResponse == nil {
				m.CNOpResponse = &CNOpResponse{}
			}
			if err := m.CNOpResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommitResponse == nil {
				m.CommitResponse = &TxnCommitResponse{}
			}
			if err := m.CommitResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RollbackResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RollbackResponse == nil {
				m.RollbackResponse = &TxnRollbackResponse{}
			}
			if err := m.RollbackResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrepareResponse == nil {
				m.PrepareResponse = &TxnPrepareResponse{}
			}
			if err := m.PrepareResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetStatusResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetStatusResponse == nil {
				m.GetStatusResponse = &TxnGetStatusResponse{}
			}
			if err := m.GetStatusResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTNShardResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommitTNShardResponse == nil {
				m.CommitTNShardResponse = &TxnCommitTNShardResponse{}
			}
			if err := m.CommitTNShardResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RollbackTNShardResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RollbackTNShardResponse == nil {
				m.RollbackTNShardResponse = &TxnRollbackTNShardResponse{}
			}
			if err := m.RollbackTNShardResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoveMetadata == nil {
				m.RemoveMetadata = &TxnRemoveMetadataResponse{}
			}
			if err := m.RemoveMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload, &TxnRequest{})
			if err := m.Payload[len(m.Payload)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable1PCOpt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable1PCOpt = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnCommitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnCommitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnCommitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTxn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.InvalidLockTables = append(m.InvalidLockTables, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTxn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTxn
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTxn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.InvalidLockTables) == 0 {
					m.InvalidLockTables = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTxn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.InvalidLockTables = append(m.InvalidLockTables, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidLockTables", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnRollbackRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnRollbackRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnRollbackRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnRollbackResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnRollbackResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnRollbackResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnPrepareRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnPrepareRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnPrepareRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TNShard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TNShard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnPrepareResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnPrepareResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnPrepareResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnGetStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnGetStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnGetStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TNShard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TNShard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnGetStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnGetStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnGetStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnCommitTNShardRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnCommitTNShardRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnCommitTNShardRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TNShard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TNShard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnCommitTNShardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnCommitTNShardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnCommitTNShardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnRollbackTNShardRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnRollbackTNShardRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnRollbackTNShardRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TNShard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TNShard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnRollbackTNShardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnRollbackTNShardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnRollbackTNShardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnRemoveMetadataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnRemoveMetadataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnRemoveMetadataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TNShard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TNShard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnRemoveMetadataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnRemoveMetadataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnRemoveMetadataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = append(m.Error[:0], dAtA[iNdEx:postIndex]...)
			if m.Error == nil {
				m.Error = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnErrCode", wireType)
			}
			m.TxnErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnErrCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			m.Features = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Features |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			m.AccountID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionID", wireType)
			}
			m.ConnectionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectionID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTxn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SkipLockTables = append(m.SkipLockTables, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTxn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTxn
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTxn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SkipLockTables) == 0 {
					m.SkipLockTables = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTxn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SkipLockTables = append(m.SkipLockTables, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipLockTables", wireType)
			}
		case 8:
			if wireType == 0 {
				var v lock.LockMode
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTxn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= lock.LockMode(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SkipLockTableModes = append(m.SkipLockTableModes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTxn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTxn
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTxn
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.SkipLockTableModes) == 0 {
					m.SkipLockTableModes = make([]lock.LockMode, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v lock.LockMode
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTxn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= lock.LockMode(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SkipLockTableModes = append(m.SkipLockTableModes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipLockTableModes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTxn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTxn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTxn(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTxn
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTxn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTxn
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTxn
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTxn
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTxn        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTxn          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTxn = fmt.Errorf("proto: unexpected end of group")
)
