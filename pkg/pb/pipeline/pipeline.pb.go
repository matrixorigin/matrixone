// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pipeline.proto

package pipeline

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	lock "github.com/matrixorigin/matrixone/pkg/pb/lock"
	plan "github.com/matrixorigin/matrixone/pkg/pb/plan"
	timestamp "github.com/matrixorigin/matrixone/pkg/pb/timestamp"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Method int32

const (
	Method_UnknownMethod            Method = 0
	Method_PipelineMessage          Method = 1
	Method_BatchMessage             Method = 2
	Method_PrepareDoneNotifyMessage Method = 3
)

var Method_name = map[int32]string{
	0: "UnknownMethod",
	1: "PipelineMessage",
	2: "BatchMessage",
	3: "PrepareDoneNotifyMessage",
}

var Method_value = map[string]int32{
	"UnknownMethod":            0,
	"PipelineMessage":          1,
	"BatchMessage":             2,
	"PrepareDoneNotifyMessage": 3,
}

func (x Method) String() string {
	return proto.EnumName(Method_name, int32(x))
}

func (Method) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{0}
}

type Status int32

const (
	Status_UnknownStatus Status = 0
	Status_WaitingNext   Status = 1
	Status_Last          Status = 2
	Status_MessageEnd    Status = 3
)

var Status_name = map[int32]string{
	0: "UnknownStatus",
	1: "WaitingNext",
	2: "Last",
	3: "MessageEnd",
}

var Status_value = map[string]int32{
	"UnknownStatus": 0,
	"WaitingNext":   1,
	"Last":          2,
	"MessageEnd":    3,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}

func (Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{1}
}

type SampleFunc_SampleType int32

const (
	SampleFunc_Rows      SampleFunc_SampleType = 0
	SampleFunc_Percent   SampleFunc_SampleType = 1
	SampleFunc_MergeRows SampleFunc_SampleType = 2
)

var SampleFunc_SampleType_name = map[int32]string{
	0: "Rows",
	1: "Percent",
	2: "MergeRows",
}

var SampleFunc_SampleType_value = map[string]int32{
	"Rows":      0,
	"Percent":   1,
	"MergeRows": 2,
}

func (x SampleFunc_SampleType) String() string {
	return proto.EnumName(SampleFunc_SampleType_name, int32(x))
}

func (SampleFunc_SampleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{36, 0}
}

type Pipeline_PipelineType int32

const (
	Pipeline_Merge    Pipeline_PipelineType = 0
	Pipeline_Normal   Pipeline_PipelineType = 1
	Pipeline_Remote   Pipeline_PipelineType = 2
	Pipeline_Parallel Pipeline_PipelineType = 3
)

var Pipeline_PipelineType_name = map[int32]string{
	0: "Merge",
	1: "Normal",
	2: "Remote",
	3: "Parallel",
}

var Pipeline_PipelineType_value = map[string]int32{
	"Merge":    0,
	"Normal":   1,
	"Remote":   2,
	"Parallel": 3,
}

func (x Pipeline_PipelineType) String() string {
	return proto.EnumName(Pipeline_PipelineType_name, int32(x))
}

func (Pipeline_PipelineType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{44, 0}
}

type Message struct {
	Sid                  Status   `protobuf:"varint,1,opt,name=sid,proto3,enum=pipeline.Status" json:"sid,omitempty"`
	Cmd                  Method   `protobuf:"varint,2,opt,name=cmd,proto3,enum=pipeline.Method" json:"cmd,omitempty"`
	Err                  []byte   `protobuf:"bytes,3,opt,name=err,proto3" json:"err,omitempty"`
	Data                 []byte   `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	ProcInfoData         []byte   `protobuf:"bytes,5,opt,name=proc_info_data,json=procInfoData,proto3" json:"proc_info_data,omitempty"`
	Analyse              []byte   `protobuf:"bytes,6,opt,name=analyse,proto3" json:"analyse,omitempty"`
	Id                   uint64   `protobuf:"varint,7,opt,name=id,proto3" json:"id,omitempty"`
	Uuid                 []byte   `protobuf:"bytes,8,opt,name=uuid,proto3" json:"uuid,omitempty"`
	BatchCnt             uint64   `protobuf:"varint,9,opt,name=batch_cnt,json=batchCnt,proto3" json:"batch_cnt,omitempty"`
	Checksum             uint32   `protobuf:"varint,10,opt,name=checksum,proto3" json:"checksum,omitempty"`
	Sequence             uint64   `protobuf:"varint,11,opt,name=sequence,proto3" json:"sequence,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{0}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetSid() Status {
	if m != nil {
		return m.Sid
	}
	return Status_UnknownStatus
}

func (m *Message) GetCmd() Method {
	if m != nil {
		return m.Cmd
	}
	return Method_UnknownMethod
}

func (m *Message) GetErr() []byte {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *Message) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Message) GetProcInfoData() []byte {
	if m != nil {
		return m.ProcInfoData
	}
	return nil
}

func (m *Message) GetAnalyse() []byte {
	if m != nil {
		return m.Analyse
	}
	return nil
}

func (m *Message) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Message) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *Message) GetBatchCnt() uint64 {
	if m != nil {
		return m.BatchCnt
	}
	return 0
}

func (m *Message) GetChecksum() uint32 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *Message) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

type Connector struct {
	PipelineId           int32    `protobuf:"varint,1,opt,name=pipeline_id,json=pipelineId,proto3" json:"pipeline_id,omitempty"`
	ConnectorIndex       int32    `protobuf:"varint,2,opt,name=connector_index,json=connectorIndex,proto3" json:"connector_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Connector) Reset()         { *m = Connector{} }
func (m *Connector) String() string { return proto.CompactTextString(m) }
func (*Connector) ProtoMessage()    {}
func (*Connector) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{1}
}
func (m *Connector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Connector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Connector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Connector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Connector.Merge(m, src)
}
func (m *Connector) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Connector) XXX_DiscardUnknown() {
	xxx_messageInfo_Connector.DiscardUnknown(m)
}

var xxx_messageInfo_Connector proto.InternalMessageInfo

func (m *Connector) GetPipelineId() int32 {
	if m != nil {
		return m.PipelineId
	}
	return 0
}

func (m *Connector) GetConnectorIndex() int32 {
	if m != nil {
		return m.ConnectorIndex
	}
	return 0
}

type Shuffle struct {
	ShuffleColIdx        int32    `protobuf:"varint,1,opt,name=ShuffleColIdx,proto3" json:"ShuffleColIdx,omitempty"`
	ShuffleType          int32    `protobuf:"varint,2,opt,name=ShuffleType,proto3" json:"ShuffleType,omitempty"`
	ShuffleColMin        int64    `protobuf:"varint,3,opt,name=ShuffleColMin,proto3" json:"ShuffleColMin,omitempty"`
	ShuffleColMax        int64    `protobuf:"varint,4,opt,name=ShuffleColMax,proto3" json:"ShuffleColMax,omitempty"`
	AliveRegCnt          int32    `protobuf:"varint,5,opt,name=AliveRegCnt,proto3" json:"AliveRegCnt,omitempty"`
	ShuffleRangesUint64  []uint64 `protobuf:"varint,6,rep,packed,name=shuffle_ranges_uint64,json=shuffleRangesUint64,proto3" json:"shuffle_ranges_uint64,omitempty"`
	ShuffleRangesInt64   []int64  `protobuf:"varint,7,rep,packed,name=shuffle_ranges_int64,json=shuffleRangesInt64,proto3" json:"shuffle_ranges_int64,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Shuffle) Reset()         { *m = Shuffle{} }
func (m *Shuffle) String() string { return proto.CompactTextString(m) }
func (*Shuffle) ProtoMessage()    {}
func (*Shuffle) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{2}
}
func (m *Shuffle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Shuffle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Shuffle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Shuffle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Shuffle.Merge(m, src)
}
func (m *Shuffle) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Shuffle) XXX_DiscardUnknown() {
	xxx_messageInfo_Shuffle.DiscardUnknown(m)
}

var xxx_messageInfo_Shuffle proto.InternalMessageInfo

func (m *Shuffle) GetShuffleColIdx() int32 {
	if m != nil {
		return m.ShuffleColIdx
	}
	return 0
}

func (m *Shuffle) GetShuffleType() int32 {
	if m != nil {
		return m.ShuffleType
	}
	return 0
}

func (m *Shuffle) GetShuffleColMin() int64 {
	if m != nil {
		return m.ShuffleColMin
	}
	return 0
}

func (m *Shuffle) GetShuffleColMax() int64 {
	if m != nil {
		return m.ShuffleColMax
	}
	return 0
}

func (m *Shuffle) GetAliveRegCnt() int32 {
	if m != nil {
		return m.AliveRegCnt
	}
	return 0
}

func (m *Shuffle) GetShuffleRangesUint64() []uint64 {
	if m != nil {
		return m.ShuffleRangesUint64
	}
	return nil
}

func (m *Shuffle) GetShuffleRangesInt64() []int64 {
	if m != nil {
		return m.ShuffleRangesInt64
	}
	return nil
}

type Dispatch struct {
	FuncId               int32        `protobuf:"varint,1,opt,name=func_id,json=funcId,proto3" json:"func_id,omitempty"`
	LocalConnector       []*Connector `protobuf:"bytes,2,rep,name=local_connector,json=localConnector,proto3" json:"local_connector,omitempty"`
	RemoteConnector      []*WrapNode  `protobuf:"bytes,3,rep,name=remote_connector,json=remoteConnector,proto3" json:"remote_connector,omitempty"`
	ShuffleRegIdxLocal   []int32      `protobuf:"varint,4,rep,packed,name=shuffle_reg_idx_local,json=shuffleRegIdxLocal,proto3" json:"shuffle_reg_idx_local,omitempty"`
	ShuffleRegIdxRemote  []int32      `protobuf:"varint,5,rep,packed,name=shuffle_reg_idx_remote,json=shuffleRegIdxRemote,proto3" json:"shuffle_reg_idx_remote,omitempty"`
	ShuffleType          int32        `protobuf:"varint,6,opt,name=shuffle_type,json=shuffleType,proto3" json:"shuffle_type,omitempty"`
	IsSink               bool         `protobuf:"varint,7,opt,name=is_sink,json=isSink,proto3" json:"is_sink,omitempty"`
	RecSink              bool         `protobuf:"varint,8,opt,name=rec_sink,json=recSink,proto3" json:"rec_sink,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Dispatch) Reset()         { *m = Dispatch{} }
func (m *Dispatch) String() string { return proto.CompactTextString(m) }
func (*Dispatch) ProtoMessage()    {}
func (*Dispatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{3}
}
func (m *Dispatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dispatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dispatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Dispatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dispatch.Merge(m, src)
}
func (m *Dispatch) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Dispatch) XXX_DiscardUnknown() {
	xxx_messageInfo_Dispatch.DiscardUnknown(m)
}

var xxx_messageInfo_Dispatch proto.InternalMessageInfo

func (m *Dispatch) GetFuncId() int32 {
	if m != nil {
		return m.FuncId
	}
	return 0
}

func (m *Dispatch) GetLocalConnector() []*Connector {
	if m != nil {
		return m.LocalConnector
	}
	return nil
}

func (m *Dispatch) GetRemoteConnector() []*WrapNode {
	if m != nil {
		return m.RemoteConnector
	}
	return nil
}

func (m *Dispatch) GetShuffleRegIdxLocal() []int32 {
	if m != nil {
		return m.ShuffleRegIdxLocal
	}
	return nil
}

func (m *Dispatch) GetShuffleRegIdxRemote() []int32 {
	if m != nil {
		return m.ShuffleRegIdxRemote
	}
	return nil
}

func (m *Dispatch) GetShuffleType() int32 {
	if m != nil {
		return m.ShuffleType
	}
	return 0
}

func (m *Dispatch) GetIsSink() bool {
	if m != nil {
		return m.IsSink
	}
	return false
}

func (m *Dispatch) GetRecSink() bool {
	if m != nil {
		return m.RecSink
	}
	return false
}

type Merge struct {
	SinkScan             bool     `protobuf:"varint,1,opt,name=sinkScan,proto3" json:"sinkScan,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Merge) Reset()         { *m = Merge{} }
func (m *Merge) String() string { return proto.CompactTextString(m) }
func (*Merge) ProtoMessage()    {}
func (*Merge) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{4}
}
func (m *Merge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Merge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Merge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Merge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Merge.Merge(m, src)
}
func (m *Merge) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Merge) XXX_DiscardUnknown() {
	xxx_messageInfo_Merge.DiscardUnknown(m)
}

var xxx_messageInfo_Merge proto.InternalMessageInfo

func (m *Merge) GetSinkScan() bool {
	if m != nil {
		return m.SinkScan
	}
	return false
}

type MultiArguemnt struct {
	Dist                 bool         `protobuf:"varint,1,opt,name=Dist,proto3" json:"Dist,omitempty"`
	GroupExpr            []*plan.Expr `protobuf:"bytes,2,rep,name=GroupExpr,proto3" json:"GroupExpr,omitempty"`
	OrderByExpr          []*plan.Expr `protobuf:"bytes,3,rep,name=OrderByExpr,proto3" json:"OrderByExpr,omitempty"`
	Separator            string       `protobuf:"bytes,4,opt,name=Separator,proto3" json:"Separator,omitempty"`
	OrderId              int32        `protobuf:"varint,5,opt,name=OrderId,proto3" json:"OrderId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *MultiArguemnt) Reset()         { *m = MultiArguemnt{} }
func (m *MultiArguemnt) String() string { return proto.CompactTextString(m) }
func (*MultiArguemnt) ProtoMessage()    {}
func (*MultiArguemnt) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{5}
}
func (m *MultiArguemnt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiArguemnt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiArguemnt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiArguemnt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiArguemnt.Merge(m, src)
}
func (m *MultiArguemnt) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MultiArguemnt) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiArguemnt.DiscardUnknown(m)
}

var xxx_messageInfo_MultiArguemnt proto.InternalMessageInfo

func (m *MultiArguemnt) GetDist() bool {
	if m != nil {
		return m.Dist
	}
	return false
}

func (m *MultiArguemnt) GetGroupExpr() []*plan.Expr {
	if m != nil {
		return m.GroupExpr
	}
	return nil
}

func (m *MultiArguemnt) GetOrderByExpr() []*plan.Expr {
	if m != nil {
		return m.OrderByExpr
	}
	return nil
}

func (m *MultiArguemnt) GetSeparator() string {
	if m != nil {
		return m.Separator
	}
	return ""
}

func (m *MultiArguemnt) GetOrderId() int32 {
	if m != nil {
		return m.OrderId
	}
	return 0
}

type Aggregate struct {
	Op                   int64        `protobuf:"varint,1,opt,name=op,proto3" json:"op,omitempty"`
	Dist                 bool         `protobuf:"varint,2,opt,name=dist,proto3" json:"dist,omitempty"`
	Expr                 []*plan.Expr `protobuf:"bytes,3,rep,name=expr,proto3" json:"expr,omitempty"`
	Config               []byte       `protobuf:"bytes,4,opt,name=config,proto3" json:"config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Aggregate) Reset()         { *m = Aggregate{} }
func (m *Aggregate) String() string { return proto.CompactTextString(m) }
func (*Aggregate) ProtoMessage()    {}
func (*Aggregate) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{6}
}
func (m *Aggregate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Aggregate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Aggregate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Aggregate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Aggregate.Merge(m, src)
}
func (m *Aggregate) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Aggregate) XXX_DiscardUnknown() {
	xxx_messageInfo_Aggregate.DiscardUnknown(m)
}

var xxx_messageInfo_Aggregate proto.InternalMessageInfo

func (m *Aggregate) GetOp() int64 {
	if m != nil {
		return m.Op
	}
	return 0
}

func (m *Aggregate) GetDist() bool {
	if m != nil {
		return m.Dist
	}
	return false
}

func (m *Aggregate) GetExpr() []*plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Aggregate) GetConfig() []byte {
	if m != nil {
		return m.Config
	}
	return nil
}

type Group struct {
	NeedEval             bool             `protobuf:"varint,1,opt,name=need_eval,json=needEval,proto3" json:"need_eval,omitempty"`
	Ibucket              uint64           `protobuf:"varint,2,opt,name=ibucket,proto3" json:"ibucket,omitempty"`
	Nbucket              uint64           `protobuf:"varint,3,opt,name=nbucket,proto3" json:"nbucket,omitempty"`
	Exprs                []*plan.Expr     `protobuf:"bytes,4,rep,name=exprs,proto3" json:"exprs,omitempty"`
	Types                []plan.Type      `protobuf:"bytes,5,rep,name=types,proto3" json:"types"`
	Aggs                 []*Aggregate     `protobuf:"bytes,6,rep,name=aggs,proto3" json:"aggs,omitempty"`
	MultiAggs            []*MultiArguemnt `protobuf:"bytes,7,rep,name=MultiAggs,proto3" json:"MultiAggs,omitempty"`
	IsShuffle            bool             `protobuf:"varint,8,opt,name=isShuffle,proto3" json:"isShuffle,omitempty"`
	PreAllocSize         uint64           `protobuf:"varint,9,opt,name=preAllocSize,proto3" json:"preAllocSize,omitempty"`
	PartialResults       []byte           `protobuf:"bytes,11,opt,name=PartialResults,proto3" json:"PartialResults,omitempty"`
	PartialResultTypes   []uint32         `protobuf:"varint,10,rep,packed,name=PartialResultTypes,proto3" json:"PartialResultTypes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Group) Reset()         { *m = Group{} }
func (m *Group) String() string { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()    {}
func (*Group) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{7}
}
func (m *Group) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Group) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Group.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Group) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Group.Merge(m, src)
}
func (m *Group) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Group) XXX_DiscardUnknown() {
	xxx_messageInfo_Group.DiscardUnknown(m)
}

var xxx_messageInfo_Group proto.InternalMessageInfo

func (m *Group) GetNeedEval() bool {
	if m != nil {
		return m.NeedEval
	}
	return false
}

func (m *Group) GetIbucket() uint64 {
	if m != nil {
		return m.Ibucket
	}
	return 0
}

func (m *Group) GetNbucket() uint64 {
	if m != nil {
		return m.Nbucket
	}
	return 0
}

func (m *Group) GetExprs() []*plan.Expr {
	if m != nil {
		return m.Exprs
	}
	return nil
}

func (m *Group) GetTypes() []plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *Group) GetAggs() []*Aggregate {
	if m != nil {
		return m.Aggs
	}
	return nil
}

func (m *Group) GetMultiAggs() []*MultiArguemnt {
	if m != nil {
		return m.MultiAggs
	}
	return nil
}

func (m *Group) GetIsShuffle() bool {
	if m != nil {
		return m.IsShuffle
	}
	return false
}

func (m *Group) GetPreAllocSize() uint64 {
	if m != nil {
		return m.PreAllocSize
	}
	return 0
}

func (m *Group) GetPartialResults() []byte {
	if m != nil {
		return m.PartialResults
	}
	return nil
}

func (m *Group) GetPartialResultTypes() []uint32 {
	if m != nil {
		return m.PartialResultTypes
	}
	return nil
}

type Insert struct {
	Affected        uint64          `protobuf:"varint,1,opt,name=affected,proto3" json:"affected,omitempty"`
	ToWriteS3       bool            `protobuf:"varint,2,opt,name=ToWriteS3,proto3" json:"ToWriteS3,omitempty"`
	AddAffectedRows bool            `protobuf:"varint,3,opt,name=add_affected_rows,json=addAffectedRows,proto3" json:"add_affected_rows,omitempty"`
	Ref             *plan.ObjectRef `protobuf:"bytes,4,opt,name=ref,proto3" json:"ref,omitempty"`
	Attrs           []string        `protobuf:"bytes,5,rep,name=attrs,proto3" json:"attrs,omitempty"`
	// Align array index with the partition number
	PartitionTableIds    []uint64       `protobuf:"varint,6,rep,packed,name=partition_table_ids,json=partitionTableIds,proto3" json:"partition_table_ids,omitempty"`
	PartitionTableNames  []string       `protobuf:"bytes,7,rep,name=partition_table_names,json=partitionTableNames,proto3" json:"partition_table_names,omitempty"`
	PartitionIdx         int32          `protobuf:"varint,8,opt,name=partition_idx,json=partitionIdx,proto3" json:"partition_idx,omitempty"`
	IsEnd                bool           `protobuf:"varint,9,opt,name=is_end,json=isEnd,proto3" json:"is_end,omitempty"`
	TableDef             *plan.TableDef `protobuf:"bytes,10,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Insert) Reset()         { *m = Insert{} }
func (m *Insert) String() string { return proto.CompactTextString(m) }
func (*Insert) ProtoMessage()    {}
func (*Insert) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{8}
}
func (m *Insert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Insert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Insert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Insert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Insert.Merge(m, src)
}
func (m *Insert) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Insert) XXX_DiscardUnknown() {
	xxx_messageInfo_Insert.DiscardUnknown(m)
}

var xxx_messageInfo_Insert proto.InternalMessageInfo

func (m *Insert) GetAffected() uint64 {
	if m != nil {
		return m.Affected
	}
	return 0
}

func (m *Insert) GetToWriteS3() bool {
	if m != nil {
		return m.ToWriteS3
	}
	return false
}

func (m *Insert) GetAddAffectedRows() bool {
	if m != nil {
		return m.AddAffectedRows
	}
	return false
}

func (m *Insert) GetRef() *plan.ObjectRef {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *Insert) GetAttrs() []string {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *Insert) GetPartitionTableIds() []uint64 {
	if m != nil {
		return m.PartitionTableIds
	}
	return nil
}

func (m *Insert) GetPartitionTableNames() []string {
	if m != nil {
		return m.PartitionTableNames
	}
	return nil
}

func (m *Insert) GetPartitionIdx() int32 {
	if m != nil {
		return m.PartitionIdx
	}
	return 0
}

func (m *Insert) GetIsEnd() bool {
	if m != nil {
		return m.IsEnd
	}
	return false
}

func (m *Insert) GetTableDef() *plan.TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

type Array struct {
	Array                []int32  `protobuf:"varint,1,rep,packed,name=array,proto3" json:"array,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Array) Reset()         { *m = Array{} }
func (m *Array) String() string { return proto.CompactTextString(m) }
func (*Array) ProtoMessage()    {}
func (*Array) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{9}
}
func (m *Array) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Array) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Array.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Array) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Array.Merge(m, src)
}
func (m *Array) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Array) XXX_DiscardUnknown() {
	xxx_messageInfo_Array.DiscardUnknown(m)
}

var xxx_messageInfo_Array proto.InternalMessageInfo

func (m *Array) GetArray() []int32 {
	if m != nil {
		return m.Array
	}
	return nil
}

type Map struct {
	Mp                   map[string]int32 `protobuf:"bytes,1,rep,name=mp,proto3" json:"mp,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Map) Reset()         { *m = Map{} }
func (m *Map) String() string { return proto.CompactTextString(m) }
func (*Map) ProtoMessage()    {}
func (*Map) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{10}
}
func (m *Map) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Map) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Map.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Map) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Map.Merge(m, src)
}
func (m *Map) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Map) XXX_DiscardUnknown() {
	xxx_messageInfo_Map.DiscardUnknown(m)
}

var xxx_messageInfo_Map proto.InternalMessageInfo

func (m *Map) GetMp() map[string]int32 {
	if m != nil {
		return m.Mp
	}
	return nil
}

type Deletion struct {
	AffectedRows          uint64           `protobuf:"varint,1,opt,name=AffectedRows,proto3" json:"AffectedRows,omitempty"`
	RemoteDelete          bool             `protobuf:"varint,2,opt,name=RemoteDelete,proto3" json:"RemoteDelete,omitempty"`
	IBucket               uint32           `protobuf:"varint,3,opt,name=IBucket,proto3" json:"IBucket,omitempty"`
	NBucket               uint32           `protobuf:"varint,4,opt,name=NBucket,proto3" json:"NBucket,omitempty"`
	RowIdIdx              int32            `protobuf:"varint,5,opt,name=row_id_idx,json=rowIdIdx,proto3" json:"row_id_idx,omitempty"`
	PartitionTableIds     []uint64         `protobuf:"varint,6,rep,packed,name=partition_table_ids,json=partitionTableIds,proto3" json:"partition_table_ids,omitempty"`
	PartitionTableNames   []string         `protobuf:"bytes,7,rep,name=partition_table_names,json=partitionTableNames,proto3" json:"partition_table_names,omitempty"`
	PartitionIndexInBatch int32            `protobuf:"varint,8,opt,name=partition_index_in_batch,json=partitionIndexInBatch,proto3" json:"partition_index_in_batch,omitempty"`
	Ref                   *plan.ObjectRef  `protobuf:"bytes,9,opt,name=ref,proto3" json:"ref,omitempty"`
	AddAffectedRows       bool             `protobuf:"varint,10,opt,name=add_affected_rows,json=addAffectedRows,proto3" json:"add_affected_rows,omitempty"`
	SegmentMap            map[string]int32 `protobuf:"bytes,11,rep,name=SegmentMap,proto3" json:"SegmentMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	CanTruncate           bool             `protobuf:"varint,12,opt,name=can_truncate,json=canTruncate,proto3" json:"can_truncate,omitempty"`
	IsEnd                 bool             `protobuf:"varint,13,opt,name=is_end,json=isEnd,proto3" json:"is_end,omitempty"`
	PrimaryKeyIdx         int32            `protobuf:"varint,14,opt,name=primary_key_idx,json=primaryKeyIdx,proto3" json:"primary_key_idx,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}         `json:"-"`
	XXX_unrecognized      []byte           `json:"-"`
	XXX_sizecache         int32            `json:"-"`
}

func (m *Deletion) Reset()         { *m = Deletion{} }
func (m *Deletion) String() string { return proto.CompactTextString(m) }
func (*Deletion) ProtoMessage()    {}
func (*Deletion) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{11}
}
func (m *Deletion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deletion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deletion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deletion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deletion.Merge(m, src)
}
func (m *Deletion) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Deletion) XXX_DiscardUnknown() {
	xxx_messageInfo_Deletion.DiscardUnknown(m)
}

var xxx_messageInfo_Deletion proto.InternalMessageInfo

func (m *Deletion) GetAffectedRows() uint64 {
	if m != nil {
		return m.AffectedRows
	}
	return 0
}

func (m *Deletion) GetRemoteDelete() bool {
	if m != nil {
		return m.RemoteDelete
	}
	return false
}

func (m *Deletion) GetIBucket() uint32 {
	if m != nil {
		return m.IBucket
	}
	return 0
}

func (m *Deletion) GetNBucket() uint32 {
	if m != nil {
		return m.NBucket
	}
	return 0
}

func (m *Deletion) GetRowIdIdx() int32 {
	if m != nil {
		return m.RowIdIdx
	}
	return 0
}

func (m *Deletion) GetPartitionTableIds() []uint64 {
	if m != nil {
		return m.PartitionTableIds
	}
	return nil
}

func (m *Deletion) GetPartitionTableNames() []string {
	if m != nil {
		return m.PartitionTableNames
	}
	return nil
}

func (m *Deletion) GetPartitionIndexInBatch() int32 {
	if m != nil {
		return m.PartitionIndexInBatch
	}
	return 0
}

func (m *Deletion) GetRef() *plan.ObjectRef {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *Deletion) GetAddAffectedRows() bool {
	if m != nil {
		return m.AddAffectedRows
	}
	return false
}

func (m *Deletion) GetSegmentMap() map[string]int32 {
	if m != nil {
		return m.SegmentMap
	}
	return nil
}

func (m *Deletion) GetCanTruncate() bool {
	if m != nil {
		return m.CanTruncate
	}
	return false
}

func (m *Deletion) GetIsEnd() bool {
	if m != nil {
		return m.IsEnd
	}
	return false
}

func (m *Deletion) GetPrimaryKeyIdx() int32 {
	if m != nil {
		return m.PrimaryKeyIdx
	}
	return 0
}

type PreInsert struct {
	SchemaName           string         `protobuf:"bytes,1,opt,name=schema_name,json=schemaName,proto3" json:"schema_name,omitempty"`
	TableDef             *plan.TableDef `protobuf:"bytes,2,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	Idx                  []int32        `protobuf:"varint,3,rep,packed,name=idx,proto3" json:"idx,omitempty"`
	Attrs                []string       `protobuf:"bytes,4,rep,name=attrs,proto3" json:"attrs,omitempty"`
	HasAutoCol           bool           `protobuf:"varint,5,opt,name=has_auto_col,json=hasAutoCol,proto3" json:"has_auto_col,omitempty"`
	IsUpdate             bool           `protobuf:"varint,6,opt,name=is_update,json=isUpdate,proto3" json:"is_update,omitempty"`
	EstimatedRowCount    int64          `protobuf:"varint,7,opt,name=estimated_row_count,json=estimatedRowCount,proto3" json:"estimated_row_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *PreInsert) Reset()         { *m = PreInsert{} }
func (m *PreInsert) String() string { return proto.CompactTextString(m) }
func (*PreInsert) ProtoMessage()    {}
func (*PreInsert) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{12}
}
func (m *PreInsert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreInsert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PreInsert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PreInsert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreInsert.Merge(m, src)
}
func (m *PreInsert) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PreInsert) XXX_DiscardUnknown() {
	xxx_messageInfo_PreInsert.DiscardUnknown(m)
}

var xxx_messageInfo_PreInsert proto.InternalMessageInfo

func (m *PreInsert) GetSchemaName() string {
	if m != nil {
		return m.SchemaName
	}
	return ""
}

func (m *PreInsert) GetTableDef() *plan.TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *PreInsert) GetIdx() []int32 {
	if m != nil {
		return m.Idx
	}
	return nil
}

func (m *PreInsert) GetAttrs() []string {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *PreInsert) GetHasAutoCol() bool {
	if m != nil {
		return m.HasAutoCol
	}
	return false
}

func (m *PreInsert) GetIsUpdate() bool {
	if m != nil {
		return m.IsUpdate
	}
	return false
}

func (m *PreInsert) GetEstimatedRowCount() int64 {
	if m != nil {
		return m.EstimatedRowCount
	}
	return 0
}

type LockTarget struct {
	TableId              uint64        `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	PrimaryColIdxInBat   int32         `protobuf:"varint,2,opt,name=primary_col_idx_in_bat,json=primaryColIdxInBat,proto3" json:"primary_col_idx_in_bat,omitempty"`
	PrimaryColTyp        plan.Type     `protobuf:"bytes,3,opt,name=primary_col_typ,json=primaryColTyp,proto3" json:"primary_col_typ"`
	RefreshTsIdxInBat    int32         `protobuf:"varint,4,opt,name=refresh_ts_idx_in_bat,json=refreshTsIdxInBat,proto3" json:"refresh_ts_idx_in_bat,omitempty"`
	FilterColIdxInBat    int32         `protobuf:"varint,5,opt,name=filter_col_idx_in_bat,json=filterColIdxInBat,proto3" json:"filter_col_idx_in_bat,omitempty"`
	LockTable            bool          `protobuf:"varint,6,opt,name=lock_table,json=lockTable,proto3" json:"lock_table,omitempty"`
	ChangeDef            bool          `protobuf:"varint,7,opt,name=ChangeDef,proto3" json:"ChangeDef,omitempty"`
	Mode                 lock.LockMode `protobuf:"varint,8,opt,name=Mode,proto3,enum=lock.LockMode" json:"Mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LockTarget) Reset()         { *m = LockTarget{} }
func (m *LockTarget) String() string { return proto.CompactTextString(m) }
func (*LockTarget) ProtoMessage()    {}
func (*LockTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{13}
}
func (m *LockTarget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockTarget.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LockTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockTarget.Merge(m, src)
}
func (m *LockTarget) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LockTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_LockTarget.DiscardUnknown(m)
}

var xxx_messageInfo_LockTarget proto.InternalMessageInfo

func (m *LockTarget) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *LockTarget) GetPrimaryColIdxInBat() int32 {
	if m != nil {
		return m.PrimaryColIdxInBat
	}
	return 0
}

func (m *LockTarget) GetPrimaryColTyp() plan.Type {
	if m != nil {
		return m.PrimaryColTyp
	}
	return plan.Type{}
}

func (m *LockTarget) GetRefreshTsIdxInBat() int32 {
	if m != nil {
		return m.RefreshTsIdxInBat
	}
	return 0
}

func (m *LockTarget) GetFilterColIdxInBat() int32 {
	if m != nil {
		return m.FilterColIdxInBat
	}
	return 0
}

func (m *LockTarget) GetLockTable() bool {
	if m != nil {
		return m.LockTable
	}
	return false
}

func (m *LockTarget) GetChangeDef() bool {
	if m != nil {
		return m.ChangeDef
	}
	return false
}

func (m *LockTarget) GetMode() lock.LockMode {
	if m != nil {
		return m.Mode
	}
	return lock.LockMode_Exclusive
}

type LockOp struct {
	Targets              []*LockTarget `protobuf:"bytes,1,rep,name=targets,proto3" json:"targets,omitempty"`
	Block                bool          `protobuf:"varint,2,opt,name=block,proto3" json:"block,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LockOp) Reset()         { *m = LockOp{} }
func (m *LockOp) String() string { return proto.CompactTextString(m) }
func (*LockOp) ProtoMessage()    {}
func (*LockOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{14}
}
func (m *LockOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LockOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockOp.Merge(m, src)
}
func (m *LockOp) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LockOp) XXX_DiscardUnknown() {
	xxx_messageInfo_LockOp.DiscardUnknown(m)
}

var xxx_messageInfo_LockOp proto.InternalMessageInfo

func (m *LockOp) GetTargets() []*LockTarget {
	if m != nil {
		return m.Targets
	}
	return nil
}

func (m *LockOp) GetBlock() bool {
	if m != nil {
		return m.Block
	}
	return false
}

type PreInsertUnique struct {
	PreInsertUkCtx       *plan.PreInsertUkCtx `protobuf:"bytes,1,opt,name=pre_insert_uk_ctx,json=preInsertUkCtx,proto3" json:"pre_insert_uk_ctx,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *PreInsertUnique) Reset()         { *m = PreInsertUnique{} }
func (m *PreInsertUnique) String() string { return proto.CompactTextString(m) }
func (*PreInsertUnique) ProtoMessage()    {}
func (*PreInsertUnique) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{15}
}
func (m *PreInsertUnique) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreInsertUnique) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PreInsertUnique.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PreInsertUnique) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreInsertUnique.Merge(m, src)
}
func (m *PreInsertUnique) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PreInsertUnique) XXX_DiscardUnknown() {
	xxx_messageInfo_PreInsertUnique.DiscardUnknown(m)
}

var xxx_messageInfo_PreInsertUnique proto.InternalMessageInfo

func (m *PreInsertUnique) GetPreInsertUkCtx() *plan.PreInsertUkCtx {
	if m != nil {
		return m.PreInsertUkCtx
	}
	return nil
}

type PreInsertSecondaryIndex struct {
	PreInsertSkCtx       *plan.PreInsertUkCtx `protobuf:"bytes,1,opt,name=pre_insert_sk_ctx,json=preInsertSkCtx,proto3" json:"pre_insert_sk_ctx,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *PreInsertSecondaryIndex) Reset()         { *m = PreInsertSecondaryIndex{} }
func (m *PreInsertSecondaryIndex) String() string { return proto.CompactTextString(m) }
func (*PreInsertSecondaryIndex) ProtoMessage()    {}
func (*PreInsertSecondaryIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{16}
}
func (m *PreInsertSecondaryIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreInsertSecondaryIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PreInsertSecondaryIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PreInsertSecondaryIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreInsertSecondaryIndex.Merge(m, src)
}
func (m *PreInsertSecondaryIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PreInsertSecondaryIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_PreInsertSecondaryIndex.DiscardUnknown(m)
}

var xxx_messageInfo_PreInsertSecondaryIndex proto.InternalMessageInfo

func (m *PreInsertSecondaryIndex) GetPreInsertSkCtx() *plan.PreInsertUkCtx {
	if m != nil {
		return m.PreInsertSkCtx
	}
	return nil
}

type OnDuplicateKey struct {
	Attrs                []string              `protobuf:"bytes,1,rep,name=attrs,proto3" json:"attrs,omitempty"`
	InsertColCount       int32                 `protobuf:"varint,2,opt,name=insert_col_count,json=insertColCount,proto3" json:"insert_col_count,omitempty"`
	UniqueColCheckExpr   []*plan.Expr          `protobuf:"bytes,3,rep,name=unique_col_check_expr,json=uniqueColCheckExpr,proto3" json:"unique_col_check_expr,omitempty"`
	UniqueCols           []string              `protobuf:"bytes,4,rep,name=unique_cols,json=uniqueCols,proto3" json:"unique_cols,omitempty"`
	OnDuplicateIdx       []int32               `protobuf:"varint,5,rep,packed,name=on_duplicate_idx,json=onDuplicateIdx,proto3" json:"on_duplicate_idx,omitempty"`
	OnDuplicateExpr      map[string]*plan.Expr `protobuf:"bytes,6,rep,name=on_duplicate_expr,json=onDuplicateExpr,proto3" json:"on_duplicate_expr,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	IsIgnore             bool                  `protobuf:"varint,7,opt,name=is_ignore,json=isIgnore,proto3" json:"is_ignore,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *OnDuplicateKey) Reset()         { *m = OnDuplicateKey{} }
func (m *OnDuplicateKey) String() string { return proto.CompactTextString(m) }
func (*OnDuplicateKey) ProtoMessage()    {}
func (*OnDuplicateKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{17}
}
func (m *OnDuplicateKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OnDuplicateKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OnDuplicateKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OnDuplicateKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnDuplicateKey.Merge(m, src)
}
func (m *OnDuplicateKey) XXX_Size() int {
	return m.ProtoSize()
}
func (m *OnDuplicateKey) XXX_DiscardUnknown() {
	xxx_messageInfo_OnDuplicateKey.DiscardUnknown(m)
}

var xxx_messageInfo_OnDuplicateKey proto.InternalMessageInfo

func (m *OnDuplicateKey) GetAttrs() []string {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *OnDuplicateKey) GetInsertColCount() int32 {
	if m != nil {
		return m.InsertColCount
	}
	return 0
}

func (m *OnDuplicateKey) GetUniqueColCheckExpr() []*plan.Expr {
	if m != nil {
		return m.UniqueColCheckExpr
	}
	return nil
}

func (m *OnDuplicateKey) GetUniqueCols() []string {
	if m != nil {
		return m.UniqueCols
	}
	return nil
}

func (m *OnDuplicateKey) GetOnDuplicateIdx() []int32 {
	if m != nil {
		return m.OnDuplicateIdx
	}
	return nil
}

func (m *OnDuplicateKey) GetOnDuplicateExpr() map[string]*plan.Expr {
	if m != nil {
		return m.OnDuplicateExpr
	}
	return nil
}

func (m *OnDuplicateKey) GetIsIgnore() bool {
	if m != nil {
		return m.IsIgnore
	}
	return false
}

type FuzzyFilter struct {
	N                    float32   `protobuf:"fixed32,1,opt,name=N,proto3" json:"N,omitempty"`
	PkName               string    `protobuf:"bytes,2,opt,name=PkName,proto3" json:"PkName,omitempty"`
	PkTyp                plan.Type `protobuf:"bytes,3,opt,name=PkTyp,proto3" json:"PkTyp"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *FuzzyFilter) Reset()         { *m = FuzzyFilter{} }
func (m *FuzzyFilter) String() string { return proto.CompactTextString(m) }
func (*FuzzyFilter) ProtoMessage()    {}
func (*FuzzyFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{18}
}
func (m *FuzzyFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FuzzyFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FuzzyFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FuzzyFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FuzzyFilter.Merge(m, src)
}
func (m *FuzzyFilter) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FuzzyFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_FuzzyFilter.DiscardUnknown(m)
}

var xxx_messageInfo_FuzzyFilter proto.InternalMessageInfo

func (m *FuzzyFilter) GetN() float32 {
	if m != nil {
		return m.N
	}
	return 0
}

func (m *FuzzyFilter) GetPkName() string {
	if m != nil {
		return m.PkName
	}
	return ""
}

func (m *FuzzyFilter) GetPkTyp() plan.Type {
	if m != nil {
		return m.PkTyp
	}
	return plan.Type{}
}

type Join struct {
	RelList                []int32                   `protobuf:"varint,1,rep,packed,name=rel_list,json=relList,proto3" json:"rel_list,omitempty"`
	ColList                []int32                   `protobuf:"varint,2,rep,packed,name=col_list,json=colList,proto3" json:"col_list,omitempty"`
	Expr                   *plan.Expr                `protobuf:"bytes,3,opt,name=expr,proto3" json:"expr,omitempty"`
	Types                  []plan.Type               `protobuf:"bytes,4,rep,name=types,proto3" json:"types"`
	LeftCond               []*plan.Expr              `protobuf:"bytes,5,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond              []*plan.Expr              `protobuf:"bytes,6,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	RuntimeFilterBuildList []*plan.RuntimeFilterSpec `protobuf:"bytes,7,rep,name=runtime_filter_build_list,json=runtimeFilterBuildList,proto3" json:"runtime_filter_build_list,omitempty"`
	HashOnPk               bool                      `protobuf:"varint,8,opt,name=hash_on_pk,json=hashOnPk,proto3" json:"hash_on_pk,omitempty"`
	IsShuffle              bool                      `protobuf:"varint,9,opt,name=is_shuffle,json=isShuffle,proto3" json:"is_shuffle,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                  `json:"-"`
	XXX_unrecognized       []byte                    `json:"-"`
	XXX_sizecache          int32                     `json:"-"`
}

func (m *Join) Reset()         { *m = Join{} }
func (m *Join) String() string { return proto.CompactTextString(m) }
func (*Join) ProtoMessage()    {}
func (*Join) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{19}
}
func (m *Join) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Join) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Join.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Join) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Join.Merge(m, src)
}
func (m *Join) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Join) XXX_DiscardUnknown() {
	xxx_messageInfo_Join.DiscardUnknown(m)
}

var xxx_messageInfo_Join proto.InternalMessageInfo

func (m *Join) GetRelList() []int32 {
	if m != nil {
		return m.RelList
	}
	return nil
}

func (m *Join) GetColList() []int32 {
	if m != nil {
		return m.ColList
	}
	return nil
}

func (m *Join) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Join) GetTypes() []plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *Join) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *Join) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

func (m *Join) GetRuntimeFilterBuildList() []*plan.RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterBuildList
	}
	return nil
}

func (m *Join) GetHashOnPk() bool {
	if m != nil {
		return m.HashOnPk
	}
	return false
}

func (m *Join) GetIsShuffle() bool {
	if m != nil {
		return m.IsShuffle
	}
	return false
}

type AntiJoin struct {
	Result               []int32      `protobuf:"varint,1,rep,packed,name=result,proto3" json:"result,omitempty"`
	Expr                 *plan.Expr   `protobuf:"bytes,2,opt,name=expr,proto3" json:"expr,omitempty"`
	Types                []plan.Type  `protobuf:"bytes,3,rep,name=types,proto3" json:"types"`
	LeftCond             []*plan.Expr `protobuf:"bytes,4,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond            []*plan.Expr `protobuf:"bytes,5,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	HashOnPk             bool         `protobuf:"varint,6,opt,name=hash_on_pk,json=hashOnPk,proto3" json:"hash_on_pk,omitempty"`
	IsShuffle            bool         `protobuf:"varint,7,opt,name=is_shuffle,json=isShuffle,proto3" json:"is_shuffle,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *AntiJoin) Reset()         { *m = AntiJoin{} }
func (m *AntiJoin) String() string { return proto.CompactTextString(m) }
func (*AntiJoin) ProtoMessage()    {}
func (*AntiJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{20}
}
func (m *AntiJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AntiJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AntiJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AntiJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AntiJoin.Merge(m, src)
}
func (m *AntiJoin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AntiJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_AntiJoin.DiscardUnknown(m)
}

var xxx_messageInfo_AntiJoin proto.InternalMessageInfo

func (m *AntiJoin) GetResult() []int32 {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *AntiJoin) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *AntiJoin) GetTypes() []plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *AntiJoin) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *AntiJoin) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

func (m *AntiJoin) GetHashOnPk() bool {
	if m != nil {
		return m.HashOnPk
	}
	return false
}

func (m *AntiJoin) GetIsShuffle() bool {
	if m != nil {
		return m.IsShuffle
	}
	return false
}

type LeftJoin struct {
	RelList                []int32                   `protobuf:"varint,1,rep,packed,name=rel_list,json=relList,proto3" json:"rel_list,omitempty"`
	ColList                []int32                   `protobuf:"varint,2,rep,packed,name=col_list,json=colList,proto3" json:"col_list,omitempty"`
	Expr                   *plan.Expr                `protobuf:"bytes,3,opt,name=expr,proto3" json:"expr,omitempty"`
	Types                  []plan.Type               `protobuf:"bytes,4,rep,name=types,proto3" json:"types"`
	LeftCond               []*plan.Expr              `protobuf:"bytes,5,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond              []*plan.Expr              `protobuf:"bytes,6,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	RuntimeFilterBuildList []*plan.RuntimeFilterSpec `protobuf:"bytes,7,rep,name=runtime_filter_build_list,json=runtimeFilterBuildList,proto3" json:"runtime_filter_build_list,omitempty"`
	HashOnPk               bool                      `protobuf:"varint,8,opt,name=hash_on_pk,json=hashOnPk,proto3" json:"hash_on_pk,omitempty"`
	IsShuffle              bool                      `protobuf:"varint,9,opt,name=is_shuffle,json=isShuffle,proto3" json:"is_shuffle,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                  `json:"-"`
	XXX_unrecognized       []byte                    `json:"-"`
	XXX_sizecache          int32                     `json:"-"`
}

func (m *LeftJoin) Reset()         { *m = LeftJoin{} }
func (m *LeftJoin) String() string { return proto.CompactTextString(m) }
func (*LeftJoin) ProtoMessage()    {}
func (*LeftJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{21}
}
func (m *LeftJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeftJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeftJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeftJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeftJoin.Merge(m, src)
}
func (m *LeftJoin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LeftJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_LeftJoin.DiscardUnknown(m)
}

var xxx_messageInfo_LeftJoin proto.InternalMessageInfo

func (m *LeftJoin) GetRelList() []int32 {
	if m != nil {
		return m.RelList
	}
	return nil
}

func (m *LeftJoin) GetColList() []int32 {
	if m != nil {
		return m.ColList
	}
	return nil
}

func (m *LeftJoin) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *LeftJoin) GetTypes() []plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *LeftJoin) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *LeftJoin) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

func (m *LeftJoin) GetRuntimeFilterBuildList() []*plan.RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterBuildList
	}
	return nil
}

func (m *LeftJoin) GetHashOnPk() bool {
	if m != nil {
		return m.HashOnPk
	}
	return false
}

func (m *LeftJoin) GetIsShuffle() bool {
	if m != nil {
		return m.IsShuffle
	}
	return false
}

type RightJoin struct {
	RelList                []int32                   `protobuf:"varint,1,rep,packed,name=rel_list,json=relList,proto3" json:"rel_list,omitempty"`
	ColList                []int32                   `protobuf:"varint,2,rep,packed,name=col_list,json=colList,proto3" json:"col_list,omitempty"`
	Expr                   *plan.Expr                `protobuf:"bytes,3,opt,name=expr,proto3" json:"expr,omitempty"`
	LeftTypes              []plan.Type               `protobuf:"bytes,4,rep,name=left_types,json=leftTypes,proto3" json:"left_types"`
	RightTypes             []plan.Type               `protobuf:"bytes,5,rep,name=right_types,json=rightTypes,proto3" json:"right_types"`
	LeftCond               []*plan.Expr              `protobuf:"bytes,6,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond              []*plan.Expr              `protobuf:"bytes,7,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	RuntimeFilterBuildList []*plan.RuntimeFilterSpec `protobuf:"bytes,8,rep,name=runtime_filter_build_list,json=runtimeFilterBuildList,proto3" json:"runtime_filter_build_list,omitempty"`
	HashOnPk               bool                      `protobuf:"varint,9,opt,name=hash_on_pk,json=hashOnPk,proto3" json:"hash_on_pk,omitempty"`
	IsShuffle              bool                      `protobuf:"varint,10,opt,name=is_shuffle,json=isShuffle,proto3" json:"is_shuffle,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                  `json:"-"`
	XXX_unrecognized       []byte                    `json:"-"`
	XXX_sizecache          int32                     `json:"-"`
}

func (m *RightJoin) Reset()         { *m = RightJoin{} }
func (m *RightJoin) String() string { return proto.CompactTextString(m) }
func (*RightJoin) ProtoMessage()    {}
func (*RightJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{22}
}
func (m *RightJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RightJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RightJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RightJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RightJoin.Merge(m, src)
}
func (m *RightJoin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RightJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_RightJoin.DiscardUnknown(m)
}

var xxx_messageInfo_RightJoin proto.InternalMessageInfo

func (m *RightJoin) GetRelList() []int32 {
	if m != nil {
		return m.RelList
	}
	return nil
}

func (m *RightJoin) GetColList() []int32 {
	if m != nil {
		return m.ColList
	}
	return nil
}

func (m *RightJoin) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *RightJoin) GetLeftTypes() []plan.Type {
	if m != nil {
		return m.LeftTypes
	}
	return nil
}

func (m *RightJoin) GetRightTypes() []plan.Type {
	if m != nil {
		return m.RightTypes
	}
	return nil
}

func (m *RightJoin) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *RightJoin) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

func (m *RightJoin) GetRuntimeFilterBuildList() []*plan.RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterBuildList
	}
	return nil
}

func (m *RightJoin) GetHashOnPk() bool {
	if m != nil {
		return m.HashOnPk
	}
	return false
}

func (m *RightJoin) GetIsShuffle() bool {
	if m != nil {
		return m.IsShuffle
	}
	return false
}

type RightSemiJoin struct {
	Result                 []int32                   `protobuf:"varint,1,rep,packed,name=result,proto3" json:"result,omitempty"`
	Expr                   *plan.Expr                `protobuf:"bytes,2,opt,name=expr,proto3" json:"expr,omitempty"`
	RightTypes             []plan.Type               `protobuf:"bytes,3,rep,name=right_types,json=rightTypes,proto3" json:"right_types"`
	LeftCond               []*plan.Expr              `protobuf:"bytes,4,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond              []*plan.Expr              `protobuf:"bytes,5,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	RuntimeFilterBuildList []*plan.RuntimeFilterSpec `protobuf:"bytes,6,rep,name=runtime_filter_build_list,json=runtimeFilterBuildList,proto3" json:"runtime_filter_build_list,omitempty"`
	HashOnPk               bool                      `protobuf:"varint,7,opt,name=hash_on_pk,json=hashOnPk,proto3" json:"hash_on_pk,omitempty"`
	IsShuffle              bool                      `protobuf:"varint,8,opt,name=is_shuffle,json=isShuffle,proto3" json:"is_shuffle,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                  `json:"-"`
	XXX_unrecognized       []byte                    `json:"-"`
	XXX_sizecache          int32                     `json:"-"`
}

func (m *RightSemiJoin) Reset()         { *m = RightSemiJoin{} }
func (m *RightSemiJoin) String() string { return proto.CompactTextString(m) }
func (*RightSemiJoin) ProtoMessage()    {}
func (*RightSemiJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{23}
}
func (m *RightSemiJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RightSemiJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RightSemiJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RightSemiJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RightSemiJoin.Merge(m, src)
}
func (m *RightSemiJoin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RightSemiJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_RightSemiJoin.DiscardUnknown(m)
}

var xxx_messageInfo_RightSemiJoin proto.InternalMessageInfo

func (m *RightSemiJoin) GetResult() []int32 {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *RightSemiJoin) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *RightSemiJoin) GetRightTypes() []plan.Type {
	if m != nil {
		return m.RightTypes
	}
	return nil
}

func (m *RightSemiJoin) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *RightSemiJoin) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

func (m *RightSemiJoin) GetRuntimeFilterBuildList() []*plan.RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterBuildList
	}
	return nil
}

func (m *RightSemiJoin) GetHashOnPk() bool {
	if m != nil {
		return m.HashOnPk
	}
	return false
}

func (m *RightSemiJoin) GetIsShuffle() bool {
	if m != nil {
		return m.IsShuffle
	}
	return false
}

type RightAntiJoin struct {
	Result                 []int32                   `protobuf:"varint,1,rep,packed,name=result,proto3" json:"result,omitempty"`
	Expr                   *plan.Expr                `protobuf:"bytes,2,opt,name=expr,proto3" json:"expr,omitempty"`
	RightTypes             []plan.Type               `protobuf:"bytes,3,rep,name=right_types,json=rightTypes,proto3" json:"right_types"`
	LeftCond               []*plan.Expr              `protobuf:"bytes,4,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond              []*plan.Expr              `protobuf:"bytes,5,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	RuntimeFilterBuildList []*plan.RuntimeFilterSpec `protobuf:"bytes,6,rep,name=runtime_filter_build_list,json=runtimeFilterBuildList,proto3" json:"runtime_filter_build_list,omitempty"`
	HashOnPk               bool                      `protobuf:"varint,7,opt,name=hash_on_pk,json=hashOnPk,proto3" json:"hash_on_pk,omitempty"`
	IsShuffle              bool                      `protobuf:"varint,8,opt,name=is_shuffle,json=isShuffle,proto3" json:"is_shuffle,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                  `json:"-"`
	XXX_unrecognized       []byte                    `json:"-"`
	XXX_sizecache          int32                     `json:"-"`
}

func (m *RightAntiJoin) Reset()         { *m = RightAntiJoin{} }
func (m *RightAntiJoin) String() string { return proto.CompactTextString(m) }
func (*RightAntiJoin) ProtoMessage()    {}
func (*RightAntiJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{24}
}
func (m *RightAntiJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RightAntiJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RightAntiJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RightAntiJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RightAntiJoin.Merge(m, src)
}
func (m *RightAntiJoin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RightAntiJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_RightAntiJoin.DiscardUnknown(m)
}

var xxx_messageInfo_RightAntiJoin proto.InternalMessageInfo

func (m *RightAntiJoin) GetResult() []int32 {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *RightAntiJoin) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *RightAntiJoin) GetRightTypes() []plan.Type {
	if m != nil {
		return m.RightTypes
	}
	return nil
}

func (m *RightAntiJoin) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *RightAntiJoin) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

func (m *RightAntiJoin) GetRuntimeFilterBuildList() []*plan.RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterBuildList
	}
	return nil
}

func (m *RightAntiJoin) GetHashOnPk() bool {
	if m != nil {
		return m.HashOnPk
	}
	return false
}

func (m *RightAntiJoin) GetIsShuffle() bool {
	if m != nil {
		return m.IsShuffle
	}
	return false
}

type SemiJoin struct {
	Result                 []int32                   `protobuf:"varint,1,rep,packed,name=result,proto3" json:"result,omitempty"`
	Expr                   *plan.Expr                `protobuf:"bytes,2,opt,name=expr,proto3" json:"expr,omitempty"`
	Types                  []plan.Type               `protobuf:"bytes,3,rep,name=types,proto3" json:"types"`
	LeftCond               []*plan.Expr              `protobuf:"bytes,4,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond              []*plan.Expr              `protobuf:"bytes,5,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	RuntimeFilterBuildList []*plan.RuntimeFilterSpec `protobuf:"bytes,6,rep,name=runtime_filter_build_list,json=runtimeFilterBuildList,proto3" json:"runtime_filter_build_list,omitempty"`
	HashOnPk               bool                      `protobuf:"varint,7,opt,name=hash_on_pk,json=hashOnPk,proto3" json:"hash_on_pk,omitempty"`
	IsShuffle              bool                      `protobuf:"varint,8,opt,name=is_shuffle,json=isShuffle,proto3" json:"is_shuffle,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                  `json:"-"`
	XXX_unrecognized       []byte                    `json:"-"`
	XXX_sizecache          int32                     `json:"-"`
}

func (m *SemiJoin) Reset()         { *m = SemiJoin{} }
func (m *SemiJoin) String() string { return proto.CompactTextString(m) }
func (*SemiJoin) ProtoMessage()    {}
func (*SemiJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{25}
}
func (m *SemiJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SemiJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SemiJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SemiJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SemiJoin.Merge(m, src)
}
func (m *SemiJoin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SemiJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_SemiJoin.DiscardUnknown(m)
}

var xxx_messageInfo_SemiJoin proto.InternalMessageInfo

func (m *SemiJoin) GetResult() []int32 {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *SemiJoin) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *SemiJoin) GetTypes() []plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *SemiJoin) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *SemiJoin) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

func (m *SemiJoin) GetRuntimeFilterBuildList() []*plan.RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterBuildList
	}
	return nil
}

func (m *SemiJoin) GetHashOnPk() bool {
	if m != nil {
		return m.HashOnPk
	}
	return false
}

func (m *SemiJoin) GetIsShuffle() bool {
	if m != nil {
		return m.IsShuffle
	}
	return false
}

type SingleJoin struct {
	RelList                []int32                   `protobuf:"varint,1,rep,packed,name=rel_list,json=relList,proto3" json:"rel_list,omitempty"`
	ColList                []int32                   `protobuf:"varint,2,rep,packed,name=col_list,json=colList,proto3" json:"col_list,omitempty"`
	Expr                   *plan.Expr                `protobuf:"bytes,3,opt,name=expr,proto3" json:"expr,omitempty"`
	Types                  []plan.Type               `protobuf:"bytes,4,rep,name=types,proto3" json:"types"`
	LeftCond               []*plan.Expr              `protobuf:"bytes,5,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond              []*plan.Expr              `protobuf:"bytes,6,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	RuntimeFilterBuildList []*plan.RuntimeFilterSpec `protobuf:"bytes,7,rep,name=runtime_filter_build_list,json=runtimeFilterBuildList,proto3" json:"runtime_filter_build_list,omitempty"`
	HashOnPk               bool                      `protobuf:"varint,8,opt,name=hash_on_pk,json=hashOnPk,proto3" json:"hash_on_pk,omitempty"`
	IsShuffle              bool                      `protobuf:"varint,9,opt,name=is_shuffle,json=isShuffle,proto3" json:"is_shuffle,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                  `json:"-"`
	XXX_unrecognized       []byte                    `json:"-"`
	XXX_sizecache          int32                     `json:"-"`
}

func (m *SingleJoin) Reset()         { *m = SingleJoin{} }
func (m *SingleJoin) String() string { return proto.CompactTextString(m) }
func (*SingleJoin) ProtoMessage()    {}
func (*SingleJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{26}
}
func (m *SingleJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SingleJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SingleJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SingleJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SingleJoin.Merge(m, src)
}
func (m *SingleJoin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SingleJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_SingleJoin.DiscardUnknown(m)
}

var xxx_messageInfo_SingleJoin proto.InternalMessageInfo

func (m *SingleJoin) GetRelList() []int32 {
	if m != nil {
		return m.RelList
	}
	return nil
}

func (m *SingleJoin) GetColList() []int32 {
	if m != nil {
		return m.ColList
	}
	return nil
}

func (m *SingleJoin) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *SingleJoin) GetTypes() []plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *SingleJoin) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *SingleJoin) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

func (m *SingleJoin) GetRuntimeFilterBuildList() []*plan.RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterBuildList
	}
	return nil
}

func (m *SingleJoin) GetHashOnPk() bool {
	if m != nil {
		return m.HashOnPk
	}
	return false
}

func (m *SingleJoin) GetIsShuffle() bool {
	if m != nil {
		return m.IsShuffle
	}
	return false
}

type MarkJoin struct {
	Result               []int32      `protobuf:"varint,1,rep,packed,name=result,proto3" json:"result,omitempty"`
	Expr                 *plan.Expr   `protobuf:"bytes,2,opt,name=expr,proto3" json:"expr,omitempty"`
	Types                []plan.Type  `protobuf:"bytes,3,rep,name=types,proto3" json:"types"`
	LeftCond             []*plan.Expr `protobuf:"bytes,4,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond            []*plan.Expr `protobuf:"bytes,5,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	OnList               []*plan.Expr `protobuf:"bytes,6,rep,name=on_list,json=onList,proto3" json:"on_list,omitempty"`
	HashOnPk             bool         `protobuf:"varint,7,opt,name=hash_on_pk,json=hashOnPk,proto3" json:"hash_on_pk,omitempty"`
	IsShuffle            bool         `protobuf:"varint,8,opt,name=is_shuffle,json=isShuffle,proto3" json:"is_shuffle,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *MarkJoin) Reset()         { *m = MarkJoin{} }
func (m *MarkJoin) String() string { return proto.CompactTextString(m) }
func (*MarkJoin) ProtoMessage()    {}
func (*MarkJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{27}
}
func (m *MarkJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarkJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkJoin.Merge(m, src)
}
func (m *MarkJoin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MarkJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkJoin.DiscardUnknown(m)
}

var xxx_messageInfo_MarkJoin proto.InternalMessageInfo

func (m *MarkJoin) GetResult() []int32 {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *MarkJoin) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *MarkJoin) GetTypes() []plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *MarkJoin) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *MarkJoin) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

func (m *MarkJoin) GetOnList() []*plan.Expr {
	if m != nil {
		return m.OnList
	}
	return nil
}

func (m *MarkJoin) GetHashOnPk() bool {
	if m != nil {
		return m.HashOnPk
	}
	return false
}

func (m *MarkJoin) GetIsShuffle() bool {
	if m != nil {
		return m.IsShuffle
	}
	return false
}

type Product struct {
	RelList              []int32     `protobuf:"varint,1,rep,packed,name=rel_list,json=relList,proto3" json:"rel_list,omitempty"`
	ColList              []int32     `protobuf:"varint,2,rep,packed,name=col_list,json=colList,proto3" json:"col_list,omitempty"`
	Types                []plan.Type `protobuf:"bytes,3,rep,name=types,proto3" json:"types"`
	IsShuffle            bool        `protobuf:"varint,4,opt,name=is_shuffle,json=isShuffle,proto3" json:"is_shuffle,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Product) Reset()         { *m = Product{} }
func (m *Product) String() string { return proto.CompactTextString(m) }
func (*Product) ProtoMessage()    {}
func (*Product) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{28}
}
func (m *Product) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Product) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Product.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Product) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Product.Merge(m, src)
}
func (m *Product) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Product) XXX_DiscardUnknown() {
	xxx_messageInfo_Product.DiscardUnknown(m)
}

var xxx_messageInfo_Product proto.InternalMessageInfo

func (m *Product) GetRelList() []int32 {
	if m != nil {
		return m.RelList
	}
	return nil
}

func (m *Product) GetColList() []int32 {
	if m != nil {
		return m.ColList
	}
	return nil
}

func (m *Product) GetTypes() []plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *Product) GetIsShuffle() bool {
	if m != nil {
		return m.IsShuffle
	}
	return false
}

type IndexJoin struct {
	Result                 []int32                   `protobuf:"varint,1,rep,packed,name=result,proto3" json:"result,omitempty"`
	Types                  []plan.Type               `protobuf:"bytes,2,rep,name=types,proto3" json:"types"`
	RuntimeFilterBuildList []*plan.RuntimeFilterSpec `protobuf:"bytes,3,rep,name=runtime_filter_build_list,json=runtimeFilterBuildList,proto3" json:"runtime_filter_build_list,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                  `json:"-"`
	XXX_unrecognized       []byte                    `json:"-"`
	XXX_sizecache          int32                     `json:"-"`
}

func (m *IndexJoin) Reset()         { *m = IndexJoin{} }
func (m *IndexJoin) String() string { return proto.CompactTextString(m) }
func (*IndexJoin) ProtoMessage()    {}
func (*IndexJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{29}
}
func (m *IndexJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexJoin.Merge(m, src)
}
func (m *IndexJoin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *IndexJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexJoin.DiscardUnknown(m)
}

var xxx_messageInfo_IndexJoin proto.InternalMessageInfo

func (m *IndexJoin) GetResult() []int32 {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *IndexJoin) GetTypes() []plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *IndexJoin) GetRuntimeFilterBuildList() []*plan.RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterBuildList
	}
	return nil
}

type TableFunction struct {
	Attrs                []string       `protobuf:"bytes,1,rep,name=attrs,proto3" json:"attrs,omitempty"`
	Rets                 []*plan.ColDef `protobuf:"bytes,2,rep,name=rets,proto3" json:"rets,omitempty"`
	Args                 []*plan.Expr   `protobuf:"bytes,3,rep,name=args,proto3" json:"args,omitempty"`
	Params               []byte         `protobuf:"bytes,4,opt,name=params,proto3" json:"params,omitempty"`
	Name                 string         `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TableFunction) Reset()         { *m = TableFunction{} }
func (m *TableFunction) String() string { return proto.CompactTextString(m) }
func (*TableFunction) ProtoMessage()    {}
func (*TableFunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{30}
}
func (m *TableFunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableFunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableFunction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableFunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableFunction.Merge(m, src)
}
func (m *TableFunction) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableFunction) XXX_DiscardUnknown() {
	xxx_messageInfo_TableFunction.DiscardUnknown(m)
}

var xxx_messageInfo_TableFunction proto.InternalMessageInfo

func (m *TableFunction) GetAttrs() []string {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *TableFunction) GetRets() []*plan.ColDef {
	if m != nil {
		return m.Rets
	}
	return nil
}

func (m *TableFunction) GetArgs() []*plan.Expr {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *TableFunction) GetParams() []byte {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TableFunction) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type HashBuild struct {
	NeedExpr             bool         `protobuf:"varint,1,opt,name=need_expr,json=needExpr,proto3" json:"need_expr,omitempty"`
	NeedHash             bool         `protobuf:"varint,2,opt,name=need_hash,json=needHash,proto3" json:"need_hash,omitempty"`
	Ibucket              uint64       `protobuf:"varint,3,opt,name=ibucket,proto3" json:"ibucket,omitempty"`
	Nbucket              uint64       `protobuf:"varint,4,opt,name=nbucket,proto3" json:"nbucket,omitempty"`
	Types                []plan.Type  `protobuf:"bytes,5,rep,name=types,proto3" json:"types"`
	Conds                []*plan.Expr `protobuf:"bytes,6,rep,name=conds,proto3" json:"conds,omitempty"`
	HashOnPk             bool         `protobuf:"varint,7,opt,name=hash_on_pk,json=hashOnPk,proto3" json:"hash_on_pk,omitempty"`
	NeedMergedBatch      bool         `protobuf:"varint,8,opt,name=need_merged_batch,json=needMergedBatch,proto3" json:"need_merged_batch,omitempty"`
	NeedAllocateSels     bool         `protobuf:"varint,9,opt,name=need_allocate_sels,json=needAllocateSels,proto3" json:"need_allocate_sels,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *HashBuild) Reset()         { *m = HashBuild{} }
func (m *HashBuild) String() string { return proto.CompactTextString(m) }
func (*HashBuild) ProtoMessage()    {}
func (*HashBuild) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{31}
}
func (m *HashBuild) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HashBuild) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HashBuild.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HashBuild) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HashBuild.Merge(m, src)
}
func (m *HashBuild) XXX_Size() int {
	return m.ProtoSize()
}
func (m *HashBuild) XXX_DiscardUnknown() {
	xxx_messageInfo_HashBuild.DiscardUnknown(m)
}

var xxx_messageInfo_HashBuild proto.InternalMessageInfo

func (m *HashBuild) GetNeedExpr() bool {
	if m != nil {
		return m.NeedExpr
	}
	return false
}

func (m *HashBuild) GetNeedHash() bool {
	if m != nil {
		return m.NeedHash
	}
	return false
}

func (m *HashBuild) GetIbucket() uint64 {
	if m != nil {
		return m.Ibucket
	}
	return 0
}

func (m *HashBuild) GetNbucket() uint64 {
	if m != nil {
		return m.Nbucket
	}
	return 0
}

func (m *HashBuild) GetTypes() []plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *HashBuild) GetConds() []*plan.Expr {
	if m != nil {
		return m.Conds
	}
	return nil
}

func (m *HashBuild) GetHashOnPk() bool {
	if m != nil {
		return m.HashOnPk
	}
	return false
}

func (m *HashBuild) GetNeedMergedBatch() bool {
	if m != nil {
		return m.NeedMergedBatch
	}
	return false
}

func (m *HashBuild) GetNeedAllocateSels() bool {
	if m != nil {
		return m.NeedAllocateSels
	}
	return false
}

type ExternalName2ColIndex struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Index                int32    `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExternalName2ColIndex) Reset()         { *m = ExternalName2ColIndex{} }
func (m *ExternalName2ColIndex) String() string { return proto.CompactTextString(m) }
func (*ExternalName2ColIndex) ProtoMessage()    {}
func (*ExternalName2ColIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{32}
}
func (m *ExternalName2ColIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalName2ColIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExternalName2ColIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExternalName2ColIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalName2ColIndex.Merge(m, src)
}
func (m *ExternalName2ColIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExternalName2ColIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalName2ColIndex.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalName2ColIndex proto.InternalMessageInfo

func (m *ExternalName2ColIndex) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ExternalName2ColIndex) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

type FileOffset struct {
	Offset               []int64  `protobuf:"varint,1,rep,packed,name=offset,proto3" json:"offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileOffset) Reset()         { *m = FileOffset{} }
func (m *FileOffset) String() string { return proto.CompactTextString(m) }
func (*FileOffset) ProtoMessage()    {}
func (*FileOffset) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{33}
}
func (m *FileOffset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileOffset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileOffset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileOffset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileOffset.Merge(m, src)
}
func (m *FileOffset) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FileOffset) XXX_DiscardUnknown() {
	xxx_messageInfo_FileOffset.DiscardUnknown(m)
}

var xxx_messageInfo_FileOffset proto.InternalMessageInfo

func (m *FileOffset) GetOffset() []int64 {
	if m != nil {
		return m.Offset
	}
	return nil
}

type ExternalScan struct {
	Attrs                []string                 `protobuf:"bytes,1,rep,name=attrs,proto3" json:"attrs,omitempty"`
	FileSize             []int64                  `protobuf:"varint,2,rep,packed,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
	FileOffsetTotal      []*FileOffset            `protobuf:"bytes,3,rep,name=file_offset_total,json=fileOffsetTotal,proto3" json:"file_offset_total,omitempty"`
	Cols                 []*plan.ColDef           `protobuf:"bytes,4,rep,name=cols,proto3" json:"cols,omitempty"`
	Name2ColIndex        []*ExternalName2ColIndex `protobuf:"bytes,5,rep,name=name2_col_index,json=name2ColIndex,proto3" json:"name2_col_index,omitempty"`
	CreateSql            string                   `protobuf:"bytes,6,opt,name=create_sql,json=createSql,proto3" json:"create_sql,omitempty"`
	FileList             []string                 `protobuf:"bytes,7,rep,name=file_list,json=fileList,proto3" json:"file_list,omitempty"`
	OriginCols           []*plan.ColDef           `protobuf:"bytes,8,rep,name=origin_cols,json=originCols,proto3" json:"origin_cols,omitempty"`
	Filter               *plan.Expr               `protobuf:"bytes,9,opt,name=filter,proto3" json:"filter,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *ExternalScan) Reset()         { *m = ExternalScan{} }
func (m *ExternalScan) String() string { return proto.CompactTextString(m) }
func (*ExternalScan) ProtoMessage()    {}
func (*ExternalScan) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{34}
}
func (m *ExternalScan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalScan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExternalScan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExternalScan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalScan.Merge(m, src)
}
func (m *ExternalScan) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExternalScan) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalScan.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalScan proto.InternalMessageInfo

func (m *ExternalScan) GetAttrs() []string {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *ExternalScan) GetFileSize() []int64 {
	if m != nil {
		return m.FileSize
	}
	return nil
}

func (m *ExternalScan) GetFileOffsetTotal() []*FileOffset {
	if m != nil {
		return m.FileOffsetTotal
	}
	return nil
}

func (m *ExternalScan) GetCols() []*plan.ColDef {
	if m != nil {
		return m.Cols
	}
	return nil
}

func (m *ExternalScan) GetName2ColIndex() []*ExternalName2ColIndex {
	if m != nil {
		return m.Name2ColIndex
	}
	return nil
}

func (m *ExternalScan) GetCreateSql() string {
	if m != nil {
		return m.CreateSql
	}
	return ""
}

func (m *ExternalScan) GetFileList() []string {
	if m != nil {
		return m.FileList
	}
	return nil
}

func (m *ExternalScan) GetOriginCols() []*plan.ColDef {
	if m != nil {
		return m.OriginCols
	}
	return nil
}

func (m *ExternalScan) GetFilter() *plan.Expr {
	if m != nil {
		return m.Filter
	}
	return nil
}

type StreamScan struct {
	TblDef               *plan.TableDef `protobuf:"bytes,1,opt,name=tbl_def,json=tblDef,proto3" json:"tbl_def,omitempty"`
	Offset               int64          `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	Limit                int64          `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *StreamScan) Reset()         { *m = StreamScan{} }
func (m *StreamScan) String() string { return proto.CompactTextString(m) }
func (*StreamScan) ProtoMessage()    {}
func (*StreamScan) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{35}
}
func (m *StreamScan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamScan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamScan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamScan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamScan.Merge(m, src)
}
func (m *StreamScan) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StreamScan) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamScan.DiscardUnknown(m)
}

var xxx_messageInfo_StreamScan proto.InternalMessageInfo

func (m *StreamScan) GetTblDef() *plan.TableDef {
	if m != nil {
		return m.TblDef
	}
	return nil
}

func (m *StreamScan) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *StreamScan) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type SampleFunc struct {
	SampleType           SampleFunc_SampleType `protobuf:"varint,1,opt,name=sample_type,json=sampleType,proto3,enum=pipeline.SampleFunc_SampleType" json:"sample_type,omitempty"`
	SampleRows           int32                 `protobuf:"varint,2,opt,name=sample_rows,json=sampleRows,proto3" json:"sample_rows,omitempty"`
	SamplePercent        float64               `protobuf:"fixed64,3,opt,name=sample_percent,json=samplePercent,proto3" json:"sample_percent,omitempty"`
	SampleColumns        []*plan.Expr          `protobuf:"bytes,4,rep,name=sample_columns,json=sampleColumns,proto3" json:"sample_columns,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *SampleFunc) Reset()         { *m = SampleFunc{} }
func (m *SampleFunc) String() string { return proto.CompactTextString(m) }
func (*SampleFunc) ProtoMessage()    {}
func (*SampleFunc) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{36}
}
func (m *SampleFunc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SampleFunc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SampleFunc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SampleFunc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SampleFunc.Merge(m, src)
}
func (m *SampleFunc) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SampleFunc) XXX_DiscardUnknown() {
	xxx_messageInfo_SampleFunc.DiscardUnknown(m)
}

var xxx_messageInfo_SampleFunc proto.InternalMessageInfo

func (m *SampleFunc) GetSampleType() SampleFunc_SampleType {
	if m != nil {
		return m.SampleType
	}
	return SampleFunc_Rows
}

func (m *SampleFunc) GetSampleRows() int32 {
	if m != nil {
		return m.SampleRows
	}
	return 0
}

func (m *SampleFunc) GetSamplePercent() float64 {
	if m != nil {
		return m.SamplePercent
	}
	return 0
}

func (m *SampleFunc) GetSampleColumns() []*plan.Expr {
	if m != nil {
		return m.SampleColumns
	}
	return nil
}

type Instruction struct {
	// Op specified the operator code of an instruction.
	Op int32 `protobuf:"varint,1,opt,name=op,proto3" json:"op,omitempty"`
	// Idx specified the anaylze information index.
	Idx             int32               `protobuf:"varint,2,opt,name=idx,proto3" json:"idx,omitempty"`
	Anti            *AntiJoin           `protobuf:"bytes,3,opt,name=anti,proto3" json:"anti,omitempty"`
	Connect         *Connector          `protobuf:"bytes,4,opt,name=connect,proto3" json:"connect,omitempty"`
	Dispatch        *Dispatch           `protobuf:"bytes,5,opt,name=dispatch,proto3" json:"dispatch,omitempty"`
	Agg             *Group              `protobuf:"bytes,6,opt,name=agg,proto3" json:"agg,omitempty"`
	LeftJoin        *LeftJoin           `protobuf:"bytes,8,opt,name=left_join,json=leftJoin,proto3" json:"left_join,omitempty"`
	SemiJoin        *SemiJoin           `protobuf:"bytes,9,opt,name=semi_join,json=semiJoin,proto3" json:"semi_join,omitempty"`
	SingleJoin      *SingleJoin         `protobuf:"bytes,10,opt,name=single_join,json=singleJoin,proto3" json:"single_join,omitempty"`
	MarkJoin        *MarkJoin           `protobuf:"bytes,11,opt,name=mark_join,json=markJoin,proto3" json:"mark_join,omitempty"`
	Join            *Join               `protobuf:"bytes,12,opt,name=join,proto3" json:"join,omitempty"`
	Product         *Product            `protobuf:"bytes,13,opt,name=product,proto3" json:"product,omitempty"`
	TableFunction   *TableFunction      `protobuf:"bytes,14,opt,name=table_function,json=tableFunction,proto3" json:"table_function,omitempty"`
	HashBuild       *HashBuild          `protobuf:"bytes,15,opt,name=hash_build,json=hashBuild,proto3" json:"hash_build,omitempty"`
	ExternalScan    *ExternalScan       `protobuf:"bytes,16,opt,name=external_scan,json=externalScan,proto3" json:"external_scan,omitempty"`
	Insert          *Insert             `protobuf:"bytes,17,opt,name=insert,proto3" json:"insert,omitempty"`
	OnDuplicateKey  *OnDuplicateKey     `protobuf:"bytes,18,opt,name=on_duplicate_key,json=onDuplicateKey,proto3" json:"on_duplicate_key,omitempty"`
	PreInsert       *PreInsert          `protobuf:"bytes,19,opt,name=pre_insert,json=preInsert,proto3" json:"pre_insert,omitempty"`
	PreInsertUnique *PreInsertUnique    `protobuf:"bytes,20,opt,name=pre_insert_unique,json=preInsertUnique,proto3" json:"pre_insert_unique,omitempty"`
	OrderBy         []*plan.OrderBySpec `protobuf:"bytes,21,rep,name=order_by,json=orderBy,proto3" json:"order_by,omitempty"`
	ProjectList     []*plan.Expr        `protobuf:"bytes,22,rep,name=project_list,json=projectList,proto3" json:"project_list,omitempty"`
	Filter          *plan.Expr          `protobuf:"bytes,23,opt,name=filter,proto3" json:"filter,omitempty"`
	Limit           *plan.Expr          `protobuf:"bytes,24,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset          *plan.Expr          `protobuf:"bytes,25,opt,name=offset,proto3" json:"offset,omitempty"`
	// isFirst identifies whether it is the first instruction of analyzeInfo corresponding to idx
	IsFirst bool `protobuf:"varint,26,opt,name=isFirst,proto3" json:"isFirst,omitempty"`
	// isLast identifies whether it is the last instruction of analyzeInfo corresponding to idx
	IsLast                  bool                     `protobuf:"varint,27,opt,name=isLast,proto3" json:"isLast,omitempty"`
	RightJoin               *RightJoin               `protobuf:"bytes,28,opt,name=right_join,json=rightJoin,proto3" json:"right_join,omitempty"`
	RightSemiJoin           *RightSemiJoin           `protobuf:"bytes,29,opt,name=right_semi_join,json=rightSemiJoin,proto3" json:"right_semi_join,omitempty"`
	RightAntiJoin           *RightAntiJoin           `protobuf:"bytes,30,opt,name=right_anti_join,json=rightAntiJoin,proto3" json:"right_anti_join,omitempty"`
	Delete                  *Deletion                `protobuf:"bytes,31,opt,name=delete,proto3" json:"delete,omitempty"`
	LockOp                  *LockOp                  `protobuf:"bytes,32,opt,name=lock_op,json=lockOp,proto3" json:"lock_op,omitempty"`
	Shuffle                 *Shuffle                 `protobuf:"bytes,33,opt,name=shuffle,proto3" json:"shuffle,omitempty"`
	Merge                   *Merge                   `protobuf:"bytes,34,opt,name=merge,proto3" json:"merge,omitempty"`
	StreamScan              *StreamScan              `protobuf:"bytes,35,opt,name=stream_scan,json=streamScan,proto3" json:"stream_scan,omitempty"`
	PreInsertSecondaryIndex *PreInsertSecondaryIndex `protobuf:"bytes,36,opt,name=pre_insert_secondary_index,json=preInsertSecondaryIndex,proto3" json:"pre_insert_secondary_index,omitempty"`
	SampleFunc              *SampleFunc              `protobuf:"bytes,37,opt,name=sample_func,json=sampleFunc,proto3" json:"sample_func,omitempty"`
	FuzzyFilter             *FuzzyFilter             `protobuf:"bytes,38,opt,name=fuzzy_filter,json=fuzzyFilter,proto3" json:"fuzzy_filter,omitempty"`
	CnAddr                  string                   `protobuf:"bytes,39,opt,name=cn_addr,json=cnAddr,proto3" json:"cn_addr,omitempty"`
	OperatorId              int32                    `protobuf:"varint,40,opt,name=operator_id,json=operatorId,proto3" json:"operator_id,omitempty"`
	ParallelId              int32                    `protobuf:"varint,41,opt,name=parallel_id,json=parallelId,proto3" json:"parallel_id,omitempty"`
	MaxParallel             int32                    `protobuf:"varint,42,opt,name=max_parallel,json=maxParallel,proto3" json:"max_parallel,omitempty"`
	IndexJoin               *IndexJoin               `protobuf:"bytes,43,opt,name=index_join,json=indexJoin,proto3" json:"index_join,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}                 `json:"-"`
	XXX_unrecognized        []byte                   `json:"-"`
	XXX_sizecache           int32                    `json:"-"`
}

func (m *Instruction) Reset()         { *m = Instruction{} }
func (m *Instruction) String() string { return proto.CompactTextString(m) }
func (*Instruction) ProtoMessage()    {}
func (*Instruction) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{37}
}
func (m *Instruction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Instruction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Instruction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Instruction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Instruction.Merge(m, src)
}
func (m *Instruction) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Instruction) XXX_DiscardUnknown() {
	xxx_messageInfo_Instruction.DiscardUnknown(m)
}

var xxx_messageInfo_Instruction proto.InternalMessageInfo

func (m *Instruction) GetOp() int32 {
	if m != nil {
		return m.Op
	}
	return 0
}

func (m *Instruction) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *Instruction) GetAnti() *AntiJoin {
	if m != nil {
		return m.Anti
	}
	return nil
}

func (m *Instruction) GetConnect() *Connector {
	if m != nil {
		return m.Connect
	}
	return nil
}

func (m *Instruction) GetDispatch() *Dispatch {
	if m != nil {
		return m.Dispatch
	}
	return nil
}

func (m *Instruction) GetAgg() *Group {
	if m != nil {
		return m.Agg
	}
	return nil
}

func (m *Instruction) GetLeftJoin() *LeftJoin {
	if m != nil {
		return m.LeftJoin
	}
	return nil
}

func (m *Instruction) GetSemiJoin() *SemiJoin {
	if m != nil {
		return m.SemiJoin
	}
	return nil
}

func (m *Instruction) GetSingleJoin() *SingleJoin {
	if m != nil {
		return m.SingleJoin
	}
	return nil
}

func (m *Instruction) GetMarkJoin() *MarkJoin {
	if m != nil {
		return m.MarkJoin
	}
	return nil
}

func (m *Instruction) GetJoin() *Join {
	if m != nil {
		return m.Join
	}
	return nil
}

func (m *Instruction) GetProduct() *Product {
	if m != nil {
		return m.Product
	}
	return nil
}

func (m *Instruction) GetTableFunction() *TableFunction {
	if m != nil {
		return m.TableFunction
	}
	return nil
}

func (m *Instruction) GetHashBuild() *HashBuild {
	if m != nil {
		return m.HashBuild
	}
	return nil
}

func (m *Instruction) GetExternalScan() *ExternalScan {
	if m != nil {
		return m.ExternalScan
	}
	return nil
}

func (m *Instruction) GetInsert() *Insert {
	if m != nil {
		return m.Insert
	}
	return nil
}

func (m *Instruction) GetOnDuplicateKey() *OnDuplicateKey {
	if m != nil {
		return m.OnDuplicateKey
	}
	return nil
}

func (m *Instruction) GetPreInsert() *PreInsert {
	if m != nil {
		return m.PreInsert
	}
	return nil
}

func (m *Instruction) GetPreInsertUnique() *PreInsertUnique {
	if m != nil {
		return m.PreInsertUnique
	}
	return nil
}

func (m *Instruction) GetOrderBy() []*plan.OrderBySpec {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *Instruction) GetProjectList() []*plan.Expr {
	if m != nil {
		return m.ProjectList
	}
	return nil
}

func (m *Instruction) GetFilter() *plan.Expr {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *Instruction) GetLimit() *plan.Expr {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *Instruction) GetOffset() *plan.Expr {
	if m != nil {
		return m.Offset
	}
	return nil
}

func (m *Instruction) GetIsFirst() bool {
	if m != nil {
		return m.IsFirst
	}
	return false
}

func (m *Instruction) GetIsLast() bool {
	if m != nil {
		return m.IsLast
	}
	return false
}

func (m *Instruction) GetRightJoin() *RightJoin {
	if m != nil {
		return m.RightJoin
	}
	return nil
}

func (m *Instruction) GetRightSemiJoin() *RightSemiJoin {
	if m != nil {
		return m.RightSemiJoin
	}
	return nil
}

func (m *Instruction) GetRightAntiJoin() *RightAntiJoin {
	if m != nil {
		return m.RightAntiJoin
	}
	return nil
}

func (m *Instruction) GetDelete() *Deletion {
	if m != nil {
		return m.Delete
	}
	return nil
}

func (m *Instruction) GetLockOp() *LockOp {
	if m != nil {
		return m.LockOp
	}
	return nil
}

func (m *Instruction) GetShuffle() *Shuffle {
	if m != nil {
		return m.Shuffle
	}
	return nil
}

func (m *Instruction) GetMerge() *Merge {
	if m != nil {
		return m.Merge
	}
	return nil
}

func (m *Instruction) GetStreamScan() *StreamScan {
	if m != nil {
		return m.StreamScan
	}
	return nil
}

func (m *Instruction) GetPreInsertSecondaryIndex() *PreInsertSecondaryIndex {
	if m != nil {
		return m.PreInsertSecondaryIndex
	}
	return nil
}

func (m *Instruction) GetSampleFunc() *SampleFunc {
	if m != nil {
		return m.SampleFunc
	}
	return nil
}

func (m *Instruction) GetFuzzyFilter() *FuzzyFilter {
	if m != nil {
		return m.FuzzyFilter
	}
	return nil
}

func (m *Instruction) GetCnAddr() string {
	if m != nil {
		return m.CnAddr
	}
	return ""
}

func (m *Instruction) GetOperatorId() int32 {
	if m != nil {
		return m.OperatorId
	}
	return 0
}

func (m *Instruction) GetParallelId() int32 {
	if m != nil {
		return m.ParallelId
	}
	return 0
}

func (m *Instruction) GetMaxParallel() int32 {
	if m != nil {
		return m.MaxParallel
	}
	return 0
}

func (m *Instruction) GetIndexJoin() *IndexJoin {
	if m != nil {
		return m.IndexJoin
	}
	return nil
}

type AnalysisList struct {
	List                 []*plan.AnalyzeInfo `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *AnalysisList) Reset()         { *m = AnalysisList{} }
func (m *AnalysisList) String() string { return proto.CompactTextString(m) }
func (*AnalysisList) ProtoMessage()    {}
func (*AnalysisList) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{38}
}
func (m *AnalysisList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnalysisList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnalysisList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AnalysisList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnalysisList.Merge(m, src)
}
func (m *AnalysisList) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AnalysisList) XXX_DiscardUnknown() {
	xxx_messageInfo_AnalysisList.DiscardUnknown(m)
}

var xxx_messageInfo_AnalysisList proto.InternalMessageInfo

func (m *AnalysisList) GetList() []*plan.AnalyzeInfo {
	if m != nil {
		return m.List
	}
	return nil
}

type Source struct {
	SchemaName             string                    `protobuf:"bytes,1,opt,name=schema_name,json=schemaName,proto3" json:"schema_name,omitempty"`
	TableName              string                    `protobuf:"bytes,2,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	ColList                []string                  `protobuf:"bytes,3,rep,name=col_list,json=colList,proto3" json:"col_list,omitempty"`
	Block                  string                    `protobuf:"bytes,4,opt,name=block,proto3" json:"block,omitempty"`
	PushdownId             uint64                    `protobuf:"varint,5,opt,name=pushdown_id,json=pushdownId,proto3" json:"pushdown_id,omitempty"`
	PushdownAddr           string                    `protobuf:"bytes,6,opt,name=pushdown_addr,json=pushdownAddr,proto3" json:"pushdown_addr,omitempty"`
	Expr                   *plan.Expr                `protobuf:"bytes,7,opt,name=expr,proto3" json:"expr,omitempty"`
	TableDef               *plan.TableDef            `protobuf:"bytes,8,opt,name=tableDef,proto3" json:"tableDef,omitempty"`
	Timestamp              *timestamp.Timestamp      `protobuf:"bytes,9,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	RuntimeFilterProbeList []*plan.RuntimeFilterSpec `protobuf:"bytes,10,rep,name=runtime_filter_probe_list,json=runtimeFilterProbeList,proto3" json:"runtime_filter_probe_list,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                  `json:"-"`
	XXX_unrecognized       []byte                    `json:"-"`
	XXX_sizecache          int32                     `json:"-"`
}

func (m *Source) Reset()         { *m = Source{} }
func (m *Source) String() string { return proto.CompactTextString(m) }
func (*Source) ProtoMessage()    {}
func (*Source) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{39}
}
func (m *Source) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Source) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Source.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Source) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Source.Merge(m, src)
}
func (m *Source) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Source) XXX_DiscardUnknown() {
	xxx_messageInfo_Source.DiscardUnknown(m)
}

var xxx_messageInfo_Source proto.InternalMessageInfo

func (m *Source) GetSchemaName() string {
	if m != nil {
		return m.SchemaName
	}
	return ""
}

func (m *Source) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *Source) GetColList() []string {
	if m != nil {
		return m.ColList
	}
	return nil
}

func (m *Source) GetBlock() string {
	if m != nil {
		return m.Block
	}
	return ""
}

func (m *Source) GetPushdownId() uint64 {
	if m != nil {
		return m.PushdownId
	}
	return 0
}

func (m *Source) GetPushdownAddr() string {
	if m != nil {
		return m.PushdownAddr
	}
	return ""
}

func (m *Source) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Source) GetTableDef() *plan.TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *Source) GetTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *Source) GetRuntimeFilterProbeList() []*plan.RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterProbeList
	}
	return nil
}

type NodeInfo struct {
	Mcpu                 int32    `protobuf:"varint,1,opt,name=mcpu,proto3" json:"mcpu,omitempty"`
	Id                   string   `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	Addr                 string   `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
	Payload              string   `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`
	Type                 uint32   `protobuf:"varint,5,opt,name=type,proto3" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeInfo) Reset()         { *m = NodeInfo{} }
func (m *NodeInfo) String() string { return proto.CompactTextString(m) }
func (*NodeInfo) ProtoMessage()    {}
func (*NodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{40}
}
func (m *NodeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInfo.Merge(m, src)
}
func (m *NodeInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *NodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInfo proto.InternalMessageInfo

func (m *NodeInfo) GetMcpu() int32 {
	if m != nil {
		return m.Mcpu
	}
	return 0
}

func (m *NodeInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NodeInfo) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *NodeInfo) GetPayload() string {
	if m != nil {
		return m.Payload
	}
	return ""
}

func (m *NodeInfo) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

type ProcessLimitation struct {
	Size                 int64    `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
	BatchRows            int64    `protobuf:"varint,2,opt,name=batch_rows,json=batchRows,proto3" json:"batch_rows,omitempty"`
	BatchSize            int64    `protobuf:"varint,3,opt,name=batch_size,json=batchSize,proto3" json:"batch_size,omitempty"`
	PartitionRows        int64    `protobuf:"varint,4,opt,name=partition_rows,json=partitionRows,proto3" json:"partition_rows,omitempty"`
	ReaderSize           int64    `protobuf:"varint,5,opt,name=reader_size,json=readerSize,proto3" json:"reader_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProcessLimitation) Reset()         { *m = ProcessLimitation{} }
func (m *ProcessLimitation) String() string { return proto.CompactTextString(m) }
func (*ProcessLimitation) ProtoMessage()    {}
func (*ProcessLimitation) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{41}
}
func (m *ProcessLimitation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessLimitation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessLimitation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessLimitation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessLimitation.Merge(m, src)
}
func (m *ProcessLimitation) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ProcessLimitation) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessLimitation.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessLimitation proto.InternalMessageInfo

func (m *ProcessLimitation) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *ProcessLimitation) GetBatchRows() int64 {
	if m != nil {
		return m.BatchRows
	}
	return 0
}

func (m *ProcessLimitation) GetBatchSize() int64 {
	if m != nil {
		return m.BatchSize
	}
	return 0
}

func (m *ProcessLimitation) GetPartitionRows() int64 {
	if m != nil {
		return m.PartitionRows
	}
	return 0
}

func (m *ProcessLimitation) GetReaderSize() int64 {
	if m != nil {
		return m.ReaderSize
	}
	return 0
}

type ProcessInfo struct {
	Id                   string             `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Sql                  string             `protobuf:"bytes,2,opt,name=sql,proto3" json:"sql,omitempty"`
	Lim                  *ProcessLimitation `protobuf:"bytes,3,opt,name=lim,proto3" json:"lim,omitempty"`
	UnixTime             int64              `protobuf:"varint,4,opt,name=unix_time,json=unixTime,proto3" json:"unix_time,omitempty"`
	AccountId            uint32             `protobuf:"varint,5,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
	Snapshot             string             `protobuf:"bytes,6,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	SessionInfo          *SessionInfo       `protobuf:"bytes,7,opt,name=session_info,json=sessionInfo,proto3" json:"session_info,omitempty"`
	AnalysisNodeList     []int32            `protobuf:"varint,8,rep,packed,name=analysis_node_list,json=analysisNodeList,proto3" json:"analysis_node_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ProcessInfo) Reset()         { *m = ProcessInfo{} }
func (m *ProcessInfo) String() string { return proto.CompactTextString(m) }
func (*ProcessInfo) ProtoMessage()    {}
func (*ProcessInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{42}
}
func (m *ProcessInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessInfo.Merge(m, src)
}
func (m *ProcessInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ProcessInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessInfo proto.InternalMessageInfo

func (m *ProcessInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ProcessInfo) GetSql() string {
	if m != nil {
		return m.Sql
	}
	return ""
}

func (m *ProcessInfo) GetLim() *ProcessLimitation {
	if m != nil {
		return m.Lim
	}
	return nil
}

func (m *ProcessInfo) GetUnixTime() int64 {
	if m != nil {
		return m.UnixTime
	}
	return 0
}

func (m *ProcessInfo) GetAccountId() uint32 {
	if m != nil {
		return m.AccountId
	}
	return 0
}

func (m *ProcessInfo) GetSnapshot() string {
	if m != nil {
		return m.Snapshot
	}
	return ""
}

func (m *ProcessInfo) GetSessionInfo() *SessionInfo {
	if m != nil {
		return m.SessionInfo
	}
	return nil
}

func (m *ProcessInfo) GetAnalysisNodeList() []int32 {
	if m != nil {
		return m.AnalysisNodeList
	}
	return nil
}

type SessionInfo struct {
	User                 string   `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	Host                 string   `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	Role                 string   `protobuf:"bytes,3,opt,name=role,proto3" json:"role,omitempty"`
	ConnectionId         uint64   `protobuf:"varint,4,opt,name=connection_id,json=connectionId,proto3" json:"connection_id,omitempty"`
	Database             string   `protobuf:"bytes,5,opt,name=database,proto3" json:"database,omitempty"`
	Version              string   `protobuf:"bytes,6,opt,name=version,proto3" json:"version,omitempty"`
	TimeZone             []byte   `protobuf:"bytes,7,opt,name=time_zone,json=timeZone,proto3" json:"time_zone,omitempty"`
	Account              string   `protobuf:"bytes,8,opt,name=account,proto3" json:"account,omitempty"`
	QueryId              []string `protobuf:"bytes,9,rep,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SessionInfo) Reset()         { *m = SessionInfo{} }
func (m *SessionInfo) String() string { return proto.CompactTextString(m) }
func (*SessionInfo) ProtoMessage()    {}
func (*SessionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{43}
}
func (m *SessionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionInfo.Merge(m, src)
}
func (m *SessionInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SessionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SessionInfo proto.InternalMessageInfo

func (m *SessionInfo) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *SessionInfo) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *SessionInfo) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *SessionInfo) GetConnectionId() uint64 {
	if m != nil {
		return m.ConnectionId
	}
	return 0
}

func (m *SessionInfo) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *SessionInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *SessionInfo) GetTimeZone() []byte {
	if m != nil {
		return m.TimeZone
	}
	return nil
}

func (m *SessionInfo) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *SessionInfo) GetQueryId() []string {
	if m != nil {
		return m.QueryId
	}
	return nil
}

type Pipeline struct {
	PipelineType         Pipeline_PipelineType `protobuf:"varint,1,opt,name=pipeline_type,json=pipelineType,proto3,enum=pipeline.Pipeline_PipelineType" json:"pipeline_type,omitempty"`
	PipelineId           int32                 `protobuf:"varint,2,opt,name=pipeline_id,json=pipelineId,proto3" json:"pipeline_id,omitempty"`
	Qry                  *plan.Plan            `protobuf:"bytes,3,opt,name=qry,proto3" json:"qry,omitempty"`
	DataSource           *Source               `protobuf:"bytes,4,opt,name=data_source,json=dataSource,proto3" json:"data_source,omitempty"`
	Children             []*Pipeline           `protobuf:"bytes,5,rep,name=children,proto3" json:"children,omitempty"`
	InstructionList      []*Instruction        `protobuf:"bytes,6,rep,name=instruction_list,json=instructionList,proto3" json:"instruction_list,omitempty"`
	IsEnd                bool                  `protobuf:"varint,7,opt,name=is_end,json=isEnd,proto3" json:"is_end,omitempty"`
	IsJoin               bool                  `protobuf:"varint,8,opt,name=is_join,json=isJoin,proto3" json:"is_join,omitempty"`
	IsLoad               bool                  `protobuf:"varint,9,opt,name=is_load,json=isLoad,proto3" json:"is_load,omitempty"`
	Node                 *NodeInfo             `protobuf:"bytes,10,opt,name=node,proto3" json:"node,omitempty"`
	PushDownInfo         int32                 `protobuf:"varint,11,opt,name=push_down_info,json=pushDownInfo,proto3" json:"push_down_info,omitempty"`
	ChildrenCount        int32                 `protobuf:"varint,12,opt,name=children_count,json=childrenCount,proto3" json:"children_count,omitempty"`
	UuidsToRegIdx        []*UuidToRegIdx       `protobuf:"bytes,13,rep,name=uuids_to_reg_idx,json=uuidsToRegIdx,proto3" json:"uuids_to_reg_idx,omitempty"`
	BuildIdx             int32                 `protobuf:"varint,14,opt,name=build_idx,json=buildIdx,proto3" json:"build_idx,omitempty"`
	ShuffleCnt           int32                 `protobuf:"varint,15,opt,name=shuffle_cnt,json=shuffleCnt,proto3" json:"shuffle_cnt,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Pipeline) Reset()         { *m = Pipeline{} }
func (m *Pipeline) String() string { return proto.CompactTextString(m) }
func (*Pipeline) ProtoMessage()    {}
func (*Pipeline) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{44}
}
func (m *Pipeline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pipeline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pipeline.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pipeline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pipeline.Merge(m, src)
}
func (m *Pipeline) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Pipeline) XXX_DiscardUnknown() {
	xxx_messageInfo_Pipeline.DiscardUnknown(m)
}

var xxx_messageInfo_Pipeline proto.InternalMessageInfo

func (m *Pipeline) GetPipelineType() Pipeline_PipelineType {
	if m != nil {
		return m.PipelineType
	}
	return Pipeline_Merge
}

func (m *Pipeline) GetPipelineId() int32 {
	if m != nil {
		return m.PipelineId
	}
	return 0
}

func (m *Pipeline) GetQry() *plan.Plan {
	if m != nil {
		return m.Qry
	}
	return nil
}

func (m *Pipeline) GetDataSource() *Source {
	if m != nil {
		return m.DataSource
	}
	return nil
}

func (m *Pipeline) GetChildren() []*Pipeline {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *Pipeline) GetInstructionList() []*Instruction {
	if m != nil {
		return m.InstructionList
	}
	return nil
}

func (m *Pipeline) GetIsEnd() bool {
	if m != nil {
		return m.IsEnd
	}
	return false
}

func (m *Pipeline) GetIsJoin() bool {
	if m != nil {
		return m.IsJoin
	}
	return false
}

func (m *Pipeline) GetIsLoad() bool {
	if m != nil {
		return m.IsLoad
	}
	return false
}

func (m *Pipeline) GetNode() *NodeInfo {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *Pipeline) GetPushDownInfo() int32 {
	if m != nil {
		return m.PushDownInfo
	}
	return 0
}

func (m *Pipeline) GetChildrenCount() int32 {
	if m != nil {
		return m.ChildrenCount
	}
	return 0
}

func (m *Pipeline) GetUuidsToRegIdx() []*UuidToRegIdx {
	if m != nil {
		return m.UuidsToRegIdx
	}
	return nil
}

func (m *Pipeline) GetBuildIdx() int32 {
	if m != nil {
		return m.BuildIdx
	}
	return 0
}

func (m *Pipeline) GetShuffleCnt() int32 {
	if m != nil {
		return m.ShuffleCnt
	}
	return 0
}

type WrapNode struct {
	NodeAddr             string   `protobuf:"bytes,1,opt,name=node_addr,json=nodeAddr,proto3" json:"node_addr,omitempty"`
	Uuid                 []byte   `protobuf:"bytes,2,opt,name=uuid,proto3" json:"uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WrapNode) Reset()         { *m = WrapNode{} }
func (m *WrapNode) String() string { return proto.CompactTextString(m) }
func (*WrapNode) ProtoMessage()    {}
func (*WrapNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{45}
}
func (m *WrapNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WrapNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WrapNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WrapNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WrapNode.Merge(m, src)
}
func (m *WrapNode) XXX_Size() int {
	return m.ProtoSize()
}
func (m *WrapNode) XXX_DiscardUnknown() {
	xxx_messageInfo_WrapNode.DiscardUnknown(m)
}

var xxx_messageInfo_WrapNode proto.InternalMessageInfo

func (m *WrapNode) GetNodeAddr() string {
	if m != nil {
		return m.NodeAddr
	}
	return ""
}

func (m *WrapNode) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

type UuidToRegIdx struct {
	Idx                  int32    `protobuf:"varint,1,opt,name=idx,proto3" json:"idx,omitempty"`
	Uuid                 []byte   `protobuf:"bytes,2,opt,name=uuid,proto3" json:"uuid,omitempty"`
	FromAddr             string   `protobuf:"bytes,3,opt,name=from_addr,json=fromAddr,proto3" json:"from_addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UuidToRegIdx) Reset()         { *m = UuidToRegIdx{} }
func (m *UuidToRegIdx) String() string { return proto.CompactTextString(m) }
func (*UuidToRegIdx) ProtoMessage()    {}
func (*UuidToRegIdx) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{46}
}
func (m *UuidToRegIdx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UuidToRegIdx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UuidToRegIdx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UuidToRegIdx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UuidToRegIdx.Merge(m, src)
}
func (m *UuidToRegIdx) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UuidToRegIdx) XXX_DiscardUnknown() {
	xxx_messageInfo_UuidToRegIdx.DiscardUnknown(m)
}

var xxx_messageInfo_UuidToRegIdx proto.InternalMessageInfo

func (m *UuidToRegIdx) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *UuidToRegIdx) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *UuidToRegIdx) GetFromAddr() string {
	if m != nil {
		return m.FromAddr
	}
	return ""
}

func init() {
	proto.RegisterEnum("pipeline.Method", Method_name, Method_value)
	proto.RegisterEnum("pipeline.Status", Status_name, Status_value)
	proto.RegisterEnum("pipeline.SampleFunc_SampleType", SampleFunc_SampleType_name, SampleFunc_SampleType_value)
	proto.RegisterEnum("pipeline.Pipeline_PipelineType", Pipeline_PipelineType_name, Pipeline_PipelineType_value)
	proto.RegisterType((*Message)(nil), "pipeline.Message")
	proto.RegisterType((*Connector)(nil), "pipeline.Connector")
	proto.RegisterType((*Shuffle)(nil), "pipeline.Shuffle")
	proto.RegisterType((*Dispatch)(nil), "pipeline.Dispatch")
	proto.RegisterType((*Merge)(nil), "pipeline.Merge")
	proto.RegisterType((*MultiArguemnt)(nil), "pipeline.MultiArguemnt")
	proto.RegisterType((*Aggregate)(nil), "pipeline.Aggregate")
	proto.RegisterType((*Group)(nil), "pipeline.Group")
	proto.RegisterType((*Insert)(nil), "pipeline.Insert")
	proto.RegisterType((*Array)(nil), "pipeline.Array")
	proto.RegisterType((*Map)(nil), "pipeline.Map")
	proto.RegisterMapType((map[string]int32)(nil), "pipeline.Map.MpEntry")
	proto.RegisterType((*Deletion)(nil), "pipeline.Deletion")
	proto.RegisterMapType((map[string]int32)(nil), "pipeline.Deletion.SegmentMapEntry")
	proto.RegisterType((*PreInsert)(nil), "pipeline.PreInsert")
	proto.RegisterType((*LockTarget)(nil), "pipeline.LockTarget")
	proto.RegisterType((*LockOp)(nil), "pipeline.LockOp")
	proto.RegisterType((*PreInsertUnique)(nil), "pipeline.PreInsertUnique")
	proto.RegisterType((*PreInsertSecondaryIndex)(nil), "pipeline.PreInsertSecondaryIndex")
	proto.RegisterType((*OnDuplicateKey)(nil), "pipeline.OnDuplicateKey")
	proto.RegisterMapType((map[string]*plan.Expr)(nil), "pipeline.OnDuplicateKey.OnDuplicateExprEntry")
	proto.RegisterType((*FuzzyFilter)(nil), "pipeline.FuzzyFilter")
	proto.RegisterType((*Join)(nil), "pipeline.Join")
	proto.RegisterType((*AntiJoin)(nil), "pipeline.AntiJoin")
	proto.RegisterType((*LeftJoin)(nil), "pipeline.LeftJoin")
	proto.RegisterType((*RightJoin)(nil), "pipeline.RightJoin")
	proto.RegisterType((*RightSemiJoin)(nil), "pipeline.RightSemiJoin")
	proto.RegisterType((*RightAntiJoin)(nil), "pipeline.RightAntiJoin")
	proto.RegisterType((*SemiJoin)(nil), "pipeline.SemiJoin")
	proto.RegisterType((*SingleJoin)(nil), "pipeline.SingleJoin")
	proto.RegisterType((*MarkJoin)(nil), "pipeline.MarkJoin")
	proto.RegisterType((*Product)(nil), "pipeline.Product")
	proto.RegisterType((*IndexJoin)(nil), "pipeline.IndexJoin")
	proto.RegisterType((*TableFunction)(nil), "pipeline.TableFunction")
	proto.RegisterType((*HashBuild)(nil), "pipeline.HashBuild")
	proto.RegisterType((*ExternalName2ColIndex)(nil), "pipeline.ExternalName2ColIndex")
	proto.RegisterType((*FileOffset)(nil), "pipeline.file_offset")
	proto.RegisterType((*ExternalScan)(nil), "pipeline.ExternalScan")
	proto.RegisterType((*StreamScan)(nil), "pipeline.StreamScan")
	proto.RegisterType((*SampleFunc)(nil), "pipeline.SampleFunc")
	proto.RegisterType((*Instruction)(nil), "pipeline.Instruction")
	proto.RegisterType((*AnalysisList)(nil), "pipeline.AnalysisList")
	proto.RegisterType((*Source)(nil), "pipeline.Source")
	proto.RegisterType((*NodeInfo)(nil), "pipeline.NodeInfo")
	proto.RegisterType((*ProcessLimitation)(nil), "pipeline.ProcessLimitation")
	proto.RegisterType((*ProcessInfo)(nil), "pipeline.ProcessInfo")
	proto.RegisterType((*SessionInfo)(nil), "pipeline.SessionInfo")
	proto.RegisterType((*Pipeline)(nil), "pipeline.Pipeline")
	proto.RegisterType((*WrapNode)(nil), "pipeline.WrapNode")
	proto.RegisterType((*UuidToRegIdx)(nil), "pipeline.UuidToRegIdx")
}

func init() { proto.RegisterFile("pipeline.proto", fileDescriptor_7ac67a7adf3df9c7) }

var fileDescriptor_7ac67a7adf3df9c7 = []byte{
	// 4529 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x7b, 0xcd, 0x93, 0x1c, 0xc7,
	0x52, 0xb8, 0xe6, 0xbb, 0x27, 0x67, 0x76, 0x77, 0xb6, 0xf4, 0x35, 0x96, 0x65, 0x69, 0xd5, 0xb6,
	0xe4, 0xb5, 0x6c, 0xad, 0xec, 0xf5, 0xcf, 0x3f, 0x1c, 0x3c, 0x8c, 0xdf, 0x6a, 0x25, 0x3f, 0x06,
	0x4b, 0xab, 0xa5, 0x76, 0x15, 0x0e, 0x4c, 0x04, 0x4d, 0x6f, 0x77, 0xcd, 0x6c, 0x7b, 0x7b, 0xaa,
	0x5a, 0xfd, 0x61, 0xed, 0xea, 0x0f, 0xe0, 0x1f, 0x78, 0x57, 0x02, 0x5e, 0xbc, 0x08, 0x2e, 0x44,
	0x10, 0x41, 0xc0, 0x91, 0x7f, 0xe0, 0xdd, 0xe0, 0xcc, 0x81, 0x47, 0x98, 0x13, 0x07, 0x02, 0x0e,
	0xc0, 0x85, 0x80, 0x20, 0x32, 0xab, 0xfa, 0x63, 0x66, 0x47, 0xeb, 0x4f, 0x0c, 0x44, 0xf8, 0x56,
	0x95, 0x99, 0x55, 0x5d, 0x95, 0x99, 0x95, 0x95, 0x59, 0x99, 0x0d, 0xcb, 0x51, 0x10, 0x89, 0x30,
	0x90, 0x62, 0x23, 0x8a, 0x55, 0xaa, 0x98, 0x95, 0xf7, 0xaf, 0xdc, 0x99, 0x04, 0xe9, 0x61, 0x76,
	0xb0, 0xe1, 0xa9, 0xe9, 0xdd, 0x89, 0x9a, 0xa8, 0xbb, 0x44, 0x70, 0x90, 0x8d, 0xa9, 0x47, 0x1d,
	0x6a, 0xe9, 0x81, 0x57, 0x20, 0x0a, 0x5d, 0x69, 0xda, 0x2b, 0x69, 0x30, 0x15, 0x49, 0xea, 0x4e,
	0xa3, 0x1c, 0x19, 0x2a, 0xef, 0x48, 0xb7, 0xed, 0x3f, 0xab, 0x43, 0xe7, 0x91, 0x48, 0x12, 0x77,
	0x22, 0x98, 0x0d, 0x8d, 0x24, 0xf0, 0x87, 0xb5, 0xb5, 0xda, 0xfa, 0xf2, 0xe6, 0x60, 0xa3, 0x58,
	0xcb, 0x5e, 0xea, 0xa6, 0x59, 0xc2, 0x11, 0x89, 0x34, 0xde, 0xd4, 0x1f, 0xd6, 0xe7, 0x69, 0x1e,
	0x89, 0xf4, 0x50, 0xf9, 0x1c, 0x91, 0x6c, 0x00, 0x0d, 0x11, 0xc7, 0xc3, 0xc6, 0x5a, 0x6d, 0xbd,
	0xcf, 0xb1, 0xc9, 0x18, 0x34, 0x7d, 0x37, 0x75, 0x87, 0x4d, 0x02, 0x51, 0x9b, 0xbd, 0x06, 0xcb,
	0x51, 0xac, 0x3c, 0x27, 0x90, 0x63, 0xe5, 0x10, 0xb6, 0x45, 0xd8, 0x3e, 0x42, 0x47, 0x72, 0xac,
	0xee, 0x23, 0xd5, 0x10, 0x3a, 0xae, 0x74, 0xc3, 0x93, 0x44, 0x0c, 0xdb, 0x84, 0xce, 0xbb, 0x6c,
	0x19, 0xea, 0x81, 0x3f, 0xec, 0xac, 0xd5, 0xd6, 0x9b, 0xbc, 0x1e, 0xf8, 0xf8, 0x8d, 0x2c, 0x0b,
	0xfc, 0xa1, 0xa5, 0xbf, 0x81, 0x6d, 0xf6, 0x32, 0x74, 0x0f, 0xdc, 0xd4, 0x3b, 0x74, 0x3c, 0x99,
	0x0e, 0xbb, 0x44, 0x6a, 0x11, 0x60, 0x5b, 0xa6, 0xec, 0x0a, 0x58, 0xde, 0xa1, 0xf0, 0x8e, 0x92,
	0x6c, 0x3a, 0x84, 0xb5, 0xda, 0xfa, 0x12, 0x2f, 0xfa, 0x88, 0x4b, 0xc4, 0xd3, 0x4c, 0x48, 0x4f,
	0x0c, 0x7b, 0x7a, 0x5c, 0xde, 0xb7, 0x9f, 0x40, 0x77, 0x5b, 0x49, 0x29, 0xbc, 0x54, 0xc5, 0xec,
	0x3a, 0xf4, 0x72, 0x1e, 0x38, 0x86, 0x77, 0x2d, 0x0e, 0x39, 0x68, 0xe4, 0xb3, 0xd7, 0x61, 0xc5,
	0xcb, 0xa9, 0x9d, 0x40, 0xfa, 0xe2, 0x98, 0x98, 0xd7, 0xe2, 0xcb, 0x05, 0x78, 0x84, 0x50, 0xfb,
	0x8f, 0xeb, 0xd0, 0xd9, 0x3b, 0xcc, 0xc6, 0xe3, 0x50, 0xb0, 0xd7, 0x60, 0xc9, 0x34, 0xb7, 0x55,
	0x38, 0xf2, 0x8f, 0xcd, 0xbc, 0xb3, 0x40, 0xb6, 0x06, 0x3d, 0x03, 0xd8, 0x3f, 0x89, 0x84, 0x99,
	0xb6, 0x0a, 0x9a, 0x9d, 0xe7, 0x51, 0x20, 0x49, 0x26, 0x0d, 0x3e, 0x0b, 0x9c, 0xa3, 0x72, 0x8f,
	0x49, 0x4c, 0xb3, 0x54, 0x2e, 0x7d, 0x6d, 0x2b, 0x0c, 0x3e, 0x17, 0x5c, 0x4c, 0xb6, 0x65, 0x4a,
	0xc2, 0x6a, 0xf1, 0x2a, 0x88, 0x6d, 0xc2, 0xc5, 0x44, 0x0f, 0x71, 0x62, 0x57, 0x4e, 0x44, 0xe2,
	0x64, 0x81, 0x4c, 0xff, 0xff, 0xff, 0x1b, 0xb6, 0xd7, 0x1a, 0xeb, 0x4d, 0x7e, 0xde, 0x20, 0x39,
	0xe1, 0x9e, 0x10, 0x8a, 0xbd, 0x0d, 0x17, 0xe6, 0xc6, 0xe8, 0x21, 0x9d, 0xb5, 0xc6, 0x7a, 0x83,
	0xb3, 0x99, 0x21, 0x23, 0xc4, 0xd8, 0xbf, 0xac, 0x83, 0x75, 0x3f, 0x48, 0x22, 0x14, 0x23, 0xbb,
	0x0c, 0x9d, 0x71, 0x26, 0xbd, 0x92, 0xf5, 0x6d, 0xec, 0x8e, 0x7c, 0xf6, 0x6b, 0xb0, 0x12, 0x2a,
	0xcf, 0x0d, 0x9d, 0x82, 0xcb, 0xc3, 0xfa, 0x5a, 0x63, 0xbd, 0xb7, 0x79, 0xbe, 0xd4, 0xd9, 0x42,
	0x8a, 0x7c, 0x99, 0x68, 0x4b, 0xa9, 0x7e, 0x00, 0x83, 0x58, 0x4c, 0x55, 0x2a, 0x2a, 0xc3, 0x1b,
	0x34, 0x9c, 0x95, 0xc3, 0x3f, 0x89, 0xdd, 0x68, 0x47, 0xf9, 0x82, 0xaf, 0x68, 0xda, 0x72, 0xf8,
	0x3b, 0x15, 0x46, 0x88, 0x89, 0x13, 0xf8, 0xc7, 0x0e, 0x7d, 0x60, 0xd8, 0x5c, 0x6b, 0xac, 0xb7,
	0xca, 0x5d, 0x89, 0xc9, 0xc8, 0x3f, 0x7e, 0x88, 0x18, 0xf6, 0x2e, 0x5c, 0x9a, 0x1f, 0xa2, 0x67,
	0x1d, 0xb6, 0x68, 0xcc, 0xf9, 0x99, 0x31, 0x9c, 0x50, 0xec, 0x06, 0xf4, 0xf3, 0x41, 0x29, 0x6a,
	0x40, 0x5b, 0xcb, 0x24, 0xa9, 0x68, 0xc0, 0x65, 0xe8, 0x04, 0x89, 0x93, 0x04, 0xf2, 0x88, 0x8e,
	0x8a, 0xc5, 0xdb, 0x41, 0xb2, 0x17, 0xc8, 0x23, 0xf6, 0x12, 0x58, 0xb1, 0xf0, 0x34, 0xc6, 0x22,
	0x4c, 0x27, 0x16, 0x1e, 0xa2, 0xec, 0x57, 0xa1, 0xf5, 0x48, 0xc4, 0x13, 0x41, 0xa7, 0x20, 0x90,
	0x47, 0x7b, 0x9e, 0x2b, 0x89, 0xbd, 0x16, 0x2f, 0xfa, 0xf6, 0x5f, 0xd4, 0x60, 0xe9, 0x51, 0x16,
	0xa6, 0xc1, 0x56, 0x3c, 0xc9, 0xc4, 0x54, 0xa6, 0x78, 0x00, 0xef, 0x07, 0x49, 0x6a, 0x28, 0xa9,
	0xcd, 0xd6, 0xa1, 0xfb, 0x93, 0x58, 0x65, 0xd1, 0x83, 0xe3, 0x28, 0x17, 0x00, 0x6c, 0x90, 0x6d,
	0x42, 0x08, 0x2f, 0x91, 0xec, 0x2d, 0xe8, 0x3d, 0x8e, 0x7d, 0x11, 0xdf, 0x3b, 0x21, 0xda, 0xc6,
	0x29, 0xda, 0x2a, 0x9a, 0x5d, 0x85, 0xee, 0x9e, 0x88, 0xdc, 0xd8, 0x45, 0xc9, 0xa0, 0xba, 0x76,
	0x79, 0x09, 0x40, 0xa3, 0x41, 0xc4, 0x23, 0xdf, 0xa8, 0x69, 0xde, 0xb5, 0x27, 0xd0, 0xdd, 0x9a,
	0x4c, 0x62, 0x31, 0x71, 0x53, 0xb2, 0x20, 0x2a, 0xa2, 0xe5, 0x36, 0x78, 0x5d, 0x45, 0x64, 0xa5,
	0x70, 0x03, 0x75, 0xbd, 0x01, 0x6c, 0xb3, 0x6b, 0xd0, 0x14, 0x8b, 0xd7, 0x43, 0x70, 0x76, 0x09,
	0xda, 0x9e, 0x92, 0xe3, 0x60, 0x62, 0x6c, 0x9b, 0xe9, 0xd9, 0x7f, 0xd0, 0x80, 0x16, 0x6d, 0x0e,
	0x6d, 0x90, 0x14, 0xc2, 0x77, 0xc4, 0xe7, 0x6e, 0x98, 0x73, 0x11, 0x01, 0x0f, 0x3e, 0x77, 0x43,
	0x5c, 0x69, 0x70, 0x90, 0x79, 0x47, 0x42, 0x7f, 0xb5, 0xc9, 0xf3, 0x2e, 0x62, 0xa4, 0xc1, 0x34,
	0x34, 0xc6, 0x74, 0xd9, 0x1a, 0xb4, 0xf0, 0xd3, 0x09, 0x69, 0xd3, 0xec, 0x9a, 0x34, 0x82, 0xdd,
	0x82, 0x16, 0xea, 0x43, 0x42, 0xba, 0x53, 0x50, 0xa0, 0x3e, 0xdc, 0x6b, 0xfe, 0xe2, 0x6f, 0xaf,
	0x9f, 0xe3, 0x1a, 0xcd, 0x5e, 0x87, 0xa6, 0x3b, 0x99, 0x24, 0x74, 0x3e, 0x67, 0x4e, 0x46, 0xc1,
	0x23, 0x4e, 0x04, 0xec, 0x3d, 0xe8, 0x6a, 0x59, 0x23, 0x75, 0x87, 0xa8, 0x2f, 0x57, 0x6c, 0x7f,
	0x55, 0x0d, 0x78, 0x49, 0x89, 0x52, 0x0a, 0x12, 0x63, 0x45, 0x8c, 0x92, 0x95, 0x00, 0x66, 0x43,
	0x3f, 0x8a, 0xc5, 0x56, 0x18, 0x2a, 0x6f, 0x2f, 0x78, 0x2e, 0x8c, 0x7d, 0x9e, 0x81, 0xb1, 0x5b,
	0xb0, 0xbc, 0xeb, 0xc6, 0x69, 0xe0, 0x86, 0x5c, 0x24, 0x59, 0x98, 0x26, 0x64, 0x8d, 0xfb, 0x7c,
	0x0e, 0xca, 0x36, 0x80, 0xcd, 0x40, 0xf6, 0x69, 0xfb, 0xb0, 0xd6, 0x58, 0x5f, 0xe2, 0x0b, 0x30,
	0xf6, 0xbf, 0xd4, 0xa1, 0x3d, 0x92, 0x89, 0x88, 0xe9, 0x1a, 0x70, 0xc7, 0x63, 0xe1, 0xa5, 0x42,
	0xdb, 0x90, 0x26, 0x2f, 0xfa, 0xb8, 0x81, 0x7d, 0xf5, 0x49, 0x1c, 0xa4, 0x62, 0xef, 0x5d, 0xa3,
	0x16, 0x25, 0x80, 0xdd, 0x86, 0x55, 0xd7, 0xf7, 0x9d, 0x9c, 0xda, 0x89, 0xd5, 0xb3, 0x84, 0x84,
	0x65, 0xf1, 0x15, 0xd7, 0xf7, 0xb7, 0x0c, 0x9c, 0xab, 0x67, 0x09, 0xbb, 0x01, 0x8d, 0x58, 0x8c,
	0x49, 0x49, 0x7a, 0x9b, 0x2b, 0x5a, 0x20, 0x8f, 0x0f, 0x3e, 0x13, 0x5e, 0xca, 0xc5, 0x98, 0x23,
	0x8e, 0x5d, 0x80, 0x96, 0x9b, 0xa6, 0xb1, 0x96, 0x5a, 0x97, 0xeb, 0x0e, 0xdb, 0x80, 0xf3, 0x11,
	0xae, 0x3f, 0x0d, 0x94, 0x74, 0x52, 0xf7, 0x20, 0xc4, 0x7b, 0x26, 0x31, 0x26, 0x75, 0xb5, 0x40,
	0xed, 0x23, 0x66, 0xe4, 0x27, 0x68, 0x84, 0xe7, 0xe9, 0xa5, 0x3b, 0x15, 0x5a, 0x6c, 0x5d, 0x7e,
	0x7e, 0x76, 0xc4, 0x0e, 0xa2, 0xd8, 0xab, 0xb0, 0x54, 0x8e, 0x09, 0xfc, 0x63, 0x92, 0x55, 0x8b,
	0xf7, 0x0b, 0x20, 0xde, 0x36, 0x17, 0xa1, 0x1d, 0x24, 0x8e, 0x90, 0x3e, 0x09, 0xca, 0xe2, 0xad,
	0x20, 0x79, 0x20, 0x7d, 0xf6, 0x26, 0x74, 0xf5, 0x57, 0x7c, 0x31, 0xa6, 0x6b, 0xb4, 0xb7, 0xb9,
	0x6c, 0xf4, 0x0d, 0xc1, 0xf7, 0xc5, 0x98, 0x5b, 0xa9, 0x69, 0xd9, 0xaf, 0x40, 0x6b, 0x2b, 0x8e,
	0xdd, 0x13, 0xda, 0x2b, 0x36, 0x86, 0x35, 0xb2, 0x6e, 0xba, 0x63, 0x7b, 0xd0, 0x78, 0xe4, 0x46,
	0xec, 0x26, 0xd4, 0xa7, 0x11, 0x61, 0x7a, 0x9b, 0x17, 0x2b, 0x6a, 0xe6, 0x46, 0x1b, 0x8f, 0xa2,
	0x07, 0x32, 0x8d, 0x4f, 0x78, 0x7d, 0x1a, 0x5d, 0x79, 0x0f, 0x3a, 0xa6, 0x8b, 0x1e, 0xc7, 0x91,
	0x38, 0x21, 0xf1, 0x75, 0x39, 0x36, 0xf1, 0x03, 0x9f, 0xbb, 0x61, 0x96, 0xdf, 0x8a, 0xba, 0xf3,
	0xab, 0xf5, 0xf7, 0x6b, 0xf6, 0xbf, 0x36, 0xc1, 0xba, 0x2f, 0x42, 0x81, 0xfb, 0x42, 0x1d, 0xac,
	0x8a, 0xc9, 0x28, 0xc0, 0x0c, 0x0c, 0x69, 0xb4, 0xbd, 0xa5, 0x51, 0xc2, 0xe8, 0xc1, 0x0c, 0x0c,
	0x4f, 0xeb, 0xe8, 0x5e, 0x79, 0x5a, 0x97, 0x78, 0xde, 0x45, 0xcc, 0x8e, 0xc1, 0x34, 0x35, 0xc6,
	0x74, 0xd9, 0x55, 0x80, 0x58, 0x3d, 0x73, 0x02, 0x9f, 0x58, 0xae, 0x0d, 0x95, 0x15, 0xab, 0x67,
	0x23, 0x1f, 0xd9, 0xfd, 0x7d, 0xc8, 0xfd, 0x57, 0x60, 0x58, 0x91, 0x3b, 0x7a, 0x21, 0x4e, 0x20,
	0x1d, 0x72, 0x90, 0x8c, 0x0a, 0x94, 0x73, 0x92, 0x93, 0x32, 0x92, 0xf7, 0xe8, 0xda, 0x35, 0xda,
	0xdc, 0x3d, 0x43, 0x9b, 0x17, 0x1e, 0x0e, 0x58, 0x7c, 0x38, 0xee, 0x01, 0xec, 0x89, 0xc9, 0x54,
	0xc8, 0xf4, 0x91, 0x1b, 0x0d, 0x7b, 0x24, 0x78, 0xbb, 0x14, 0x7c, 0x2e, 0xad, 0x8d, 0x92, 0x48,
	0x6b, 0x41, 0x65, 0x14, 0xde, 0x85, 0x9e, 0x2b, 0x9d, 0x34, 0xce, 0xa4, 0xe7, 0xa6, 0x62, 0xd8,
	0xa7, 0x4f, 0xf5, 0x3c, 0x57, 0xee, 0x1b, 0x50, 0x45, 0x83, 0x97, 0xaa, 0x1a, 0x7c, 0x0b, 0x56,
	0xa2, 0x38, 0x98, 0xba, 0xf1, 0x89, 0x73, 0x24, 0x4e, 0x48, 0x18, 0xcb, 0xda, 0xdd, 0x32, 0xe0,
	0x8f, 0xc5, 0xc9, 0xc8, 0x3f, 0xbe, 0xf2, 0x01, 0xac, 0xcc, 0x2d, 0xe0, 0x6b, 0xe9, 0xdd, 0x3f,
	0xd7, 0xa0, 0xbb, 0x1b, 0x0b, 0x63, 0x75, 0xae, 0x43, 0x2f, 0xf1, 0x0e, 0xc5, 0xd4, 0x25, 0x29,
	0x99, 0x19, 0x40, 0x83, 0x50, 0x38, 0xb3, 0xe7, 0xaa, 0x7e, 0xf6, 0xb9, 0xc2, 0x75, 0xe0, 0xb2,
	0x1b, 0x74, 0x98, 0xb0, 0x59, 0x1a, 0x93, 0x66, 0xd5, 0x98, 0xac, 0x41, 0xff, 0xd0, 0x4d, 0x1c,
	0x37, 0x4b, 0x95, 0xe3, 0xa9, 0x90, 0x94, 0xce, 0xe2, 0x70, 0xe8, 0x26, 0x5b, 0x59, 0xaa, 0xb6,
	0x55, 0x88, 0xb7, 0x55, 0x90, 0x38, 0x59, 0xe4, 0x23, 0x0f, 0xdb, 0xfa, 0xb6, 0x0a, 0x92, 0x27,
	0xd4, 0x47, 0x9d, 0x14, 0x49, 0x1a, 0x4c, 0x5d, 0x23, 0x50, 0xc7, 0x53, 0x99, 0x4c, 0xc9, 0xb1,
	0x68, 0xf0, 0xd5, 0x02, 0xc5, 0xd5, 0xb3, 0x6d, 0x44, 0xd8, 0x7f, 0x53, 0x07, 0x78, 0xa8, 0xbc,
	0xa3, 0x7d, 0x37, 0x9e, 0x88, 0x14, 0x5d, 0x8e, 0x5c, 0x91, 0xcd, 0x41, 0xeb, 0xa4, 0x5a, 0x7d,
	0xd9, 0x26, 0x5c, 0xca, 0x65, 0xe0, 0xa9, 0x90, 0xdc, 0x1f, 0xad, 0x89, 0x86, 0x8f, 0xcc, 0x60,
	0xb5, 0xe7, 0x4b, 0x6a, 0xc8, 0xde, 0x2f, 0xe5, 0x86, 0x63, 0xd2, 0x93, 0x88, 0xce, 0xde, 0xa2,
	0xfb, 0x6e, 0xa9, 0x1c, 0xbe, 0x7f, 0x12, 0xb1, 0xb7, 0xe1, 0x62, 0x2c, 0xc6, 0xb1, 0x48, 0x0e,
	0x9d, 0x34, 0xa9, 0x7e, 0xac, 0x49, 0x1f, 0x5b, 0x35, 0xc8, 0xfd, 0xa4, 0xf8, 0xd6, 0xdb, 0x70,
	0x71, 0x1c, 0x84, 0xa9, 0x88, 0xe7, 0x97, 0xa7, 0x8f, 0xed, 0xaa, 0x46, 0x56, 0x57, 0xf7, 0x0a,
	0x50, 0x98, 0xa5, 0x8f, 0xa2, 0xe1, 0x64, 0x37, 0x24, 0x66, 0x1c, 0x84, 0x02, 0x6f, 0x96, 0xed,
	0x43, 0xf4, 0x6a, 0xef, 0x8b, 0xb1, 0xf1, 0xcc, 0x4a, 0x00, 0xb3, 0xa1, 0xf9, 0x48, 0xf9, 0xfa,
	0xce, 0x5c, 0xde, 0x5c, 0xde, 0xa0, 0x80, 0x0d, 0x39, 0x89, 0x50, 0x4e, 0x38, 0x7b, 0x07, 0xda,
	0x08, 0x79, 0x1c, 0xb1, 0x0d, 0xe8, 0xa4, 0xc4, 0xe1, 0xc4, 0x18, 0xcd, 0x0b, 0xe5, 0xd9, 0x29,
	0xd9, 0xcf, 0x73, 0x22, 0xd4, 0x8d, 0x03, 0x9c, 0xd1, 0x58, 0x32, 0xdd, 0xb1, 0x39, 0xac, 0x14,
	0xea, 0xf9, 0x44, 0x06, 0x4f, 0x33, 0xc1, 0x3e, 0x84, 0xd5, 0x28, 0x16, 0x4e, 0x40, 0x30, 0x27,
	0x3b, 0x72, 0xbc, 0x54, 0x87, 0x22, 0xf4, 0x09, 0xe4, 0x71, 0x39, 0xe2, 0x68, 0x3b, 0x3d, 0xe6,
	0xcb, 0xd1, 0x4c, 0xdf, 0xfe, 0x14, 0x2e, 0x17, 0x14, 0x7b, 0xc2, 0x53, 0xd2, 0x77, 0xe3, 0x13,
	0xb2, 0x24, 0x73, 0x73, 0x27, 0x5f, 0x67, 0xee, 0x3d, 0x9a, 0xfb, 0xe7, 0x0d, 0x58, 0x7e, 0x2c,
	0xef, 0x67, 0x51, 0x18, 0xe0, 0xe9, 0xfe, 0x58, 0x1f, 0x3e, 0xad, 0xf4, 0xb5, 0xaa, 0xd2, 0xaf,
	0xc3, 0xc0, 0x7c, 0x05, 0x65, 0xa7, 0x55, 0xd6, 0x84, 0x60, 0x1a, 0xbe, 0xad, 0x42, 0xd2, 0x57,
	0xf6, 0x01, 0x5c, 0xcc, 0x68, 0xe7, 0x9a, 0x12, 0x83, 0x41, 0xe7, 0x05, 0xde, 0x1f, 0xd3, 0x84,
	0x38, 0x14, 0xc9, 0xc8, 0x29, 0xbd, 0x0e, 0xbd, 0x72, 0x78, 0x7e, 0xf2, 0xa0, 0x20, 0xa4, 0x95,
	0x28, 0xe9, 0xf8, 0xf9, 0x92, 0x8d, 0xdd, 0xc7, 0x33, 0xbb, 0xac, 0xca, 0x9d, 0xa0, 0xf5, 0xff,
	0x6d, 0x58, 0x9d, 0xa1, 0xa4, 0x55, 0x68, 0x37, 0xed, 0x4e, 0x29, 0xdc, 0xd9, 0xed, 0x57, 0xbb,
	0xb8, 0x1e, 0x6d, 0x23, 0x57, 0xd4, 0x2c, 0xd4, 0x9c, 0xf0, 0x60, 0x22, 0x55, 0x2c, 0x8c, 0xe6,
	0x59, 0x41, 0x32, 0xa2, 0xfe, 0x95, 0x1d, 0xb8, 0xb0, 0x68, 0x96, 0x05, 0x86, 0x6e, 0xad, 0x6a,
	0xe8, 0xe6, 0xbc, 0xd0, 0xd2, 0xe8, 0xfd, 0x0e, 0xf4, 0x3e, 0xca, 0x9e, 0x3f, 0x3f, 0xf9, 0x88,
	0xce, 0x07, 0xeb, 0x43, 0x6d, 0x87, 0x26, 0xa9, 0xf3, 0xda, 0x0e, 0xfa, 0xce, 0xbb, 0x47, 0x68,
	0xec, 0x68, 0x8e, 0x2e, 0x37, 0x3d, 0x74, 0x5f, 0x77, 0x8f, 0xf6, 0xcf, 0x38, 0xce, 0x1a, 0x6d,
	0xff, 0x43, 0x1d, 0x9a, 0xbf, 0xa9, 0x02, 0xa9, 0x63, 0x99, 0xd0, 0x09, 0x75, 0xf4, 0x81, 0xfc,
	0xec, 0xc4, 0x22, 0x7c, 0x88, 0xfe, 0xfb, 0x4b, 0x60, 0xa1, 0x2c, 0x43, 0xed, 0xd7, 0x13, 0xca,
	0x53, 0x1a, 0x55, 0xba, 0xf6, 0xb5, 0x85, 0xae, 0x7d, 0xe1, 0x45, 0x37, 0xbf, 0xcc, 0x8b, 0xee,
	0x86, 0x62, 0x8c, 0xda, 0x25, 0xfd, 0x59, 0x8f, 0x9b, 0x26, 0xb3, 0x10, 0xb9, 0xad, 0xa4, 0xcf,
	0xde, 0x00, 0x88, 0x83, 0xc9, 0xa1, 0xa1, 0x6c, 0x9f, 0x8e, 0x86, 0x08, 0x4b, 0xa4, 0x1c, 0x5e,
	0x8a, 0x33, 0x99, 0x06, 0x53, 0xe1, 0x18, 0xbb, 0x73, 0x90, 0x05, 0xa1, 0xaf, 0xf7, 0x51, 0x38,
	0xe0, 0x38, 0x92, 0x6b, 0x32, 0xcd, 0xe0, 0xbd, 0x48, 0x78, 0xfc, 0x52, 0x5c, 0x05, 0xdd, 0xc3,
	0x71, 0xb4, 0xdf, 0xab, 0x80, 0x86, 0xfe, 0xd0, 0x51, 0xd2, 0x89, 0xf2, 0x98, 0xcf, 0x42, 0xc8,
	0x63, 0xb9, 0x7b, 0x84, 0xf6, 0x0a, 0x03, 0x45, 0xe3, 0xac, 0x77, 0xe7, 0x9c, 0x75, 0xfb, 0xdf,
	0x6b, 0x60, 0x6d, 0xc9, 0x34, 0x20, 0x7e, 0x5f, 0x82, 0x76, 0x4c, 0xce, 0xb4, 0xe1, 0xb6, 0xe9,
	0x15, 0x1c, 0xad, 0x7f, 0x19, 0x47, 0x1b, 0x5f, 0x83, 0xa3, 0xcd, 0xaf, 0xcc, 0xd1, 0xd6, 0x59,
	0x1c, 0x9d, 0xdd, 0x7d, 0xfb, 0xcc, 0xdd, 0x77, 0xe6, 0x77, 0xff, 0x8f, 0x75, 0xb0, 0x1e, 0x8a,
	0x71, 0xfa, 0x83, 0xb6, 0x7d, 0x3f, 0xda, 0xf6, 0x27, 0x0d, 0xe8, 0x72, 0x5c, 0xde, 0x7f, 0x23,
	0xc3, 0xef, 0x02, 0x10, 0x23, 0xcf, 0xe6, 0x3a, 0x31, 0x9b, 0x62, 0x46, 0xf6, 0x0e, 0xf4, 0x34,
	0x43, 0xcf, 0x8e, 0xad, 0x35, 0xd7, 0xf7, 0x4f, 0x0b, 0xab, 0xfd, 0x95, 0x85, 0xd5, 0xf9, 0xc6,
	0xc2, 0xb2, 0xbe, 0x0b, 0x61, 0x75, 0xcf, 0x14, 0x16, 0xcc, 0x0b, 0xeb, 0x97, 0x75, 0x58, 0x22,
	0x61, 0xed, 0x89, 0xe9, 0xb7, 0xb3, 0x0f, 0x73, 0x1c, 0x6e, 0x7c, 0x5d, 0x0e, 0x7f, 0x47, 0xa6,
	0xe2, 0x4c, 0x0e, 0xb7, 0xbf, 0x0b, 0x0e, 0x77, 0xce, 0xe4, 0xb0, 0xf5, 0x42, 0x0e, 0x7f, 0x6b,
	0x0b, 0xfc, 0x03, 0x87, 0x17, 0x73, 0xf8, 0xaf, 0xea, 0x60, 0x7d, 0x6b, 0xf5, 0xfd, 0x9f, 0xbc,
	0xde, 0xfe, 0xd7, 0x71, 0xf4, 0x9f, 0xea, 0x00, 0x7b, 0x81, 0x9c, 0x84, 0xe2, 0x87, 0x4b, 0xf3,
	0xfb, 0xb9, 0x34, 0x7f, 0x56, 0x07, 0xeb, 0x91, 0x1b, 0x1f, 0xfd, 0x9f, 0xd5, 0xe1, 0x57, 0xa1,
	0xa3, 0x64, 0x55, 0x63, 0xab, 0x74, 0x6d, 0x25, 0xbf, 0xbd, 0x52, 0xfe, 0x7e, 0x0d, 0x3a, 0xbb,
	0xb1, 0xf2, 0x33, 0x2f, 0xfd, 0x86, 0x1a, 0xf9, 0x55, 0xf9, 0x33, 0xbb, 0x90, 0xe6, 0xfc, 0x42,
	0xfe, 0xa8, 0x06, 0x5d, 0x8a, 0x83, 0xcf, 0x14, 0x56, 0xf1, 0xb1, 0xfa, 0xd9, 0x1f, 0x3b, 0x53,
	0x15, 0x1b, 0xdf, 0x48, 0x15, 0xed, 0x9f, 0xd6, 0x60, 0x89, 0x9e, 0x2a, 0x3e, 0xca, 0xa4, 0x47,
	0x6f, 0xa5, 0x8b, 0xa3, 0xeb, 0x35, 0x68, 0xc6, 0x22, 0xcd, 0x97, 0xd8, 0xd7, 0x9f, 0xd9, 0x56,
	0xe1, 0x7d, 0x31, 0xe6, 0x84, 0x41, 0x95, 0x73, 0xe3, 0x49, 0xb2, 0x28, 0x85, 0x82, 0x70, 0xdc,
	0x7d, 0xe4, 0xc6, 0xee, 0x34, 0xc9, 0x53, 0x28, 0xba, 0xc7, 0x18, 0x34, 0xe9, 0x6d, 0xac, 0x45,
	0xc1, 0x21, 0xb5, 0xed, 0xbf, 0xac, 0x43, 0xf7, 0x37, 0xdc, 0xe4, 0x90, 0xd6, 0x59, 0xa6, 0x56,
	0x50, 0xa3, 0xab, 0xa9, 0x15, 0x13, 0xe7, 0x12, 0x12, 0x75, 0xc3, 0xbc, 0x74, 0x10, 0x12, 0x87,
	0x57, 0xf3, 0x2e, 0x8d, 0x17, 0xe6, 0x5d, 0x9a, 0xb3, 0x79, 0x97, 0xaf, 0x9a, 0x55, 0x59, 0x83,
	0x16, 0xea, 0x7a, 0xb2, 0x40, 0x89, 0x35, 0xe2, 0x4b, 0x74, 0xf8, 0x36, 0xac, 0xd2, 0xc2, 0xa7,
	0x22, 0x9e, 0x08, 0xbf, 0xf2, 0x1c, 0x6b, 0xf1, 0x15, 0x44, 0x50, 0x6e, 0xce, 0xd7, 0x0f, 0xb1,
	0x6f, 0x01, 0x23, 0x5a, 0x37, 0x0c, 0x15, 0x3d, 0x14, 0x24, 0x22, 0x4c, 0x8c, 0x69, 0x18, 0x20,
	0x66, 0xcb, 0x20, 0xf6, 0x44, 0x98, 0xd8, 0x5b, 0x70, 0xf1, 0xc1, 0x71, 0x2a, 0x62, 0xe9, 0x86,
	0x18, 0x68, 0x6f, 0x6e, 0xab, 0x50, 0x3f, 0xc6, 0xe4, 0xac, 0xae, 0x95, 0xac, 0x46, 0x71, 0x57,
	0xd3, 0xd5, 0xba, 0x63, 0xdf, 0x84, 0xde, 0x38, 0x08, 0x85, 0xa3, 0xc6, 0xe3, 0x44, 0xa4, 0x28,
	0x3b, 0xdd, 0x22, 0xa5, 0x68, 0x70, 0xd3, 0xb3, 0xff, 0xb3, 0x0e, 0xfd, 0xfc, 0x53, 0x7b, 0x9e,
	0xfb, 0x22, 0xe5, 0x79, 0x19, 0xba, 0x34, 0x5b, 0x12, 0x3c, 0x17, 0xa4, 0x41, 0x0d, 0x6e, 0x21,
	0x80, 0x72, 0x3f, 0x5b, 0xb0, 0x5a, 0xf9, 0x94, 0x93, 0xaa, 0xd4, 0x0d, 0x8d, 0x12, 0x55, 0xb2,
	0x02, 0x15, 0x12, 0xbe, 0x82, 0x9d, 0xc7, 0xd4, 0xde, 0x47, 0x6a, 0x54, 0xce, 0xe2, 0x29, 0xe6,
	0x94, 0x72, 0x22, 0x86, 0xfd, 0x04, 0x56, 0x70, 0xb7, 0x9b, 0xfa, 0x5d, 0x8f, 0xf6, 0xab, 0xc5,
	0x7b, 0xbd, 0xfc, 0xc4, 0x42, 0x9e, 0xf1, 0x25, 0x39, 0xc3, 0xc2, 0x57, 0x00, 0xbc, 0x58, 0x90,
	0x08, 0x9e, 0x86, 0x14, 0x5f, 0x76, 0x79, 0x57, 0x43, 0xf6, 0x9e, 0x86, 0xc5, 0x4e, 0x8b, 0xdb,
	0xa1, 0xab, 0x77, 0x4a, 0x46, 0xe5, 0x0e, 0xf4, 0x54, 0x1c, 0x4c, 0x02, 0xa9, 0x1f, 0x8e, 0xac,
	0x05, 0xab, 0x05, 0x4d, 0x40, 0xcf, 0x48, 0x36, 0xb4, 0xf5, 0x31, 0x37, 0x0f, 0xf0, 0x33, 0x66,
	0x52, 0x63, 0x6c, 0x0f, 0x60, 0x2f, 0x8d, 0x85, 0x3b, 0x25, 0xee, 0xbf, 0x0e, 0x9d, 0xf4, 0x20,
	0xa4, 0xa7, 0xe4, 0xda, 0xc2, 0xa7, 0xe4, 0x76, 0x7a, 0x80, 0x9f, 0xa9, 0xc8, 0xb3, 0x4e, 0x8f,
	0xba, 0xa6, 0x87, 0xe2, 0x0b, 0x83, 0x69, 0x90, 0x9a, 0x02, 0x02, 0xdd, 0xb1, 0xff, 0xa3, 0x06,
	0xb0, 0xe7, 0x4e, 0x23, 0x6d, 0x24, 0xd8, 0x8f, 0xa1, 0x97, 0x50, 0x4f, 0x67, 0xa3, 0x75, 0x1d,
	0x49, 0x85, 0x8f, 0x25, 0xa9, 0x69, 0xe2, 0xd9, 0xe1, 0x90, 0x14, 0x6d, 0x7a, 0x15, 0xd7, 0x33,
	0x50, 0xba, 0x40, 0x6b, 0x9e, 0x21, 0xa0, 0x4c, 0xc1, 0x4d, 0x58, 0x36, 0x04, 0x91, 0x88, 0x3d,
	0x21, 0xf5, 0x82, 0x6a, 0x7c, 0x49, 0x43, 0x77, 0x35, 0x90, 0xbd, 0x53, 0x90, 0x79, 0x2a, 0xcc,
	0xa6, 0x72, 0x51, 0xae, 0xd4, 0x0c, 0xd9, 0xd6, 0x04, 0xf6, 0x66, 0xbe, 0x15, 0x5a, 0x88, 0x05,
	0x4d, 0xfc, 0xde, 0xe0, 0x1c, 0xeb, 0x41, 0xc7, 0xcc, 0x3a, 0xa8, 0xb1, 0x25, 0xe8, 0xd2, 0xe9,
	0x23, 0x5c, 0xdd, 0xfe, 0xf9, 0x0a, 0xf4, 0x46, 0x32, 0x49, 0xe3, 0x4c, 0x5b, 0xc8, 0x32, 0xa1,
	0xdc, 0xa2, 0x84, 0xb2, 0x79, 0x96, 0xd7, 0xdb, 0xa0, 0x67, 0xf9, 0x5b, 0xd0, 0x74, 0x65, 0x1a,
	0x18, 0x87, 0xa6, 0x52, 0x4c, 0x90, 0x7b, 0xf6, 0x9c, 0xf0, 0xec, 0x0e, 0x74, 0x4c, 0xe5, 0x81,
	0x49, 0x19, 0x2e, 0x2c, 0x5b, 0xc8, 0x69, 0xd8, 0x06, 0x58, 0xbe, 0x29, 0x89, 0x20, 0x73, 0x39,
	0x33, 0x75, 0x5e, 0x2c, 0xc1, 0x0b, 0x1a, 0x76, 0x03, 0x1a, 0xee, 0x64, 0x42, 0x5a, 0x4a, 0xf9,
	0x9b, 0x9c, 0x94, 0x32, 0xd6, 0x1c, 0x71, 0xec, 0xae, 0xb9, 0xe0, 0x3f, 0x53, 0x81, 0x24, 0xeb,
	0x33, 0x33, 0x67, 0xfe, 0x18, 0xa2, 0x2f, 0x7a, 0xba, 0xc4, 0xee, 0x42, 0x37, 0x11, 0xd3, 0x40,
	0x0f, 0xe8, 0xce, 0x0f, 0xc8, 0x9d, 0x6b, 0x6e, 0x25, 0xb9, 0x9b, 0xfd, 0x1e, 0xf4, 0x12, 0x72,
	0x10, 0xf5, 0x10, 0xc8, 0xdf, 0x7e, 0x8b, 0x21, 0x85, 0xf7, 0xc8, 0x21, 0x29, 0x3d, 0xc9, 0xbb,
	0xd0, 0x9d, 0xba, 0xf1, 0x91, 0x1e, 0xd4, 0x9b, 0xff, 0x4e, 0xee, 0x00, 0x71, 0x6b, 0x9a, 0xbb,
	0x42, 0x36, 0x34, 0x89, 0xb6, 0x9f, 0x6b, 0x7e, 0x4e, 0xab, 0xf9, 0x8d, 0x38, 0xf6, 0x26, 0x74,
	0x22, 0xed, 0x17, 0x50, 0x6e, 0xa8, 0xb7, 0xb9, 0x5a, 0x92, 0x19, 0x87, 0x81, 0xe7, 0x14, 0xec,
	0xd7, 0x61, 0x59, 0xe7, 0x31, 0xc6, 0xe6, 0x6a, 0xa4, 0x7c, 0xd1, 0x4c, 0x4a, 0x7c, 0xe6, 0xe6,
	0xe4, 0x4b, 0xe9, 0xcc, 0x45, 0xba, 0x69, 0xcc, 0x3f, 0x5d, 0xd2, 0xc3, 0x95, 0x79, 0xf9, 0x16,
	0xf7, 0x1b, 0xef, 0x1e, 0x16, 0x57, 0xdd, 0x8f, 0x60, 0x49, 0x18, 0x33, 0xe4, 0x24, 0x9e, 0x2b,
	0x87, 0x03, 0x1a, 0x76, 0xe9, 0xb4, 0x95, 0xc2, 0x03, 0xcf, 0xfb, 0xa2, 0x6a, 0x7c, 0xd7, 0xa1,
	0xad, 0x5f, 0xba, 0x87, 0xab, 0x34, 0xaa, 0x52, 0xb7, 0xa5, 0x5f, 0xd4, 0xb9, 0xc1, 0xb3, 0x7b,
	0x73, 0x2f, 0xd4, 0x47, 0xe2, 0x64, 0xc8, 0x68, 0xcc, 0xf0, 0x45, 0xcf, 0xce, 0x33, 0x6f, 0xd7,
	0x1f, 0x8b, 0x13, 0xdc, 0x5e, 0xf9, 0xb2, 0x3f, 0x3c, 0x3f, 0xbf, 0xbd, 0xe2, 0x59, 0x9f, 0x77,
	0x8b, 0x17, 0x7d, 0xf6, 0x60, 0x36, 0xd3, 0x40, 0x4f, 0xe6, 0xc3, 0x0b, 0x34, 0xf4, 0xa5, 0x05,
	0x43, 0x75, 0x7e, 0x82, 0xaf, 0x44, 0x73, 0x09, 0x8b, 0xb7, 0xc0, 0x52, 0xb1, 0x8f, 0xfe, 0xcf,
	0xc9, 0xf0, 0x22, 0x9d, 0xf8, 0x55, 0x93, 0x9c, 0xd4, 0xb5, 0x23, 0xe4, 0xf1, 0x74, 0x94, 0xee,
	0xb0, 0x3b, 0xd0, 0x8f, 0x62, 0xf5, 0x99, 0xf0, 0x52, 0x6d, 0x96, 0x2f, 0x9d, 0xae, 0x39, 0x31,
	0x78, 0xb2, 0xd2, 0xa5, 0xd9, 0xbd, 0xfc, 0x22, 0xb3, 0x8b, 0x77, 0xbf, 0xb6, 0x93, 0xc3, 0xd3,
	0xaf, 0xe2, 0x84, 0xc0, 0x59, 0x8c, 0x85, 0x7d, 0xe9, 0xf4, 0x2c, 0xc6, 0xda, 0xa2, 0x77, 0x92,
	0x7c, 0x14, 0xc4, 0x49, 0x3a, 0xbc, 0xa2, 0x4b, 0x73, 0x4c, 0x17, 0xed, 0x73, 0x90, 0x3c, 0x74,
	0x93, 0x74, 0xf8, 0x72, 0x5e, 0xcd, 0x83, 0x3d, 0xe4, 0xb9, 0xf6, 0xb2, 0x49, 0xd3, 0xaf, 0xce,
	0xf3, 0xbc, 0x78, 0x4b, 0x33, 0xee, 0x36, 0x9d, 0x8b, 0x0f, 0x61, 0x45, 0x8f, 0x29, 0x8f, 0xed,
	0x2b, 0xf3, 0x7a, 0x3c, 0xf3, 0xae, 0xc3, 0x97, 0xe2, 0x99, 0x67, 0x9e, 0x62, 0x02, 0x34, 0x59,
	0x7a, 0x82, 0x6b, 0x0b, 0x27, 0x28, 0x8c, 0x9b, 0x9e, 0xa0, 0x78, 0xc5, 0xb8, 0x0d, 0x6d, 0x5f,
	0xe7, 0xd4, 0xaf, 0x9f, 0x32, 0x5a, 0x26, 0xe7, 0xcb, 0x0d, 0x05, 0x7b, 0x03, 0x3a, 0x94, 0x4f,
	0x53, 0xd1, 0x70, 0x6d, 0x5e, 0x89, 0x75, 0x1e, 0x8c, 0xb7, 0x43, 0x9d, 0x0f, 0x7b, 0x13, 0x3a,
	0xb9, 0xe3, 0x7d, 0x63, 0xfe, 0x30, 0x1b, 0x07, 0x9c, 0xe7, 0x14, 0xec, 0x26, 0xb4, 0xc8, 0xd1,
	0x1a, 0xda, 0xf3, 0xc6, 0x50, 0x5b, 0x7a, 0x8d, 0x25, 0x63, 0x45, 0xf7, 0xa9, 0x3e, 0x7d, 0xaf,
	0x9e, 0x32, 0x56, 0xc5, 0x65, 0xcb, 0x21, 0x29, 0x2f, 0xde, 0xdf, 0x85, 0x2b, 0xd5, 0x2c, 0x57,
	0x9e, 0x02, 0x33, 0x9e, 0xc6, 0x6b, 0x34, 0xcb, 0x8d, 0x05, 0x0a, 0x3e, 0x9b, 0x2c, 0xe3, 0x97,
	0xa3, 0x17, 0x64, 0xd1, 0xde, 0x2b, 0x2e, 0x4c, 0xb4, 0x45, 0xc3, 0x9b, 0xa7, 0x96, 0x55, 0x5c,
	0xb9, 0xf9, 0x35, 0x4a, 0x37, 0xf5, 0xfb, 0xd0, 0x1f, 0x67, 0xcf, 0x9f, 0x9f, 0x98, 0x70, 0x61,
	0x78, 0x8b, 0xc6, 0x55, 0xbc, 0xaa, 0x4a, 0xd2, 0x86, 0xf7, 0xc6, 0x95, 0x0c, 0xce, 0x65, 0xe8,
	0x78, 0xd2, 0x71, 0x7d, 0x3f, 0x1e, 0xbe, 0xae, 0x93, 0x36, 0x9e, 0xdc, 0xf2, 0x7d, 0x4a, 0x7e,
	0xa9, 0x48, 0x50, 0xfd, 0x95, 0x13, 0xf8, 0xc3, 0x75, 0x7d, 0x75, 0xe7, 0xa0, 0x91, 0x4f, 0x95,
	0x92, 0x6e, 0xec, 0x86, 0xa1, 0x08, 0x91, 0xe0, 0x0d, 0x53, 0x29, 0x69, 0x40, 0x23, 0x9f, 0xdd,
	0x80, 0xfe, 0xd4, 0x3d, 0x76, 0x72, 0xc8, 0xf0, 0xb6, 0xae, 0x66, 0x9b, 0xba, 0xc7, 0xbb, 0x06,
	0x84, 0x6a, 0xae, 0xcb, 0x14, 0x48, 0xd9, 0xde, 0x9c, 0x57, 0xf3, 0x22, 0xa2, 0xe2, 0xdd, 0x20,
	0x6f, 0xda, 0xef, 0x41, 0x7f, 0x8b, 0x4a, 0x46, 0x83, 0x84, 0x8e, 0xf1, 0x4d, 0x68, 0x16, 0x31,
	0x5f, 0x61, 0x1f, 0x88, 0xe2, 0xb9, 0x18, 0xc9, 0xb1, 0xe2, 0x84, 0xb6, 0x7f, 0xda, 0x80, 0xf6,
	0x9e, 0xca, 0x62, 0x4f, 0x7c, 0x79, 0xae, 0xfe, 0x15, 0x80, 0xb2, 0xe2, 0xc2, 0x24, 0xb3, 0x74,
	0xf6, 0x9e, 0xd0, 0xd5, 0x70, 0xb2, 0x41, 0xae, 0x5f, 0x11, 0x4e, 0x16, 0xa9, 0x58, 0x5d, 0xc3,
	0xa6, 0x3b, 0xc4, 0xaa, 0x2c, 0x39, 0xf4, 0xd5, 0x33, 0x89, 0xac, 0x6a, 0x51, 0x1c, 0x02, 0x39,
	0x68, 0xe4, 0x53, 0xc1, 0x4e, 0x4e, 0x40, 0xb2, 0xd0, 0xfe, 0x66, 0x3f, 0x07, 0x92, 0x44, 0xf2,
	0x50, 0xbf, 0xf3, 0x82, 0x50, 0xff, 0x36, 0x14, 0x05, 0x04, 0xe6, 0x82, 0x7f, 0x71, 0x81, 0xc1,
	0x26, 0x74, 0x8b, 0x2a, 0x62, 0x73, 0xb9, 0x5f, 0xd8, 0x28, 0xeb, 0x8a, 0xf7, 0xf3, 0x16, 0x2f,
	0xc9, 0x16, 0x44, 0xa5, 0x51, 0xac, 0x0e, 0x8c, 0x0b, 0x0c, 0x5f, 0x27, 0x2a, 0xdd, 0xc5, 0x71,
	0x14, 0x95, 0x46, 0x60, 0xed, 0x28, 0x9f, 0xe4, 0x84, 0x41, 0xcb, 0xd4, 0x8b, 0x32, 0xe3, 0x6f,
	0x51, 0xdb, 0x14, 0x05, 0x6b, 0x09, 0x98, 0xa2, 0x60, 0xe2, 0x4f, 0x43, 0x07, 0x36, 0xd8, 0x46,
	0xeb, 0x1a, 0xb9, 0x27, 0xa1, 0x72, 0x7d, 0xc3, 0xf5, 0xbc, 0x8b, 0xd4, 0xe4, 0xb9, 0xb6, 0xa8,
	0x50, 0x87, 0xda, 0xf6, 0x9f, 0xd6, 0x60, 0x75, 0x37, 0x56, 0x9e, 0x48, 0x92, 0x87, 0x68, 0xc0,
	0x5d, 0xba, 0xc2, 0x19, 0x34, 0x29, 0x66, 0xd1, 0xc5, 0x83, 0xd4, 0x46, 0x2d, 0xd0, 0xc5, 0xc6,
	0x85, 0xef, 0xda, 0xe0, 0xba, 0xfc, 0x98, 0x5c, 0xd7, 0x02, 0x4d, 0x03, 0x1b, 0x15, 0x34, 0x45,
	0x3b, 0x37, 0x61, 0xb9, 0xac, 0xc5, 0xa1, 0x19, 0x4c, 0x15, 0x6e, 0x01, 0xa5, 0x59, 0xae, 0x43,
	0x2f, 0x16, 0x2e, 0x5e, 0x71, 0x34, 0x4d, 0x8b, 0x68, 0x40, 0x83, 0x70, 0x1e, 0xfb, 0x0f, 0xeb,
	0xd0, 0x33, 0xeb, 0x25, 0x2e, 0x69, 0x8e, 0xd4, 0x0a, 0x8e, 0x0c, 0xa0, 0x81, 0x01, 0x8a, 0x66,
	0x11, 0x36, 0xd9, 0x1d, 0x68, 0x84, 0xc1, 0xd4, 0xb8, 0xa4, 0x2f, 0xcf, 0xf8, 0x3d, 0xb3, 0xbb,
	0xe6, 0x48, 0x87, 0x91, 0x4c, 0x26, 0x83, 0x63, 0x07, 0xc5, 0x63, 0xd6, 0x68, 0x21, 0x00, 0x75,
	0x00, 0x37, 0xe9, 0x7a, 0x94, 0x62, 0xcf, 0x15, 0x77, 0x89, 0x77, 0x0d, 0x64, 0xe4, 0x53, 0x41,
	0xa9, 0x74, 0xa3, 0xe4, 0x50, 0xa5, 0x46, 0x65, 0x8b, 0x3e, 0xda, 0xa4, 0x44, 0x24, 0x89, 0x2e,
	0x45, 0x1a, 0x2b, 0xa3, 0xb6, 0x17, 0xab, 0x2e, 0x24, 0x61, 0xe9, 0x8c, 0xf6, 0x92, 0xb2, 0x83,
	0x41, 0xb0, 0x6b, 0x4e, 0xb8, 0x23, 0x95, 0x2f, 0xca, 0x54, 0x48, 0x8b, 0x0f, 0x72, 0x0c, 0xaa,
	0x0d, 0xa9, 0xd0, 0xbf, 0xd5, 0xa0, 0x57, 0x99, 0x8a, 0xea, 0xc6, 0x13, 0x11, 0xe7, 0xb1, 0x2f,
	0xb6, 0x11, 0x76, 0xa8, 0x4c, 0x25, 0x68, 0x97, 0x53, 0x1b, 0x61, 0xb1, 0x0a, 0x45, 0xae, 0x4a,
	0xd8, 0xc6, 0x73, 0x68, 0x5c, 0x70, 0x5d, 0x39, 0x67, 0x9e, 0x0c, 0xfa, 0x25, 0x50, 0x6f, 0xda,
	0x77, 0x53, 0xf7, 0xc0, 0x4d, 0xf2, 0xb7, 0x8c, 0xa2, 0x8f, 0xba, 0xf8, 0xb9, 0x88, 0x71, 0x2d,
	0x86, 0x1f, 0x79, 0x17, 0xd9, 0x4c, 0x47, 0xe7, 0xb9, 0x92, 0x3a, 0x21, 0xd9, 0xe7, 0x16, 0x02,
	0x3e, 0x55, 0x92, 0x86, 0x19, 0xa6, 0xd2, 0xc9, 0xed, 0xf2, 0xbc, 0x8b, 0xb6, 0xe6, 0x69, 0x26,
	0xf0, 0x86, 0xf1, 0x87, 0x5d, 0x6d, 0x6b, 0xa8, 0x3f, 0xf2, 0xed, 0x3f, 0x6f, 0x81, 0xb5, 0x6b,
	0x98, 0xc9, 0xee, 0xc3, 0x52, 0x51, 0xb7, 0xbe, 0x38, 0x5a, 0xdb, 0x9d, 0x6f, 0x50, 0xb4, 0xd6,
	0x8f, 0x2a, 0xbd, 0xf9, 0xea, 0xf7, 0xfa, 0xa9, 0xea, 0xf7, 0xab, 0xd0, 0x78, 0x1a, 0x9f, 0xcc,
	0xbe, 0xdf, 0xee, 0x86, 0xae, 0xe4, 0x08, 0x66, 0xef, 0x40, 0x0f, 0x39, 0xe1, 0x24, 0x64, 0x67,
	0x4d, 0xa4, 0x53, 0xfd, 0xf1, 0x80, 0xe0, 0x1c, 0x90, 0xc8, 0xd8, 0xe2, 0x0d, 0xb0, 0xbc, 0xc3,
	0x20, 0xf4, 0x63, 0x21, 0x4d, 0xa0, 0xce, 0x4e, 0x2f, 0x99, 0x17, 0x34, 0xec, 0xc7, 0x54, 0xfc,
	0x91, 0x47, 0x68, 0xd5, 0xc7, 0xc5, 0x8b, 0x33, 0x4e, 0x70, 0x4e, 0xc1, 0x57, 0x2a, 0xe4, 0x64,
	0xa2, 0xcb, 0xaa, 0xb1, 0x4e, 0xb5, 0x6a, 0x4c, 0x17, 0x56, 0x17, 0xd1, 0x11, 0xb9, 0x62, 0xe4,
	0xd4, 0x68, 0x04, 0x99, 0x97, 0x6e, 0xe1, 0xa3, 0xa1, 0x75, 0xb9, 0x05, 0x4d, 0xd4, 0x4e, 0x13,
	0xe8, 0x54, 0x96, 0x9d, 0x5b, 0x34, 0x4e, 0x78, 0xfa, 0x31, 0x22, 0x4b, 0x0e, 0x1d, 0x6d, 0xfe,
	0xf1, 0x28, 0xf4, 0x4c, 0x39, 0x66, 0x96, 0x1c, 0xde, 0xc7, 0x0b, 0x00, 0xd5, 0xf6, 0x26, 0x2c,
	0xe7, 0x9b, 0x34, 0x35, 0x2d, 0x7d, 0x5d, 0xb4, 0x96, 0x43, 0x75, 0x49, 0xcb, 0x87, 0x30, 0xc8,
	0xb2, 0xc0, 0x4f, 0x9c, 0x54, 0xe5, 0x85, 0xe5, 0xc3, 0x25, 0xda, 0x7f, 0x25, 0x74, 0x78, 0x92,
	0x05, 0xfe, 0xbe, 0x32, 0xa5, 0xe5, 0x4b, 0x44, 0x9f, 0x77, 0xe9, 0x17, 0x0a, 0x7a, 0x4c, 0x2c,
	0xeb, 0xe2, 0x2c, 0x02, 0x20, 0x12, 0x6f, 0x46, 0x53, 0x80, 0xee, 0xc9, 0x94, 0x42, 0x19, 0x8c,
	0xd7, 0xcd, 0x7f, 0x03, 0x32, 0xb5, 0x3f, 0x84, 0x7e, 0x55, 0x7d, 0x58, 0xd7, 0x94, 0x96, 0x0f,
	0xce, 0x31, 0x80, 0xf6, 0x8e, 0x8a, 0xa7, 0x6e, 0x38, 0xa8, 0x61, 0x5b, 0x97, 0x53, 0x0e, 0xea,
	0xac, 0x0f, 0x56, 0x7e, 0xdf, 0x0f, 0x1a, 0xf6, 0x8f, 0xc0, 0xca, 0xeb, 0xec, 0xe9, 0x45, 0x0f,
	0x8f, 0x37, 0x59, 0x74, 0x7d, 0x5c, 0x2d, 0x04, 0xd0, 0x6d, 0x97, 0xff, 0xfe, 0x51, 0x2f, 0x7f,
	0xff, 0xb0, 0x7f, 0x0b, 0xfa, 0xd5, 0xad, 0xe5, 0xf1, 0x78, 0xad, 0x8c, 0xc7, 0x17, 0x8c, 0xa2,
	0xa7, 0x9a, 0x58, 0x4d, 0x9d, 0xca, 0xc5, 0x61, 0x21, 0x00, 0x3f, 0x73, 0xfb, 0xf7, 0xa0, 0xad,
	0x7f, 0x75, 0x61, 0xab, 0xb0, 0xf4, 0x44, 0x1e, 0x49, 0xf5, 0x4c, 0x6a, 0xc0, 0xe0, 0x1c, 0x3b,
	0x0f, 0x2b, 0xf9, 0x6e, 0xcd, 0x3f, 0x35, 0x83, 0x1a, 0x1b, 0x40, 0x9f, 0xde, 0xea, 0x72, 0x48,
	0x9d, 0x5d, 0x85, 0xe1, 0x6e, 0x2c, 0x22, 0x37, 0x16, 0xf7, 0x95, 0x14, 0x3b, 0x2a, 0x0d, 0xc6,
	0x27, 0x39, 0xb6, 0x71, 0xfb, 0x23, 0x68, 0xeb, 0x1f, 0x6e, 0x2a, 0x5f, 0xd0, 0x80, 0xc1, 0x39,
	0xb6, 0x02, 0xbd, 0x4f, 0xdc, 0x20, 0x0d, 0xe4, 0x64, 0x47, 0x1c, 0xa7, 0x83, 0x1a, 0xb3, 0xa0,
	0x89, 0x01, 0xc0, 0xa0, 0xce, 0x96, 0x01, 0xcc, 0x24, 0x0f, 0xa4, 0x3f, 0x68, 0xdc, 0xdb, 0xfe,
	0xc5, 0x17, 0xd7, 0x6a, 0x7f, 0xfd, 0xc5, 0xb5, 0xda, 0xdf, 0x7d, 0x71, 0xed, 0xdc, 0xcf, 0xfe,
	0xfe, 0x5a, 0xed, 0xd3, 0x77, 0x2a, 0xff, 0x10, 0x4d, 0xdd, 0x34, 0x0e, 0x8e, 0xf5, 0xa3, 0x52,
	0xde, 0x91, 0xe2, 0x6e, 0x74, 0x34, 0xb9, 0x1b, 0x1d, 0xdc, 0xcd, 0x35, 0xe3, 0xa0, 0x4d, 0x7f,
	0x09, 0xbd, 0xfb, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x73, 0x08, 0xdf, 0x95, 0x99, 0x34, 0x00,
	0x00,
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Sequence != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x58
	}
	if m.Checksum != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Checksum))
		i--
		dAtA[i] = 0x50
	}
	if m.BatchCnt != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.BatchCnt))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x42
	}
	if m.Id != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Analyse) > 0 {
		i -= len(m.Analyse)
		copy(dAtA[i:], m.Analyse)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Analyse)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ProcInfoData) > 0 {
		i -= len(m.ProcInfoData)
		copy(dAtA[i:], m.ProcInfoData)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.ProcInfoData)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Err) > 0 {
		i -= len(m.Err)
		copy(dAtA[i:], m.Err)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Err)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Cmd != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x10
	}
	if m.Sid != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Sid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Connector) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Connector) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Connector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ConnectorIndex != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ConnectorIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.PipelineId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PipelineId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Shuffle) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Shuffle) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Shuffle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ShuffleRangesInt64) > 0 {
		dAtA2 := make([]byte, len(m.ShuffleRangesInt64)*10)
		var j1 int
		for _, num1 := range m.ShuffleRangesInt64 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintPipeline(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ShuffleRangesUint64) > 0 {
		dAtA4 := make([]byte, len(m.ShuffleRangesUint64)*10)
		var j3 int
		for _, num := range m.ShuffleRangesUint64 {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintPipeline(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x32
	}
	if m.AliveRegCnt != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.AliveRegCnt))
		i--
		dAtA[i] = 0x28
	}
	if m.ShuffleColMax != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ShuffleColMax))
		i--
		dAtA[i] = 0x20
	}
	if m.ShuffleColMin != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ShuffleColMin))
		i--
		dAtA[i] = 0x18
	}
	if m.ShuffleType != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ShuffleType))
		i--
		dAtA[i] = 0x10
	}
	if m.ShuffleColIdx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ShuffleColIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Dispatch) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dispatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dispatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RecSink {
		i--
		if m.RecSink {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.IsSink {
		i--
		if m.IsSink {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.ShuffleType != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ShuffleType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ShuffleRegIdxRemote) > 0 {
		dAtA6 := make([]byte, len(m.ShuffleRegIdxRemote)*10)
		var j5 int
		for _, num1 := range m.ShuffleRegIdxRemote {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintPipeline(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ShuffleRegIdxLocal) > 0 {
		dAtA8 := make([]byte, len(m.ShuffleRegIdxLocal)*10)
		var j7 int
		for _, num1 := range m.ShuffleRegIdxLocal {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintPipeline(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RemoteConnector) > 0 {
		for iNdEx := len(m.RemoteConnector) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RemoteConnector[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.LocalConnector) > 0 {
		for iNdEx := len(m.LocalConnector) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LocalConnector[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.FuncId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.FuncId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Merge) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Merge) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Merge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SinkScan {
		i--
		if m.SinkScan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MultiArguemnt) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiArguemnt) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiArguemnt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OrderId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.OrderId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Separator) > 0 {
		i -= len(m.Separator)
		copy(dAtA[i:], m.Separator)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Separator)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OrderByExpr) > 0 {
		for iNdEx := len(m.OrderByExpr) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OrderByExpr[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.GroupExpr) > 0 {
		for iNdEx := len(m.GroupExpr) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GroupExpr[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Dist {
		i--
		if m.Dist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Aggregate) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Aggregate) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Aggregate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Config) > 0 {
		i -= len(m.Config)
		copy(dAtA[i:], m.Config)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Config)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Expr) > 0 {
		for iNdEx := len(m.Expr) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Expr[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Dist {
		i--
		if m.Dist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Op != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Group) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Group) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Group) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PartialResults) > 0 {
		i -= len(m.PartialResults)
		copy(dAtA[i:], m.PartialResults)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.PartialResults)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.PartialResultTypes) > 0 {
		dAtA10 := make([]byte, len(m.PartialResultTypes)*10)
		var j9 int
		for _, num := range m.PartialResultTypes {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintPipeline(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x52
	}
	if m.PreAllocSize != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PreAllocSize))
		i--
		dAtA[i] = 0x48
	}
	if m.IsShuffle {
		i--
		if m.IsShuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.MultiAggs) > 0 {
		for iNdEx := len(m.MultiAggs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MultiAggs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Aggs) > 0 {
		for iNdEx := len(m.Aggs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Aggs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Exprs) > 0 {
		for iNdEx := len(m.Exprs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Exprs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Nbucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Nbucket))
		i--
		dAtA[i] = 0x18
	}
	if m.Ibucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Ibucket))
		i--
		dAtA[i] = 0x10
	}
	if m.NeedEval {
		i--
		if m.NeedEval {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Insert) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Insert) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Insert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.IsEnd {
		i--
		if m.IsEnd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.PartitionIdx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PartitionIdx))
		i--
		dAtA[i] = 0x40
	}
	if len(m.PartitionTableNames) > 0 {
		for iNdEx := len(m.PartitionTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionTableNames[iNdEx])
			copy(dAtA[i:], m.PartitionTableNames[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.PartitionTableNames[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.PartitionTableIds) > 0 {
		dAtA13 := make([]byte, len(m.PartitionTableIds)*10)
		var j12 int
		for _, num := range m.PartitionTableIds {
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintPipeline(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Attrs) > 0 {
		for iNdEx := len(m.Attrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Attrs[iNdEx])
			copy(dAtA[i:], m.Attrs[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.Attrs[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Ref != nil {
		{
			size, err := m.Ref.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.AddAffectedRows {
		i--
		if m.AddAffectedRows {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ToWriteS3 {
		i--
		if m.ToWriteS3 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Affected != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Affected))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Array) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Array) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Array) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Array) > 0 {
		dAtA16 := make([]byte, len(m.Array)*10)
		var j15 int
		for _, num1 := range m.Array {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		i -= j15
		copy(dAtA[i:], dAtA16[:j15])
		i = encodeVarintPipeline(dAtA, i, uint64(j15))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Map) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Map) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Map) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Mp) > 0 {
		for k := range m.Mp {
			v := m.Mp[k]
			baseI := i
			i = encodeVarintPipeline(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPipeline(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPipeline(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Deletion) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deletion) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Deletion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PrimaryKeyIdx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PrimaryKeyIdx))
		i--
		dAtA[i] = 0x70
	}
	if m.IsEnd {
		i--
		if m.IsEnd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.CanTruncate {
		i--
		if m.CanTruncate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if len(m.SegmentMap) > 0 {
		for k := range m.SegmentMap {
			v := m.SegmentMap[k]
			baseI := i
			i = encodeVarintPipeline(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPipeline(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPipeline(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.AddAffectedRows {
		i--
		if m.AddAffectedRows {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Ref != nil {
		{
			size, err := m.Ref.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.PartitionIndexInBatch != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PartitionIndexInBatch))
		i--
		dAtA[i] = 0x40
	}
	if len(m.PartitionTableNames) > 0 {
		for iNdEx := len(m.PartitionTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionTableNames[iNdEx])
			copy(dAtA[i:], m.PartitionTableNames[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.PartitionTableNames[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.PartitionTableIds) > 0 {
		dAtA19 := make([]byte, len(m.PartitionTableIds)*10)
		var j18 int
		for _, num := range m.PartitionTableIds {
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		i -= j18
		copy(dAtA[i:], dAtA19[:j18])
		i = encodeVarintPipeline(dAtA, i, uint64(j18))
		i--
		dAtA[i] = 0x32
	}
	if m.RowIdIdx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.RowIdIdx))
		i--
		dAtA[i] = 0x28
	}
	if m.NBucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.NBucket))
		i--
		dAtA[i] = 0x20
	}
	if m.IBucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.IBucket))
		i--
		dAtA[i] = 0x18
	}
	if m.RemoteDelete {
		i--
		if m.RemoteDelete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.AffectedRows != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.AffectedRows))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PreInsert) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreInsert) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PreInsert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EstimatedRowCount != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.EstimatedRowCount))
		i--
		dAtA[i] = 0x38
	}
	if m.IsUpdate {
		i--
		if m.IsUpdate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.HasAutoCol {
		i--
		if m.HasAutoCol {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Attrs) > 0 {
		for iNdEx := len(m.Attrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Attrs[iNdEx])
			copy(dAtA[i:], m.Attrs[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.Attrs[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Idx) > 0 {
		dAtA21 := make([]byte, len(m.Idx)*10)
		var j20 int
		for _, num1 := range m.Idx {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		i -= j20
		copy(dAtA[i:], dAtA21[:j20])
		i = encodeVarintPipeline(dAtA, i, uint64(j20))
		i--
		dAtA[i] = 0x1a
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.SchemaName) > 0 {
		i -= len(m.SchemaName)
		copy(dAtA[i:], m.SchemaName)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.SchemaName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LockTarget) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mode != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x40
	}
	if m.ChangeDef {
		i--
		if m.ChangeDef {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.LockTable {
		i--
		if m.LockTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.FilterColIdxInBat != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.FilterColIdxInBat))
		i--
		dAtA[i] = 0x28
	}
	if m.RefreshTsIdxInBat != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.RefreshTsIdxInBat))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.PrimaryColTyp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPipeline(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.PrimaryColIdxInBat != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PrimaryColIdxInBat))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LockOp) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Block {
		i--
		if m.Block {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Targets) > 0 {
		for iNdEx := len(m.Targets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Targets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PreInsertUnique) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreInsertUnique) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PreInsertUnique) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PreInsertUkCtx != nil {
		{
			size, err := m.PreInsertUkCtx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PreInsertSecondaryIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreInsertSecondaryIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PreInsertSecondaryIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PreInsertSkCtx != nil {
		{
			size, err := m.PreInsertSkCtx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OnDuplicateKey) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnDuplicateKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OnDuplicateKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsIgnore {
		i--
		if m.IsIgnore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.OnDuplicateExpr) > 0 {
		for k := range m.OnDuplicateExpr {
			v := m.OnDuplicateExpr[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPipeline(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPipeline(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPipeline(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.OnDuplicateIdx) > 0 {
		dAtA28 := make([]byte, len(m.OnDuplicateIdx)*10)
		var j27 int
		for _, num1 := range m.OnDuplicateIdx {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA28[j27] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j27++
			}
			dAtA28[j27] = uint8(num)
			j27++
		}
		i -= j27
		copy(dAtA[i:], dAtA28[:j27])
		i = encodeVarintPipeline(dAtA, i, uint64(j27))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.UniqueCols) > 0 {
		for iNdEx := len(m.UniqueCols) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UniqueCols[iNdEx])
			copy(dAtA[i:], m.UniqueCols[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.UniqueCols[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.UniqueColCheckExpr) > 0 {
		for iNdEx := len(m.UniqueColCheckExpr) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UniqueColCheckExpr[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.InsertColCount != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.InsertColCount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Attrs) > 0 {
		for iNdEx := len(m.Attrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Attrs[iNdEx])
			copy(dAtA[i:], m.Attrs[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.Attrs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FuzzyFilter) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FuzzyFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FuzzyFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.PkTyp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPipeline(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.PkName) > 0 {
		i -= len(m.PkName)
		copy(dAtA[i:], m.PkName)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.PkName)))
		i--
		dAtA[i] = 0x12
	}
	if m.N != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.N))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *Join) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Join) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Join) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsShuffle {
		i--
		if m.IsShuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.HashOnPk {
		i--
		if m.HashOnPk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for iNdEx := len(m.RuntimeFilterBuildList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterBuildList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ColList) > 0 {
		dAtA32 := make([]byte, len(m.ColList)*10)
		var j31 int
		for _, num1 := range m.ColList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA32[j31] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j31++
			}
			dAtA32[j31] = uint8(num)
			j31++
		}
		i -= j31
		copy(dAtA[i:], dAtA32[:j31])
		i = encodeVarintPipeline(dAtA, i, uint64(j31))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RelList) > 0 {
		dAtA34 := make([]byte, len(m.RelList)*10)
		var j33 int
		for _, num1 := range m.RelList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA34[j33] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j33++
			}
			dAtA34[j33] = uint8(num)
			j33++
		}
		i -= j33
		copy(dAtA[i:], dAtA34[:j33])
		i = encodeVarintPipeline(dAtA, i, uint64(j33))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AntiJoin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AntiJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AntiJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsShuffle {
		i--
		if m.IsShuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.HashOnPk {
		i--
		if m.HashOnPk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Result) > 0 {
		dAtA37 := make([]byte, len(m.Result)*10)
		var j36 int
		for _, num1 := range m.Result {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA37[j36] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j36++
			}
			dAtA37[j36] = uint8(num)
			j36++
		}
		i -= j36
		copy(dAtA[i:], dAtA37[:j36])
		i = encodeVarintPipeline(dAtA, i, uint64(j36))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LeftJoin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeftJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeftJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsShuffle {
		i--
		if m.IsShuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.HashOnPk {
		i--
		if m.HashOnPk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for iNdEx := len(m.RuntimeFilterBuildList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterBuildList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ColList) > 0 {
		dAtA40 := make([]byte, len(m.ColList)*10)
		var j39 int
		for _, num1 := range m.ColList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA40[j39] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j39++
			}
			dAtA40[j39] = uint8(num)
			j39++
		}
		i -= j39
		copy(dAtA[i:], dAtA40[:j39])
		i = encodeVarintPipeline(dAtA, i, uint64(j39))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RelList) > 0 {
		dAtA42 := make([]byte, len(m.RelList)*10)
		var j41 int
		for _, num1 := range m.RelList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA42[j41] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j41++
			}
			dAtA42[j41] = uint8(num)
			j41++
		}
		i -= j41
		copy(dAtA[i:], dAtA42[:j41])
		i = encodeVarintPipeline(dAtA, i, uint64(j41))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RightJoin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RightJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RightJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsShuffle {
		i--
		if m.IsShuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.HashOnPk {
		i--
		if m.HashOnPk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for iNdEx := len(m.RuntimeFilterBuildList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterBuildList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.RightTypes) > 0 {
		for iNdEx := len(m.RightTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.LeftTypes) > 0 {
		for iNdEx := len(m.LeftTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ColList) > 0 {
		dAtA45 := make([]byte, len(m.ColList)*10)
		var j44 int
		for _, num1 := range m.ColList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA45[j44] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j44++
			}
			dAtA45[j44] = uint8(num)
			j44++
		}
		i -= j44
		copy(dAtA[i:], dAtA45[:j44])
		i = encodeVarintPipeline(dAtA, i, uint64(j44))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RelList) > 0 {
		dAtA47 := make([]byte, len(m.RelList)*10)
		var j46 int
		for _, num1 := range m.RelList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA47[j46] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j46++
			}
			dAtA47[j46] = uint8(num)
			j46++
		}
		i -= j46
		copy(dAtA[i:], dAtA47[:j46])
		i = encodeVarintPipeline(dAtA, i, uint64(j46))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RightSemiJoin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RightSemiJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RightSemiJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsShuffle {
		i--
		if m.IsShuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.HashOnPk {
		i--
		if m.HashOnPk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for iNdEx := len(m.RuntimeFilterBuildList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterBuildList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.RightTypes) > 0 {
		for iNdEx := len(m.RightTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Result) > 0 {
		dAtA50 := make([]byte, len(m.Result)*10)
		var j49 int
		for _, num1 := range m.Result {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA50[j49] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j49++
			}
			dAtA50[j49] = uint8(num)
			j49++
		}
		i -= j49
		copy(dAtA[i:], dAtA50[:j49])
		i = encodeVarintPipeline(dAtA, i, uint64(j49))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RightAntiJoin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RightAntiJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RightAntiJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsShuffle {
		i--
		if m.IsShuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.HashOnPk {
		i--
		if m.HashOnPk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for iNdEx := len(m.RuntimeFilterBuildList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterBuildList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.RightTypes) > 0 {
		for iNdEx := len(m.RightTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Result) > 0 {
		dAtA53 := make([]byte, len(m.Result)*10)
		var j52 int
		for _, num1 := range m.Result {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA53[j52] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j52++
			}
			dAtA53[j52] = uint8(num)
			j52++
		}
		i -= j52
		copy(dAtA[i:], dAtA53[:j52])
		i = encodeVarintPipeline(dAtA, i, uint64(j52))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SemiJoin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SemiJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SemiJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsShuffle {
		i--
		if m.IsShuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.HashOnPk {
		i--
		if m.HashOnPk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for iNdEx := len(m.RuntimeFilterBuildList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterBuildList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Result) > 0 {
		dAtA56 := make([]byte, len(m.Result)*10)
		var j55 int
		for _, num1 := range m.Result {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA56[j55] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j55++
			}
			dAtA56[j55] = uint8(num)
			j55++
		}
		i -= j55
		copy(dAtA[i:], dAtA56[:j55])
		i = encodeVarintPipeline(dAtA, i, uint64(j55))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SingleJoin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SingleJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SingleJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsShuffle {
		i--
		if m.IsShuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.HashOnPk {
		i--
		if m.HashOnPk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for iNdEx := len(m.RuntimeFilterBuildList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterBuildList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ColList) > 0 {
		dAtA59 := make([]byte, len(m.ColList)*10)
		var j58 int
		for _, num1 := range m.ColList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA59[j58] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j58++
			}
			dAtA59[j58] = uint8(num)
			j58++
		}
		i -= j58
		copy(dAtA[i:], dAtA59[:j58])
		i = encodeVarintPipeline(dAtA, i, uint64(j58))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RelList) > 0 {
		dAtA61 := make([]byte, len(m.RelList)*10)
		var j60 int
		for _, num1 := range m.RelList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA61[j60] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j60++
			}
			dAtA61[j60] = uint8(num)
			j60++
		}
		i -= j60
		copy(dAtA[i:], dAtA61[:j60])
		i = encodeVarintPipeline(dAtA, i, uint64(j60))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarkJoin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarkJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsShuffle {
		i--
		if m.IsShuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.HashOnPk {
		i--
		if m.HashOnPk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.OnList) > 0 {
		for iNdEx := len(m.OnList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OnList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Result) > 0 {
		dAtA64 := make([]byte, len(m.Result)*10)
		var j63 int
		for _, num1 := range m.Result {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA64[j63] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j63++
			}
			dAtA64[j63] = uint8(num)
			j63++
		}
		i -= j63
		copy(dAtA[i:], dAtA64[:j63])
		i = encodeVarintPipeline(dAtA, i, uint64(j63))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Product) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Product) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Product) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsShuffle {
		i--
		if m.IsShuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ColList) > 0 {
		dAtA66 := make([]byte, len(m.ColList)*10)
		var j65 int
		for _, num1 := range m.ColList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA66[j65] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j65++
			}
			dAtA66[j65] = uint8(num)
			j65++
		}
		i -= j65
		copy(dAtA[i:], dAtA66[:j65])
		i = encodeVarintPipeline(dAtA, i, uint64(j65))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RelList) > 0 {
		dAtA68 := make([]byte, len(m.RelList)*10)
		var j67 int
		for _, num1 := range m.RelList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA68[j67] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j67++
			}
			dAtA68[j67] = uint8(num)
			j67++
		}
		i -= j67
		copy(dAtA[i:], dAtA68[:j67])
		i = encodeVarintPipeline(dAtA, i, uint64(j67))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IndexJoin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for iNdEx := len(m.RuntimeFilterBuildList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterBuildList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Result) > 0 {
		dAtA70 := make([]byte, len(m.Result)*10)
		var j69 int
		for _, num1 := range m.Result {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA70[j69] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j69++
			}
			dAtA70[j69] = uint8(num)
			j69++
		}
		i -= j69
		copy(dAtA[i:], dAtA70[:j69])
		i = encodeVarintPipeline(dAtA, i, uint64(j69))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableFunction) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableFunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableFunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Params) > 0 {
		i -= len(m.Params)
		copy(dAtA[i:], m.Params)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Params)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Args[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Rets) > 0 {
		for iNdEx := len(m.Rets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Attrs) > 0 {
		for iNdEx := len(m.Attrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Attrs[iNdEx])
			copy(dAtA[i:], m.Attrs[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.Attrs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *HashBuild) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HashBuild) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HashBuild) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NeedAllocateSels {
		i--
		if m.NeedAllocateSels {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.NeedMergedBatch {
		i--
		if m.NeedMergedBatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.HashOnPk {
		i--
		if m.HashOnPk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Conds) > 0 {
		for iNdEx := len(m.Conds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Nbucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Nbucket))
		i--
		dAtA[i] = 0x20
	}
	if m.Ibucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Ibucket))
		i--
		dAtA[i] = 0x18
	}
	if m.NeedHash {
		i--
		if m.NeedHash {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.NeedExpr {
		i--
		if m.NeedExpr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExternalName2ColIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalName2ColIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalName2ColIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Index != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileOffset) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileOffset) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileOffset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Offset) > 0 {
		dAtA72 := make([]byte, len(m.Offset)*10)
		var j71 int
		for _, num1 := range m.Offset {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA72[j71] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j71++
			}
			dAtA72[j71] = uint8(num)
			j71++
		}
		i -= j71
		copy(dAtA[i:], dAtA72[:j71])
		i = encodeVarintPipeline(dAtA, i, uint64(j71))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExternalScan) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalScan) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalScan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.OriginCols) > 0 {
		for iNdEx := len(m.OriginCols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OriginCols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.FileList) > 0 {
		for iNdEx := len(m.FileList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FileList[iNdEx])
			copy(dAtA[i:], m.FileList[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.FileList[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.CreateSql) > 0 {
		i -= len(m.CreateSql)
		copy(dAtA[i:], m.CreateSql)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.CreateSql)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Name2ColIndex) > 0 {
		for iNdEx := len(m.Name2ColIndex) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Name2ColIndex[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Cols) > 0 {
		for iNdEx := len(m.Cols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.FileOffsetTotal) > 0 {
		for iNdEx := len(m.FileOffsetTotal) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FileOffsetTotal[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.FileSize) > 0 {
		dAtA75 := make([]byte, len(m.FileSize)*10)
		var j74 int
		for _, num1 := range m.FileSize {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA75[j74] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j74++
			}
			dAtA75[j74] = uint8(num)
			j74++
		}
		i -= j74
		copy(dAtA[i:], dAtA75[:j74])
		i = encodeVarintPipeline(dAtA, i, uint64(j74))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Attrs) > 0 {
		for iNdEx := len(m.Attrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Attrs[iNdEx])
			copy(dAtA[i:], m.Attrs[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.Attrs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StreamScan) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamScan) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamScan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if m.Offset != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x10
	}
	if m.TblDef != nil {
		{
			size, err := m.TblDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SampleFunc) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SampleFunc) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SampleFunc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SampleColumns) > 0 {
		for iNdEx := len(m.SampleColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SampleColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.SamplePercent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SamplePercent))))
		i--
		dAtA[i] = 0x19
	}
	if m.SampleRows != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.SampleRows))
		i--
		dAtA[i] = 0x10
	}
	if m.SampleType != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.SampleType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Instruction) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Instruction) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Instruction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IndexJoin != nil {
		{
			size, err := m.IndexJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	if m.MaxParallel != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.MaxParallel))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.ParallelId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ParallelId))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.OperatorId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.OperatorId))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if len(m.CnAddr) > 0 {
		i -= len(m.CnAddr)
		copy(dAtA[i:], m.CnAddr)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.CnAddr)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if m.FuzzyFilter != nil {
		{
			size, err := m.FuzzyFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	if m.SampleFunc != nil {
		{
			size, err := m.SampleFunc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	if m.PreInsertSecondaryIndex != nil {
		{
			size, err := m.PreInsertSecondaryIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if m.StreamScan != nil {
		{
			size, err := m.StreamScan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.Merge != nil {
		{
			size, err := m.Merge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if m.Shuffle != nil {
		{
			size, err := m.Shuffle.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if m.LockOp != nil {
		{
			size, err := m.LockOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if m.Delete != nil {
		{
			size, err := m.Delete.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.RightAntiJoin != nil {
		{
			size, err := m.RightAntiJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.RightSemiJoin != nil {
		{
			size, err := m.RightSemiJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if m.RightJoin != nil {
		{
			size, err := m.RightJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.IsLast {
		i--
		if m.IsLast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.IsFirst {
		i--
		if m.IsFirst {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.Offset != nil {
		{
			size, err := m.Offset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.Limit != nil {
		{
			size, err := m.Limit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.ProjectList) > 0 {
		for iNdEx := len(m.ProjectList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProjectList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.OrderBy) > 0 {
		for iNdEx := len(m.OrderBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OrderBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if m.PreInsertUnique != nil {
		{
			size, err := m.PreInsertUnique.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.PreInsert != nil {
		{
			size, err := m.PreInsert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.OnDuplicateKey != nil {
		{
			size, err := m.OnDuplicateKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.Insert != nil {
		{
			size, err := m.Insert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.ExternalScan != nil {
		{
			size, err := m.ExternalScan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.HashBuild != nil {
		{
			size, err := m.HashBuild.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.TableFunction != nil {
		{
			size, err := m.TableFunction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Product != nil {
		{
			size, err := m.Product.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Join != nil {
		{
			size, err := m.Join.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.MarkJoin != nil {
		{
			size, err := m.MarkJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.SingleJoin != nil {
		{
			size, err := m.SingleJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.SemiJoin != nil {
		{
			size, err := m.SemiJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.LeftJoin != nil {
		{
			size, err := m.LeftJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Agg != nil {
		{
			size, err := m.Agg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Dispatch != nil {
		{
			size, err := m.Dispatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Connect != nil {
		{
			size, err := m.Connect.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Anti != nil {
		{
			size, err := m.Anti.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Idx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Idx))
		i--
		dAtA[i] = 0x10
	}
	if m.Op != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AnalysisList) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalysisList) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnalysisList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Source) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Source) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Source) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RuntimeFilterProbeList) > 0 {
		for iNdEx := len(m.RuntimeFilterProbeList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterProbeList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PushdownAddr) > 0 {
		i -= len(m.PushdownAddr)
		copy(dAtA[i:], m.PushdownAddr)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.PushdownAddr)))
		i--
		dAtA[i] = 0x32
	}
	if m.PushdownId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PushdownId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Block) > 0 {
		i -= len(m.Block)
		copy(dAtA[i:], m.Block)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Block)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ColList) > 0 {
		for iNdEx := len(m.ColList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ColList[iNdEx])
			copy(dAtA[i:], m.ColList[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.ColList[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SchemaName) > 0 {
		i -= len(m.SchemaName)
		copy(dAtA[i:], m.SchemaName)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.SchemaName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if m.Mcpu != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Mcpu))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProcessLimitation) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessLimitation) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessLimitation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReaderSize != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ReaderSize))
		i--
		dAtA[i] = 0x28
	}
	if m.PartitionRows != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PartitionRows))
		i--
		dAtA[i] = 0x20
	}
	if m.BatchSize != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.BatchSize))
		i--
		dAtA[i] = 0x18
	}
	if m.BatchRows != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.BatchRows))
		i--
		dAtA[i] = 0x10
	}
	if m.Size != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Size))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProcessInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AnalysisNodeList) > 0 {
		dAtA113 := make([]byte, len(m.AnalysisNodeList)*10)
		var j112 int
		for _, num1 := range m.AnalysisNodeList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA113[j112] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j112++
			}
			dAtA113[j112] = uint8(num)
			j112++
		}
		i -= j112
		copy(dAtA[i:], dAtA113[:j112])
		i = encodeVarintPipeline(dAtA, i, uint64(j112))
		i--
		dAtA[i] = 0x42
	}
	if m.SessionInfo != nil {
		{
			size, err := m.SessionInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Snapshot) > 0 {
		i -= len(m.Snapshot)
		copy(dAtA[i:], m.Snapshot)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Snapshot)))
		i--
		dAtA[i] = 0x32
	}
	if m.AccountId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.AccountId))
		i--
		dAtA[i] = 0x28
	}
	if m.UnixTime != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.UnixTime))
		i--
		dAtA[i] = 0x20
	}
	if m.Lim != nil {
		{
			size, err := m.Lim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sql) > 0 {
		i -= len(m.Sql)
		copy(dAtA[i:], m.Sql)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Sql)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SessionInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.QueryId) > 0 {
		for iNdEx := len(m.QueryId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.QueryId[iNdEx])
			copy(dAtA[i:], m.QueryId[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.QueryId[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.TimeZone) > 0 {
		i -= len(m.TimeZone)
		copy(dAtA[i:], m.TimeZone)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.TimeZone)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ConnectionId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ConnectionId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Pipeline) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pipeline) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pipeline) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ShuffleCnt != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ShuffleCnt))
		i--
		dAtA[i] = 0x78
	}
	if m.BuildIdx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.BuildIdx))
		i--
		dAtA[i] = 0x70
	}
	if len(m.UuidsToRegIdx) > 0 {
		for iNdEx := len(m.UuidsToRegIdx) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UuidsToRegIdx[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.ChildrenCount != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ChildrenCount))
		i--
		dAtA[i] = 0x60
	}
	if m.PushDownInfo != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PushDownInfo))
		i--
		dAtA[i] = 0x58
	}
	if m.Node != nil {
		{
			size, err := m.Node.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.IsLoad {
		i--
		if m.IsLoad {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.IsJoin {
		i--
		if m.IsJoin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.IsEnd {
		i--
		if m.IsEnd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.InstructionList) > 0 {
		for iNdEx := len(m.InstructionList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InstructionList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.DataSource != nil {
		{
			size, err := m.DataSource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Qry != nil {
		{
			size, err := m.Qry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PipelineId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PipelineId))
		i--
		dAtA[i] = 0x10
	}
	if m.PipelineType != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PipelineType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WrapNode) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WrapNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WrapNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeAddr) > 0 {
		i -= len(m.NodeAddr)
		copy(dAtA[i:], m.NodeAddr)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.NodeAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UuidToRegIdx) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UuidToRegIdx) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UuidToRegIdx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FromAddr) > 0 {
		i -= len(m.FromAddr)
		copy(dAtA[i:], m.FromAddr)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.FromAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x12
	}
	if m.Idx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Idx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintPipeline(dAtA []byte, offset int, v uint64) int {
	offset -= sovPipeline(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Message) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sid != 0 {
		n += 1 + sovPipeline(uint64(m.Sid))
	}
	if m.Cmd != 0 {
		n += 1 + sovPipeline(uint64(m.Cmd))
	}
	l = len(m.Err)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.ProcInfoData)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Analyse)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovPipeline(uint64(m.Id))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.BatchCnt != 0 {
		n += 1 + sovPipeline(uint64(m.BatchCnt))
	}
	if m.Checksum != 0 {
		n += 1 + sovPipeline(uint64(m.Checksum))
	}
	if m.Sequence != 0 {
		n += 1 + sovPipeline(uint64(m.Sequence))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Connector) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PipelineId != 0 {
		n += 1 + sovPipeline(uint64(m.PipelineId))
	}
	if m.ConnectorIndex != 0 {
		n += 1 + sovPipeline(uint64(m.ConnectorIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Shuffle) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShuffleColIdx != 0 {
		n += 1 + sovPipeline(uint64(m.ShuffleColIdx))
	}
	if m.ShuffleType != 0 {
		n += 1 + sovPipeline(uint64(m.ShuffleType))
	}
	if m.ShuffleColMin != 0 {
		n += 1 + sovPipeline(uint64(m.ShuffleColMin))
	}
	if m.ShuffleColMax != 0 {
		n += 1 + sovPipeline(uint64(m.ShuffleColMax))
	}
	if m.AliveRegCnt != 0 {
		n += 1 + sovPipeline(uint64(m.AliveRegCnt))
	}
	if len(m.ShuffleRangesUint64) > 0 {
		l = 0
		for _, e := range m.ShuffleRangesUint64 {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.ShuffleRangesInt64) > 0 {
		l = 0
		for _, e := range m.ShuffleRangesInt64 {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Dispatch) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FuncId != 0 {
		n += 1 + sovPipeline(uint64(m.FuncId))
	}
	if len(m.LocalConnector) > 0 {
		for _, e := range m.LocalConnector {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RemoteConnector) > 0 {
		for _, e := range m.RemoteConnector {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.ShuffleRegIdxLocal) > 0 {
		l = 0
		for _, e := range m.ShuffleRegIdxLocal {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.ShuffleRegIdxRemote) > 0 {
		l = 0
		for _, e := range m.ShuffleRegIdxRemote {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.ShuffleType != 0 {
		n += 1 + sovPipeline(uint64(m.ShuffleType))
	}
	if m.IsSink {
		n += 2
	}
	if m.RecSink {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Merge) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SinkScan {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MultiArguemnt) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dist {
		n += 2
	}
	if len(m.GroupExpr) > 0 {
		for _, e := range m.GroupExpr {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.OrderByExpr) > 0 {
		for _, e := range m.OrderByExpr {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	l = len(m.Separator)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.OrderId != 0 {
		n += 1 + sovPipeline(uint64(m.OrderId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Aggregate) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovPipeline(uint64(m.Op))
	}
	if m.Dist {
		n += 2
	}
	if len(m.Expr) > 0 {
		for _, e := range m.Expr {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	l = len(m.Config)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Group) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NeedEval {
		n += 2
	}
	if m.Ibucket != 0 {
		n += 1 + sovPipeline(uint64(m.Ibucket))
	}
	if m.Nbucket != 0 {
		n += 1 + sovPipeline(uint64(m.Nbucket))
	}
	if len(m.Exprs) > 0 {
		for _, e := range m.Exprs {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.Aggs) > 0 {
		for _, e := range m.Aggs {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.MultiAggs) > 0 {
		for _, e := range m.MultiAggs {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.IsShuffle {
		n += 2
	}
	if m.PreAllocSize != 0 {
		n += 1 + sovPipeline(uint64(m.PreAllocSize))
	}
	if len(m.PartialResultTypes) > 0 {
		l = 0
		for _, e := range m.PartialResultTypes {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	l = len(m.PartialResults)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Insert) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Affected != 0 {
		n += 1 + sovPipeline(uint64(m.Affected))
	}
	if m.ToWriteS3 {
		n += 2
	}
	if m.AddAffectedRows {
		n += 2
	}
	if m.Ref != nil {
		l = m.Ref.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Attrs) > 0 {
		for _, s := range m.Attrs {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.PartitionTableIds) > 0 {
		l = 0
		for _, e := range m.PartitionTableIds {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.PartitionTableNames) > 0 {
		for _, s := range m.PartitionTableNames {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.PartitionIdx != 0 {
		n += 1 + sovPipeline(uint64(m.PartitionIdx))
	}
	if m.IsEnd {
		n += 2
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Array) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Array) > 0 {
		l = 0
		for _, e := range m.Array {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Map) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Mp) > 0 {
		for k, v := range m.Mp {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPipeline(uint64(len(k))) + 1 + sovPipeline(uint64(v))
			n += mapEntrySize + 1 + sovPipeline(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Deletion) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AffectedRows != 0 {
		n += 1 + sovPipeline(uint64(m.AffectedRows))
	}
	if m.RemoteDelete {
		n += 2
	}
	if m.IBucket != 0 {
		n += 1 + sovPipeline(uint64(m.IBucket))
	}
	if m.NBucket != 0 {
		n += 1 + sovPipeline(uint64(m.NBucket))
	}
	if m.RowIdIdx != 0 {
		n += 1 + sovPipeline(uint64(m.RowIdIdx))
	}
	if len(m.PartitionTableIds) > 0 {
		l = 0
		for _, e := range m.PartitionTableIds {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.PartitionTableNames) > 0 {
		for _, s := range m.PartitionTableNames {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.PartitionIndexInBatch != 0 {
		n += 1 + sovPipeline(uint64(m.PartitionIndexInBatch))
	}
	if m.Ref != nil {
		l = m.Ref.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.AddAffectedRows {
		n += 2
	}
	if len(m.SegmentMap) > 0 {
		for k, v := range m.SegmentMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPipeline(uint64(len(k))) + 1 + sovPipeline(uint64(v))
			n += mapEntrySize + 1 + sovPipeline(uint64(mapEntrySize))
		}
	}
	if m.CanTruncate {
		n += 2
	}
	if m.IsEnd {
		n += 2
	}
	if m.PrimaryKeyIdx != 0 {
		n += 1 + sovPipeline(uint64(m.PrimaryKeyIdx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PreInsert) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SchemaName)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Idx) > 0 {
		l = 0
		for _, e := range m.Idx {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.Attrs) > 0 {
		for _, s := range m.Attrs {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.HasAutoCol {
		n += 2
	}
	if m.IsUpdate {
		n += 2
	}
	if m.EstimatedRowCount != 0 {
		n += 1 + sovPipeline(uint64(m.EstimatedRowCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LockTarget) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovPipeline(uint64(m.TableId))
	}
	if m.PrimaryColIdxInBat != 0 {
		n += 1 + sovPipeline(uint64(m.PrimaryColIdxInBat))
	}
	l = m.PrimaryColTyp.ProtoSize()
	n += 1 + l + sovPipeline(uint64(l))
	if m.RefreshTsIdxInBat != 0 {
		n += 1 + sovPipeline(uint64(m.RefreshTsIdxInBat))
	}
	if m.FilterColIdxInBat != 0 {
		n += 1 + sovPipeline(uint64(m.FilterColIdxInBat))
	}
	if m.LockTable {
		n += 2
	}
	if m.ChangeDef {
		n += 2
	}
	if m.Mode != 0 {
		n += 1 + sovPipeline(uint64(m.Mode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LockOp) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Targets) > 0 {
		for _, e := range m.Targets {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.Block {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PreInsertUnique) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PreInsertUkCtx != nil {
		l = m.PreInsertUkCtx.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PreInsertSecondaryIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PreInsertSkCtx != nil {
		l = m.PreInsertSkCtx.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OnDuplicateKey) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attrs) > 0 {
		for _, s := range m.Attrs {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.InsertColCount != 0 {
		n += 1 + sovPipeline(uint64(m.InsertColCount))
	}
	if len(m.UniqueColCheckExpr) > 0 {
		for _, e := range m.UniqueColCheckExpr {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.UniqueCols) > 0 {
		for _, s := range m.UniqueCols {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.OnDuplicateIdx) > 0 {
		l = 0
		for _, e := range m.OnDuplicateIdx {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.OnDuplicateExpr) > 0 {
		for k, v := range m.OnDuplicateExpr {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.ProtoSize()
				l += 1 + sovPipeline(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPipeline(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPipeline(uint64(mapEntrySize))
		}
	}
	if m.IsIgnore {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FuzzyFilter) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.N != 0 {
		n += 5
	}
	l = len(m.PkName)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = m.PkTyp.ProtoSize()
	n += 1 + l + sovPipeline(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Join) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RelList) > 0 {
		l = 0
		for _, e := range m.RelList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.ColList) > 0 {
		l = 0
		for _, e := range m.ColList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for _, e := range m.RuntimeFilterBuildList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.HashOnPk {
		n += 2
	}
	if m.IsShuffle {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AntiJoin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Result) > 0 {
		l = 0
		for _, e := range m.Result {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.HashOnPk {
		n += 2
	}
	if m.IsShuffle {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LeftJoin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RelList) > 0 {
		l = 0
		for _, e := range m.RelList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.ColList) > 0 {
		l = 0
		for _, e := range m.ColList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for _, e := range m.RuntimeFilterBuildList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.HashOnPk {
		n += 2
	}
	if m.IsShuffle {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RightJoin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RelList) > 0 {
		l = 0
		for _, e := range m.RelList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.ColList) > 0 {
		l = 0
		for _, e := range m.ColList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.LeftTypes) > 0 {
		for _, e := range m.LeftTypes {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightTypes) > 0 {
		for _, e := range m.RightTypes {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for _, e := range m.RuntimeFilterBuildList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.HashOnPk {
		n += 2
	}
	if m.IsShuffle {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RightSemiJoin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Result) > 0 {
		l = 0
		for _, e := range m.Result {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.RightTypes) > 0 {
		for _, e := range m.RightTypes {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for _, e := range m.RuntimeFilterBuildList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.HashOnPk {
		n += 2
	}
	if m.IsShuffle {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RightAntiJoin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Result) > 0 {
		l = 0
		for _, e := range m.Result {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.RightTypes) > 0 {
		for _, e := range m.RightTypes {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for _, e := range m.RuntimeFilterBuildList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.HashOnPk {
		n += 2
	}
	if m.IsShuffle {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SemiJoin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Result) > 0 {
		l = 0
		for _, e := range m.Result {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for _, e := range m.RuntimeFilterBuildList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.HashOnPk {
		n += 2
	}
	if m.IsShuffle {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SingleJoin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RelList) > 0 {
		l = 0
		for _, e := range m.RelList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.ColList) > 0 {
		l = 0
		for _, e := range m.ColList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for _, e := range m.RuntimeFilterBuildList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.HashOnPk {
		n += 2
	}
	if m.IsShuffle {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MarkJoin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Result) > 0 {
		l = 0
		for _, e := range m.Result {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.OnList) > 0 {
		for _, e := range m.OnList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.HashOnPk {
		n += 2
	}
	if m.IsShuffle {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Product) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RelList) > 0 {
		l = 0
		for _, e := range m.RelList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.ColList) > 0 {
		l = 0
		for _, e := range m.ColList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.IsShuffle {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IndexJoin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Result) > 0 {
		l = 0
		for _, e := range m.Result {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for _, e := range m.RuntimeFilterBuildList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableFunction) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attrs) > 0 {
		for _, s := range m.Attrs {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.Rets) > 0 {
		for _, e := range m.Rets {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.Args) > 0 {
		for _, e := range m.Args {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	l = len(m.Params)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HashBuild) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NeedExpr {
		n += 2
	}
	if m.NeedHash {
		n += 2
	}
	if m.Ibucket != 0 {
		n += 1 + sovPipeline(uint64(m.Ibucket))
	}
	if m.Nbucket != 0 {
		n += 1 + sovPipeline(uint64(m.Nbucket))
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.Conds) > 0 {
		for _, e := range m.Conds {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.HashOnPk {
		n += 2
	}
	if m.NeedMergedBatch {
		n += 2
	}
	if m.NeedAllocateSels {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExternalName2ColIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovPipeline(uint64(m.Index))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileOffset) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Offset) > 0 {
		l = 0
		for _, e := range m.Offset {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExternalScan) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attrs) > 0 {
		for _, s := range m.Attrs {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.FileSize) > 0 {
		l = 0
		for _, e := range m.FileSize {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.FileOffsetTotal) > 0 {
		for _, e := range m.FileOffsetTotal {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.Cols) > 0 {
		for _, e := range m.Cols {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.Name2ColIndex) > 0 {
		for _, e := range m.Name2ColIndex {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	l = len(m.CreateSql)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.FileList) > 0 {
		for _, s := range m.FileList {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.OriginCols) > 0 {
		for _, e := range m.OriginCols {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.Filter != nil {
		l = m.Filter.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamScan) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TblDef != nil {
		l = m.TblDef.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovPipeline(uint64(m.Offset))
	}
	if m.Limit != 0 {
		n += 1 + sovPipeline(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SampleFunc) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SampleType != 0 {
		n += 1 + sovPipeline(uint64(m.SampleType))
	}
	if m.SampleRows != 0 {
		n += 1 + sovPipeline(uint64(m.SampleRows))
	}
	if m.SamplePercent != 0 {
		n += 9
	}
	if len(m.SampleColumns) > 0 {
		for _, e := range m.SampleColumns {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Instruction) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovPipeline(uint64(m.Op))
	}
	if m.Idx != 0 {
		n += 1 + sovPipeline(uint64(m.Idx))
	}
	if m.Anti != nil {
		l = m.Anti.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Connect != nil {
		l = m.Connect.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Dispatch != nil {
		l = m.Dispatch.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Agg != nil {
		l = m.Agg.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.LeftJoin != nil {
		l = m.LeftJoin.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.SemiJoin != nil {
		l = m.SemiJoin.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.SingleJoin != nil {
		l = m.SingleJoin.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.MarkJoin != nil {
		l = m.MarkJoin.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Join != nil {
		l = m.Join.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Product != nil {
		l = m.Product.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.TableFunction != nil {
		l = m.TableFunction.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.HashBuild != nil {
		l = m.HashBuild.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.ExternalScan != nil {
		l = m.ExternalScan.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.Insert != nil {
		l = m.Insert.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.OnDuplicateKey != nil {
		l = m.OnDuplicateKey.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.PreInsert != nil {
		l = m.PreInsert.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.PreInsertUnique != nil {
		l = m.PreInsertUnique.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if len(m.OrderBy) > 0 {
		for _, e := range m.OrderBy {
			l = e.ProtoSize()
			n += 2 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.ProjectList) > 0 {
		for _, e := range m.ProjectList {
			l = e.ProtoSize()
			n += 2 + l + sovPipeline(uint64(l))
		}
	}
	if m.Filter != nil {
		l = m.Filter.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.Limit != nil {
		l = m.Limit.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.Offset != nil {
		l = m.Offset.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.IsFirst {
		n += 3
	}
	if m.IsLast {
		n += 3
	}
	if m.RightJoin != nil {
		l = m.RightJoin.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.RightSemiJoin != nil {
		l = m.RightSemiJoin.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.RightAntiJoin != nil {
		l = m.RightAntiJoin.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.Delete != nil {
		l = m.Delete.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.LockOp != nil {
		l = m.LockOp.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.Shuffle != nil {
		l = m.Shuffle.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.Merge != nil {
		l = m.Merge.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.StreamScan != nil {
		l = m.StreamScan.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.PreInsertSecondaryIndex != nil {
		l = m.PreInsertSecondaryIndex.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.SampleFunc != nil {
		l = m.SampleFunc.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.FuzzyFilter != nil {
		l = m.FuzzyFilter.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	l = len(m.CnAddr)
	if l > 0 {
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.OperatorId != 0 {
		n += 2 + sovPipeline(uint64(m.OperatorId))
	}
	if m.ParallelId != 0 {
		n += 2 + sovPipeline(uint64(m.ParallelId))
	}
	if m.MaxParallel != 0 {
		n += 2 + sovPipeline(uint64(m.MaxParallel))
	}
	if m.IndexJoin != nil {
		l = m.IndexJoin.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnalysisList) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Source) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SchemaName)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.ColList) > 0 {
		for _, s := range m.ColList {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	l = len(m.Block)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.PushdownId != 0 {
		n += 1 + sovPipeline(uint64(m.PushdownId))
	}
	l = len(m.PushdownAddr)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.RuntimeFilterProbeList) > 0 {
		for _, e := range m.RuntimeFilterProbeList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mcpu != 0 {
		n += 1 + sovPipeline(uint64(m.Mcpu))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovPipeline(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProcessLimitation) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Size != 0 {
		n += 1 + sovPipeline(uint64(m.Size))
	}
	if m.BatchRows != 0 {
		n += 1 + sovPipeline(uint64(m.BatchRows))
	}
	if m.BatchSize != 0 {
		n += 1 + sovPipeline(uint64(m.BatchSize))
	}
	if m.PartitionRows != 0 {
		n += 1 + sovPipeline(uint64(m.PartitionRows))
	}
	if m.ReaderSize != 0 {
		n += 1 + sovPipeline(uint64(m.ReaderSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProcessInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Sql)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Lim != nil {
		l = m.Lim.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.UnixTime != 0 {
		n += 1 + sovPipeline(uint64(m.UnixTime))
	}
	if m.AccountId != 0 {
		n += 1 + sovPipeline(uint64(m.AccountId))
	}
	l = len(m.Snapshot)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.SessionInfo != nil {
		l = m.SessionInfo.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.AnalysisNodeList) > 0 {
		l = 0
		for _, e := range m.AnalysisNodeList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.ConnectionId != 0 {
		n += 1 + sovPipeline(uint64(m.ConnectionId))
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.TimeZone)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.QueryId) > 0 {
		for _, s := range m.QueryId {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Pipeline) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PipelineType != 0 {
		n += 1 + sovPipeline(uint64(m.PipelineType))
	}
	if m.PipelineId != 0 {
		n += 1 + sovPipeline(uint64(m.PipelineId))
	}
	if m.Qry != nil {
		l = m.Qry.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.DataSource != nil {
		l = m.DataSource.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.InstructionList) > 0 {
		for _, e := range m.InstructionList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.IsEnd {
		n += 2
	}
	if m.IsJoin {
		n += 2
	}
	if m.IsLoad {
		n += 2
	}
	if m.Node != nil {
		l = m.Node.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.PushDownInfo != 0 {
		n += 1 + sovPipeline(uint64(m.PushDownInfo))
	}
	if m.ChildrenCount != 0 {
		n += 1 + sovPipeline(uint64(m.ChildrenCount))
	}
	if len(m.UuidsToRegIdx) > 0 {
		for _, e := range m.UuidsToRegIdx {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.BuildIdx != 0 {
		n += 1 + sovPipeline(uint64(m.BuildIdx))
	}
	if m.ShuffleCnt != 0 {
		n += 1 + sovPipeline(uint64(m.ShuffleCnt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WrapNode) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeAddr)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UuidToRegIdx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Idx != 0 {
		n += 1 + sovPipeline(uint64(m.Idx))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.FromAddr)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPipeline(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPipeline(x uint64) (n int) {
	return sovPipeline(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= Method(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Err = append(m.Err[:0], dAtA[iNdEx:postIndex]...)
			if m.Err == nil {
				m.Err = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcInfoData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcInfoData = append(m.ProcInfoData[:0], dAtA[iNdEx:postIndex]...)
			if m.ProcInfoData == nil {
				m.ProcInfoData = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Analyse", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Analyse = append(m.Analyse[:0], dAtA[iNdEx:postIndex]...)
			if m.Analyse == nil {
				m.Analyse = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCnt", wireType)
			}
			m.BatchCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchCnt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Connector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Connector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Connector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineId", wireType)
			}
			m.PipelineId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PipelineId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorIndex", wireType)
			}
			m.ConnectorIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectorIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Shuffle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Shuffle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Shuffle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleColIdx", wireType)
			}
			m.ShuffleColIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleColIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleType", wireType)
			}
			m.ShuffleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleColMin", wireType)
			}
			m.ShuffleColMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleColMin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleColMax", wireType)
			}
			m.ShuffleColMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleColMax |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliveRegCnt", wireType)
			}
			m.AliveRegCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AliveRegCnt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ShuffleRangesUint64 = append(m.ShuffleRangesUint64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ShuffleRangesUint64) == 0 {
					m.ShuffleRangesUint64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ShuffleRangesUint64 = append(m.ShuffleRangesUint64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleRangesUint64", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ShuffleRangesInt64 = append(m.ShuffleRangesInt64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ShuffleRangesInt64) == 0 {
					m.ShuffleRangesInt64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ShuffleRangesInt64 = append(m.ShuffleRangesInt64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleRangesInt64", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dispatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dispatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dispatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuncId", wireType)
			}
			m.FuncId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FuncId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalConnector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalConnector = append(m.LocalConnector, &Connector{})
			if err := m.LocalConnector[len(m.LocalConnector)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteConnector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteConnector = append(m.RemoteConnector, &WrapNode{})
			if err := m.RemoteConnector[len(m.RemoteConnector)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ShuffleRegIdxLocal = append(m.ShuffleRegIdxLocal, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ShuffleRegIdxLocal) == 0 {
					m.ShuffleRegIdxLocal = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ShuffleRegIdxLocal = append(m.ShuffleRegIdxLocal, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleRegIdxLocal", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ShuffleRegIdxRemote = append(m.ShuffleRegIdxRemote, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ShuffleRegIdxRemote) == 0 {
					m.ShuffleRegIdxRemote = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ShuffleRegIdxRemote = append(m.ShuffleRegIdxRemote, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleRegIdxRemote", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleType", wireType)
			}
			m.ShuffleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSink", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSink = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecSink", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RecSink = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Merge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Merge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Merge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SinkScan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SinkScan = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiArguemnt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiArguemnt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiArguemnt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dist = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupExpr = append(m.GroupExpr, &plan.Expr{})
			if err := m.GroupExpr[len(m.GroupExpr)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderByExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderByExpr = append(m.OrderByExpr, &plan.Expr{})
			if err := m.OrderByExpr[len(m.OrderByExpr)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Separator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Separator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			m.OrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Aggregate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aggregate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aggregate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dist = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expr = append(m.Expr, &plan.Expr{})
			if err := m.Expr[len(m.Expr)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = append(m.Config[:0], dAtA[iNdEx:postIndex]...)
			if m.Config == nil {
				m.Config = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Group) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedEval", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedEval = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ibucket", wireType)
			}
			m.Ibucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ibucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nbucket", wireType)
			}
			m.Nbucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nbucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exprs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exprs = append(m.Exprs, &plan.Expr{})
			if err := m.Exprs[len(m.Exprs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aggs = append(m.Aggs, &Aggregate{})
			if err := m.Aggs[len(m.Aggs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiAggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultiAggs = append(m.MultiAggs, &MultiArguemnt{})
			if err := m.MultiAggs[len(m.MultiAggs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShuffle = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreAllocSize", wireType)
			}
			m.PreAllocSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreAllocSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartialResultTypes = append(m.PartialResultTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PartialResultTypes) == 0 {
					m.PartialResultTypes = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartialResultTypes = append(m.PartialResultTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialResultTypes", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialResults", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartialResults = append(m.PartialResults[:0], dAtA[iNdEx:postIndex]...)
			if m.PartialResults == nil {
				m.PartialResults = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Insert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Insert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Insert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Affected", wireType)
			}
			m.Affected = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Affected |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToWriteS3", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ToWriteS3 = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddAffectedRows", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddAffectedRows = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ref == nil {
				m.Ref = &plan.ObjectRef{}
			}
			if err := m.Ref.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attrs = append(m.Attrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartitionTableIds = append(m.PartitionTableIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PartitionTableIds) == 0 {
					m.PartitionTableIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartitionTableIds = append(m.PartitionTableIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableIds", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTableNames = append(m.PartitionTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionIdx", wireType)
			}
			m.PartitionIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEnd = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &plan.TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Array) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Array: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Array: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Array = append(m.Array, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Array) == 0 {
					m.Array = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Array = append(m.Array, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Array", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Map) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Map: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Map: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mp == nil {
				m.Mp = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPipeline
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPipeline
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPipeline(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPipeline
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Mp[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deletion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deletion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deletion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffectedRows", wireType)
			}
			m.AffectedRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AffectedRows |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteDelete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RemoteDelete = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IBucket", wireType)
			}
			m.IBucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IBucket |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NBucket", wireType)
			}
			m.NBucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NBucket |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowIdIdx", wireType)
			}
			m.RowIdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowIdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartitionTableIds = append(m.PartitionTableIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PartitionTableIds) == 0 {
					m.PartitionTableIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartitionTableIds = append(m.PartitionTableIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableIds", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTableNames = append(m.PartitionTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionIndexInBatch", wireType)
			}
			m.PartitionIndexInBatch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionIndexInBatch |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ref == nil {
				m.Ref = &plan.ObjectRef{}
			}
			if err := m.Ref.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddAffectedRows", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddAffectedRows = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SegmentMap == nil {
				m.SegmentMap = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPipeline
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPipeline
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPipeline(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPipeline
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SegmentMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanTruncate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanTruncate = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEnd = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKeyIdx", wireType)
			}
			m.PrimaryKeyIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryKeyIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreInsert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreInsert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreInsert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &plan.TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Idx = append(m.Idx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Idx) == 0 {
					m.Idx = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Idx = append(m.Idx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attrs = append(m.Attrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasAutoCol", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasAutoCol = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUpdate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUpdate = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedRowCount", wireType)
			}
			m.EstimatedRowCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EstimatedRowCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryColIdxInBat", wireType)
			}
			m.PrimaryColIdxInBat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryColIdxInBat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryColTyp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrimaryColTyp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshTsIdxInBat", wireType)
			}
			m.RefreshTsIdxInBat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefreshTsIdxInBat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterColIdxInBat", wireType)
			}
			m.FilterColIdxInBat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilterColIdxInBat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LockTable = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeDef", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChangeDef = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= lock.LockMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Targets = append(m.Targets, &LockTarget{})
			if err := m.Targets[len(m.Targets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Block = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreInsertUnique) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreInsertUnique: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreInsertUnique: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreInsertUkCtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreInsertUkCtx == nil {
				m.PreInsertUkCtx = &plan.PreInsertUkCtx{}
			}
			if err := m.PreInsertUkCtx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreInsertSecondaryIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreInsertSecondaryIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreInsertSecondaryIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreInsertSkCtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreInsertSkCtx == nil {
				m.PreInsertSkCtx = &plan.PreInsertUkCtx{}
			}
			if err := m.PreInsertSkCtx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnDuplicateKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnDuplicateKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnDuplicateKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attrs = append(m.Attrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertColCount", wireType)
			}
			m.InsertColCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InsertColCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueColCheckExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueColCheckExpr = append(m.UniqueColCheckExpr, &plan.Expr{})
			if err := m.UniqueColCheckExpr[len(m.UniqueColCheckExpr)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueCols", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueCols = append(m.UniqueCols, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OnDuplicateIdx = append(m.OnDuplicateIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OnDuplicateIdx) == 0 {
					m.OnDuplicateIdx = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OnDuplicateIdx = append(m.OnDuplicateIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDuplicateIdx", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDuplicateExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OnDuplicateExpr == nil {
				m.OnDuplicateExpr = make(map[string]*plan.Expr)
			}
			var mapkey string
			var mapvalue *plan.Expr
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPipeline
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPipeline
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPipeline
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPipeline
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &plan.Expr{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPipeline(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPipeline
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.OnDuplicateExpr[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsIgnore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsIgnore = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FuzzyFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FuzzyFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FuzzyFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.N = float32(math.Float32frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PkName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkTyp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PkTyp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Join) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Join: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Join: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelList = append(m.RelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelList) == 0 {
					m.RelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelList = append(m.RelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelList", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColList = append(m.ColList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColList) == 0 {
					m.ColList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColList = append(m.ColList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColList", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterBuildList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterBuildList = append(m.RuntimeFilterBuildList, &plan.RuntimeFilterSpec{})
			if err := m.RuntimeFilterBuildList[len(m.RuntimeFilterBuildList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOnPk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashOnPk = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShuffle = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AntiJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AntiJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AntiJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Result = append(m.Result, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Result) == 0 {
					m.Result = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Result = append(m.Result, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOnPk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashOnPk = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShuffle = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeftJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeftJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeftJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelList = append(m.RelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelList) == 0 {
					m.RelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelList = append(m.RelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelList", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColList = append(m.ColList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColList) == 0 {
					m.ColList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColList = append(m.ColList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColList", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterBuildList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterBuildList = append(m.RuntimeFilterBuildList, &plan.RuntimeFilterSpec{})
			if err := m.RuntimeFilterBuildList[len(m.RuntimeFilterBuildList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOnPk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashOnPk = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShuffle = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RightJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RightJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RightJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelList = append(m.RelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelList) == 0 {
					m.RelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelList = append(m.RelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelList", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColList = append(m.ColList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColList) == 0 {
					m.ColList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColList = append(m.ColList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColList", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftTypes = append(m.LeftTypes, plan.Type{})
			if err := m.LeftTypes[len(m.LeftTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightTypes = append(m.RightTypes, plan.Type{})
			if err := m.RightTypes[len(m.RightTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterBuildList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterBuildList = append(m.RuntimeFilterBuildList, &plan.RuntimeFilterSpec{})
			if err := m.RuntimeFilterBuildList[len(m.RuntimeFilterBuildList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOnPk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashOnPk = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShuffle = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RightSemiJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RightSemiJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RightSemiJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Result = append(m.Result, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Result) == 0 {
					m.Result = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Result = append(m.Result, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightTypes = append(m.RightTypes, plan.Type{})
			if err := m.RightTypes[len(m.RightTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterBuildList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterBuildList = append(m.RuntimeFilterBuildList, &plan.RuntimeFilterSpec{})
			if err := m.RuntimeFilterBuildList[len(m.RuntimeFilterBuildList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOnPk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashOnPk = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShuffle = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RightAntiJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RightAntiJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RightAntiJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Result = append(m.Result, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Result) == 0 {
					m.Result = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Result = append(m.Result, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightTypes = append(m.RightTypes, plan.Type{})
			if err := m.RightTypes[len(m.RightTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterBuildList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterBuildList = append(m.RuntimeFilterBuildList, &plan.RuntimeFilterSpec{})
			if err := m.RuntimeFilterBuildList[len(m.RuntimeFilterBuildList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOnPk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashOnPk = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShuffle = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SemiJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SemiJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SemiJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Result = append(m.Result, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Result) == 0 {
					m.Result = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Result = append(m.Result, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterBuildList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterBuildList = append(m.RuntimeFilterBuildList, &plan.RuntimeFilterSpec{})
			if err := m.RuntimeFilterBuildList[len(m.RuntimeFilterBuildList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOnPk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashOnPk = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShuffle = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SingleJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelList = append(m.RelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelList) == 0 {
					m.RelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelList = append(m.RelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelList", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColList = append(m.ColList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColList) == 0 {
					m.ColList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColList = append(m.ColList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColList", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterBuildList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterBuildList = append(m.RuntimeFilterBuildList, &plan.RuntimeFilterSpec{})
			if err := m.RuntimeFilterBuildList[len(m.RuntimeFilterBuildList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOnPk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashOnPk = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShuffle = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Result = append(m.Result, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Result) == 0 {
					m.Result = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Result = append(m.Result, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnList = append(m.OnList, &plan.Expr{})
			if err := m.OnList[len(m.OnList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOnPk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashOnPk = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShuffle = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Product) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Product: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Product: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelList = append(m.RelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelList) == 0 {
					m.RelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelList = append(m.RelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelList", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColList = append(m.ColList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColList) == 0 {
					m.ColList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColList = append(m.ColList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColList", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShuffle = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Result = append(m.Result, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Result) == 0 {
					m.Result = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Result = append(m.Result, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterBuildList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterBuildList = append(m.RuntimeFilterBuildList, &plan.RuntimeFilterSpec{})
			if err := m.RuntimeFilterBuildList[len(m.RuntimeFilterBuildList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableFunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableFunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableFunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attrs = append(m.Attrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rets = append(m.Rets, &plan.ColDef{})
			if err := m.Rets[len(m.Rets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, &plan.Expr{})
			if err := m.Args[len(m.Args)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params[:0], dAtA[iNdEx:postIndex]...)
			if m.Params == nil {
				m.Params = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HashBuild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HashBuild: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HashBuild: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedExpr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedExpr = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedHash", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedHash = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ibucket", wireType)
			}
			m.Ibucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ibucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nbucket", wireType)
			}
			m.Nbucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nbucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conds = append(m.Conds, &plan.Expr{})
			if err := m.Conds[len(m.Conds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOnPk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashOnPk = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedMergedBatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedMergedBatch = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedAllocateSels", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedAllocateSels = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalName2ColIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalName2ColIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalName2ColIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileOffset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: file_offset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: file_offset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Offset = append(m.Offset, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Offset) == 0 {
					m.Offset = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Offset = append(m.Offset, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalScan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalScan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalScan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attrs = append(m.Attrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FileSize = append(m.FileSize, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FileSize) == 0 {
					m.FileSize = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FileSize = append(m.FileSize, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileOffsetTotal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileOffsetTotal = append(m.FileOffsetTotal, &FileOffset{})
			if err := m.FileOffsetTotal[len(m.FileOffsetTotal)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cols = append(m.Cols, &plan.ColDef{})
			if err := m.Cols[len(m.Cols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name2ColIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name2ColIndex = append(m.Name2ColIndex, &ExternalName2ColIndex{})
			if err := m.Name2ColIndex[len(m.Name2ColIndex)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateSql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreateSql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileList = append(m.FileList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginCols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginCols = append(m.OriginCols, &plan.ColDef{})
			if err := m.OriginCols[len(m.OriginCols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &plan.Expr{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamScan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamScan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamScan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TblDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TblDef == nil {
				m.TblDef = &plan.TableDef{}
			}
			if err := m.TblDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SampleFunc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SampleFunc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SampleFunc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleType", wireType)
			}
			m.SampleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleType |= SampleFunc_SampleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleRows", wireType)
			}
			m.SampleRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleRows |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SamplePercent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SamplePercent = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SampleColumns = append(m.SampleColumns, &plan.Expr{})
			if err := m.SampleColumns[len(m.SampleColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Instruction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Instruction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Instruction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anti", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anti == nil {
				m.Anti = &AntiJoin{}
			}
			if err := m.Anti.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connect == nil {
				m.Connect = &Connector{}
			}
			if err := m.Connect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dispatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dispatch == nil {
				m.Dispatch = &Dispatch{}
			}
			if err := m.Dispatch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Agg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Agg == nil {
				m.Agg = &Group{}
			}
			if err := m.Agg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeftJoin == nil {
				m.LeftJoin = &LeftJoin{}
			}
			if err := m.LeftJoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemiJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SemiJoin == nil {
				m.SemiJoin = &SemiJoin{}
			}
			if err := m.SemiJoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SingleJoin == nil {
				m.SingleJoin = &SingleJoin{}
			}
			if err := m.SingleJoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MarkJoin == nil {
				m.MarkJoin = &MarkJoin{}
			}
			if err := m.MarkJoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Join", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Join == nil {
				m.Join = &Join{}
			}
			if err := m.Join.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Product == nil {
				m.Product = &Product{}
			}
			if err := m.Product.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableFunction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableFunction == nil {
				m.TableFunction = &TableFunction{}
			}
			if err := m.TableFunction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashBuild", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HashBuild == nil {
				m.HashBuild = &HashBuild{}
			}
			if err := m.HashBuild.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalScan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExternalScan == nil {
				m.ExternalScan = &ExternalScan{}
			}
			if err := m.ExternalScan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Insert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Insert == nil {
				m.Insert = &Insert{}
			}
			if err := m.Insert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDuplicateKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OnDuplicateKey == nil {
				m.OnDuplicateKey = &OnDuplicateKey{}
			}
			if err := m.OnDuplicateKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreInsert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreInsert == nil {
				m.PreInsert = &PreInsert{}
			}
			if err := m.PreInsert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreInsertUnique", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreInsertUnique == nil {
				m.PreInsertUnique = &PreInsertUnique{}
			}
			if err := m.PreInsertUnique.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBy = append(m.OrderBy, &plan.OrderBySpec{})
			if err := m.OrderBy[len(m.OrderBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectList = append(m.ProjectList, &plan.Expr{})
			if err := m.ProjectList[len(m.ProjectList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &plan.Expr{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limit == nil {
				m.Limit = &plan.Expr{}
			}
			if err := m.Limit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Offset == nil {
				m.Offset = &plan.Expr{}
			}
			if err := m.Offset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFirst", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFirst = bool(v != 0)
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLast = bool(v != 0)
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightJoin == nil {
				m.RightJoin = &RightJoin{}
			}
			if err := m.RightJoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightSemiJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightSemiJoin == nil {
				m.RightSemiJoin = &RightSemiJoin{}
			}
			if err := m.RightSemiJoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightAntiJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightAntiJoin == nil {
				m.RightAntiJoin = &RightAntiJoin{}
			}
			if err := m.RightAntiJoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delete == nil {
				m.Delete = &Deletion{}
			}
			if err := m.Delete.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LockOp == nil {
				m.LockOp = &LockOp{}
			}
			if err := m.LockOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shuffle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shuffle == nil {
				m.Shuffle = &Shuffle{}
			}
			if err := m.Shuffle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Merge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Merge == nil {
				m.Merge = &Merge{}
			}
			if err := m.Merge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamScan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StreamScan == nil {
				m.StreamScan = &StreamScan{}
			}
			if err := m.StreamScan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreInsertSecondaryIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreInsertSecondaryIndex == nil {
				m.PreInsertSecondaryIndex = &PreInsertSecondaryIndex{}
			}
			if err := m.PreInsertSecondaryIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleFunc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SampleFunc == nil {
				m.SampleFunc = &SampleFunc{}
			}
			if err := m.SampleFunc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuzzyFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FuzzyFilter == nil {
				m.FuzzyFilter = &FuzzyFilter{}
			}
			if err := m.FuzzyFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CnAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CnAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorId", wireType)
			}
			m.OperatorId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperatorId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParallelId", wireType)
			}
			m.ParallelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParallelId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxParallel", wireType)
			}
			m.MaxParallel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxParallel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IndexJoin == nil {
				m.IndexJoin = &IndexJoin{}
			}
			if err := m.IndexJoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnalysisList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalysisList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalysisList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &plan.AnalyzeInfo{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Source) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Source: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Source: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColList = append(m.ColList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Block = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushdownId", wireType)
			}
			m.PushdownId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PushdownId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushdownAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PushdownAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &plan.TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &timestamp.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterProbeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterProbeList = append(m.RuntimeFilterProbeList, &plan.RuntimeFilterSpec{})
			if err := m.RuntimeFilterProbeList[len(m.RuntimeFilterProbeList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mcpu", wireType)
			}
			m.Mcpu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mcpu |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessLimitation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessLimitation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessLimitation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size", wireType)
			}
			m.Size = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchRows", wireType)
			}
			m.BatchRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchRows |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSize", wireType)
			}
			m.BatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionRows", wireType)
			}
			m.PartitionRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionRows |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReaderSize", wireType)
			}
			m.ReaderSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReaderSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lim == nil {
				m.Lim = &ProcessLimitation{}
			}
			if err := m.Lim.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnixTime", wireType)
			}
			m.UnixTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnixTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			m.AccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Snapshot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SessionInfo == nil {
				m.SessionInfo = &SessionInfo{}
			}
			if err := m.SessionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AnalysisNodeList = append(m.AnalysisNodeList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AnalysisNodeList) == 0 {
					m.AnalysisNodeList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AnalysisNodeList = append(m.AnalysisNodeList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalysisNodeList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionId", wireType)
			}
			m.ConnectionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeZone", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimeZone = append(m.TimeZone[:0], dAtA[iNdEx:postIndex]...)
			if m.TimeZone == nil {
				m.TimeZone = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryId = append(m.QueryId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pipeline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pipeline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pipeline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineType", wireType)
			}
			m.PipelineType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PipelineType |= Pipeline_PipelineType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineId", wireType)
			}
			m.PipelineId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PipelineId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Qry == nil {
				m.Qry = &plan.Plan{}
			}
			if err := m.Qry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataSource == nil {
				m.DataSource = &Source{}
			}
			if err := m.DataSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &Pipeline{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstructionList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstructionList = append(m.InstructionList, &Instruction{})
			if err := m.InstructionList[len(m.InstructionList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEnd = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsJoin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsJoin = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLoad", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLoad = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &NodeInfo{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushDownInfo", wireType)
			}
			m.PushDownInfo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PushDownInfo |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildrenCount", wireType)
			}
			m.ChildrenCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChildrenCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UuidsToRegIdx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UuidsToRegIdx = append(m.UuidsToRegIdx, &UuidToRegIdx{})
			if err := m.UuidsToRegIdx[len(m.UuidsToRegIdx)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildIdx", wireType)
			}
			m.BuildIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleCnt", wireType)
			}
			m.ShuffleCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleCnt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WrapNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WrapNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WrapNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UuidToRegIdx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UuidToRegIdx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UuidToRegIdx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPipeline(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPipeline
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPipeline
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPipeline
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPipeline        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPipeline          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPipeline = fmt.Errorf("proto: unexpected end of group")
)
