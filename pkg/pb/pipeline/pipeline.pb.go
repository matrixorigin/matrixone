// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pipeline.proto

package pipeline

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	plan "github.com/matrixorigin/matrixone/pkg/pb/plan"
	timestamp "github.com/matrixorigin/matrixone/pkg/pb/timestamp"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Pipeline_PipelineType int32

const (
	Pipeline_Merge    Pipeline_PipelineType = 0
	Pipeline_Normal   Pipeline_PipelineType = 1
	Pipeline_Remote   Pipeline_PipelineType = 2
	Pipeline_Parallel Pipeline_PipelineType = 3
)

var Pipeline_PipelineType_name = map[int32]string{
	0: "Merge",
	1: "Normal",
	2: "Remote",
	3: "Parallel",
}

var Pipeline_PipelineType_value = map[string]int32{
	"Merge":    0,
	"Normal":   1,
	"Remote":   2,
	"Parallel": 3,
}

func (x Pipeline_PipelineType) String() string {
	return proto.EnumName(Pipeline_PipelineType_name, int32(x))
}

func (Pipeline_PipelineType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{25, 0}
}

type Message struct {
	Sid                  uint64   `protobuf:"varint,1,opt,name=sid,proto3" json:"sid,omitempty"`
	Cmd                  uint64   `protobuf:"varint,2,opt,name=cmd,proto3" json:"cmd,omitempty"`
	Err                  []byte   `protobuf:"bytes,3,opt,name=err,proto3" json:"err,omitempty"`
	Data                 []byte   `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	ProcInfoData         []byte   `protobuf:"bytes,5,opt,name=proc_info_data,json=procInfoData,proto3" json:"proc_info_data,omitempty"`
	Analyse              []byte   `protobuf:"bytes,6,opt,name=analyse,proto3" json:"analyse,omitempty"`
	Id                   uint64   `protobuf:"varint,7,opt,name=id,proto3" json:"id,omitempty"`
	Uuid                 []byte   `protobuf:"bytes,8,opt,name=uuid,proto3" json:"uuid,omitempty"`
	BatchCnt             uint64   `protobuf:"varint,9,opt,name=batch_cnt,json=batchCnt,proto3" json:"batch_cnt,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{0}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetSid() uint64 {
	if m != nil {
		return m.Sid
	}
	return 0
}

func (m *Message) GetCmd() uint64 {
	if m != nil {
		return m.Cmd
	}
	return 0
}

func (m *Message) GetErr() []byte {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *Message) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Message) GetProcInfoData() []byte {
	if m != nil {
		return m.ProcInfoData
	}
	return nil
}

func (m *Message) GetAnalyse() []byte {
	if m != nil {
		return m.Analyse
	}
	return nil
}

func (m *Message) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Message) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *Message) GetBatchCnt() uint64 {
	if m != nil {
		return m.BatchCnt
	}
	return 0
}

type Connector struct {
	PipelineId           int32    `protobuf:"varint,1,opt,name=pipeline_id,json=pipelineId,proto3" json:"pipeline_id,omitempty"`
	ConnectorIndex       int32    `protobuf:"varint,2,opt,name=connector_index,json=connectorIndex,proto3" json:"connector_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Connector) Reset()         { *m = Connector{} }
func (m *Connector) String() string { return proto.CompactTextString(m) }
func (*Connector) ProtoMessage()    {}
func (*Connector) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{1}
}
func (m *Connector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Connector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Connector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Connector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Connector.Merge(m, src)
}
func (m *Connector) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Connector) XXX_DiscardUnknown() {
	xxx_messageInfo_Connector.DiscardUnknown(m)
}

var xxx_messageInfo_Connector proto.InternalMessageInfo

func (m *Connector) GetPipelineId() int32 {
	if m != nil {
		return m.PipelineId
	}
	return 0
}

func (m *Connector) GetConnectorIndex() int32 {
	if m != nil {
		return m.ConnectorIndex
	}
	return 0
}

type Dispatch struct {
	All                  bool         `protobuf:"varint,1,opt,name=all,proto3" json:"all,omitempty"`
	CrossCn              bool         `protobuf:"varint,2,opt,name=cross_cn,json=crossCn,proto3" json:"cross_cn,omitempty"`
	Connector            []*Connector `protobuf:"bytes,3,rep,name=connector,proto3" json:"connector,omitempty"`
	RemoteConnector      []*WrapNode  `protobuf:"bytes,4,rep,name=remote_connector,json=remoteConnector,proto3" json:"remote_connector,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Dispatch) Reset()         { *m = Dispatch{} }
func (m *Dispatch) String() string { return proto.CompactTextString(m) }
func (*Dispatch) ProtoMessage()    {}
func (*Dispatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{2}
}
func (m *Dispatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dispatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dispatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Dispatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dispatch.Merge(m, src)
}
func (m *Dispatch) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Dispatch) XXX_DiscardUnknown() {
	xxx_messageInfo_Dispatch.DiscardUnknown(m)
}

var xxx_messageInfo_Dispatch proto.InternalMessageInfo

func (m *Dispatch) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

func (m *Dispatch) GetCrossCn() bool {
	if m != nil {
		return m.CrossCn
	}
	return false
}

func (m *Dispatch) GetConnector() []*Connector {
	if m != nil {
		return m.Connector
	}
	return nil
}

func (m *Dispatch) GetRemoteConnector() []*WrapNode {
	if m != nil {
		return m.RemoteConnector
	}
	return nil
}

type Aggregate struct {
	Op                   int32      `protobuf:"varint,1,opt,name=op,proto3" json:"op,omitempty"`
	Dist                 bool       `protobuf:"varint,2,opt,name=dist,proto3" json:"dist,omitempty"`
	Expr                 *plan.Expr `protobuf:"bytes,3,opt,name=expr,proto3" json:"expr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Aggregate) Reset()         { *m = Aggregate{} }
func (m *Aggregate) String() string { return proto.CompactTextString(m) }
func (*Aggregate) ProtoMessage()    {}
func (*Aggregate) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{3}
}
func (m *Aggregate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Aggregate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Aggregate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Aggregate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Aggregate.Merge(m, src)
}
func (m *Aggregate) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Aggregate) XXX_DiscardUnknown() {
	xxx_messageInfo_Aggregate.DiscardUnknown(m)
}

var xxx_messageInfo_Aggregate proto.InternalMessageInfo

func (m *Aggregate) GetOp() int32 {
	if m != nil {
		return m.Op
	}
	return 0
}

func (m *Aggregate) GetDist() bool {
	if m != nil {
		return m.Dist
	}
	return false
}

func (m *Aggregate) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

type Group struct {
	NeedEval             bool         `protobuf:"varint,1,opt,name=need_eval,json=needEval,proto3" json:"need_eval,omitempty"`
	Ibucket              uint64       `protobuf:"varint,2,opt,name=ibucket,proto3" json:"ibucket,omitempty"`
	Nbucket              uint64       `protobuf:"varint,3,opt,name=nbucket,proto3" json:"nbucket,omitempty"`
	Exprs                []*plan.Expr `protobuf:"bytes,4,rep,name=exprs,proto3" json:"exprs,omitempty"`
	Types                []*plan.Type `protobuf:"bytes,5,rep,name=types,proto3" json:"types,omitempty"`
	Aggs                 []*Aggregate `protobuf:"bytes,6,rep,name=aggs,proto3" json:"aggs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Group) Reset()         { *m = Group{} }
func (m *Group) String() string { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()    {}
func (*Group) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{4}
}
func (m *Group) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Group) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Group.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Group) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Group.Merge(m, src)
}
func (m *Group) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Group) XXX_DiscardUnknown() {
	xxx_messageInfo_Group.DiscardUnknown(m)
}

var xxx_messageInfo_Group proto.InternalMessageInfo

func (m *Group) GetNeedEval() bool {
	if m != nil {
		return m.NeedEval
	}
	return false
}

func (m *Group) GetIbucket() uint64 {
	if m != nil {
		return m.Ibucket
	}
	return 0
}

func (m *Group) GetNbucket() uint64 {
	if m != nil {
		return m.Nbucket
	}
	return 0
}

func (m *Group) GetExprs() []*plan.Expr {
	if m != nil {
		return m.Exprs
	}
	return nil
}

func (m *Group) GetTypes() []*plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *Group) GetAggs() []*Aggregate {
	if m != nil {
		return m.Aggs
	}
	return nil
}

type Insert struct {
	Affected uint64 `protobuf:"varint,1,opt,name=affected,proto3" json:"affected,omitempty"`
	IsRemote bool   `protobuf:"varint,2,opt,name=IsRemote,proto3" json:"IsRemote,omitempty"`
	// InsertCtx
	Idx                  []int32            `protobuf:"varint,3,rep,packed,name=idx,proto3" json:"idx,omitempty"`
	Ref                  *plan.ObjectRef    `protobuf:"bytes,4,opt,name=ref,proto3" json:"ref,omitempty"`
	TableDef             *plan.TableDef     `protobuf:"bytes,5,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	IdxIdx               []int32            `protobuf:"varint,6,rep,packed,name=idx_idx,json=idxIdx,proto3" json:"idx_idx,omitempty"`
	ParentIdx            map[string]int32   `protobuf:"bytes,7,rep,name=parent_idx,json=parentIdx,proto3" json:"parent_idx,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	ClusterTable         *plan.ClusterTable `protobuf:"bytes,8,opt,name=ClusterTable,proto3" json:"ClusterTable,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *Insert) Reset()         { *m = Insert{} }
func (m *Insert) String() string { return proto.CompactTextString(m) }
func (*Insert) ProtoMessage()    {}
func (*Insert) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{5}
}
func (m *Insert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Insert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Insert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Insert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Insert.Merge(m, src)
}
func (m *Insert) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Insert) XXX_DiscardUnknown() {
	xxx_messageInfo_Insert.DiscardUnknown(m)
}

var xxx_messageInfo_Insert proto.InternalMessageInfo

func (m *Insert) GetAffected() uint64 {
	if m != nil {
		return m.Affected
	}
	return 0
}

func (m *Insert) GetIsRemote() bool {
	if m != nil {
		return m.IsRemote
	}
	return false
}

func (m *Insert) GetIdx() []int32 {
	if m != nil {
		return m.Idx
	}
	return nil
}

func (m *Insert) GetRef() *plan.ObjectRef {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *Insert) GetTableDef() *plan.TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *Insert) GetIdxIdx() []int32 {
	if m != nil {
		return m.IdxIdx
	}
	return nil
}

func (m *Insert) GetParentIdx() map[string]int32 {
	if m != nil {
		return m.ParentIdx
	}
	return nil
}

func (m *Insert) GetClusterTable() *plan.ClusterTable {
	if m != nil {
		return m.ClusterTable
	}
	return nil
}

type Join struct {
	Ibucket              uint64       `protobuf:"varint,1,opt,name=ibucket,proto3" json:"ibucket,omitempty"`
	Nbucket              uint64       `protobuf:"varint,2,opt,name=nbucket,proto3" json:"nbucket,omitempty"`
	RelList              []int32      `protobuf:"varint,3,rep,packed,name=rel_list,json=relList,proto3" json:"rel_list,omitempty"`
	ColList              []int32      `protobuf:"varint,4,rep,packed,name=col_list,json=colList,proto3" json:"col_list,omitempty"`
	Expr                 *plan.Expr   `protobuf:"bytes,5,opt,name=expr,proto3" json:"expr,omitempty"`
	Types                []*plan.Type `protobuf:"bytes,6,rep,name=types,proto3" json:"types,omitempty"`
	LeftCond             []*plan.Expr `protobuf:"bytes,7,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond            []*plan.Expr `protobuf:"bytes,8,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Join) Reset()         { *m = Join{} }
func (m *Join) String() string { return proto.CompactTextString(m) }
func (*Join) ProtoMessage()    {}
func (*Join) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{6}
}
func (m *Join) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Join) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Join.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Join) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Join.Merge(m, src)
}
func (m *Join) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Join) XXX_DiscardUnknown() {
	xxx_messageInfo_Join.DiscardUnknown(m)
}

var xxx_messageInfo_Join proto.InternalMessageInfo

func (m *Join) GetIbucket() uint64 {
	if m != nil {
		return m.Ibucket
	}
	return 0
}

func (m *Join) GetNbucket() uint64 {
	if m != nil {
		return m.Nbucket
	}
	return 0
}

func (m *Join) GetRelList() []int32 {
	if m != nil {
		return m.RelList
	}
	return nil
}

func (m *Join) GetColList() []int32 {
	if m != nil {
		return m.ColList
	}
	return nil
}

func (m *Join) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Join) GetTypes() []*plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *Join) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *Join) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

type AntiJoin struct {
	Ibucket              uint64       `protobuf:"varint,1,opt,name=ibucket,proto3" json:"ibucket,omitempty"`
	Nbucket              uint64       `protobuf:"varint,2,opt,name=nbucket,proto3" json:"nbucket,omitempty"`
	Result               []int32      `protobuf:"varint,3,rep,packed,name=result,proto3" json:"result,omitempty"`
	Expr                 *plan.Expr   `protobuf:"bytes,4,opt,name=expr,proto3" json:"expr,omitempty"`
	Types                []*plan.Type `protobuf:"bytes,5,rep,name=types,proto3" json:"types,omitempty"`
	LeftCond             []*plan.Expr `protobuf:"bytes,6,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond            []*plan.Expr `protobuf:"bytes,7,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *AntiJoin) Reset()         { *m = AntiJoin{} }
func (m *AntiJoin) String() string { return proto.CompactTextString(m) }
func (*AntiJoin) ProtoMessage()    {}
func (*AntiJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{7}
}
func (m *AntiJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AntiJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AntiJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AntiJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AntiJoin.Merge(m, src)
}
func (m *AntiJoin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AntiJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_AntiJoin.DiscardUnknown(m)
}

var xxx_messageInfo_AntiJoin proto.InternalMessageInfo

func (m *AntiJoin) GetIbucket() uint64 {
	if m != nil {
		return m.Ibucket
	}
	return 0
}

func (m *AntiJoin) GetNbucket() uint64 {
	if m != nil {
		return m.Nbucket
	}
	return 0
}

func (m *AntiJoin) GetResult() []int32 {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *AntiJoin) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *AntiJoin) GetTypes() []*plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *AntiJoin) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *AntiJoin) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

type InnerJoin struct {
	Ibucket              uint64       `protobuf:"varint,1,opt,name=ibucket,proto3" json:"ibucket,omitempty"`
	Nbucket              uint64       `protobuf:"varint,2,opt,name=nbucket,proto3" json:"nbucket,omitempty"`
	RelList              []int32      `protobuf:"varint,3,rep,packed,name=rel_list,json=relList,proto3" json:"rel_list,omitempty"`
	ColList              []int32      `protobuf:"varint,4,rep,packed,name=col_list,json=colList,proto3" json:"col_list,omitempty"`
	Expr                 *plan.Expr   `protobuf:"bytes,5,opt,name=expr,proto3" json:"expr,omitempty"`
	Types                []*plan.Type `protobuf:"bytes,6,rep,name=types,proto3" json:"types,omitempty"`
	LeftCond             []*plan.Expr `protobuf:"bytes,7,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond            []*plan.Expr `protobuf:"bytes,8,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *InnerJoin) Reset()         { *m = InnerJoin{} }
func (m *InnerJoin) String() string { return proto.CompactTextString(m) }
func (*InnerJoin) ProtoMessage()    {}
func (*InnerJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{8}
}
func (m *InnerJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InnerJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InnerJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InnerJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InnerJoin.Merge(m, src)
}
func (m *InnerJoin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *InnerJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_InnerJoin.DiscardUnknown(m)
}

var xxx_messageInfo_InnerJoin proto.InternalMessageInfo

func (m *InnerJoin) GetIbucket() uint64 {
	if m != nil {
		return m.Ibucket
	}
	return 0
}

func (m *InnerJoin) GetNbucket() uint64 {
	if m != nil {
		return m.Nbucket
	}
	return 0
}

func (m *InnerJoin) GetRelList() []int32 {
	if m != nil {
		return m.RelList
	}
	return nil
}

func (m *InnerJoin) GetColList() []int32 {
	if m != nil {
		return m.ColList
	}
	return nil
}

func (m *InnerJoin) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *InnerJoin) GetTypes() []*plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *InnerJoin) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *InnerJoin) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

type LeftJoin struct {
	Ibucket              uint64       `protobuf:"varint,1,opt,name=ibucket,proto3" json:"ibucket,omitempty"`
	Nbucket              uint64       `protobuf:"varint,2,opt,name=nbucket,proto3" json:"nbucket,omitempty"`
	RelList              []int32      `protobuf:"varint,3,rep,packed,name=rel_list,json=relList,proto3" json:"rel_list,omitempty"`
	ColList              []int32      `protobuf:"varint,4,rep,packed,name=col_list,json=colList,proto3" json:"col_list,omitempty"`
	Expr                 *plan.Expr   `protobuf:"bytes,5,opt,name=expr,proto3" json:"expr,omitempty"`
	Types                []*plan.Type `protobuf:"bytes,6,rep,name=types,proto3" json:"types,omitempty"`
	LeftCond             []*plan.Expr `protobuf:"bytes,7,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond            []*plan.Expr `protobuf:"bytes,8,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *LeftJoin) Reset()         { *m = LeftJoin{} }
func (m *LeftJoin) String() string { return proto.CompactTextString(m) }
func (*LeftJoin) ProtoMessage()    {}
func (*LeftJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{9}
}
func (m *LeftJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeftJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeftJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeftJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeftJoin.Merge(m, src)
}
func (m *LeftJoin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LeftJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_LeftJoin.DiscardUnknown(m)
}

var xxx_messageInfo_LeftJoin proto.InternalMessageInfo

func (m *LeftJoin) GetIbucket() uint64 {
	if m != nil {
		return m.Ibucket
	}
	return 0
}

func (m *LeftJoin) GetNbucket() uint64 {
	if m != nil {
		return m.Nbucket
	}
	return 0
}

func (m *LeftJoin) GetRelList() []int32 {
	if m != nil {
		return m.RelList
	}
	return nil
}

func (m *LeftJoin) GetColList() []int32 {
	if m != nil {
		return m.ColList
	}
	return nil
}

func (m *LeftJoin) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *LeftJoin) GetTypes() []*plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *LeftJoin) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *LeftJoin) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

type SemiJoin struct {
	Ibucket              uint64       `protobuf:"varint,1,opt,name=ibucket,proto3" json:"ibucket,omitempty"`
	Nbucket              uint64       `protobuf:"varint,2,opt,name=nbucket,proto3" json:"nbucket,omitempty"`
	Result               []int32      `protobuf:"varint,3,rep,packed,name=result,proto3" json:"result,omitempty"`
	Expr                 *plan.Expr   `protobuf:"bytes,4,opt,name=expr,proto3" json:"expr,omitempty"`
	Types                []*plan.Type `protobuf:"bytes,5,rep,name=types,proto3" json:"types,omitempty"`
	LeftCond             []*plan.Expr `protobuf:"bytes,6,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond            []*plan.Expr `protobuf:"bytes,7,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *SemiJoin) Reset()         { *m = SemiJoin{} }
func (m *SemiJoin) String() string { return proto.CompactTextString(m) }
func (*SemiJoin) ProtoMessage()    {}
func (*SemiJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{10}
}
func (m *SemiJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SemiJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SemiJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SemiJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SemiJoin.Merge(m, src)
}
func (m *SemiJoin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SemiJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_SemiJoin.DiscardUnknown(m)
}

var xxx_messageInfo_SemiJoin proto.InternalMessageInfo

func (m *SemiJoin) GetIbucket() uint64 {
	if m != nil {
		return m.Ibucket
	}
	return 0
}

func (m *SemiJoin) GetNbucket() uint64 {
	if m != nil {
		return m.Nbucket
	}
	return 0
}

func (m *SemiJoin) GetResult() []int32 {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *SemiJoin) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *SemiJoin) GetTypes() []*plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *SemiJoin) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *SemiJoin) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

type SingleJoin struct {
	Ibucket              uint64       `protobuf:"varint,1,opt,name=ibucket,proto3" json:"ibucket,omitempty"`
	Nbucket              uint64       `protobuf:"varint,2,opt,name=nbucket,proto3" json:"nbucket,omitempty"`
	RelList              []int32      `protobuf:"varint,3,rep,packed,name=rel_list,json=relList,proto3" json:"rel_list,omitempty"`
	ColList              []int32      `protobuf:"varint,4,rep,packed,name=col_list,json=colList,proto3" json:"col_list,omitempty"`
	Expr                 *plan.Expr   `protobuf:"bytes,5,opt,name=expr,proto3" json:"expr,omitempty"`
	Types                []*plan.Type `protobuf:"bytes,6,rep,name=types,proto3" json:"types,omitempty"`
	LeftCond             []*plan.Expr `protobuf:"bytes,7,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond            []*plan.Expr `protobuf:"bytes,8,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *SingleJoin) Reset()         { *m = SingleJoin{} }
func (m *SingleJoin) String() string { return proto.CompactTextString(m) }
func (*SingleJoin) ProtoMessage()    {}
func (*SingleJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{11}
}
func (m *SingleJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SingleJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SingleJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SingleJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SingleJoin.Merge(m, src)
}
func (m *SingleJoin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SingleJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_SingleJoin.DiscardUnknown(m)
}

var xxx_messageInfo_SingleJoin proto.InternalMessageInfo

func (m *SingleJoin) GetIbucket() uint64 {
	if m != nil {
		return m.Ibucket
	}
	return 0
}

func (m *SingleJoin) GetNbucket() uint64 {
	if m != nil {
		return m.Nbucket
	}
	return 0
}

func (m *SingleJoin) GetRelList() []int32 {
	if m != nil {
		return m.RelList
	}
	return nil
}

func (m *SingleJoin) GetColList() []int32 {
	if m != nil {
		return m.ColList
	}
	return nil
}

func (m *SingleJoin) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *SingleJoin) GetTypes() []*plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *SingleJoin) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *SingleJoin) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

type MarkJoin struct {
	Ibucket              uint64       `protobuf:"varint,1,opt,name=ibucket,proto3" json:"ibucket,omitempty"`
	Nbucket              uint64       `protobuf:"varint,2,opt,name=nbucket,proto3" json:"nbucket,omitempty"`
	Result               []int32      `protobuf:"varint,3,rep,packed,name=result,proto3" json:"result,omitempty"`
	Expr                 *plan.Expr   `protobuf:"bytes,4,opt,name=expr,proto3" json:"expr,omitempty"`
	Types                []*plan.Type `protobuf:"bytes,5,rep,name=types,proto3" json:"types,omitempty"`
	LeftCond             []*plan.Expr `protobuf:"bytes,6,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond            []*plan.Expr `protobuf:"bytes,7,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	OnList               []*plan.Expr `protobuf:"bytes,8,rep,name=on_list,json=onList,proto3" json:"on_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *MarkJoin) Reset()         { *m = MarkJoin{} }
func (m *MarkJoin) String() string { return proto.CompactTextString(m) }
func (*MarkJoin) ProtoMessage()    {}
func (*MarkJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{12}
}
func (m *MarkJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarkJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkJoin.Merge(m, src)
}
func (m *MarkJoin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MarkJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkJoin.DiscardUnknown(m)
}

var xxx_messageInfo_MarkJoin proto.InternalMessageInfo

func (m *MarkJoin) GetIbucket() uint64 {
	if m != nil {
		return m.Ibucket
	}
	return 0
}

func (m *MarkJoin) GetNbucket() uint64 {
	if m != nil {
		return m.Nbucket
	}
	return 0
}

func (m *MarkJoin) GetResult() []int32 {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *MarkJoin) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *MarkJoin) GetTypes() []*plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *MarkJoin) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *MarkJoin) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

func (m *MarkJoin) GetOnList() []*plan.Expr {
	if m != nil {
		return m.OnList
	}
	return nil
}

type Product struct {
	RelList              []int32      `protobuf:"varint,1,rep,packed,name=rel_list,json=relList,proto3" json:"rel_list,omitempty"`
	ColList              []int32      `protobuf:"varint,2,rep,packed,name=col_list,json=colList,proto3" json:"col_list,omitempty"`
	Types                []*plan.Type `protobuf:"bytes,3,rep,name=types,proto3" json:"types,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Product) Reset()         { *m = Product{} }
func (m *Product) String() string { return proto.CompactTextString(m) }
func (*Product) ProtoMessage()    {}
func (*Product) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{13}
}
func (m *Product) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Product) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Product.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Product) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Product.Merge(m, src)
}
func (m *Product) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Product) XXX_DiscardUnknown() {
	xxx_messageInfo_Product.DiscardUnknown(m)
}

var xxx_messageInfo_Product proto.InternalMessageInfo

func (m *Product) GetRelList() []int32 {
	if m != nil {
		return m.RelList
	}
	return nil
}

func (m *Product) GetColList() []int32 {
	if m != nil {
		return m.ColList
	}
	return nil
}

func (m *Product) GetTypes() []*plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

type TableFunction struct {
	Attrs                []string       `protobuf:"bytes,1,rep,name=attrs,proto3" json:"attrs,omitempty"`
	Rets                 []*plan.ColDef `protobuf:"bytes,2,rep,name=rets,proto3" json:"rets,omitempty"`
	Args                 []*plan.Expr   `protobuf:"bytes,3,rep,name=args,proto3" json:"args,omitempty"`
	Params               []byte         `protobuf:"bytes,4,opt,name=params,proto3" json:"params,omitempty"`
	Name                 string         `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TableFunction) Reset()         { *m = TableFunction{} }
func (m *TableFunction) String() string { return proto.CompactTextString(m) }
func (*TableFunction) ProtoMessage()    {}
func (*TableFunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{14}
}
func (m *TableFunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableFunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableFunction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableFunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableFunction.Merge(m, src)
}
func (m *TableFunction) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableFunction) XXX_DiscardUnknown() {
	xxx_messageInfo_TableFunction.DiscardUnknown(m)
}

var xxx_messageInfo_TableFunction proto.InternalMessageInfo

func (m *TableFunction) GetAttrs() []string {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *TableFunction) GetRets() []*plan.ColDef {
	if m != nil {
		return m.Rets
	}
	return nil
}

func (m *TableFunction) GetArgs() []*plan.Expr {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *TableFunction) GetParams() []byte {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TableFunction) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type HashBuild struct {
	NeedExpr             bool         `protobuf:"varint,1,opt,name=need_expr,json=needExpr,proto3" json:"need_expr,omitempty"`
	NeedHash             bool         `protobuf:"varint,2,opt,name=need_hash,json=needHash,proto3" json:"need_hash,omitempty"`
	Ibucket              uint64       `protobuf:"varint,3,opt,name=ibucket,proto3" json:"ibucket,omitempty"`
	Nbucket              uint64       `protobuf:"varint,4,opt,name=nbucket,proto3" json:"nbucket,omitempty"`
	Types                []*plan.Type `protobuf:"bytes,5,rep,name=types,proto3" json:"types,omitempty"`
	Conds                []*plan.Expr `protobuf:"bytes,6,rep,name=conds,proto3" json:"conds,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *HashBuild) Reset()         { *m = HashBuild{} }
func (m *HashBuild) String() string { return proto.CompactTextString(m) }
func (*HashBuild) ProtoMessage()    {}
func (*HashBuild) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{15}
}
func (m *HashBuild) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HashBuild) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HashBuild.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HashBuild) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HashBuild.Merge(m, src)
}
func (m *HashBuild) XXX_Size() int {
	return m.ProtoSize()
}
func (m *HashBuild) XXX_DiscardUnknown() {
	xxx_messageInfo_HashBuild.DiscardUnknown(m)
}

var xxx_messageInfo_HashBuild proto.InternalMessageInfo

func (m *HashBuild) GetNeedExpr() bool {
	if m != nil {
		return m.NeedExpr
	}
	return false
}

func (m *HashBuild) GetNeedHash() bool {
	if m != nil {
		return m.NeedHash
	}
	return false
}

func (m *HashBuild) GetIbucket() uint64 {
	if m != nil {
		return m.Ibucket
	}
	return 0
}

func (m *HashBuild) GetNbucket() uint64 {
	if m != nil {
		return m.Nbucket
	}
	return 0
}

func (m *HashBuild) GetTypes() []*plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *HashBuild) GetConds() []*plan.Expr {
	if m != nil {
		return m.Conds
	}
	return nil
}

type ExternalName2ColIndex struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Index                int32    `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExternalName2ColIndex) Reset()         { *m = ExternalName2ColIndex{} }
func (m *ExternalName2ColIndex) String() string { return proto.CompactTextString(m) }
func (*ExternalName2ColIndex) ProtoMessage()    {}
func (*ExternalName2ColIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{16}
}
func (m *ExternalName2ColIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalName2ColIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExternalName2ColIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExternalName2ColIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalName2ColIndex.Merge(m, src)
}
func (m *ExternalName2ColIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExternalName2ColIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalName2ColIndex.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalName2ColIndex proto.InternalMessageInfo

func (m *ExternalName2ColIndex) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ExternalName2ColIndex) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

type ExternalScan struct {
	Attrs                []string                 `protobuf:"bytes,1,rep,name=attrs,proto3" json:"attrs,omitempty"`
	Cols                 []*plan.ColDef           `protobuf:"bytes,2,rep,name=cols,proto3" json:"cols,omitempty"`
	Name2ColIndex        []*ExternalName2ColIndex `protobuf:"bytes,3,rep,name=name2_col_index,json=name2ColIndex,proto3" json:"name2_col_index,omitempty"`
	CreateSql            string                   `protobuf:"bytes,4,opt,name=create_sql,json=createSql,proto3" json:"create_sql,omitempty"`
	FileList             []string                 `protobuf:"bytes,5,rep,name=file_list,json=fileList,proto3" json:"file_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *ExternalScan) Reset()         { *m = ExternalScan{} }
func (m *ExternalScan) String() string { return proto.CompactTextString(m) }
func (*ExternalScan) ProtoMessage()    {}
func (*ExternalScan) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{17}
}
func (m *ExternalScan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalScan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExternalScan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExternalScan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalScan.Merge(m, src)
}
func (m *ExternalScan) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExternalScan) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalScan.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalScan proto.InternalMessageInfo

func (m *ExternalScan) GetAttrs() []string {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *ExternalScan) GetCols() []*plan.ColDef {
	if m != nil {
		return m.Cols
	}
	return nil
}

func (m *ExternalScan) GetName2ColIndex() []*ExternalName2ColIndex {
	if m != nil {
		return m.Name2ColIndex
	}
	return nil
}

func (m *ExternalScan) GetCreateSql() string {
	if m != nil {
		return m.CreateSql
	}
	return ""
}

func (m *ExternalScan) GetFileList() []string {
	if m != nil {
		return m.FileList
	}
	return nil
}

type Instruction struct {
	// Op specified the operator code of an instruction.
	Op int32 `protobuf:"varint,1,opt,name=op,proto3" json:"op,omitempty"`
	// Idx specified the anaylze information index.
	Idx           int32               `protobuf:"varint,2,opt,name=idx,proto3" json:"idx,omitempty"`
	Anti          *AntiJoin           `protobuf:"bytes,3,opt,name=anti,proto3" json:"anti,omitempty"`
	Connect       *Connector          `protobuf:"bytes,4,opt,name=connect,proto3" json:"connect,omitempty"`
	Dispatch      *Dispatch           `protobuf:"bytes,5,opt,name=dispatch,proto3" json:"dispatch,omitempty"`
	Agg           *Group              `protobuf:"bytes,6,opt,name=agg,proto3" json:"agg,omitempty"`
	InnerJoin     *InnerJoin          `protobuf:"bytes,7,opt,name=inner_join,json=innerJoin,proto3" json:"inner_join,omitempty"`
	LeftJoin      *LeftJoin           `protobuf:"bytes,8,opt,name=left_join,json=leftJoin,proto3" json:"left_join,omitempty"`
	SemiJoin      *SemiJoin           `protobuf:"bytes,9,opt,name=semi_join,json=semiJoin,proto3" json:"semi_join,omitempty"`
	SingleJoin    *SingleJoin         `protobuf:"bytes,10,opt,name=single_join,json=singleJoin,proto3" json:"single_join,omitempty"`
	MarkJoin      *MarkJoin           `protobuf:"bytes,11,opt,name=mark_join,json=markJoin,proto3" json:"mark_join,omitempty"`
	Join          *Join               `protobuf:"bytes,12,opt,name=join,proto3" json:"join,omitempty"`
	Product       *Product            `protobuf:"bytes,13,opt,name=product,proto3" json:"product,omitempty"`
	TableFunction *TableFunction      `protobuf:"bytes,14,opt,name=table_function,json=tableFunction,proto3" json:"table_function,omitempty"`
	HashBuild     *HashBuild          `protobuf:"bytes,15,opt,name=hash_build,json=hashBuild,proto3" json:"hash_build,omitempty"`
	ExternalScan  *ExternalScan       `protobuf:"bytes,16,opt,name=external_scan,json=externalScan,proto3" json:"external_scan,omitempty"`
	Insert        *Insert             `protobuf:"bytes,17,opt,name=insert,proto3" json:"insert,omitempty"`
	OrderBy       []*plan.OrderBySpec `protobuf:"bytes,18,rep,name=order_by,json=orderBy,proto3" json:"order_by,omitempty"`
	ProjectList   []*plan.Expr        `protobuf:"bytes,19,rep,name=project_list,json=projectList,proto3" json:"project_list,omitempty"`
	Filter        *plan.Expr          `protobuf:"bytes,20,opt,name=filter,proto3" json:"filter,omitempty"`
	Limit         uint64              `protobuf:"varint,21,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset        uint64              `protobuf:"varint,22,opt,name=offset,proto3" json:"offset,omitempty"`
	// isFirst identifies whether it is the first instruction of analyzeInfo corresponding to idx
	IsFirst bool `protobuf:"varint,23,opt,name=isFirst,proto3" json:"isFirst,omitempty"`
	// isLast identifies whether it is the last instruction of analyzeInfo corresponding to idx
	IsLast               bool     `protobuf:"varint,24,opt,name=isLast,proto3" json:"isLast,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Instruction) Reset()         { *m = Instruction{} }
func (m *Instruction) String() string { return proto.CompactTextString(m) }
func (*Instruction) ProtoMessage()    {}
func (*Instruction) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{18}
}
func (m *Instruction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Instruction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Instruction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Instruction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Instruction.Merge(m, src)
}
func (m *Instruction) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Instruction) XXX_DiscardUnknown() {
	xxx_messageInfo_Instruction.DiscardUnknown(m)
}

var xxx_messageInfo_Instruction proto.InternalMessageInfo

func (m *Instruction) GetOp() int32 {
	if m != nil {
		return m.Op
	}
	return 0
}

func (m *Instruction) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *Instruction) GetAnti() *AntiJoin {
	if m != nil {
		return m.Anti
	}
	return nil
}

func (m *Instruction) GetConnect() *Connector {
	if m != nil {
		return m.Connect
	}
	return nil
}

func (m *Instruction) GetDispatch() *Dispatch {
	if m != nil {
		return m.Dispatch
	}
	return nil
}

func (m *Instruction) GetAgg() *Group {
	if m != nil {
		return m.Agg
	}
	return nil
}

func (m *Instruction) GetInnerJoin() *InnerJoin {
	if m != nil {
		return m.InnerJoin
	}
	return nil
}

func (m *Instruction) GetLeftJoin() *LeftJoin {
	if m != nil {
		return m.LeftJoin
	}
	return nil
}

func (m *Instruction) GetSemiJoin() *SemiJoin {
	if m != nil {
		return m.SemiJoin
	}
	return nil
}

func (m *Instruction) GetSingleJoin() *SingleJoin {
	if m != nil {
		return m.SingleJoin
	}
	return nil
}

func (m *Instruction) GetMarkJoin() *MarkJoin {
	if m != nil {
		return m.MarkJoin
	}
	return nil
}

func (m *Instruction) GetJoin() *Join {
	if m != nil {
		return m.Join
	}
	return nil
}

func (m *Instruction) GetProduct() *Product {
	if m != nil {
		return m.Product
	}
	return nil
}

func (m *Instruction) GetTableFunction() *TableFunction {
	if m != nil {
		return m.TableFunction
	}
	return nil
}

func (m *Instruction) GetHashBuild() *HashBuild {
	if m != nil {
		return m.HashBuild
	}
	return nil
}

func (m *Instruction) GetExternalScan() *ExternalScan {
	if m != nil {
		return m.ExternalScan
	}
	return nil
}

func (m *Instruction) GetInsert() *Insert {
	if m != nil {
		return m.Insert
	}
	return nil
}

func (m *Instruction) GetOrderBy() []*plan.OrderBySpec {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *Instruction) GetProjectList() []*plan.Expr {
	if m != nil {
		return m.ProjectList
	}
	return nil
}

func (m *Instruction) GetFilter() *plan.Expr {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *Instruction) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *Instruction) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *Instruction) GetIsFirst() bool {
	if m != nil {
		return m.IsFirst
	}
	return false
}

func (m *Instruction) GetIsLast() bool {
	if m != nil {
		return m.IsLast
	}
	return false
}

type AnalysisList struct {
	List                 []*plan.AnalyzeInfo `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *AnalysisList) Reset()         { *m = AnalysisList{} }
func (m *AnalysisList) String() string { return proto.CompactTextString(m) }
func (*AnalysisList) ProtoMessage()    {}
func (*AnalysisList) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{19}
}
func (m *AnalysisList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnalysisList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnalysisList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AnalysisList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnalysisList.Merge(m, src)
}
func (m *AnalysisList) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AnalysisList) XXX_DiscardUnknown() {
	xxx_messageInfo_AnalysisList.DiscardUnknown(m)
}

var xxx_messageInfo_AnalysisList proto.InternalMessageInfo

func (m *AnalysisList) GetList() []*plan.AnalyzeInfo {
	if m != nil {
		return m.List
	}
	return nil
}

type Source struct {
	SchemaName           string               `protobuf:"bytes,1,opt,name=schema_name,json=schemaName,proto3" json:"schema_name,omitempty"`
	TableName            string               `protobuf:"bytes,2,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	ColList              []string             `protobuf:"bytes,3,rep,name=col_list,json=colList,proto3" json:"col_list,omitempty"`
	Block                string               `protobuf:"bytes,4,opt,name=block,proto3" json:"block,omitempty"`
	PushdownId           uint64               `protobuf:"varint,5,opt,name=pushdown_id,json=pushdownId,proto3" json:"pushdown_id,omitempty"`
	PushdownAddr         string               `protobuf:"bytes,6,opt,name=pushdown_addr,json=pushdownAddr,proto3" json:"pushdown_addr,omitempty"`
	Expr                 *plan.Expr           `protobuf:"bytes,7,opt,name=expr,proto3" json:"expr,omitempty"`
	TableDef             *plan.TableDef       `protobuf:"bytes,8,opt,name=tableDef,proto3" json:"tableDef,omitempty"`
	Timestamp            *timestamp.Timestamp `protobuf:"bytes,9,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Source) Reset()         { *m = Source{} }
func (m *Source) String() string { return proto.CompactTextString(m) }
func (*Source) ProtoMessage()    {}
func (*Source) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{20}
}
func (m *Source) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Source) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Source.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Source) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Source.Merge(m, src)
}
func (m *Source) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Source) XXX_DiscardUnknown() {
	xxx_messageInfo_Source.DiscardUnknown(m)
}

var xxx_messageInfo_Source proto.InternalMessageInfo

func (m *Source) GetSchemaName() string {
	if m != nil {
		return m.SchemaName
	}
	return ""
}

func (m *Source) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *Source) GetColList() []string {
	if m != nil {
		return m.ColList
	}
	return nil
}

func (m *Source) GetBlock() string {
	if m != nil {
		return m.Block
	}
	return ""
}

func (m *Source) GetPushdownId() uint64 {
	if m != nil {
		return m.PushdownId
	}
	return 0
}

func (m *Source) GetPushdownAddr() string {
	if m != nil {
		return m.PushdownAddr
	}
	return ""
}

func (m *Source) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Source) GetTableDef() *plan.TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *Source) GetTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type NodeInfo struct {
	Mcpu                 int32    `protobuf:"varint,1,opt,name=mcpu,proto3" json:"mcpu,omitempty"`
	Id                   string   `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	Addr                 string   `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
	Payload              []string `protobuf:"bytes,4,rep,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeInfo) Reset()         { *m = NodeInfo{} }
func (m *NodeInfo) String() string { return proto.CompactTextString(m) }
func (*NodeInfo) ProtoMessage()    {}
func (*NodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{21}
}
func (m *NodeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInfo.Merge(m, src)
}
func (m *NodeInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *NodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInfo proto.InternalMessageInfo

func (m *NodeInfo) GetMcpu() int32 {
	if m != nil {
		return m.Mcpu
	}
	return 0
}

func (m *NodeInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NodeInfo) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *NodeInfo) GetPayload() []string {
	if m != nil {
		return m.Payload
	}
	return nil
}

type ProcessLimitation struct {
	Size                 int64    `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
	BatchRows            int64    `protobuf:"varint,2,opt,name=batch_rows,json=batchRows,proto3" json:"batch_rows,omitempty"`
	BatchSize            int64    `protobuf:"varint,3,opt,name=batch_size,json=batchSize,proto3" json:"batch_size,omitempty"`
	PartitionRows        int64    `protobuf:"varint,4,opt,name=partition_rows,json=partitionRows,proto3" json:"partition_rows,omitempty"`
	ReaderSize           int64    `protobuf:"varint,5,opt,name=reader_size,json=readerSize,proto3" json:"reader_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProcessLimitation) Reset()         { *m = ProcessLimitation{} }
func (m *ProcessLimitation) String() string { return proto.CompactTextString(m) }
func (*ProcessLimitation) ProtoMessage()    {}
func (*ProcessLimitation) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{22}
}
func (m *ProcessLimitation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessLimitation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessLimitation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessLimitation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessLimitation.Merge(m, src)
}
func (m *ProcessLimitation) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ProcessLimitation) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessLimitation.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessLimitation proto.InternalMessageInfo

func (m *ProcessLimitation) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *ProcessLimitation) GetBatchRows() int64 {
	if m != nil {
		return m.BatchRows
	}
	return 0
}

func (m *ProcessLimitation) GetBatchSize() int64 {
	if m != nil {
		return m.BatchSize
	}
	return 0
}

func (m *ProcessLimitation) GetPartitionRows() int64 {
	if m != nil {
		return m.PartitionRows
	}
	return 0
}

func (m *ProcessLimitation) GetReaderSize() int64 {
	if m != nil {
		return m.ReaderSize
	}
	return 0
}

type ProcessInfo struct {
	Id                   string             `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Lim                  *ProcessLimitation `protobuf:"bytes,2,opt,name=lim,proto3" json:"lim,omitempty"`
	UnixTime             int64              `protobuf:"varint,3,opt,name=unix_time,json=unixTime,proto3" json:"unix_time,omitempty"`
	Snapshot             string             `protobuf:"bytes,4,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	SessionInfo          *SessionInfo       `protobuf:"bytes,5,opt,name=session_info,json=sessionInfo,proto3" json:"session_info,omitempty"`
	AnalysisNodeList     []int32            `protobuf:"varint,6,rep,packed,name=analysis_node_list,json=analysisNodeList,proto3" json:"analysis_node_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ProcessInfo) Reset()         { *m = ProcessInfo{} }
func (m *ProcessInfo) String() string { return proto.CompactTextString(m) }
func (*ProcessInfo) ProtoMessage()    {}
func (*ProcessInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{23}
}
func (m *ProcessInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessInfo.Merge(m, src)
}
func (m *ProcessInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ProcessInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessInfo proto.InternalMessageInfo

func (m *ProcessInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ProcessInfo) GetLim() *ProcessLimitation {
	if m != nil {
		return m.Lim
	}
	return nil
}

func (m *ProcessInfo) GetUnixTime() int64 {
	if m != nil {
		return m.UnixTime
	}
	return 0
}

func (m *ProcessInfo) GetSnapshot() string {
	if m != nil {
		return m.Snapshot
	}
	return ""
}

func (m *ProcessInfo) GetSessionInfo() *SessionInfo {
	if m != nil {
		return m.SessionInfo
	}
	return nil
}

func (m *ProcessInfo) GetAnalysisNodeList() []int32 {
	if m != nil {
		return m.AnalysisNodeList
	}
	return nil
}

type SessionInfo struct {
	User                 string   `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	Host                 string   `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	Role                 string   `protobuf:"bytes,3,opt,name=role,proto3" json:"role,omitempty"`
	ConnectionId         uint64   `protobuf:"varint,4,opt,name=connection_id,json=connectionId,proto3" json:"connection_id,omitempty"`
	Database             string   `protobuf:"bytes,5,opt,name=database,proto3" json:"database,omitempty"`
	Version              string   `protobuf:"bytes,6,opt,name=version,proto3" json:"version,omitempty"`
	TimeZone             []byte   `protobuf:"bytes,7,opt,name=time_zone,json=timeZone,proto3" json:"time_zone,omitempty"`
	Account              string   `protobuf:"bytes,8,opt,name=account,proto3" json:"account,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SessionInfo) Reset()         { *m = SessionInfo{} }
func (m *SessionInfo) String() string { return proto.CompactTextString(m) }
func (*SessionInfo) ProtoMessage()    {}
func (*SessionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{24}
}
func (m *SessionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionInfo.Merge(m, src)
}
func (m *SessionInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SessionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SessionInfo proto.InternalMessageInfo

func (m *SessionInfo) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *SessionInfo) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *SessionInfo) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *SessionInfo) GetConnectionId() uint64 {
	if m != nil {
		return m.ConnectionId
	}
	return 0
}

func (m *SessionInfo) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *SessionInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *SessionInfo) GetTimeZone() []byte {
	if m != nil {
		return m.TimeZone
	}
	return nil
}

func (m *SessionInfo) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

type Pipeline struct {
	PipelineType         Pipeline_PipelineType `protobuf:"varint,1,opt,name=pipeline_type,json=pipelineType,proto3,enum=pipeline.Pipeline_PipelineType" json:"pipeline_type,omitempty"`
	PipelineId           int32                 `protobuf:"varint,2,opt,name=pipeline_id,json=pipelineId,proto3" json:"pipeline_id,omitempty"`
	Qry                  *plan.Plan            `protobuf:"bytes,3,opt,name=qry,proto3" json:"qry,omitempty"`
	DataSource           *Source               `protobuf:"bytes,4,opt,name=data_source,json=dataSource,proto3" json:"data_source,omitempty"`
	Children             []*Pipeline           `protobuf:"bytes,5,rep,name=children,proto3" json:"children,omitempty"`
	InstructionList      []*Instruction        `protobuf:"bytes,6,rep,name=instruction_list,json=instructionList,proto3" json:"instruction_list,omitempty"`
	IsEnd                bool                  `protobuf:"varint,7,opt,name=is_end,json=isEnd,proto3" json:"is_end,omitempty"`
	IsJoin               bool                  `protobuf:"varint,8,opt,name=is_join,json=isJoin,proto3" json:"is_join,omitempty"`
	Node                 *NodeInfo             `protobuf:"bytes,9,opt,name=node,proto3" json:"node,omitempty"`
	PushDownInfo         int32                 `protobuf:"varint,10,opt,name=push_down_info,json=pushDownInfo,proto3" json:"push_down_info,omitempty"`
	ChildrenCount        int32                 `protobuf:"varint,11,opt,name=children_count,json=childrenCount,proto3" json:"children_count,omitempty"`
	UuidsToRegIdx        []*UuidToRegIdx       `protobuf:"bytes,12,rep,name=uuids_to_reg_idx,json=uuidsToRegIdx,proto3" json:"uuids_to_reg_idx,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Pipeline) Reset()         { *m = Pipeline{} }
func (m *Pipeline) String() string { return proto.CompactTextString(m) }
func (*Pipeline) ProtoMessage()    {}
func (*Pipeline) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{25}
}
func (m *Pipeline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pipeline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pipeline.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pipeline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pipeline.Merge(m, src)
}
func (m *Pipeline) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Pipeline) XXX_DiscardUnknown() {
	xxx_messageInfo_Pipeline.DiscardUnknown(m)
}

var xxx_messageInfo_Pipeline proto.InternalMessageInfo

func (m *Pipeline) GetPipelineType() Pipeline_PipelineType {
	if m != nil {
		return m.PipelineType
	}
	return Pipeline_Merge
}

func (m *Pipeline) GetPipelineId() int32 {
	if m != nil {
		return m.PipelineId
	}
	return 0
}

func (m *Pipeline) GetQry() *plan.Plan {
	if m != nil {
		return m.Qry
	}
	return nil
}

func (m *Pipeline) GetDataSource() *Source {
	if m != nil {
		return m.DataSource
	}
	return nil
}

func (m *Pipeline) GetChildren() []*Pipeline {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *Pipeline) GetInstructionList() []*Instruction {
	if m != nil {
		return m.InstructionList
	}
	return nil
}

func (m *Pipeline) GetIsEnd() bool {
	if m != nil {
		return m.IsEnd
	}
	return false
}

func (m *Pipeline) GetIsJoin() bool {
	if m != nil {
		return m.IsJoin
	}
	return false
}

func (m *Pipeline) GetNode() *NodeInfo {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *Pipeline) GetPushDownInfo() int32 {
	if m != nil {
		return m.PushDownInfo
	}
	return 0
}

func (m *Pipeline) GetChildrenCount() int32 {
	if m != nil {
		return m.ChildrenCount
	}
	return 0
}

func (m *Pipeline) GetUuidsToRegIdx() []*UuidToRegIdx {
	if m != nil {
		return m.UuidsToRegIdx
	}
	return nil
}

type WrapNode struct {
	NodeAddr             string   `protobuf:"bytes,1,opt,name=node_addr,json=nodeAddr,proto3" json:"node_addr,omitempty"`
	Uuids                [][]byte `protobuf:"bytes,2,rep,name=uuids,proto3" json:"uuids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WrapNode) Reset()         { *m = WrapNode{} }
func (m *WrapNode) String() string { return proto.CompactTextString(m) }
func (*WrapNode) ProtoMessage()    {}
func (*WrapNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{26}
}
func (m *WrapNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WrapNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WrapNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WrapNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WrapNode.Merge(m, src)
}
func (m *WrapNode) XXX_Size() int {
	return m.ProtoSize()
}
func (m *WrapNode) XXX_DiscardUnknown() {
	xxx_messageInfo_WrapNode.DiscardUnknown(m)
}

var xxx_messageInfo_WrapNode proto.InternalMessageInfo

func (m *WrapNode) GetNodeAddr() string {
	if m != nil {
		return m.NodeAddr
	}
	return ""
}

func (m *WrapNode) GetUuids() [][]byte {
	if m != nil {
		return m.Uuids
	}
	return nil
}

type UuidToRegIdx struct {
	Uuid                 []byte   `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	Idx                  int32    `protobuf:"varint,2,opt,name=idx,proto3" json:"idx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UuidToRegIdx) Reset()         { *m = UuidToRegIdx{} }
func (m *UuidToRegIdx) String() string { return proto.CompactTextString(m) }
func (*UuidToRegIdx) ProtoMessage()    {}
func (*UuidToRegIdx) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{27}
}
func (m *UuidToRegIdx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UuidToRegIdx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UuidToRegIdx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UuidToRegIdx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UuidToRegIdx.Merge(m, src)
}
func (m *UuidToRegIdx) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UuidToRegIdx) XXX_DiscardUnknown() {
	xxx_messageInfo_UuidToRegIdx.DiscardUnknown(m)
}

var xxx_messageInfo_UuidToRegIdx proto.InternalMessageInfo

func (m *UuidToRegIdx) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *UuidToRegIdx) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func init() {
	proto.RegisterEnum("pipeline.Pipeline_PipelineType", Pipeline_PipelineType_name, Pipeline_PipelineType_value)
	proto.RegisterType((*Message)(nil), "pipeline.Message")
	proto.RegisterType((*Connector)(nil), "pipeline.Connector")
	proto.RegisterType((*Dispatch)(nil), "pipeline.Dispatch")
	proto.RegisterType((*Aggregate)(nil), "pipeline.Aggregate")
	proto.RegisterType((*Group)(nil), "pipeline.Group")
	proto.RegisterType((*Insert)(nil), "pipeline.Insert")
	proto.RegisterMapType((map[string]int32)(nil), "pipeline.Insert.ParentIdxEntry")
	proto.RegisterType((*Join)(nil), "pipeline.Join")
	proto.RegisterType((*AntiJoin)(nil), "pipeline.AntiJoin")
	proto.RegisterType((*InnerJoin)(nil), "pipeline.InnerJoin")
	proto.RegisterType((*LeftJoin)(nil), "pipeline.LeftJoin")
	proto.RegisterType((*SemiJoin)(nil), "pipeline.SemiJoin")
	proto.RegisterType((*SingleJoin)(nil), "pipeline.SingleJoin")
	proto.RegisterType((*MarkJoin)(nil), "pipeline.MarkJoin")
	proto.RegisterType((*Product)(nil), "pipeline.Product")
	proto.RegisterType((*TableFunction)(nil), "pipeline.TableFunction")
	proto.RegisterType((*HashBuild)(nil), "pipeline.HashBuild")
	proto.RegisterType((*ExternalName2ColIndex)(nil), "pipeline.ExternalName2ColIndex")
	proto.RegisterType((*ExternalScan)(nil), "pipeline.ExternalScan")
	proto.RegisterType((*Instruction)(nil), "pipeline.Instruction")
	proto.RegisterType((*AnalysisList)(nil), "pipeline.AnalysisList")
	proto.RegisterType((*Source)(nil), "pipeline.Source")
	proto.RegisterType((*NodeInfo)(nil), "pipeline.NodeInfo")
	proto.RegisterType((*ProcessLimitation)(nil), "pipeline.ProcessLimitation")
	proto.RegisterType((*ProcessInfo)(nil), "pipeline.ProcessInfo")
	proto.RegisterType((*SessionInfo)(nil), "pipeline.SessionInfo")
	proto.RegisterType((*Pipeline)(nil), "pipeline.Pipeline")
	proto.RegisterType((*WrapNode)(nil), "pipeline.WrapNode")
	proto.RegisterType((*UuidToRegIdx)(nil), "pipeline.UuidToRegIdx")
}

func init() { proto.RegisterFile("pipeline.proto", fileDescriptor_7ac67a7adf3df9c7) }

var fileDescriptor_7ac67a7adf3df9c7 = []byte{
	// 2351 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x19, 0x4d, 0x8f, 0x1c, 0x47,
	0x35, 0xf3, 0xdd, 0xfd, 0x66, 0xf6, 0xc3, 0x1d, 0x3b, 0x99, 0x38, 0x60, 0x9b, 0x86, 0x24, 0x86,
	0xc4, 0xbb, 0xca, 0x42, 0x50, 0x04, 0x24, 0xc1, 0x59, 0x3b, 0x61, 0x90, 0xe3, 0xac, 0x6a, 0x13,
	0x21, 0x45, 0x48, 0xad, 0xda, 0xee, 0x9a, 0x99, 0x8a, 0x7b, 0xaa, 0x3a, 0x55, 0x3d, 0xce, 0x6c,
	0x7e, 0x00, 0x07, 0xe0, 0x82, 0xf8, 0x03, 0x5c, 0x39, 0xf0, 0x13, 0x10, 0x27, 0x24, 0x24, 0x2e,
	0x1c, 0xb8, 0xe5, 0x82, 0x02, 0x47, 0x38, 0xf0, 0x0f, 0xd0, 0x7b, 0x55, 0xdd, 0xd3, 0xb3, 0xeb,
	0x4d, 0x22, 0xae, 0xf1, 0xad, 0xde, 0x47, 0x75, 0xd5, 0xfb, 0xac, 0xf7, 0x5e, 0xc3, 0x76, 0x21,
	0x0b, 0x91, 0x4b, 0x25, 0xf6, 0x0a, 0xa3, 0x4b, 0x1d, 0x05, 0x15, 0x7c, 0xf5, 0xd6, 0x4c, 0x96,
	0xf3, 0xe5, 0xc9, 0x5e, 0xaa, 0x17, 0xfb, 0x33, 0x3d, 0xd3, 0xfb, 0xc4, 0x70, 0xb2, 0x9c, 0x12,
	0x44, 0x00, 0xad, 0xdc, 0xc6, 0xab, 0x50, 0xe4, 0x5c, 0xf9, 0xf5, 0x4e, 0x29, 0x17, 0xc2, 0x96,
	0x7c, 0x51, 0x38, 0x44, 0xfc, 0xf7, 0x16, 0x0c, 0xde, 0x11, 0xd6, 0xf2, 0x99, 0x88, 0x76, 0xa1,
	0x63, 0x65, 0x36, 0x6e, 0xdd, 0x68, 0xdd, 0xec, 0x32, 0x5c, 0x22, 0x26, 0x5d, 0x64, 0xe3, 0xb6,
	0xc3, 0xa4, 0x0b, 0xc2, 0x08, 0x63, 0xc6, 0x9d, 0x1b, 0xad, 0x9b, 0x23, 0x86, 0xcb, 0x28, 0x82,
	0x6e, 0xc6, 0x4b, 0x3e, 0xee, 0x12, 0x8a, 0xd6, 0xd1, 0xb7, 0x60, 0xbb, 0x30, 0x3a, 0x4d, 0xa4,
	0x9a, 0xea, 0x84, 0xa8, 0x3d, 0xa2, 0x8e, 0x10, 0x3b, 0x51, 0x53, 0x7d, 0x07, 0xb9, 0xc6, 0x30,
	0xe0, 0x8a, 0xe7, 0xa7, 0x56, 0x8c, 0xfb, 0x44, 0xae, 0xc0, 0x68, 0x1b, 0xda, 0x32, 0x1b, 0x0f,
	0xe8, 0xd8, 0xb6, 0xcc, 0xf0, 0x8c, 0xe5, 0x52, 0x66, 0xe3, 0xc0, 0x9d, 0x81, 0xeb, 0xe8, 0x59,
	0x08, 0x4f, 0x78, 0x99, 0xce, 0x93, 0x54, 0x95, 0xe3, 0x90, 0x58, 0x03, 0x42, 0x1c, 0xaa, 0x32,
	0x7e, 0x1f, 0xc2, 0x43, 0xad, 0x94, 0x48, 0x4b, 0x6d, 0xa2, 0xeb, 0x30, 0xac, 0x74, 0x97, 0x78,
	0xf9, 0x7a, 0x0c, 0x2a, 0xd4, 0x24, 0x8b, 0x5e, 0x80, 0x9d, 0xb4, 0xe2, 0x4e, 0xa4, 0xca, 0xc4,
	0x8a, 0x44, 0xee, 0xb1, 0xed, 0x1a, 0x3d, 0x41, 0x6c, 0xfc, 0xfb, 0x16, 0x04, 0x77, 0xa4, 0x2d,
	0xf0, 0x18, 0x54, 0x05, 0xcf, 0x73, 0xfa, 0x5c, 0xc0, 0x70, 0x19, 0x3d, 0x03, 0x41, 0x6a, 0xb4,
	0xb5, 0x49, 0xaa, 0xe8, 0x03, 0x01, 0x1b, 0x10, 0x7c, 0xa8, 0xa2, 0x97, 0x21, 0xac, 0xbf, 0x35,
	0xee, 0xdc, 0xe8, 0xdc, 0x1c, 0x1e, 0x3c, 0xb9, 0x57, 0x5b, 0xb8, 0xbe, 0x2b, 0x5b, 0x73, 0x45,
	0xaf, 0xc1, 0xae, 0x11, 0x0b, 0x5d, 0x8a, 0x64, 0xbd, 0xb3, 0x4b, 0x3b, 0xa3, 0xf5, 0xce, 0x9f,
	0x19, 0x5e, 0xdc, 0xd7, 0x99, 0x60, 0x3b, 0x8e, 0xb7, 0xfe, 0x52, 0xfc, 0x2e, 0x84, 0xb7, 0x67,
	0x33, 0x23, 0x66, 0xbc, 0x24, 0x85, 0xea, 0xc2, 0x4b, 0xde, 0xd6, 0x05, 0x19, 0x4d, 0xda, 0xd2,
	0xdf, 0x92, 0xd6, 0xd1, 0x35, 0xe8, 0x8a, 0x55, 0xe1, 0x6c, 0x3b, 0x3c, 0x80, 0x3d, 0x72, 0x9b,
	0xbb, 0xab, 0xc2, 0x30, 0xc2, 0xc7, 0x7f, 0x6e, 0x41, 0xef, 0x6d, 0xa3, 0x97, 0x05, 0xaa, 0x5e,
	0x09, 0x91, 0x25, 0xe2, 0x21, 0xaf, 0xe4, 0x0f, 0x10, 0x71, 0xf7, 0x21, 0xcf, 0xd1, 0xaa, 0xf2,
	0x64, 0x99, 0x3e, 0x10, 0xa5, 0xf7, 0x9b, 0x0a, 0x44, 0x8a, 0xf2, 0x94, 0x8e, 0xa3, 0x78, 0x30,
	0xba, 0x01, 0x3d, 0x3c, 0xc2, 0x7a, 0xf9, 0x9a, 0x67, 0x3b, 0x02, 0x72, 0x94, 0xa7, 0x85, 0xb0,
	0xe3, 0x5e, 0x93, 0xe3, 0xbd, 0xd3, 0x42, 0x30, 0x47, 0x88, 0x5e, 0x80, 0x2e, 0x9f, 0xcd, 0xec,
	0xb8, 0x7f, 0x56, 0xb9, 0xb5, 0x16, 0x18, 0x31, 0xc4, 0xff, 0x6d, 0x43, 0x7f, 0xa2, 0xac, 0x30,
	0x65, 0x74, 0x15, 0x02, 0x3e, 0x9d, 0x8a, 0xb4, 0x14, 0x95, 0xdb, 0xd7, 0x30, 0xd2, 0x26, 0x96,
	0x91, 0x52, 0xbd, 0x9a, 0x6a, 0x18, 0x4d, 0x2f, 0xb3, 0x15, 0xd9, 0xb1, 0xc7, 0x70, 0x19, 0x7d,
	0x03, 0x3a, 0x46, 0x4c, 0x29, 0x08, 0x86, 0x07, 0x3b, 0xee, 0x76, 0xef, 0x9e, 0x7c, 0x28, 0xd2,
	0x92, 0x89, 0x29, 0x43, 0x5a, 0xf4, 0x22, 0x84, 0x25, 0x3f, 0xc9, 0x45, 0x92, 0x89, 0x29, 0xc5,
	0xc3, 0xf0, 0x60, 0xdb, 0x8b, 0x81, 0xe8, 0x3b, 0x62, 0xca, 0x82, 0xd2, 0xaf, 0xa2, 0xa7, 0x61,
	0x20, 0xb3, 0x55, 0x82, 0xa7, 0xf4, 0xe9, 0x94, 0xbe, 0xcc, 0x56, 0x93, 0x6c, 0x15, 0xbd, 0x0e,
	0x50, 0x70, 0x23, 0x54, 0x49, 0xb4, 0x01, 0x09, 0x7b, 0x7d, 0x2d, 0xac, 0x13, 0x6c, 0xef, 0x88,
	0x58, 0x26, 0xd9, 0xea, 0xae, 0x2a, 0xcd, 0x29, 0x0b, 0x8b, 0x0a, 0x8e, 0xbe, 0x0f, 0xa3, 0xc3,
	0x7c, 0x69, 0x4b, 0x61, 0xe8, 0x54, 0x0a, 0x29, 0xf2, 0x28, 0xbc, 0x48, 0x93, 0xc2, 0x36, 0xf8,
	0xae, 0xfe, 0x08, 0xb6, 0x37, 0x3f, 0x8a, 0x4a, 0x78, 0x20, 0x4e, 0x49, 0x6f, 0x21, 0xc3, 0x65,
	0x74, 0x19, 0x7a, 0x0f, 0x79, 0xbe, 0x14, 0x3e, 0x7a, 0x1c, 0xf0, 0x83, 0xf6, 0xab, 0xad, 0xf8,
	0x17, 0x6d, 0xe8, 0xfe, 0x54, 0x4b, 0xd5, 0xf4, 0x8e, 0xd6, 0x85, 0xde, 0xd1, 0xde, 0xf4, 0x8e,
	0x67, 0x20, 0x30, 0x22, 0x4f, 0x72, 0x74, 0x58, 0xa7, 0xf2, 0x81, 0x11, 0xf9, 0x3d, 0xf4, 0x59,
	0x8c, 0x38, 0xed, 0x49, 0x5d, 0x47, 0x4a, 0xb5, 0x23, 0x55, 0xee, 0xdc, 0x7b, 0xb4, 0x3b, 0xaf,
	0x3d, 0xaa, 0x7f, 0xb1, 0x47, 0x85, 0xb9, 0x98, 0x96, 0x18, 0x7e, 0x99, 0xd7, 0x74, 0xf3, 0x33,
	0x01, 0x12, 0x0f, 0xb5, 0xca, 0xa2, 0x6f, 0x03, 0x18, 0x39, 0x9b, 0x7b, 0xce, 0xe0, 0x1c, 0x67,
	0x48, 0x54, 0x64, 0x8d, 0xff, 0xdd, 0x82, 0xe0, 0xb6, 0x2a, 0xe5, 0xff, 0xad, 0x8c, 0xa7, 0xa0,
	0x6f, 0x84, 0x5d, 0xe6, 0x95, 0x2a, 0x3c, 0x54, 0x8b, 0xdb, 0xfd, 0x22, 0x71, 0x7b, 0x5f, 0x4a,
	0xdc, 0xfe, 0x97, 0x16, 0x77, 0xf0, 0x79, 0xe2, 0xfe, 0xaa, 0x0d, 0xe1, 0x44, 0x29, 0x61, 0x1e,
	0x1b, 0x5f, 0x65, 0xf1, 0x2f, 0xdb, 0x10, 0xdc, 0x13, 0xd3, 0xf2, 0xb1, 0x32, 0x7c, 0x24, 0x1c,
	0x8b, 0xc5, 0x57, 0x25, 0x12, 0x7e, 0xdd, 0x06, 0x38, 0x96, 0x6a, 0x96, 0x8b, 0xc7, 0xd6, 0x57,
	0x59, 0xfc, 0x9b, 0x36, 0x04, 0xef, 0x70, 0xf3, 0xe0, 0xab, 0x61, 0xfd, 0xe8, 0x9b, 0x30, 0xd0,
	0xca, 0x99, 0xe7, 0xbc, 0x5a, 0xfa, 0x5a, 0xa1, 0xa5, 0x62, 0x0e, 0x83, 0x23, 0xa3, 0xb3, 0x65,
	0xba, 0x69, 0xea, 0xd6, 0xc5, 0xa6, 0x6e, 0x6f, 0x9a, 0xba, 0x96, 0xad, 0x73, 0x81, 0x6c, 0xf1,
	0x6f, 0x5b, 0xb0, 0x45, 0xef, 0xf9, 0x5b, 0x4b, 0x95, 0x96, 0x52, 0x2b, 0x7c, 0xb3, 0x79, 0x59,
	0x1a, 0x4b, 0xc7, 0x84, 0xcc, 0x01, 0xd1, 0x0d, 0xe8, 0x1a, 0x51, 0x5a, 0x3a, 0x60, 0x78, 0x30,
	0xf2, 0xd5, 0x81, 0xce, 0xb1, 0x48, 0x21, 0x0a, 0xea, 0x99, 0x9b, 0xd9, 0x99, 0xa3, 0x9c, 0x9e,
	0x11, 0x8f, 0xf6, 0x29, 0xb8, 0xe1, 0x0b, 0xeb, 0x1b, 0x03, 0x0f, 0x61, 0xe5, 0xa9, 0xf8, 0x42,
	0x90, 0x3b, 0x86, 0x8c, 0xd6, 0xf1, 0x1f, 0x5b, 0x10, 0xfe, 0x84, 0xdb, 0xf9, 0x9b, 0x4b, 0x99,
	0x67, 0xeb, 0xea, 0x12, 0xcd, 0xd8, 0xac, 0x2e, 0xd1, 0x7c, 0x15, 0x71, 0xce, 0xed, 0xbc, 0x2a,
	0xcb, 0x10, 0x81, 0xdb, 0x9b, 0x7e, 0xd4, 0xb9, 0xd0, 0x8f, 0xba, 0xe7, 0x4a, 0xcf, 0x2f, 0xf0,
	0x87, 0x1b, 0xd0, 0x43, 0x03, 0xdb, 0x47, 0xf8, 0x82, 0x23, 0xc4, 0xb7, 0xe1, 0xca, 0xdd, 0x55,
	0x29, 0x8c, 0xe2, 0xf9, 0x7d, 0xbe, 0x10, 0x07, 0x87, 0x3a, 0xa7, 0x7e, 0xa1, 0x16, 0xb6, 0xb5,
	0x16, 0x16, 0x15, 0xde, 0x6c, 0x31, 0x1c, 0x10, 0xff, 0xb5, 0x05, 0xa3, 0xea, 0x1b, 0xc7, 0x29,
	0xff, 0x1c, 0xbb, 0xa4, 0x3a, 0xbf, 0xc0, 0x2e, 0x48, 0x89, 0xde, 0x86, 0x1d, 0x3c, 0xe6, 0x20,
	0x41, 0x27, 0x71, 0x07, 0x75, 0xce, 0x16, 0x89, 0x8f, 0xbc, 0x2c, 0xdb, 0x52, 0x1b, 0x77, 0xff,
	0x3a, 0x40, 0x6a, 0x04, 0x2f, 0x45, 0x62, 0x3f, 0xca, 0x49, 0x6b, 0x21, 0x0b, 0x1d, 0xe6, 0xf8,
	0xa3, 0x1c, 0x0d, 0x31, 0x95, 0xb9, 0x70, 0x7e, 0xd8, 0xa3, 0x3b, 0x06, 0x88, 0x20, 0x4f, 0xfe,
	0xd7, 0x00, 0x86, 0x13, 0x65, 0x4b, 0xb3, 0x74, 0x4e, 0x76, 0xb6, 0xfd, 0xf0, 0xf5, 0xb3, 0xd3,
	0x00, 0xd5, 0xcf, 0xcf, 0x43, 0x97, 0xab, 0x52, 0xfa, 0xe6, 0xa3, 0xd1, 0xe0, 0x54, 0xc5, 0x12,
	0x23, 0x7a, 0x74, 0x0b, 0x06, 0xbe, 0x1b, 0xf2, 0x11, 0xfe, 0xc8, 0x2e, 0xaa, 0xe2, 0x89, 0xf6,
	0x20, 0xc8, 0x7c, 0xbf, 0xe6, 0x13, 0x60, 0xe3, 0xd3, 0x55, 0x27, 0xc7, 0x6a, 0x1e, 0x2c, 0xe3,
	0xf9, 0x6c, 0x46, 0xed, 0x28, 0x95, 0xf1, 0x15, 0x2b, 0xf5, 0x3d, 0x0c, 0x69, 0xd1, 0x01, 0x80,
	0xc4, 0x8a, 0x26, 0xf9, 0x50, 0x4b, 0x45, 0x3d, 0xea, 0xc6, 0x25, 0xea, 0x6a, 0x87, 0x85, 0xb2,
	0x2e, 0x7c, 0xf6, 0x7d, 0x4a, 0xa1, 0x2d, 0xc1, 0xd9, 0x7b, 0x54, 0x25, 0x81, 0x4b, 0x2d, 0xd5,
	0x06, 0x2b, 0x16, 0xd2, 0x6d, 0x08, 0xcf, 0x6e, 0xa8, 0x9e, 0x4d, 0x16, 0xd8, 0xea, 0x01, 0x7d,
	0x05, 0x86, 0x96, 0x5e, 0x17, 0xb7, 0x05, 0x68, 0xcb, 0xe5, 0xc6, 0x96, 0xfa, 0xe9, 0x61, 0x60,
	0xd7, 0xcf, 0xd0, 0x3e, 0x84, 0x0b, 0x6e, 0x1e, 0xb8, 0x4d, 0xc3, 0xb3, 0xe7, 0x54, 0x09, 0x9a,
	0x05, 0x8b, 0x2a, 0x55, 0xc7, 0xd0, 0x25, 0xde, 0x51, 0xd5, 0xbf, 0x54, 0xbc, 0xce, 0x46, 0x48,
	0x8b, 0x5e, 0x84, 0x41, 0xe1, 0xf2, 0xd8, 0x78, 0x8b, 0xd8, 0x2e, 0xad, 0xd9, 0x7c, 0x82, 0x63,
	0x15, 0x47, 0xf4, 0x3a, 0x6c, 0xbb, 0xae, 0x68, 0xea, 0x33, 0xd2, 0x78, 0x9b, 0xf6, 0x3c, 0xbd,
	0xde, 0xb3, 0x91, 0xb0, 0xd8, 0x56, 0xb9, 0x91, 0xbf, 0x0e, 0x00, 0x30, 0x17, 0x24, 0x27, 0x98,
	0x3b, 0xc6, 0x3b, 0x67, 0xcd, 0x51, 0xa7, 0x15, 0x16, 0xce, 0xeb, 0x0c, 0xf3, 0x43, 0xd8, 0x12,
	0x3e, 0x04, 0x12, 0x9b, 0x72, 0x35, 0xde, 0xa5, 0x6d, 0x4f, 0x9d, 0x8f, 0x10, 0x0c, 0x45, 0x36,
	0x12, 0xcd, 0xc0, 0xbc, 0x09, 0x7d, 0x49, 0x4d, 0xd6, 0xf8, 0x12, 0xed, 0xda, 0x3d, 0xdb, 0x7c,
	0x31, 0x4f, 0x8f, 0x5e, 0x82, 0x40, 0x9b, 0x4c, 0x98, 0xe4, 0xe4, 0x74, 0x1c, 0x51, 0x0c, 0x5e,
	0xf2, 0x8d, 0x21, 0x62, 0xdf, 0x3c, 0x3d, 0x2e, 0x44, 0xca, 0x06, 0xda, 0x01, 0xd1, 0x2d, 0x18,
	0x15, 0x46, 0x63, 0xc7, 0xe8, 0x62, 0xea, 0xc9, 0x73, 0xd9, 0x66, 0xe8, 0xe9, 0x94, 0xeb, 0x63,
	0xe8, 0x4f, 0x65, 0x5e, 0x0a, 0x33, 0xbe, 0x7c, 0xee, 0xa5, 0xf3, 0x14, 0xcc, 0x21, 0xb9, 0x5c,
	0xc8, 0x72, 0x7c, 0x85, 0x72, 0x9e, 0x03, 0x30, 0x33, 0xeb, 0xe9, 0xd4, 0x8a, 0x72, 0xfc, 0x14,
	0xa1, 0x3d, 0x44, 0xd9, 0xd3, 0xbe, 0x25, 0x8d, 0x2d, 0xc7, 0x4f, 0xbb, 0xe1, 0x85, 0x07, 0x71,
	0x87, 0xb4, 0xf7, 0xb8, 0x2d, 0xc7, 0x63, 0x22, 0x78, 0x28, 0x7e, 0x05, 0x46, 0xb7, 0x69, 0x62,
	0x23, 0x2d, 0xdd, 0xe9, 0x39, 0xe8, 0xd6, 0x2f, 0x56, 0x2d, 0x2c, 0x71, 0x7c, 0x22, 0x26, 0x6a,
	0xaa, 0x19, 0x91, 0xe3, 0x3f, 0xb5, 0xa1, 0x7f, 0xac, 0x97, 0x26, 0x15, 0xd1, 0x75, 0x18, 0xda,
	0x74, 0x2e, 0x16, 0x3c, 0x69, 0xe4, 0x49, 0x70, 0x28, 0xcc, 0x4e, 0x98, 0x85, 0x9c, 0x7b, 0x10,
	0xbd, 0xed, 0xb2, 0x10, 0x61, 0x88, 0xdc, 0x7c, 0x0c, 0x3b, 0x94, 0x84, 0xea, 0xc7, 0xf0, 0x32,
	0xf4, 0x4e, 0x72, 0x9d, 0x3e, 0xf0, 0xa9, 0xcb, 0x01, 0x34, 0x0b, 0x5a, 0xda, 0x79, 0xa6, 0x3f,
	0x56, 0x89, 0xcc, 0x28, 0x27, 0x74, 0x19, 0x54, 0xa8, 0x09, 0xbe, 0xd4, 0x5b, 0x35, 0x03, 0xcf,
	0x32, 0x43, 0xb9, 0x20, 0x64, 0xa3, 0x0a, 0x79, 0x3b, 0xcb, 0x4c, 0x5d, 0x64, 0x0c, 0x2e, 0x28,
	0x32, 0xbe, 0x03, 0x75, 0x27, 0xef, 0xc3, 0xfd, 0xe2, 0x4e, 0xff, 0x00, 0xc2, 0x7a, 0x28, 0xe7,
	0x43, 0xfd, 0xf2, 0xde, 0x7a, 0x4c, 0xf7, 0x5e, 0xb5, 0x62, 0x6b, 0xb6, 0xf8, 0xe7, 0x10, 0xdc,
	0xd7, 0x19, 0xe9, 0x14, 0xdf, 0x98, 0x45, 0x5a, 0x2c, 0x7d, 0x76, 0xa5, 0xb5, 0x9f, 0x9f, 0x39,
	0x6d, 0xf9, 0xf9, 0x19, 0xc9, 0xd2, 0x71, 0xef, 0x10, 0xae, 0xd1, 0xdc, 0x05, 0x3f, 0xcd, 0x35,
	0xcf, 0xa8, 0x62, 0x0c, 0x59, 0x05, 0xc6, 0x7f, 0x68, 0xc1, 0xa5, 0x23, 0xa3, 0x53, 0x61, 0xed,
	0x3d, 0xf4, 0x18, 0x4e, 0x81, 0x16, 0x41, 0xd7, 0xca, 0x4f, 0x9c, 0x8d, 0x3a, 0x8c, 0xd6, 0x68,
	0x1d, 0x37, 0x83, 0x33, 0xfa, 0x63, 0x4b, 0xe7, 0x75, 0x98, 0x9b, 0xca, 0x31, 0xfd, 0xb1, 0x5d,
	0x93, 0x69, 0x63, 0xa7, 0x41, 0x3e, 0xc6, 0xdd, 0xcf, 0xc1, 0x76, 0xc1, 0x4d, 0x29, 0xf1, 0xf3,
	0xee, 0x0b, 0x5d, 0x62, 0xd9, 0xaa, 0xb1, 0xf4, 0x95, 0xeb, 0x30, 0x34, 0x82, 0x63, 0x1c, 0xd1,
	0x67, 0x7a, 0xc4, 0x03, 0x0e, 0x85, 0xdf, 0x89, 0xff, 0xd3, 0x82, 0xa1, 0xbf, 0x2f, 0x69, 0xc4,
	0x49, 0xdf, 0xaa, 0xa5, 0xbf, 0x05, 0x9d, 0x5c, 0x2e, 0xe8, 0x7a, 0xc3, 0x83, 0x67, 0x37, 0x72,
	0xd1, 0xa6, 0x8c, 0x0c, 0xf9, 0xf0, 0x65, 0x5b, 0x2a, 0xb9, 0x4a, 0x50, 0xdd, 0xfe, 0xd2, 0x01,
	0x22, 0xd0, 0x12, 0xd1, 0x55, 0x08, 0xac, 0xe2, 0x85, 0x9d, 0xeb, 0xd2, 0x3b, 0x56, 0x0d, 0x47,
	0xaf, 0xc2, 0xc8, 0x0a, 0x6b, 0x51, 0x1a, 0xa9, 0xa6, 0xda, 0x3f, 0x38, 0x57, 0x9a, 0x79, 0x9b,
	0xa8, 0x14, 0x0a, 0x43, 0xbb, 0x06, 0xa2, 0x97, 0x20, 0xe2, 0x3e, 0x90, 0x12, 0xa5, 0x33, 0xff,
	0xaa, 0xba, 0xc1, 0xcf, 0x6e, 0x45, 0x41, 0x8b, 0xd3, 0xeb, 0xfa, 0x69, 0x0b, 0x86, 0x8d, 0x4f,
	0xd1, 0x74, 0xd4, 0x0a, 0x53, 0x55, 0x19, 0xb8, 0x46, 0xdc, 0x5c, 0xfb, 0x01, 0x5f, 0xc8, 0x68,
	0x8d, 0x38, 0xa3, 0x73, 0x51, 0x79, 0x01, 0xae, 0xd1, 0xdd, 0xfd, 0x5b, 0x49, 0xd7, 0xce, 0x7c,
	0x79, 0x34, 0x5a, 0x23, 0x27, 0x34, 0x0a, 0xcb, 0x78, 0xc9, 0x4f, 0xb8, 0xad, 0xea, 0xb6, 0x1a,
	0x46, 0x37, 0x7a, 0x28, 0x0c, 0xde, 0xc5, 0x47, 0x4a, 0x05, 0xa2, 0x1e, 0x51, 0x85, 0xc9, 0x27,
	0x5a, 0x09, 0x8a, 0x94, 0x11, 0x0b, 0x10, 0xf1, 0x81, 0x56, 0xb4, 0x8d, 0xa7, 0xa9, 0x5e, 0xaa,
	0x92, 0x02, 0x24, 0x64, 0x15, 0x18, 0x7f, 0xda, 0x85, 0xe0, 0xc8, 0x6b, 0x2c, 0xba, 0x03, 0x5b,
	0xf5, 0xe8, 0x16, 0xab, 0x31, 0x92, 0x71, 0xbb, 0x59, 0xcb, 0x1c, 0x9d, 0x5d, 0x50, 0xe9, 0x36,
	0x2a, 0x1a, 0xd0, 0xd9, 0x01, 0x70, 0xfb, 0xdc, 0x00, 0xf8, 0x6b, 0xd0, 0xf9, 0xc8, 0x9c, 0x6e,
	0x4e, 0x3e, 0x8f, 0x72, 0xae, 0x18, 0xa2, 0xa3, 0x97, 0x61, 0x88, 0xe2, 0x26, 0x96, 0x72, 0x96,
	0xaf, 0x3b, 0x1a, 0x69, 0xdf, 0xe5, 0x32, 0x06, 0xc8, 0xe4, 0xf3, 0xda, 0x1e, 0x04, 0xe9, 0x5c,
	0xe6, 0x99, 0x11, 0xca, 0x17, 0x96, 0xd1, 0xf9, 0x2b, 0xb3, 0x9a, 0x27, 0xfa, 0x31, 0xec, 0xca,
	0x75, 0xbd, 0xb4, 0x36, 0xff, 0x86, 0xfb, 0x34, 0x2a, 0x2a, 0xb6, 0xd3, 0x60, 0xa7, 0x74, 0x77,
	0x05, 0x73, 0x74, 0x22, 0x94, 0x1b, 0x9b, 0x07, 0xac, 0x27, 0xed, 0x5d, 0x95, 0xd1, 0x1c, 0xd1,
	0xae, 0xeb, 0x0e, 0xca, 0xdd, 0xf4, 0x90, 0x3f, 0x0f, 0x5d, 0xf4, 0xb4, 0xf3, 0xc5, 0x45, 0x95,
	0x58, 0x18, 0xd1, 0x69, 0x94, 0xbf, 0xb4, 0xf3, 0xc4, 0x65, 0x4c, 0x74, 0x6b, 0x20, 0xf5, 0x51,
	0x42, 0xbc, 0x83, 0x39, 0x13, 0x5d, 0xf0, 0x39, 0xd8, 0xae, 0x64, 0x49, 0x9c, 0x55, 0x87, 0xc4,
	0xb5, 0x55, 0x61, 0x0f, 0x11, 0x19, 0xbd, 0x01, 0xbb, 0xcb, 0xa5, 0xcc, 0x6c, 0x52, 0xea, 0xc4,
	0x88, 0x19, 0x8d, 0x30, 0x47, 0x24, 0x66, 0xe3, 0xed, 0x7d, 0x7f, 0x29, 0xb3, 0xf7, 0x34, 0x13,
	0xb3, 0x49, 0xb6, 0x62, 0x5b, 0xc4, 0x5f, 0x81, 0xf1, 0x1b, 0x30, 0x6a, 0xda, 0x39, 0x0a, 0xa1,
	0xf7, 0x8e, 0x30, 0x33, 0xb1, 0xfb, 0x44, 0x04, 0xd0, 0xbf, 0xaf, 0xcd, 0x82, 0xe7, 0xbb, 0x2d,
	0x5c, 0xbb, 0x49, 0xed, 0x6e, 0x3b, 0x1a, 0x41, 0x70, 0xc4, 0x0d, 0xcf, 0x73, 0x91, 0xef, 0x76,
	0xe2, 0xd7, 0x20, 0xa8, 0x46, 0xe6, 0xd4, 0x4b, 0x60, 0xb0, 0x51, 0x6a, 0x74, 0xc1, 0x13, 0x20,
	0x82, 0x52, 0xfc, 0x65, 0xe8, 0xd1, 0xd1, 0x54, 0x6a, 0x8f, 0x98, 0x03, 0xe2, 0xef, 0xc1, 0xa8,
	0x79, 0xbd, 0xfa, 0xc7, 0x44, 0xab, 0xf1, 0x63, 0xe2, 0x5c, 0x71, 0xfb, 0xe6, 0xe1, 0x5f, 0x3e,
	0xbb, 0xd6, 0xfa, 0xdb, 0x67, 0xd7, 0x5a, 0xff, 0xf8, 0xec, 0xda, 0x13, 0xbf, 0xfb, 0xe7, 0xb5,
	0xd6, 0x07, 0x2f, 0x37, 0x7e, 0xe1, 0x2c, 0x78, 0x69, 0xe4, 0x4a, 0x1b, 0x39, 0x93, 0xaa, 0x02,
	0x94, 0xd8, 0x2f, 0x1e, 0xcc, 0xf6, 0x8b, 0x93, 0xfd, 0x4a, 0x2d, 0x27, 0x7d, 0xfa, 0x61, 0xf3,
	0xdd, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x1b, 0xe4, 0xca, 0xbd, 0x18, 0x1a, 0x00, 0x00,
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BatchCnt != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.BatchCnt))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x42
	}
	if m.Id != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Analyse) > 0 {
		i -= len(m.Analyse)
		copy(dAtA[i:], m.Analyse)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Analyse)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ProcInfoData) > 0 {
		i -= len(m.ProcInfoData)
		copy(dAtA[i:], m.ProcInfoData)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.ProcInfoData)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Err) > 0 {
		i -= len(m.Err)
		copy(dAtA[i:], m.Err)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Err)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Cmd != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x10
	}
	if m.Sid != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Sid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Connector) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Connector) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Connector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ConnectorIndex != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ConnectorIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.PipelineId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PipelineId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Dispatch) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dispatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dispatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RemoteConnector) > 0 {
		for iNdEx := len(m.RemoteConnector) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RemoteConnector[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Connector) > 0 {
		for iNdEx := len(m.Connector) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Connector[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.CrossCn {
		i--
		if m.CrossCn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.All {
		i--
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Aggregate) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Aggregate) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Aggregate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Dist {
		i--
		if m.Dist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Op != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Group) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Group) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Group) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Aggs) > 0 {
		for iNdEx := len(m.Aggs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Aggs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Exprs) > 0 {
		for iNdEx := len(m.Exprs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Exprs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Nbucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Nbucket))
		i--
		dAtA[i] = 0x18
	}
	if m.Ibucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Ibucket))
		i--
		dAtA[i] = 0x10
	}
	if m.NeedEval {
		i--
		if m.NeedEval {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Insert) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Insert) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Insert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ClusterTable != nil {
		{
			size, err := m.ClusterTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.ParentIdx) > 0 {
		for k := range m.ParentIdx {
			v := m.ParentIdx[k]
			baseI := i
			i = encodeVarintPipeline(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPipeline(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPipeline(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.IdxIdx) > 0 {
		dAtA4 := make([]byte, len(m.IdxIdx)*10)
		var j3 int
		for _, num1 := range m.IdxIdx {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintPipeline(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x32
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Ref != nil {
		{
			size, err := m.Ref.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Idx) > 0 {
		dAtA8 := make([]byte, len(m.Idx)*10)
		var j7 int
		for _, num1 := range m.Idx {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintPipeline(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x1a
	}
	if m.IsRemote {
		i--
		if m.IsRemote {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Affected != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Affected))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Join) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Join) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Join) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ColList) > 0 {
		dAtA11 := make([]byte, len(m.ColList)*10)
		var j10 int
		for _, num1 := range m.ColList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintPipeline(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RelList) > 0 {
		dAtA13 := make([]byte, len(m.RelList)*10)
		var j12 int
		for _, num1 := range m.RelList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintPipeline(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0x1a
	}
	if m.Nbucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Nbucket))
		i--
		dAtA[i] = 0x10
	}
	if m.Ibucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Ibucket))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AntiJoin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AntiJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AntiJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Result) > 0 {
		dAtA16 := make([]byte, len(m.Result)*10)
		var j15 int
		for _, num1 := range m.Result {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		i -= j15
		copy(dAtA[i:], dAtA16[:j15])
		i = encodeVarintPipeline(dAtA, i, uint64(j15))
		i--
		dAtA[i] = 0x1a
	}
	if m.Nbucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Nbucket))
		i--
		dAtA[i] = 0x10
	}
	if m.Ibucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Ibucket))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InnerJoin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InnerJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InnerJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ColList) > 0 {
		dAtA19 := make([]byte, len(m.ColList)*10)
		var j18 int
		for _, num1 := range m.ColList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		i -= j18
		copy(dAtA[i:], dAtA19[:j18])
		i = encodeVarintPipeline(dAtA, i, uint64(j18))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RelList) > 0 {
		dAtA21 := make([]byte, len(m.RelList)*10)
		var j20 int
		for _, num1 := range m.RelList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		i -= j20
		copy(dAtA[i:], dAtA21[:j20])
		i = encodeVarintPipeline(dAtA, i, uint64(j20))
		i--
		dAtA[i] = 0x1a
	}
	if m.Nbucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Nbucket))
		i--
		dAtA[i] = 0x10
	}
	if m.Ibucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Ibucket))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LeftJoin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeftJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeftJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ColList) > 0 {
		dAtA24 := make([]byte, len(m.ColList)*10)
		var j23 int
		for _, num1 := range m.ColList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA24[j23] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j23++
			}
			dAtA24[j23] = uint8(num)
			j23++
		}
		i -= j23
		copy(dAtA[i:], dAtA24[:j23])
		i = encodeVarintPipeline(dAtA, i, uint64(j23))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RelList) > 0 {
		dAtA26 := make([]byte, len(m.RelList)*10)
		var j25 int
		for _, num1 := range m.RelList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA26[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA26[j25] = uint8(num)
			j25++
		}
		i -= j25
		copy(dAtA[i:], dAtA26[:j25])
		i = encodeVarintPipeline(dAtA, i, uint64(j25))
		i--
		dAtA[i] = 0x1a
	}
	if m.Nbucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Nbucket))
		i--
		dAtA[i] = 0x10
	}
	if m.Ibucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Ibucket))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SemiJoin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SemiJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SemiJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Result) > 0 {
		dAtA29 := make([]byte, len(m.Result)*10)
		var j28 int
		for _, num1 := range m.Result {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		i -= j28
		copy(dAtA[i:], dAtA29[:j28])
		i = encodeVarintPipeline(dAtA, i, uint64(j28))
		i--
		dAtA[i] = 0x1a
	}
	if m.Nbucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Nbucket))
		i--
		dAtA[i] = 0x10
	}
	if m.Ibucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Ibucket))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SingleJoin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SingleJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SingleJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ColList) > 0 {
		dAtA32 := make([]byte, len(m.ColList)*10)
		var j31 int
		for _, num1 := range m.ColList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA32[j31] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j31++
			}
			dAtA32[j31] = uint8(num)
			j31++
		}
		i -= j31
		copy(dAtA[i:], dAtA32[:j31])
		i = encodeVarintPipeline(dAtA, i, uint64(j31))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RelList) > 0 {
		dAtA34 := make([]byte, len(m.RelList)*10)
		var j33 int
		for _, num1 := range m.RelList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA34[j33] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j33++
			}
			dAtA34[j33] = uint8(num)
			j33++
		}
		i -= j33
		copy(dAtA[i:], dAtA34[:j33])
		i = encodeVarintPipeline(dAtA, i, uint64(j33))
		i--
		dAtA[i] = 0x1a
	}
	if m.Nbucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Nbucket))
		i--
		dAtA[i] = 0x10
	}
	if m.Ibucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Ibucket))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MarkJoin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarkJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OnList) > 0 {
		for iNdEx := len(m.OnList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OnList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Result) > 0 {
		dAtA37 := make([]byte, len(m.Result)*10)
		var j36 int
		for _, num1 := range m.Result {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA37[j36] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j36++
			}
			dAtA37[j36] = uint8(num)
			j36++
		}
		i -= j36
		copy(dAtA[i:], dAtA37[:j36])
		i = encodeVarintPipeline(dAtA, i, uint64(j36))
		i--
		dAtA[i] = 0x1a
	}
	if m.Nbucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Nbucket))
		i--
		dAtA[i] = 0x10
	}
	if m.Ibucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Ibucket))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Product) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Product) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Product) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ColList) > 0 {
		dAtA39 := make([]byte, len(m.ColList)*10)
		var j38 int
		for _, num1 := range m.ColList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA39[j38] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j38++
			}
			dAtA39[j38] = uint8(num)
			j38++
		}
		i -= j38
		copy(dAtA[i:], dAtA39[:j38])
		i = encodeVarintPipeline(dAtA, i, uint64(j38))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RelList) > 0 {
		dAtA41 := make([]byte, len(m.RelList)*10)
		var j40 int
		for _, num1 := range m.RelList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA41[j40] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j40++
			}
			dAtA41[j40] = uint8(num)
			j40++
		}
		i -= j40
		copy(dAtA[i:], dAtA41[:j40])
		i = encodeVarintPipeline(dAtA, i, uint64(j40))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableFunction) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableFunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableFunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Params) > 0 {
		i -= len(m.Params)
		copy(dAtA[i:], m.Params)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Params)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Args[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Rets) > 0 {
		for iNdEx := len(m.Rets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Attrs) > 0 {
		for iNdEx := len(m.Attrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Attrs[iNdEx])
			copy(dAtA[i:], m.Attrs[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.Attrs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *HashBuild) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HashBuild) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HashBuild) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Conds) > 0 {
		for iNdEx := len(m.Conds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Nbucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Nbucket))
		i--
		dAtA[i] = 0x20
	}
	if m.Ibucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Ibucket))
		i--
		dAtA[i] = 0x18
	}
	if m.NeedHash {
		i--
		if m.NeedHash {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.NeedExpr {
		i--
		if m.NeedExpr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExternalName2ColIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalName2ColIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalName2ColIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Index != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExternalScan) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalScan) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalScan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FileList) > 0 {
		for iNdEx := len(m.FileList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FileList[iNdEx])
			copy(dAtA[i:], m.FileList[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.FileList[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.CreateSql) > 0 {
		i -= len(m.CreateSql)
		copy(dAtA[i:], m.CreateSql)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.CreateSql)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name2ColIndex) > 0 {
		for iNdEx := len(m.Name2ColIndex) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Name2ColIndex[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Cols) > 0 {
		for iNdEx := len(m.Cols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Attrs) > 0 {
		for iNdEx := len(m.Attrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Attrs[iNdEx])
			copy(dAtA[i:], m.Attrs[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.Attrs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Instruction) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Instruction) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Instruction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsLast {
		i--
		if m.IsLast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.IsFirst {
		i--
		if m.IsFirst {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.Offset != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.Limit != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.ProjectList) > 0 {
		for iNdEx := len(m.ProjectList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProjectList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.OrderBy) > 0 {
		for iNdEx := len(m.OrderBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OrderBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if m.Insert != nil {
		{
			size, err := m.Insert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.ExternalScan != nil {
		{
			size, err := m.ExternalScan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.HashBuild != nil {
		{
			size, err := m.HashBuild.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.TableFunction != nil {
		{
			size, err := m.TableFunction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Product != nil {
		{
			size, err := m.Product.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Join != nil {
		{
			size, err := m.Join.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.MarkJoin != nil {
		{
			size, err := m.MarkJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.SingleJoin != nil {
		{
			size, err := m.SingleJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.SemiJoin != nil {
		{
			size, err := m.SemiJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.LeftJoin != nil {
		{
			size, err := m.LeftJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.InnerJoin != nil {
		{
			size, err := m.InnerJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Agg != nil {
		{
			size, err := m.Agg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Dispatch != nil {
		{
			size, err := m.Dispatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Connect != nil {
		{
			size, err := m.Connect.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Anti != nil {
		{
			size, err := m.Anti.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Idx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Idx))
		i--
		dAtA[i] = 0x10
	}
	if m.Op != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AnalysisList) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalysisList) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnalysisList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Source) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Source) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Source) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PushdownAddr) > 0 {
		i -= len(m.PushdownAddr)
		copy(dAtA[i:], m.PushdownAddr)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.PushdownAddr)))
		i--
		dAtA[i] = 0x32
	}
	if m.PushdownId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PushdownId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Block) > 0 {
		i -= len(m.Block)
		copy(dAtA[i:], m.Block)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Block)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ColList) > 0 {
		for iNdEx := len(m.ColList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ColList[iNdEx])
			copy(dAtA[i:], m.ColList[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.ColList[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SchemaName) > 0 {
		i -= len(m.SchemaName)
		copy(dAtA[i:], m.SchemaName)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.SchemaName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Payload) > 0 {
		for iNdEx := len(m.Payload) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Payload[iNdEx])
			copy(dAtA[i:], m.Payload[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.Payload[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if m.Mcpu != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Mcpu))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProcessLimitation) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessLimitation) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessLimitation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReaderSize != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ReaderSize))
		i--
		dAtA[i] = 0x28
	}
	if m.PartitionRows != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PartitionRows))
		i--
		dAtA[i] = 0x20
	}
	if m.BatchSize != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.BatchSize))
		i--
		dAtA[i] = 0x18
	}
	if m.BatchRows != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.BatchRows))
		i--
		dAtA[i] = 0x10
	}
	if m.Size != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Size))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProcessInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AnalysisNodeList) > 0 {
		dAtA62 := make([]byte, len(m.AnalysisNodeList)*10)
		var j61 int
		for _, num1 := range m.AnalysisNodeList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA62[j61] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j61++
			}
			dAtA62[j61] = uint8(num)
			j61++
		}
		i -= j61
		copy(dAtA[i:], dAtA62[:j61])
		i = encodeVarintPipeline(dAtA, i, uint64(j61))
		i--
		dAtA[i] = 0x32
	}
	if m.SessionInfo != nil {
		{
			size, err := m.SessionInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Snapshot) > 0 {
		i -= len(m.Snapshot)
		copy(dAtA[i:], m.Snapshot)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Snapshot)))
		i--
		dAtA[i] = 0x22
	}
	if m.UnixTime != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.UnixTime))
		i--
		dAtA[i] = 0x18
	}
	if m.Lim != nil {
		{
			size, err := m.Lim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SessionInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.TimeZone) > 0 {
		i -= len(m.TimeZone)
		copy(dAtA[i:], m.TimeZone)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.TimeZone)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ConnectionId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ConnectionId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Pipeline) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pipeline) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pipeline) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UuidsToRegIdx) > 0 {
		for iNdEx := len(m.UuidsToRegIdx) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UuidsToRegIdx[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.ChildrenCount != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ChildrenCount))
		i--
		dAtA[i] = 0x58
	}
	if m.PushDownInfo != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PushDownInfo))
		i--
		dAtA[i] = 0x50
	}
	if m.Node != nil {
		{
			size, err := m.Node.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.IsJoin {
		i--
		if m.IsJoin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.IsEnd {
		i--
		if m.IsEnd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.InstructionList) > 0 {
		for iNdEx := len(m.InstructionList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InstructionList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.DataSource != nil {
		{
			size, err := m.DataSource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Qry != nil {
		{
			size, err := m.Qry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PipelineId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PipelineId))
		i--
		dAtA[i] = 0x10
	}
	if m.PipelineType != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PipelineType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WrapNode) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WrapNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WrapNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Uuids) > 0 {
		for iNdEx := len(m.Uuids) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Uuids[iNdEx])
			copy(dAtA[i:], m.Uuids[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.Uuids[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.NodeAddr) > 0 {
		i -= len(m.NodeAddr)
		copy(dAtA[i:], m.NodeAddr)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.NodeAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UuidToRegIdx) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UuidToRegIdx) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UuidToRegIdx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Idx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Idx))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPipeline(dAtA []byte, offset int, v uint64) int {
	offset -= sovPipeline(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Message) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sid != 0 {
		n += 1 + sovPipeline(uint64(m.Sid))
	}
	if m.Cmd != 0 {
		n += 1 + sovPipeline(uint64(m.Cmd))
	}
	l = len(m.Err)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.ProcInfoData)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Analyse)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovPipeline(uint64(m.Id))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.BatchCnt != 0 {
		n += 1 + sovPipeline(uint64(m.BatchCnt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Connector) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PipelineId != 0 {
		n += 1 + sovPipeline(uint64(m.PipelineId))
	}
	if m.ConnectorIndex != 0 {
		n += 1 + sovPipeline(uint64(m.ConnectorIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Dispatch) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.All {
		n += 2
	}
	if m.CrossCn {
		n += 2
	}
	if len(m.Connector) > 0 {
		for _, e := range m.Connector {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RemoteConnector) > 0 {
		for _, e := range m.RemoteConnector {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Aggregate) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovPipeline(uint64(m.Op))
	}
	if m.Dist {
		n += 2
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Group) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NeedEval {
		n += 2
	}
	if m.Ibucket != 0 {
		n += 1 + sovPipeline(uint64(m.Ibucket))
	}
	if m.Nbucket != 0 {
		n += 1 + sovPipeline(uint64(m.Nbucket))
	}
	if len(m.Exprs) > 0 {
		for _, e := range m.Exprs {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.Aggs) > 0 {
		for _, e := range m.Aggs {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Insert) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Affected != 0 {
		n += 1 + sovPipeline(uint64(m.Affected))
	}
	if m.IsRemote {
		n += 2
	}
	if len(m.Idx) > 0 {
		l = 0
		for _, e := range m.Idx {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Ref != nil {
		l = m.Ref.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.IdxIdx) > 0 {
		l = 0
		for _, e := range m.IdxIdx {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.ParentIdx) > 0 {
		for k, v := range m.ParentIdx {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPipeline(uint64(len(k))) + 1 + sovPipeline(uint64(v))
			n += mapEntrySize + 1 + sovPipeline(uint64(mapEntrySize))
		}
	}
	if m.ClusterTable != nil {
		l = m.ClusterTable.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Join) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ibucket != 0 {
		n += 1 + sovPipeline(uint64(m.Ibucket))
	}
	if m.Nbucket != 0 {
		n += 1 + sovPipeline(uint64(m.Nbucket))
	}
	if len(m.RelList) > 0 {
		l = 0
		for _, e := range m.RelList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.ColList) > 0 {
		l = 0
		for _, e := range m.ColList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AntiJoin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ibucket != 0 {
		n += 1 + sovPipeline(uint64(m.Ibucket))
	}
	if m.Nbucket != 0 {
		n += 1 + sovPipeline(uint64(m.Nbucket))
	}
	if len(m.Result) > 0 {
		l = 0
		for _, e := range m.Result {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InnerJoin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ibucket != 0 {
		n += 1 + sovPipeline(uint64(m.Ibucket))
	}
	if m.Nbucket != 0 {
		n += 1 + sovPipeline(uint64(m.Nbucket))
	}
	if len(m.RelList) > 0 {
		l = 0
		for _, e := range m.RelList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.ColList) > 0 {
		l = 0
		for _, e := range m.ColList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LeftJoin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ibucket != 0 {
		n += 1 + sovPipeline(uint64(m.Ibucket))
	}
	if m.Nbucket != 0 {
		n += 1 + sovPipeline(uint64(m.Nbucket))
	}
	if len(m.RelList) > 0 {
		l = 0
		for _, e := range m.RelList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.ColList) > 0 {
		l = 0
		for _, e := range m.ColList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SemiJoin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ibucket != 0 {
		n += 1 + sovPipeline(uint64(m.Ibucket))
	}
	if m.Nbucket != 0 {
		n += 1 + sovPipeline(uint64(m.Nbucket))
	}
	if len(m.Result) > 0 {
		l = 0
		for _, e := range m.Result {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SingleJoin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ibucket != 0 {
		n += 1 + sovPipeline(uint64(m.Ibucket))
	}
	if m.Nbucket != 0 {
		n += 1 + sovPipeline(uint64(m.Nbucket))
	}
	if len(m.RelList) > 0 {
		l = 0
		for _, e := range m.RelList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.ColList) > 0 {
		l = 0
		for _, e := range m.ColList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MarkJoin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ibucket != 0 {
		n += 1 + sovPipeline(uint64(m.Ibucket))
	}
	if m.Nbucket != 0 {
		n += 1 + sovPipeline(uint64(m.Nbucket))
	}
	if len(m.Result) > 0 {
		l = 0
		for _, e := range m.Result {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.OnList) > 0 {
		for _, e := range m.OnList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Product) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RelList) > 0 {
		l = 0
		for _, e := range m.RelList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.ColList) > 0 {
		l = 0
		for _, e := range m.ColList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableFunction) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attrs) > 0 {
		for _, s := range m.Attrs {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.Rets) > 0 {
		for _, e := range m.Rets {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.Args) > 0 {
		for _, e := range m.Args {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	l = len(m.Params)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HashBuild) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NeedExpr {
		n += 2
	}
	if m.NeedHash {
		n += 2
	}
	if m.Ibucket != 0 {
		n += 1 + sovPipeline(uint64(m.Ibucket))
	}
	if m.Nbucket != 0 {
		n += 1 + sovPipeline(uint64(m.Nbucket))
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.Conds) > 0 {
		for _, e := range m.Conds {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExternalName2ColIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovPipeline(uint64(m.Index))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExternalScan) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attrs) > 0 {
		for _, s := range m.Attrs {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.Cols) > 0 {
		for _, e := range m.Cols {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.Name2ColIndex) > 0 {
		for _, e := range m.Name2ColIndex {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	l = len(m.CreateSql)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.FileList) > 0 {
		for _, s := range m.FileList {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Instruction) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovPipeline(uint64(m.Op))
	}
	if m.Idx != 0 {
		n += 1 + sovPipeline(uint64(m.Idx))
	}
	if m.Anti != nil {
		l = m.Anti.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Connect != nil {
		l = m.Connect.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Dispatch != nil {
		l = m.Dispatch.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Agg != nil {
		l = m.Agg.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.InnerJoin != nil {
		l = m.InnerJoin.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.LeftJoin != nil {
		l = m.LeftJoin.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.SemiJoin != nil {
		l = m.SemiJoin.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.SingleJoin != nil {
		l = m.SingleJoin.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.MarkJoin != nil {
		l = m.MarkJoin.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Join != nil {
		l = m.Join.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Product != nil {
		l = m.Product.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.TableFunction != nil {
		l = m.TableFunction.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.HashBuild != nil {
		l = m.HashBuild.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.ExternalScan != nil {
		l = m.ExternalScan.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.Insert != nil {
		l = m.Insert.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if len(m.OrderBy) > 0 {
		for _, e := range m.OrderBy {
			l = e.ProtoSize()
			n += 2 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.ProjectList) > 0 {
		for _, e := range m.ProjectList {
			l = e.ProtoSize()
			n += 2 + l + sovPipeline(uint64(l))
		}
	}
	if m.Filter != nil {
		l = m.Filter.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.Limit != 0 {
		n += 2 + sovPipeline(uint64(m.Limit))
	}
	if m.Offset != 0 {
		n += 2 + sovPipeline(uint64(m.Offset))
	}
	if m.IsFirst {
		n += 3
	}
	if m.IsLast {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnalysisList) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Source) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SchemaName)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.ColList) > 0 {
		for _, s := range m.ColList {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	l = len(m.Block)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.PushdownId != 0 {
		n += 1 + sovPipeline(uint64(m.PushdownId))
	}
	l = len(m.PushdownAddr)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mcpu != 0 {
		n += 1 + sovPipeline(uint64(m.Mcpu))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Payload) > 0 {
		for _, s := range m.Payload {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProcessLimitation) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Size != 0 {
		n += 1 + sovPipeline(uint64(m.Size))
	}
	if m.BatchRows != 0 {
		n += 1 + sovPipeline(uint64(m.BatchRows))
	}
	if m.BatchSize != 0 {
		n += 1 + sovPipeline(uint64(m.BatchSize))
	}
	if m.PartitionRows != 0 {
		n += 1 + sovPipeline(uint64(m.PartitionRows))
	}
	if m.ReaderSize != 0 {
		n += 1 + sovPipeline(uint64(m.ReaderSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProcessInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Lim != nil {
		l = m.Lim.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.UnixTime != 0 {
		n += 1 + sovPipeline(uint64(m.UnixTime))
	}
	l = len(m.Snapshot)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.SessionInfo != nil {
		l = m.SessionInfo.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.AnalysisNodeList) > 0 {
		l = 0
		for _, e := range m.AnalysisNodeList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.ConnectionId != 0 {
		n += 1 + sovPipeline(uint64(m.ConnectionId))
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.TimeZone)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Pipeline) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PipelineType != 0 {
		n += 1 + sovPipeline(uint64(m.PipelineType))
	}
	if m.PipelineId != 0 {
		n += 1 + sovPipeline(uint64(m.PipelineId))
	}
	if m.Qry != nil {
		l = m.Qry.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.DataSource != nil {
		l = m.DataSource.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.InstructionList) > 0 {
		for _, e := range m.InstructionList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.IsEnd {
		n += 2
	}
	if m.IsJoin {
		n += 2
	}
	if m.Node != nil {
		l = m.Node.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.PushDownInfo != 0 {
		n += 1 + sovPipeline(uint64(m.PushDownInfo))
	}
	if m.ChildrenCount != 0 {
		n += 1 + sovPipeline(uint64(m.ChildrenCount))
	}
	if len(m.UuidsToRegIdx) > 0 {
		for _, e := range m.UuidsToRegIdx {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WrapNode) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeAddr)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Uuids) > 0 {
		for _, b := range m.Uuids {
			l = len(b)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UuidToRegIdx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Idx != 0 {
		n += 1 + sovPipeline(uint64(m.Idx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPipeline(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPipeline(x uint64) (n int) {
	return sovPipeline(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Err = append(m.Err[:0], dAtA[iNdEx:postIndex]...)
			if m.Err == nil {
				m.Err = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcInfoData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcInfoData = append(m.ProcInfoData[:0], dAtA[iNdEx:postIndex]...)
			if m.ProcInfoData == nil {
				m.ProcInfoData = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Analyse", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Analyse = append(m.Analyse[:0], dAtA[iNdEx:postIndex]...)
			if m.Analyse == nil {
				m.Analyse = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCnt", wireType)
			}
			m.BatchCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchCnt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Connector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Connector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Connector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineId", wireType)
			}
			m.PipelineId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PipelineId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorIndex", wireType)
			}
			m.ConnectorIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectorIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dispatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dispatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dispatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossCn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CrossCn = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Connector = append(m.Connector, &Connector{})
			if err := m.Connector[len(m.Connector)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteConnector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteConnector = append(m.RemoteConnector, &WrapNode{})
			if err := m.RemoteConnector[len(m.RemoteConnector)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Aggregate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aggregate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aggregate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dist = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Group) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedEval", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedEval = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ibucket", wireType)
			}
			m.Ibucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ibucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nbucket", wireType)
			}
			m.Nbucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nbucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exprs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exprs = append(m.Exprs, &plan.Expr{})
			if err := m.Exprs[len(m.Exprs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, &plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aggs = append(m.Aggs, &Aggregate{})
			if err := m.Aggs[len(m.Aggs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Insert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Insert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Insert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Affected", wireType)
			}
			m.Affected = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Affected |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRemote", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRemote = bool(v != 0)
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Idx = append(m.Idx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Idx) == 0 {
					m.Idx = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Idx = append(m.Idx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ref == nil {
				m.Ref = &plan.ObjectRef{}
			}
			if err := m.Ref.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &plan.TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IdxIdx = append(m.IdxIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IdxIdx) == 0 {
					m.IdxIdx = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IdxIdx = append(m.IdxIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IdxIdx", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentIdx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParentIdx == nil {
				m.ParentIdx = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPipeline
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPipeline
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPipeline(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPipeline
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ParentIdx[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterTable == nil {
				m.ClusterTable = &plan.ClusterTable{}
			}
			if err := m.ClusterTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Join) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Join: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Join: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ibucket", wireType)
			}
			m.Ibucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ibucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nbucket", wireType)
			}
			m.Nbucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nbucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelList = append(m.RelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelList) == 0 {
					m.RelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelList = append(m.RelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelList", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColList = append(m.ColList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColList) == 0 {
					m.ColList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColList = append(m.ColList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColList", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, &plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AntiJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AntiJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AntiJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ibucket", wireType)
			}
			m.Ibucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ibucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nbucket", wireType)
			}
			m.Nbucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nbucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Result = append(m.Result, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Result) == 0 {
					m.Result = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Result = append(m.Result, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, &plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InnerJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InnerJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InnerJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ibucket", wireType)
			}
			m.Ibucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ibucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nbucket", wireType)
			}
			m.Nbucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nbucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelList = append(m.RelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelList) == 0 {
					m.RelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelList = append(m.RelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelList", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColList = append(m.ColList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColList) == 0 {
					m.ColList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColList = append(m.ColList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColList", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, &plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeftJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeftJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeftJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ibucket", wireType)
			}
			m.Ibucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ibucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nbucket", wireType)
			}
			m.Nbucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nbucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelList = append(m.RelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelList) == 0 {
					m.RelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelList = append(m.RelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelList", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColList = append(m.ColList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColList) == 0 {
					m.ColList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColList = append(m.ColList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColList", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, &plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SemiJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SemiJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SemiJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ibucket", wireType)
			}
			m.Ibucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ibucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nbucket", wireType)
			}
			m.Nbucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nbucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Result = append(m.Result, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Result) == 0 {
					m.Result = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Result = append(m.Result, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, &plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SingleJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ibucket", wireType)
			}
			m.Ibucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ibucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nbucket", wireType)
			}
			m.Nbucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nbucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelList = append(m.RelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelList) == 0 {
					m.RelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelList = append(m.RelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelList", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColList = append(m.ColList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColList) == 0 {
					m.ColList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColList = append(m.ColList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColList", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, &plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ibucket", wireType)
			}
			m.Ibucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ibucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nbucket", wireType)
			}
			m.Nbucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nbucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Result = append(m.Result, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Result) == 0 {
					m.Result = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Result = append(m.Result, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, &plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnList = append(m.OnList, &plan.Expr{})
			if err := m.OnList[len(m.OnList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Product) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Product: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Product: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelList = append(m.RelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelList) == 0 {
					m.RelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelList = append(m.RelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelList", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColList = append(m.ColList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColList) == 0 {
					m.ColList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColList = append(m.ColList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColList", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, &plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableFunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableFunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableFunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attrs = append(m.Attrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rets = append(m.Rets, &plan.ColDef{})
			if err := m.Rets[len(m.Rets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, &plan.Expr{})
			if err := m.Args[len(m.Args)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params[:0], dAtA[iNdEx:postIndex]...)
			if m.Params == nil {
				m.Params = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HashBuild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HashBuild: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HashBuild: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedExpr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedExpr = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedHash", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedHash = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ibucket", wireType)
			}
			m.Ibucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ibucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nbucket", wireType)
			}
			m.Nbucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nbucket |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, &plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conds = append(m.Conds, &plan.Expr{})
			if err := m.Conds[len(m.Conds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalName2ColIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalName2ColIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalName2ColIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalScan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalScan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalScan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attrs = append(m.Attrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cols = append(m.Cols, &plan.ColDef{})
			if err := m.Cols[len(m.Cols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name2ColIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name2ColIndex = append(m.Name2ColIndex, &ExternalName2ColIndex{})
			if err := m.Name2ColIndex[len(m.Name2ColIndex)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateSql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreateSql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileList = append(m.FileList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Instruction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Instruction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Instruction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anti", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anti == nil {
				m.Anti = &AntiJoin{}
			}
			if err := m.Anti.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connect == nil {
				m.Connect = &Connector{}
			}
			if err := m.Connect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dispatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dispatch == nil {
				m.Dispatch = &Dispatch{}
			}
			if err := m.Dispatch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Agg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Agg == nil {
				m.Agg = &Group{}
			}
			if err := m.Agg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InnerJoin == nil {
				m.InnerJoin = &InnerJoin{}
			}
			if err := m.InnerJoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeftJoin == nil {
				m.LeftJoin = &LeftJoin{}
			}
			if err := m.LeftJoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemiJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SemiJoin == nil {
				m.SemiJoin = &SemiJoin{}
			}
			if err := m.SemiJoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SingleJoin == nil {
				m.SingleJoin = &SingleJoin{}
			}
			if err := m.SingleJoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MarkJoin == nil {
				m.MarkJoin = &MarkJoin{}
			}
			if err := m.MarkJoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Join", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Join == nil {
				m.Join = &Join{}
			}
			if err := m.Join.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Product == nil {
				m.Product = &Product{}
			}
			if err := m.Product.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableFunction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableFunction == nil {
				m.TableFunction = &TableFunction{}
			}
			if err := m.TableFunction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashBuild", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HashBuild == nil {
				m.HashBuild = &HashBuild{}
			}
			if err := m.HashBuild.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalScan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExternalScan == nil {
				m.ExternalScan = &ExternalScan{}
			}
			if err := m.ExternalScan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Insert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Insert == nil {
				m.Insert = &Insert{}
			}
			if err := m.Insert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBy = append(m.OrderBy, &plan.OrderBySpec{})
			if err := m.OrderBy[len(m.OrderBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectList = append(m.ProjectList, &plan.Expr{})
			if err := m.ProjectList[len(m.ProjectList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &plan.Expr{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFirst", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFirst = bool(v != 0)
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLast = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnalysisList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalysisList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalysisList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &plan.AnalyzeInfo{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Source) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Source: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Source: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColList = append(m.ColList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Block = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushdownId", wireType)
			}
			m.PushdownId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PushdownId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushdownAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PushdownAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &plan.TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &timestamp.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mcpu", wireType)
			}
			m.Mcpu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mcpu |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessLimitation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessLimitation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessLimitation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size", wireType)
			}
			m.Size = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchRows", wireType)
			}
			m.BatchRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchRows |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSize", wireType)
			}
			m.BatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionRows", wireType)
			}
			m.PartitionRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionRows |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReaderSize", wireType)
			}
			m.ReaderSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReaderSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lim == nil {
				m.Lim = &ProcessLimitation{}
			}
			if err := m.Lim.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnixTime", wireType)
			}
			m.UnixTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnixTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Snapshot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SessionInfo == nil {
				m.SessionInfo = &SessionInfo{}
			}
			if err := m.SessionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AnalysisNodeList = append(m.AnalysisNodeList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AnalysisNodeList) == 0 {
					m.AnalysisNodeList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AnalysisNodeList = append(m.AnalysisNodeList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalysisNodeList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionId", wireType)
			}
			m.ConnectionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeZone", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimeZone = append(m.TimeZone[:0], dAtA[iNdEx:postIndex]...)
			if m.TimeZone == nil {
				m.TimeZone = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pipeline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pipeline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pipeline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineType", wireType)
			}
			m.PipelineType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PipelineType |= Pipeline_PipelineType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineId", wireType)
			}
			m.PipelineId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PipelineId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Qry == nil {
				m.Qry = &plan.Plan{}
			}
			if err := m.Qry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataSource == nil {
				m.DataSource = &Source{}
			}
			if err := m.DataSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &Pipeline{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstructionList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstructionList = append(m.InstructionList, &Instruction{})
			if err := m.InstructionList[len(m.InstructionList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEnd = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsJoin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsJoin = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &NodeInfo{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushDownInfo", wireType)
			}
			m.PushDownInfo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PushDownInfo |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildrenCount", wireType)
			}
			m.ChildrenCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChildrenCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UuidsToRegIdx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UuidsToRegIdx = append(m.UuidsToRegIdx, &UuidToRegIdx{})
			if err := m.UuidsToRegIdx[len(m.UuidsToRegIdx)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WrapNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WrapNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WrapNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuids", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuids = append(m.Uuids, make([]byte, postIndex-iNdEx))
			copy(m.Uuids[len(m.Uuids)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UuidToRegIdx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UuidToRegIdx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UuidToRegIdx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPipeline(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPipeline
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPipeline
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPipeline
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPipeline        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPipeline          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPipeline = fmt.Errorf("proto: unexpected end of group")
)
