// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pipeline.proto

package pipeline

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	lock "github.com/matrixorigin/matrixone/pkg/pb/lock"
	plan "github.com/matrixorigin/matrixone/pkg/pb/plan"
	timestamp "github.com/matrixorigin/matrixone/pkg/pb/timestamp"
	txn "github.com/matrixorigin/matrixone/pkg/pb/txn"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Method int32

const (
	Method_UnknownMethod            Method = 0
	Method_PipelineMessage          Method = 1
	Method_BatchMessage             Method = 2
	Method_PrepareDoneNotifyMessage Method = 3
	Method_StopSending              Method = 4
)

var Method_name = map[int32]string{
	0: "UnknownMethod",
	1: "PipelineMessage",
	2: "BatchMessage",
	3: "PrepareDoneNotifyMessage",
	4: "StopSending",
}

var Method_value = map[string]int32{
	"UnknownMethod":            0,
	"PipelineMessage":          1,
	"BatchMessage":             2,
	"PrepareDoneNotifyMessage": 3,
	"StopSending":              4,
}

func (x Method) String() string {
	return proto.EnumName(Method_name, int32(x))
}

func (Method) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{0}
}

type Status int32

const (
	Status_UnknownStatus Status = 0
	Status_WaitingNext   Status = 1
	Status_Last          Status = 2
	Status_MessageEnd    Status = 3
)

var Status_name = map[int32]string{
	0: "UnknownStatus",
	1: "WaitingNext",
	2: "Last",
	3: "MessageEnd",
}

var Status_value = map[string]int32{
	"UnknownStatus": 0,
	"WaitingNext":   1,
	"Last":          2,
	"MessageEnd":    3,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}

func (Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{1}
}

type SampleFunc_SampleType int32

const (
	SampleFunc_Rows      SampleFunc_SampleType = 0
	SampleFunc_Percent   SampleFunc_SampleType = 1
	SampleFunc_MergeRows SampleFunc_SampleType = 2
)

var SampleFunc_SampleType_name = map[int32]string{
	0: "Rows",
	1: "Percent",
	2: "MergeRows",
}

var SampleFunc_SampleType_value = map[string]int32{
	"Rows":      0,
	"Percent":   1,
	"MergeRows": 2,
}

func (x SampleFunc_SampleType) String() string {
	return proto.EnumName(SampleFunc_SampleType_name, int32(x))
}

func (SampleFunc_SampleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{43, 0}
}

type SessionLoggerInfo_LogLevel int32

const (
	SessionLoggerInfo_Debug SessionLoggerInfo_LogLevel = 0
	SessionLoggerInfo_Info  SessionLoggerInfo_LogLevel = 1
	SessionLoggerInfo_Warn  SessionLoggerInfo_LogLevel = 2
	SessionLoggerInfo_Error SessionLoggerInfo_LogLevel = 3
	SessionLoggerInfo_Panic SessionLoggerInfo_LogLevel = 4
	SessionLoggerInfo_Fatal SessionLoggerInfo_LogLevel = 5
)

var SessionLoggerInfo_LogLevel_name = map[int32]string{
	0: "Debug",
	1: "Info",
	2: "Warn",
	3: "Error",
	4: "Panic",
	5: "Fatal",
}

var SessionLoggerInfo_LogLevel_value = map[string]int32{
	"Debug": 0,
	"Info":  1,
	"Warn":  2,
	"Error": 3,
	"Panic": 4,
	"Fatal": 5,
}

func (x SessionLoggerInfo_LogLevel) String() string {
	return proto.EnumName(SessionLoggerInfo_LogLevel_name, int32(x))
}

func (SessionLoggerInfo_LogLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{52, 0}
}

type Pipeline_PipelineType int32

const (
	Pipeline_Merge    Pipeline_PipelineType = 0
	Pipeline_Normal   Pipeline_PipelineType = 1
	Pipeline_Remote   Pipeline_PipelineType = 2
	Pipeline_Parallel Pipeline_PipelineType = 3
)

var Pipeline_PipelineType_name = map[int32]string{
	0: "Merge",
	1: "Normal",
	2: "Remote",
	3: "Parallel",
}

var Pipeline_PipelineType_value = map[string]int32{
	"Merge":    0,
	"Normal":   1,
	"Remote":   2,
	"Parallel": 3,
}

func (x Pipeline_PipelineType) String() string {
	return proto.EnumName(Pipeline_PipelineType_name, int32(x))
}

func (Pipeline_PipelineType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{53, 0}
}

type Message struct {
	Sid                  Status   `protobuf:"varint,1,opt,name=sid,proto3,enum=pipeline.Status" json:"sid,omitempty"`
	Cmd                  Method   `protobuf:"varint,2,opt,name=cmd,proto3,enum=pipeline.Method" json:"cmd,omitempty"`
	Err                  []byte   `protobuf:"bytes,3,opt,name=err,proto3" json:"err,omitempty"`
	Data                 []byte   `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	ProcInfoData         []byte   `protobuf:"bytes,5,opt,name=proc_info_data,json=procInfoData,proto3" json:"proc_info_data,omitempty"`
	Analyse              []byte   `protobuf:"bytes,6,opt,name=analyse,proto3" json:"analyse,omitempty"`
	Id                   uint64   `protobuf:"varint,7,opt,name=id,proto3" json:"id,omitempty"`
	Uuid                 []byte   `protobuf:"bytes,8,opt,name=uuid,proto3" json:"uuid,omitempty"`
	NeedNotReply         bool     `protobuf:"varint,9,opt,name=needNotReply,proto3" json:"needNotReply,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{0}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetSid() Status {
	if m != nil {
		return m.Sid
	}
	return Status_UnknownStatus
}

func (m *Message) GetCmd() Method {
	if m != nil {
		return m.Cmd
	}
	return Method_UnknownMethod
}

func (m *Message) GetErr() []byte {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *Message) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Message) GetProcInfoData() []byte {
	if m != nil {
		return m.ProcInfoData
	}
	return nil
}

func (m *Message) GetAnalyse() []byte {
	if m != nil {
		return m.Analyse
	}
	return nil
}

func (m *Message) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Message) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *Message) GetNeedNotReply() bool {
	if m != nil {
		return m.NeedNotReply
	}
	return false
}

type Connector struct {
	PipelineId           int32    `protobuf:"varint,1,opt,name=pipeline_id,json=pipelineId,proto3" json:"pipeline_id,omitempty"`
	ConnectorIndex       int32    `protobuf:"varint,2,opt,name=connector_index,json=connectorIndex,proto3" json:"connector_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Connector) Reset()         { *m = Connector{} }
func (m *Connector) String() string { return proto.CompactTextString(m) }
func (*Connector) ProtoMessage()    {}
func (*Connector) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{1}
}
func (m *Connector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Connector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Connector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Connector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Connector.Merge(m, src)
}
func (m *Connector) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Connector) XXX_DiscardUnknown() {
	xxx_messageInfo_Connector.DiscardUnknown(m)
}

var xxx_messageInfo_Connector proto.InternalMessageInfo

func (m *Connector) GetPipelineId() int32 {
	if m != nil {
		return m.PipelineId
	}
	return 0
}

func (m *Connector) GetConnectorIndex() int32 {
	if m != nil {
		return m.ConnectorIndex
	}
	return 0
}

type Shuffle struct {
	ShuffleColIdx        int32                   `protobuf:"varint,1,opt,name=ShuffleColIdx,proto3" json:"ShuffleColIdx,omitempty"`
	ShuffleType          int32                   `protobuf:"varint,2,opt,name=ShuffleType,proto3" json:"ShuffleType,omitempty"`
	ShuffleColMin        int64                   `protobuf:"varint,3,opt,name=ShuffleColMin,proto3" json:"ShuffleColMin,omitempty"`
	ShuffleColMax        int64                   `protobuf:"varint,4,opt,name=ShuffleColMax,proto3" json:"ShuffleColMax,omitempty"`
	AliveRegCnt          int32                   `protobuf:"varint,5,opt,name=AliveRegCnt,proto3" json:"AliveRegCnt,omitempty"`
	ShuffleRangesUint64  []uint64                `protobuf:"varint,6,rep,packed,name=shuffle_ranges_uint64,json=shuffleRangesUint64,proto3" json:"shuffle_ranges_uint64,omitempty"`
	ShuffleRangesInt64   []int64                 `protobuf:"varint,7,rep,packed,name=shuffle_ranges_int64,json=shuffleRangesInt64,proto3" json:"shuffle_ranges_int64,omitempty"`
	RuntimeFilterSpec    *plan.RuntimeFilterSpec `protobuf:"bytes,8,opt,name=runtimeFilterSpec,proto3" json:"runtimeFilterSpec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *Shuffle) Reset()         { *m = Shuffle{} }
func (m *Shuffle) String() string { return proto.CompactTextString(m) }
func (*Shuffle) ProtoMessage()    {}
func (*Shuffle) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{2}
}
func (m *Shuffle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Shuffle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Shuffle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Shuffle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Shuffle.Merge(m, src)
}
func (m *Shuffle) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Shuffle) XXX_DiscardUnknown() {
	xxx_messageInfo_Shuffle.DiscardUnknown(m)
}

var xxx_messageInfo_Shuffle proto.InternalMessageInfo

func (m *Shuffle) GetShuffleColIdx() int32 {
	if m != nil {
		return m.ShuffleColIdx
	}
	return 0
}

func (m *Shuffle) GetShuffleType() int32 {
	if m != nil {
		return m.ShuffleType
	}
	return 0
}

func (m *Shuffle) GetShuffleColMin() int64 {
	if m != nil {
		return m.ShuffleColMin
	}
	return 0
}

func (m *Shuffle) GetShuffleColMax() int64 {
	if m != nil {
		return m.ShuffleColMax
	}
	return 0
}

func (m *Shuffle) GetAliveRegCnt() int32 {
	if m != nil {
		return m.AliveRegCnt
	}
	return 0
}

func (m *Shuffle) GetShuffleRangesUint64() []uint64 {
	if m != nil {
		return m.ShuffleRangesUint64
	}
	return nil
}

func (m *Shuffle) GetShuffleRangesInt64() []int64 {
	if m != nil {
		return m.ShuffleRangesInt64
	}
	return nil
}

func (m *Shuffle) GetRuntimeFilterSpec() *plan.RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterSpec
	}
	return nil
}

type Dispatch struct {
	FuncId               int32        `protobuf:"varint,1,opt,name=func_id,json=funcId,proto3" json:"func_id,omitempty"`
	LocalConnector       []*Connector `protobuf:"bytes,2,rep,name=local_connector,json=localConnector,proto3" json:"local_connector,omitempty"`
	RemoteConnector      []*WrapNode  `protobuf:"bytes,3,rep,name=remote_connector,json=remoteConnector,proto3" json:"remote_connector,omitempty"`
	ShuffleRegIdxLocal   []int32      `protobuf:"varint,4,rep,packed,name=shuffle_reg_idx_local,json=shuffleRegIdxLocal,proto3" json:"shuffle_reg_idx_local,omitempty"`
	ShuffleRegIdxRemote  []int32      `protobuf:"varint,5,rep,packed,name=shuffle_reg_idx_remote,json=shuffleRegIdxRemote,proto3" json:"shuffle_reg_idx_remote,omitempty"`
	ShuffleType          int32        `protobuf:"varint,6,opt,name=shuffle_type,json=shuffleType,proto3" json:"shuffle_type,omitempty"`
	IsSink               bool         `protobuf:"varint,7,opt,name=is_sink,json=isSink,proto3" json:"is_sink,omitempty"`
	RecSink              bool         `protobuf:"varint,8,opt,name=rec_sink,json=recSink,proto3" json:"rec_sink,omitempty"`
	RecCte               bool         `protobuf:"varint,9,opt,name=rec_cte,json=recCte,proto3" json:"rec_cte,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Dispatch) Reset()         { *m = Dispatch{} }
func (m *Dispatch) String() string { return proto.CompactTextString(m) }
func (*Dispatch) ProtoMessage()    {}
func (*Dispatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{3}
}
func (m *Dispatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dispatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dispatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Dispatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dispatch.Merge(m, src)
}
func (m *Dispatch) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Dispatch) XXX_DiscardUnknown() {
	xxx_messageInfo_Dispatch.DiscardUnknown(m)
}

var xxx_messageInfo_Dispatch proto.InternalMessageInfo

func (m *Dispatch) GetFuncId() int32 {
	if m != nil {
		return m.FuncId
	}
	return 0
}

func (m *Dispatch) GetLocalConnector() []*Connector {
	if m != nil {
		return m.LocalConnector
	}
	return nil
}

func (m *Dispatch) GetRemoteConnector() []*WrapNode {
	if m != nil {
		return m.RemoteConnector
	}
	return nil
}

func (m *Dispatch) GetShuffleRegIdxLocal() []int32 {
	if m != nil {
		return m.ShuffleRegIdxLocal
	}
	return nil
}

func (m *Dispatch) GetShuffleRegIdxRemote() []int32 {
	if m != nil {
		return m.ShuffleRegIdxRemote
	}
	return nil
}

func (m *Dispatch) GetShuffleType() int32 {
	if m != nil {
		return m.ShuffleType
	}
	return 0
}

func (m *Dispatch) GetIsSink() bool {
	if m != nil {
		return m.IsSink
	}
	return false
}

func (m *Dispatch) GetRecSink() bool {
	if m != nil {
		return m.RecSink
	}
	return false
}

func (m *Dispatch) GetRecCte() bool {
	if m != nil {
		return m.RecCte
	}
	return false
}

type Merge struct {
	SinkScan             bool     `protobuf:"varint,1,opt,name=sinkScan,proto3" json:"sinkScan,omitempty"`
	Partial              bool     `protobuf:"varint,2,opt,name=partial,proto3" json:"partial,omitempty"`
	StartIdx             int32    `protobuf:"varint,3,opt,name=start_idx,json=startIdx,proto3" json:"start_idx,omitempty"`
	EndIdx               int32    `protobuf:"varint,4,opt,name=end_idx,json=endIdx,proto3" json:"end_idx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Merge) Reset()         { *m = Merge{} }
func (m *Merge) String() string { return proto.CompactTextString(m) }
func (*Merge) ProtoMessage()    {}
func (*Merge) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{4}
}
func (m *Merge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Merge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Merge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Merge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Merge.Merge(m, src)
}
func (m *Merge) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Merge) XXX_DiscardUnknown() {
	xxx_messageInfo_Merge.DiscardUnknown(m)
}

var xxx_messageInfo_Merge proto.InternalMessageInfo

func (m *Merge) GetSinkScan() bool {
	if m != nil {
		return m.SinkScan
	}
	return false
}

func (m *Merge) GetPartial() bool {
	if m != nil {
		return m.Partial
	}
	return false
}

func (m *Merge) GetStartIdx() int32 {
	if m != nil {
		return m.StartIdx
	}
	return 0
}

func (m *Merge) GetEndIdx() int32 {
	if m != nil {
		return m.EndIdx
	}
	return 0
}

type MultiArguemnt struct {
	Dist                 bool         `protobuf:"varint,1,opt,name=Dist,proto3" json:"Dist,omitempty"`
	GroupExpr            []*plan.Expr `protobuf:"bytes,2,rep,name=GroupExpr,proto3" json:"GroupExpr,omitempty"`
	OrderByExpr          []*plan.Expr `protobuf:"bytes,3,rep,name=OrderByExpr,proto3" json:"OrderByExpr,omitempty"`
	Separator            string       `protobuf:"bytes,4,opt,name=Separator,proto3" json:"Separator,omitempty"`
	OrderId              int32        `protobuf:"varint,5,opt,name=OrderId,proto3" json:"OrderId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *MultiArguemnt) Reset()         { *m = MultiArguemnt{} }
func (m *MultiArguemnt) String() string { return proto.CompactTextString(m) }
func (*MultiArguemnt) ProtoMessage()    {}
func (*MultiArguemnt) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{5}
}
func (m *MultiArguemnt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiArguemnt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiArguemnt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiArguemnt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiArguemnt.Merge(m, src)
}
func (m *MultiArguemnt) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MultiArguemnt) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiArguemnt.DiscardUnknown(m)
}

var xxx_messageInfo_MultiArguemnt proto.InternalMessageInfo

func (m *MultiArguemnt) GetDist() bool {
	if m != nil {
		return m.Dist
	}
	return false
}

func (m *MultiArguemnt) GetGroupExpr() []*plan.Expr {
	if m != nil {
		return m.GroupExpr
	}
	return nil
}

func (m *MultiArguemnt) GetOrderByExpr() []*plan.Expr {
	if m != nil {
		return m.OrderByExpr
	}
	return nil
}

func (m *MultiArguemnt) GetSeparator() string {
	if m != nil {
		return m.Separator
	}
	return ""
}

func (m *MultiArguemnt) GetOrderId() int32 {
	if m != nil {
		return m.OrderId
	}
	return 0
}

type Aggregate struct {
	Op                   int64        `protobuf:"varint,1,opt,name=op,proto3" json:"op,omitempty"`
	Dist                 bool         `protobuf:"varint,2,opt,name=dist,proto3" json:"dist,omitempty"`
	Expr                 []*plan.Expr `protobuf:"bytes,3,rep,name=expr,proto3" json:"expr,omitempty"`
	Config               []byte       `protobuf:"bytes,4,opt,name=config,proto3" json:"config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Aggregate) Reset()         { *m = Aggregate{} }
func (m *Aggregate) String() string { return proto.CompactTextString(m) }
func (*Aggregate) ProtoMessage()    {}
func (*Aggregate) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{6}
}
func (m *Aggregate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Aggregate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Aggregate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Aggregate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Aggregate.Merge(m, src)
}
func (m *Aggregate) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Aggregate) XXX_DiscardUnknown() {
	xxx_messageInfo_Aggregate.DiscardUnknown(m)
}

var xxx_messageInfo_Aggregate proto.InternalMessageInfo

func (m *Aggregate) GetOp() int64 {
	if m != nil {
		return m.Op
	}
	return 0
}

func (m *Aggregate) GetDist() bool {
	if m != nil {
		return m.Dist
	}
	return false
}

func (m *Aggregate) GetExpr() []*plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Aggregate) GetConfig() []byte {
	if m != nil {
		return m.Config
	}
	return nil
}

type Group struct {
	NeedEval             bool             `protobuf:"varint,1,opt,name=need_eval,json=needEval,proto3" json:"need_eval,omitempty"`
	Exprs                []*plan.Expr     `protobuf:"bytes,2,rep,name=exprs,proto3" json:"exprs,omitempty"`
	Types                []plan.Type      `protobuf:"bytes,3,rep,name=types,proto3" json:"types"`
	Aggs                 []*Aggregate     `protobuf:"bytes,4,rep,name=aggs,proto3" json:"aggs,omitempty"`
	MultiAggs            []*MultiArguemnt `protobuf:"bytes,5,rep,name=MultiAggs,proto3" json:"MultiAggs,omitempty"`
	IsShuffle            bool             `protobuf:"varint,6,opt,name=isShuffle,proto3" json:"isShuffle,omitempty"`
	PreAllocSize         uint64           `protobuf:"varint,7,opt,name=preAllocSize,proto3" json:"preAllocSize,omitempty"`
	PartialResults       []byte           `protobuf:"bytes,8,opt,name=PartialResults,proto3" json:"PartialResults,omitempty"`
	PartialResultTypes   []uint32         `protobuf:"varint,9,rep,packed,name=PartialResultTypes,proto3" json:"PartialResultTypes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Group) Reset()         { *m = Group{} }
func (m *Group) String() string { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()    {}
func (*Group) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{7}
}
func (m *Group) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Group) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Group.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Group) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Group.Merge(m, src)
}
func (m *Group) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Group) XXX_DiscardUnknown() {
	xxx_messageInfo_Group.DiscardUnknown(m)
}

var xxx_messageInfo_Group proto.InternalMessageInfo

func (m *Group) GetNeedEval() bool {
	if m != nil {
		return m.NeedEval
	}
	return false
}

func (m *Group) GetExprs() []*plan.Expr {
	if m != nil {
		return m.Exprs
	}
	return nil
}

func (m *Group) GetTypes() []plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *Group) GetAggs() []*Aggregate {
	if m != nil {
		return m.Aggs
	}
	return nil
}

func (m *Group) GetMultiAggs() []*MultiArguemnt {
	if m != nil {
		return m.MultiAggs
	}
	return nil
}

func (m *Group) GetIsShuffle() bool {
	if m != nil {
		return m.IsShuffle
	}
	return false
}

func (m *Group) GetPreAllocSize() uint64 {
	if m != nil {
		return m.PreAllocSize
	}
	return 0
}

func (m *Group) GetPartialResults() []byte {
	if m != nil {
		return m.PartialResults
	}
	return nil
}

func (m *Group) GetPartialResultTypes() []uint32 {
	if m != nil {
		return m.PartialResultTypes
	}
	return nil
}

type Insert struct {
	Affected        uint64          `protobuf:"varint,1,opt,name=affected,proto3" json:"affected,omitempty"`
	ToWriteS3       bool            `protobuf:"varint,2,opt,name=ToWriteS3,proto3" json:"ToWriteS3,omitempty"`
	AddAffectedRows bool            `protobuf:"varint,3,opt,name=add_affected_rows,json=addAffectedRows,proto3" json:"add_affected_rows,omitempty"`
	Ref             *plan.ObjectRef `protobuf:"bytes,4,opt,name=ref,proto3" json:"ref,omitempty"`
	Attrs           []string        `protobuf:"bytes,5,rep,name=attrs,proto3" json:"attrs,omitempty"`
	// Align array index with the partition number
	PartitionTableIds    []uint64       `protobuf:"varint,6,rep,packed,name=partition_table_ids,json=partitionTableIds,proto3" json:"partition_table_ids,omitempty"`
	PartitionTableNames  []string       `protobuf:"bytes,7,rep,name=partition_table_names,json=partitionTableNames,proto3" json:"partition_table_names,omitempty"`
	PartitionIdx         int32          `protobuf:"varint,8,opt,name=partition_idx,json=partitionIdx,proto3" json:"partition_idx,omitempty"`
	IsEnd                bool           `protobuf:"varint,9,opt,name=is_end,json=isEnd,proto3" json:"is_end,omitempty"`
	TableDef             *plan.TableDef `protobuf:"bytes,10,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Insert) Reset()         { *m = Insert{} }
func (m *Insert) String() string { return proto.CompactTextString(m) }
func (*Insert) ProtoMessage()    {}
func (*Insert) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{8}
}
func (m *Insert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Insert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Insert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Insert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Insert.Merge(m, src)
}
func (m *Insert) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Insert) XXX_DiscardUnknown() {
	xxx_messageInfo_Insert.DiscardUnknown(m)
}

var xxx_messageInfo_Insert proto.InternalMessageInfo

func (m *Insert) GetAffected() uint64 {
	if m != nil {
		return m.Affected
	}
	return 0
}

func (m *Insert) GetToWriteS3() bool {
	if m != nil {
		return m.ToWriteS3
	}
	return false
}

func (m *Insert) GetAddAffectedRows() bool {
	if m != nil {
		return m.AddAffectedRows
	}
	return false
}

func (m *Insert) GetRef() *plan.ObjectRef {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *Insert) GetAttrs() []string {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *Insert) GetPartitionTableIds() []uint64 {
	if m != nil {
		return m.PartitionTableIds
	}
	return nil
}

func (m *Insert) GetPartitionTableNames() []string {
	if m != nil {
		return m.PartitionTableNames
	}
	return nil
}

func (m *Insert) GetPartitionIdx() int32 {
	if m != nil {
		return m.PartitionIdx
	}
	return 0
}

func (m *Insert) GetIsEnd() bool {
	if m != nil {
		return m.IsEnd
	}
	return false
}

func (m *Insert) GetTableDef() *plan.TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

type MultiUpdate struct {
	AffectedRows         uint64            `protobuf:"varint,1,opt,name=affected_rows,json=affectedRows,proto3" json:"affected_rows,omitempty"`
	ToWriteS3            bool              `protobuf:"varint,2,opt,name=ToWriteS3,proto3" json:"ToWriteS3,omitempty"`
	IBucket              uint32            `protobuf:"varint,3,opt,name=IBucket,proto3" json:"IBucket,omitempty"`
	NBucket              uint32            `protobuf:"varint,4,opt,name=NBucket,proto3" json:"NBucket,omitempty"`
	SegmentMap           map[string]int32  `protobuf:"bytes,5,rep,name=SegmentMap,proto3" json:"SegmentMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	UpdateCtx            []*plan.UpdateCtx `protobuf:"bytes,6,rep,name=update_ctx,json=updateCtx,proto3" json:"update_ctx,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *MultiUpdate) Reset()         { *m = MultiUpdate{} }
func (m *MultiUpdate) String() string { return proto.CompactTextString(m) }
func (*MultiUpdate) ProtoMessage()    {}
func (*MultiUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{9}
}
func (m *MultiUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiUpdate.Merge(m, src)
}
func (m *MultiUpdate) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MultiUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_MultiUpdate proto.InternalMessageInfo

func (m *MultiUpdate) GetAffectedRows() uint64 {
	if m != nil {
		return m.AffectedRows
	}
	return 0
}

func (m *MultiUpdate) GetToWriteS3() bool {
	if m != nil {
		return m.ToWriteS3
	}
	return false
}

func (m *MultiUpdate) GetIBucket() uint32 {
	if m != nil {
		return m.IBucket
	}
	return 0
}

func (m *MultiUpdate) GetNBucket() uint32 {
	if m != nil {
		return m.NBucket
	}
	return 0
}

func (m *MultiUpdate) GetSegmentMap() map[string]int32 {
	if m != nil {
		return m.SegmentMap
	}
	return nil
}

func (m *MultiUpdate) GetUpdateCtx() []*plan.UpdateCtx {
	if m != nil {
		return m.UpdateCtx
	}
	return nil
}

type Array struct {
	Array                []int32  `protobuf:"varint,1,rep,packed,name=array,proto3" json:"array,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Array) Reset()         { *m = Array{} }
func (m *Array) String() string { return proto.CompactTextString(m) }
func (*Array) ProtoMessage()    {}
func (*Array) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{10}
}
func (m *Array) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Array) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Array.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Array) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Array.Merge(m, src)
}
func (m *Array) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Array) XXX_DiscardUnknown() {
	xxx_messageInfo_Array.DiscardUnknown(m)
}

var xxx_messageInfo_Array proto.InternalMessageInfo

func (m *Array) GetArray() []int32 {
	if m != nil {
		return m.Array
	}
	return nil
}

type Map struct {
	Mp                   map[string]int32 `protobuf:"bytes,1,rep,name=mp,proto3" json:"mp,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Map) Reset()         { *m = Map{} }
func (m *Map) String() string { return proto.CompactTextString(m) }
func (*Map) ProtoMessage()    {}
func (*Map) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{11}
}
func (m *Map) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Map) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Map.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Map) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Map.Merge(m, src)
}
func (m *Map) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Map) XXX_DiscardUnknown() {
	xxx_messageInfo_Map.DiscardUnknown(m)
}

var xxx_messageInfo_Map proto.InternalMessageInfo

func (m *Map) GetMp() map[string]int32 {
	if m != nil {
		return m.Mp
	}
	return nil
}

type Deletion struct {
	AffectedRows uint64 `protobuf:"varint,1,opt,name=AffectedRows,proto3" json:"AffectedRows,omitempty"`
	RemoteDelete bool   `protobuf:"varint,2,opt,name=RemoteDelete,proto3" json:"RemoteDelete,omitempty"`
	IBucket      uint32 `protobuf:"varint,3,opt,name=IBucket,proto3" json:"IBucket,omitempty"`
	NBucket      uint32 `protobuf:"varint,4,opt,name=NBucket,proto3" json:"NBucket,omitempty"`
	// DeleteCtx
	RowIdIdx              int32            `protobuf:"varint,5,opt,name=row_id_idx,json=rowIdIdx,proto3" json:"row_id_idx,omitempty"`
	PartitionTableIds     []uint64         `protobuf:"varint,6,rep,packed,name=partition_table_ids,json=partitionTableIds,proto3" json:"partition_table_ids,omitempty"`
	PartitionTableNames   []string         `protobuf:"bytes,7,rep,name=partition_table_names,json=partitionTableNames,proto3" json:"partition_table_names,omitempty"`
	PartitionIndexInBatch int32            `protobuf:"varint,8,opt,name=partition_index_in_batch,json=partitionIndexInBatch,proto3" json:"partition_index_in_batch,omitempty"`
	Ref                   *plan.ObjectRef  `protobuf:"bytes,9,opt,name=ref,proto3" json:"ref,omitempty"`
	AddAffectedRows       bool             `protobuf:"varint,10,opt,name=add_affected_rows,json=addAffectedRows,proto3" json:"add_affected_rows,omitempty"`
	SegmentMap            map[string]int32 `protobuf:"bytes,11,rep,name=SegmentMap,proto3" json:"SegmentMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	CanTruncate           bool             `protobuf:"varint,12,opt,name=can_truncate,json=canTruncate,proto3" json:"can_truncate,omitempty"`
	IsEnd                 bool             `protobuf:"varint,13,opt,name=is_end,json=isEnd,proto3" json:"is_end,omitempty"`
	PrimaryKeyIdx         int32            `protobuf:"varint,14,opt,name=primary_key_idx,json=primaryKeyIdx,proto3" json:"primary_key_idx,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}         `json:"-"`
	XXX_unrecognized      []byte           `json:"-"`
	XXX_sizecache         int32            `json:"-"`
}

func (m *Deletion) Reset()         { *m = Deletion{} }
func (m *Deletion) String() string { return proto.CompactTextString(m) }
func (*Deletion) ProtoMessage()    {}
func (*Deletion) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{12}
}
func (m *Deletion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deletion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deletion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deletion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deletion.Merge(m, src)
}
func (m *Deletion) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Deletion) XXX_DiscardUnknown() {
	xxx_messageInfo_Deletion.DiscardUnknown(m)
}

var xxx_messageInfo_Deletion proto.InternalMessageInfo

func (m *Deletion) GetAffectedRows() uint64 {
	if m != nil {
		return m.AffectedRows
	}
	return 0
}

func (m *Deletion) GetRemoteDelete() bool {
	if m != nil {
		return m.RemoteDelete
	}
	return false
}

func (m *Deletion) GetIBucket() uint32 {
	if m != nil {
		return m.IBucket
	}
	return 0
}

func (m *Deletion) GetNBucket() uint32 {
	if m != nil {
		return m.NBucket
	}
	return 0
}

func (m *Deletion) GetRowIdIdx() int32 {
	if m != nil {
		return m.RowIdIdx
	}
	return 0
}

func (m *Deletion) GetPartitionTableIds() []uint64 {
	if m != nil {
		return m.PartitionTableIds
	}
	return nil
}

func (m *Deletion) GetPartitionTableNames() []string {
	if m != nil {
		return m.PartitionTableNames
	}
	return nil
}

func (m *Deletion) GetPartitionIndexInBatch() int32 {
	if m != nil {
		return m.PartitionIndexInBatch
	}
	return 0
}

func (m *Deletion) GetRef() *plan.ObjectRef {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *Deletion) GetAddAffectedRows() bool {
	if m != nil {
		return m.AddAffectedRows
	}
	return false
}

func (m *Deletion) GetSegmentMap() map[string]int32 {
	if m != nil {
		return m.SegmentMap
	}
	return nil
}

func (m *Deletion) GetCanTruncate() bool {
	if m != nil {
		return m.CanTruncate
	}
	return false
}

func (m *Deletion) GetIsEnd() bool {
	if m != nil {
		return m.IsEnd
	}
	return false
}

func (m *Deletion) GetPrimaryKeyIdx() int32 {
	if m != nil {
		return m.PrimaryKeyIdx
	}
	return 0
}

type PreInsert struct {
	SchemaName           string         `protobuf:"bytes,1,opt,name=schema_name,json=schemaName,proto3" json:"schema_name,omitempty"`
	TableDef             *plan.TableDef `protobuf:"bytes,2,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	Idx                  []int32        `protobuf:"varint,3,rep,packed,name=idx,proto3" json:"idx,omitempty"`
	Attrs                []string       `protobuf:"bytes,4,rep,name=attrs,proto3" json:"attrs,omitempty"`
	HasAutoCol           bool           `protobuf:"varint,5,opt,name=has_auto_col,json=hasAutoCol,proto3" json:"has_auto_col,omitempty"`
	IsUpdate             bool           `protobuf:"varint,6,opt,name=is_update,json=isUpdate,proto3" json:"is_update,omitempty"`
	EstimatedRowCount    int64          `protobuf:"varint,7,opt,name=estimated_row_count,json=estimatedRowCount,proto3" json:"estimated_row_count,omitempty"`
	CompPkeyExpr         *plan.Expr     `protobuf:"bytes,8,opt,name=comp_pkey_expr,json=compPkeyExpr,proto3" json:"comp_pkey_expr,omitempty"`
	ClusterByExpr        *plan.Expr     `protobuf:"bytes,9,opt,name=cluster_by_expr,json=clusterByExpr,proto3" json:"cluster_by_expr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *PreInsert) Reset()         { *m = PreInsert{} }
func (m *PreInsert) String() string { return proto.CompactTextString(m) }
func (*PreInsert) ProtoMessage()    {}
func (*PreInsert) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{13}
}
func (m *PreInsert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreInsert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PreInsert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PreInsert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreInsert.Merge(m, src)
}
func (m *PreInsert) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PreInsert) XXX_DiscardUnknown() {
	xxx_messageInfo_PreInsert.DiscardUnknown(m)
}

var xxx_messageInfo_PreInsert proto.InternalMessageInfo

func (m *PreInsert) GetSchemaName() string {
	if m != nil {
		return m.SchemaName
	}
	return ""
}

func (m *PreInsert) GetTableDef() *plan.TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *PreInsert) GetIdx() []int32 {
	if m != nil {
		return m.Idx
	}
	return nil
}

func (m *PreInsert) GetAttrs() []string {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *PreInsert) GetHasAutoCol() bool {
	if m != nil {
		return m.HasAutoCol
	}
	return false
}

func (m *PreInsert) GetIsUpdate() bool {
	if m != nil {
		return m.IsUpdate
	}
	return false
}

func (m *PreInsert) GetEstimatedRowCount() int64 {
	if m != nil {
		return m.EstimatedRowCount
	}
	return 0
}

func (m *PreInsert) GetCompPkeyExpr() *plan.Expr {
	if m != nil {
		return m.CompPkeyExpr
	}
	return nil
}

func (m *PreInsert) GetClusterByExpr() *plan.Expr {
	if m != nil {
		return m.ClusterByExpr
	}
	return nil
}

type LockTarget struct {
	TableId              uint64        `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	PrimaryColIdxInBat   int32         `protobuf:"varint,2,opt,name=primary_col_idx_in_bat,json=primaryColIdxInBat,proto3" json:"primary_col_idx_in_bat,omitempty"`
	PrimaryColTyp        plan.Type     `protobuf:"bytes,3,opt,name=primary_col_typ,json=primaryColTyp,proto3" json:"primary_col_typ"`
	RefreshTsIdxInBat    int32         `protobuf:"varint,4,opt,name=refresh_ts_idx_in_bat,json=refreshTsIdxInBat,proto3" json:"refresh_ts_idx_in_bat,omitempty"`
	FilterColIdxInBat    int32         `protobuf:"varint,5,opt,name=filter_col_idx_in_bat,json=filterColIdxInBat,proto3" json:"filter_col_idx_in_bat,omitempty"`
	LockTable            bool          `protobuf:"varint,6,opt,name=lock_table,json=lockTable,proto3" json:"lock_table,omitempty"`
	ChangeDef            bool          `protobuf:"varint,7,opt,name=ChangeDef,proto3" json:"ChangeDef,omitempty"`
	Mode                 lock.LockMode `protobuf:"varint,8,opt,name=Mode,proto3,enum=lock.LockMode" json:"Mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LockTarget) Reset()         { *m = LockTarget{} }
func (m *LockTarget) String() string { return proto.CompactTextString(m) }
func (*LockTarget) ProtoMessage()    {}
func (*LockTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{14}
}
func (m *LockTarget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockTarget.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LockTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockTarget.Merge(m, src)
}
func (m *LockTarget) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LockTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_LockTarget.DiscardUnknown(m)
}

var xxx_messageInfo_LockTarget proto.InternalMessageInfo

func (m *LockTarget) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *LockTarget) GetPrimaryColIdxInBat() int32 {
	if m != nil {
		return m.PrimaryColIdxInBat
	}
	return 0
}

func (m *LockTarget) GetPrimaryColTyp() plan.Type {
	if m != nil {
		return m.PrimaryColTyp
	}
	return plan.Type{}
}

func (m *LockTarget) GetRefreshTsIdxInBat() int32 {
	if m != nil {
		return m.RefreshTsIdxInBat
	}
	return 0
}

func (m *LockTarget) GetFilterColIdxInBat() int32 {
	if m != nil {
		return m.FilterColIdxInBat
	}
	return 0
}

func (m *LockTarget) GetLockTable() bool {
	if m != nil {
		return m.LockTable
	}
	return false
}

func (m *LockTarget) GetChangeDef() bool {
	if m != nil {
		return m.ChangeDef
	}
	return false
}

func (m *LockTarget) GetMode() lock.LockMode {
	if m != nil {
		return m.Mode
	}
	return lock.LockMode_Exclusive
}

type LockOp struct {
	Targets              []*LockTarget `protobuf:"bytes,1,rep,name=targets,proto3" json:"targets,omitempty"`
	Block                bool          `protobuf:"varint,2,opt,name=block,proto3" json:"block,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LockOp) Reset()         { *m = LockOp{} }
func (m *LockOp) String() string { return proto.CompactTextString(m) }
func (*LockOp) ProtoMessage()    {}
func (*LockOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{15}
}
func (m *LockOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LockOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockOp.Merge(m, src)
}
func (m *LockOp) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LockOp) XXX_DiscardUnknown() {
	xxx_messageInfo_LockOp.DiscardUnknown(m)
}

var xxx_messageInfo_LockOp proto.InternalMessageInfo

func (m *LockOp) GetTargets() []*LockTarget {
	if m != nil {
		return m.Targets
	}
	return nil
}

func (m *LockOp) GetBlock() bool {
	if m != nil {
		return m.Block
	}
	return false
}

type PreInsertUnique struct {
	PreInsertUkCtx       *plan.PreInsertUkCtx `protobuf:"bytes,1,opt,name=pre_insert_uk_ctx,json=preInsertUkCtx,proto3" json:"pre_insert_uk_ctx,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *PreInsertUnique) Reset()         { *m = PreInsertUnique{} }
func (m *PreInsertUnique) String() string { return proto.CompactTextString(m) }
func (*PreInsertUnique) ProtoMessage()    {}
func (*PreInsertUnique) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{16}
}
func (m *PreInsertUnique) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreInsertUnique) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PreInsertUnique.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PreInsertUnique) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreInsertUnique.Merge(m, src)
}
func (m *PreInsertUnique) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PreInsertUnique) XXX_DiscardUnknown() {
	xxx_messageInfo_PreInsertUnique.DiscardUnknown(m)
}

var xxx_messageInfo_PreInsertUnique proto.InternalMessageInfo

func (m *PreInsertUnique) GetPreInsertUkCtx() *plan.PreInsertUkCtx {
	if m != nil {
		return m.PreInsertUkCtx
	}
	return nil
}

type PreInsertSecondaryIndex struct {
	PreInsertSkCtx       *plan.PreInsertUkCtx `protobuf:"bytes,1,opt,name=pre_insert_sk_ctx,json=preInsertSkCtx,proto3" json:"pre_insert_sk_ctx,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *PreInsertSecondaryIndex) Reset()         { *m = PreInsertSecondaryIndex{} }
func (m *PreInsertSecondaryIndex) String() string { return proto.CompactTextString(m) }
func (*PreInsertSecondaryIndex) ProtoMessage()    {}
func (*PreInsertSecondaryIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{17}
}
func (m *PreInsertSecondaryIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreInsertSecondaryIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PreInsertSecondaryIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PreInsertSecondaryIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreInsertSecondaryIndex.Merge(m, src)
}
func (m *PreInsertSecondaryIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PreInsertSecondaryIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_PreInsertSecondaryIndex.DiscardUnknown(m)
}

var xxx_messageInfo_PreInsertSecondaryIndex proto.InternalMessageInfo

func (m *PreInsertSecondaryIndex) GetPreInsertSkCtx() *plan.PreInsertUkCtx {
	if m != nil {
		return m.PreInsertSkCtx
	}
	return nil
}

type OnDuplicateKey struct {
	// letter case: origin
	Attrs                []string              `protobuf:"bytes,1,rep,name=attrs,proto3" json:"attrs,omitempty"`
	InsertColCount       int32                 `protobuf:"varint,2,opt,name=insert_col_count,json=insertColCount,proto3" json:"insert_col_count,omitempty"`
	UniqueColCheckExpr   []*plan.Expr          `protobuf:"bytes,3,rep,name=unique_col_check_expr,json=uniqueColCheckExpr,proto3" json:"unique_col_check_expr,omitempty"`
	UniqueCols           []string              `protobuf:"bytes,4,rep,name=unique_cols,json=uniqueCols,proto3" json:"unique_cols,omitempty"`
	OnDuplicateIdx       []int32               `protobuf:"varint,5,rep,packed,name=on_duplicate_idx,json=onDuplicateIdx,proto3" json:"on_duplicate_idx,omitempty"`
	OnDuplicateExpr      map[string]*plan.Expr `protobuf:"bytes,6,rep,name=on_duplicate_expr,json=onDuplicateExpr,proto3" json:"on_duplicate_expr,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	IsIgnore             bool                  `protobuf:"varint,7,opt,name=is_ignore,json=isIgnore,proto3" json:"is_ignore,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *OnDuplicateKey) Reset()         { *m = OnDuplicateKey{} }
func (m *OnDuplicateKey) String() string { return proto.CompactTextString(m) }
func (*OnDuplicateKey) ProtoMessage()    {}
func (*OnDuplicateKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{18}
}
func (m *OnDuplicateKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OnDuplicateKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OnDuplicateKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OnDuplicateKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnDuplicateKey.Merge(m, src)
}
func (m *OnDuplicateKey) XXX_Size() int {
	return m.ProtoSize()
}
func (m *OnDuplicateKey) XXX_DiscardUnknown() {
	xxx_messageInfo_OnDuplicateKey.DiscardUnknown(m)
}

var xxx_messageInfo_OnDuplicateKey proto.InternalMessageInfo

func (m *OnDuplicateKey) GetAttrs() []string {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *OnDuplicateKey) GetInsertColCount() int32 {
	if m != nil {
		return m.InsertColCount
	}
	return 0
}

func (m *OnDuplicateKey) GetUniqueColCheckExpr() []*plan.Expr {
	if m != nil {
		return m.UniqueColCheckExpr
	}
	return nil
}

func (m *OnDuplicateKey) GetUniqueCols() []string {
	if m != nil {
		return m.UniqueCols
	}
	return nil
}

func (m *OnDuplicateKey) GetOnDuplicateIdx() []int32 {
	if m != nil {
		return m.OnDuplicateIdx
	}
	return nil
}

func (m *OnDuplicateKey) GetOnDuplicateExpr() map[string]*plan.Expr {
	if m != nil {
		return m.OnDuplicateExpr
	}
	return nil
}

func (m *OnDuplicateKey) GetIsIgnore() bool {
	if m != nil {
		return m.IsIgnore
	}
	return false
}

type FuzzyFilter struct {
	N                    float32   `protobuf:"fixed32,1,opt,name=N,proto3" json:"N,omitempty"`
	PkName               string    `protobuf:"bytes,2,opt,name=PkName,proto3" json:"PkName,omitempty"`
	PkTyp                plan.Type `protobuf:"bytes,3,opt,name=PkTyp,proto3" json:"PkTyp"`
	BuildIdx             int32     `protobuf:"varint,4,opt,name=BuildIdx,proto3" json:"BuildIdx,omitempty"`
	IfInsertFromUnique   bool      `protobuf:"varint,5,opt,name=IfInsertFromUnique,proto3" json:"IfInsertFromUnique,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *FuzzyFilter) Reset()         { *m = FuzzyFilter{} }
func (m *FuzzyFilter) String() string { return proto.CompactTextString(m) }
func (*FuzzyFilter) ProtoMessage()    {}
func (*FuzzyFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{19}
}
func (m *FuzzyFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FuzzyFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FuzzyFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FuzzyFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FuzzyFilter.Merge(m, src)
}
func (m *FuzzyFilter) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FuzzyFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_FuzzyFilter.DiscardUnknown(m)
}

var xxx_messageInfo_FuzzyFilter proto.InternalMessageInfo

func (m *FuzzyFilter) GetN() float32 {
	if m != nil {
		return m.N
	}
	return 0
}

func (m *FuzzyFilter) GetPkName() string {
	if m != nil {
		return m.PkName
	}
	return ""
}

func (m *FuzzyFilter) GetPkTyp() plan.Type {
	if m != nil {
		return m.PkTyp
	}
	return plan.Type{}
}

func (m *FuzzyFilter) GetBuildIdx() int32 {
	if m != nil {
		return m.BuildIdx
	}
	return 0
}

func (m *FuzzyFilter) GetIfInsertFromUnique() bool {
	if m != nil {
		return m.IfInsertFromUnique
	}
	return false
}

type Join struct {
	RelList                []int32                   `protobuf:"varint,1,rep,packed,name=rel_list,json=relList,proto3" json:"rel_list,omitempty"`
	ColList                []int32                   `protobuf:"varint,2,rep,packed,name=col_list,json=colList,proto3" json:"col_list,omitempty"`
	Expr                   *plan.Expr                `protobuf:"bytes,3,opt,name=expr,proto3" json:"expr,omitempty"`
	Types                  []plan.Type               `protobuf:"bytes,4,rep,name=types,proto3" json:"types"`
	LeftCond               []*plan.Expr              `protobuf:"bytes,5,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond              []*plan.Expr              `protobuf:"bytes,6,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	RuntimeFilterBuildList []*plan.RuntimeFilterSpec `protobuf:"bytes,7,rep,name=runtime_filter_build_list,json=runtimeFilterBuildList,proto3" json:"runtime_filter_build_list,omitempty"`
	HashOnPk               bool                      `protobuf:"varint,8,opt,name=hash_on_pk,json=hashOnPk,proto3" json:"hash_on_pk,omitempty"`
	IsShuffle              bool                      `protobuf:"varint,9,opt,name=is_shuffle,json=isShuffle,proto3" json:"is_shuffle,omitempty"`
	JoinMapTag             int32                     `protobuf:"varint,10,opt,name=join_map_tag,json=joinMapTag,proto3" json:"join_map_tag,omitempty"`
	ShuffleIdx             int32                     `protobuf:"varint,11,opt,name=shuffle_idx,json=shuffleIdx,proto3" json:"shuffle_idx,omitempty"`
	JoinType               int32                     `protobuf:"varint,12,opt,name=join_type,json=joinType,proto3" json:"join_type,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                  `json:"-"`
	XXX_unrecognized       []byte                    `json:"-"`
	XXX_sizecache          int32                     `json:"-"`
}

func (m *Join) Reset()         { *m = Join{} }
func (m *Join) String() string { return proto.CompactTextString(m) }
func (*Join) ProtoMessage()    {}
func (*Join) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{20}
}
func (m *Join) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Join) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Join.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Join) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Join.Merge(m, src)
}
func (m *Join) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Join) XXX_DiscardUnknown() {
	xxx_messageInfo_Join.DiscardUnknown(m)
}

var xxx_messageInfo_Join proto.InternalMessageInfo

func (m *Join) GetRelList() []int32 {
	if m != nil {
		return m.RelList
	}
	return nil
}

func (m *Join) GetColList() []int32 {
	if m != nil {
		return m.ColList
	}
	return nil
}

func (m *Join) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Join) GetTypes() []plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *Join) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *Join) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

func (m *Join) GetRuntimeFilterBuildList() []*plan.RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterBuildList
	}
	return nil
}

func (m *Join) GetHashOnPk() bool {
	if m != nil {
		return m.HashOnPk
	}
	return false
}

func (m *Join) GetIsShuffle() bool {
	if m != nil {
		return m.IsShuffle
	}
	return false
}

func (m *Join) GetJoinMapTag() int32 {
	if m != nil {
		return m.JoinMapTag
	}
	return 0
}

func (m *Join) GetShuffleIdx() int32 {
	if m != nil {
		return m.ShuffleIdx
	}
	return 0
}

func (m *Join) GetJoinType() int32 {
	if m != nil {
		return m.JoinType
	}
	return 0
}

type AntiJoin struct {
	Result                 []int32                   `protobuf:"varint,1,rep,packed,name=result,proto3" json:"result,omitempty"`
	Expr                   *plan.Expr                `protobuf:"bytes,2,opt,name=expr,proto3" json:"expr,omitempty"`
	LeftCond               []*plan.Expr              `protobuf:"bytes,3,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond              []*plan.Expr              `protobuf:"bytes,4,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	HashOnPk               bool                      `protobuf:"varint,5,opt,name=hash_on_pk,json=hashOnPk,proto3" json:"hash_on_pk,omitempty"`
	IsShuffle              bool                      `protobuf:"varint,6,opt,name=is_shuffle,json=isShuffle,proto3" json:"is_shuffle,omitempty"`
	RuntimeFilterBuildList []*plan.RuntimeFilterSpec `protobuf:"bytes,7,rep,name=runtime_filter_build_list,json=runtimeFilterBuildList,proto3" json:"runtime_filter_build_list,omitempty"`
	JoinMapTag             int32                     `protobuf:"varint,8,opt,name=join_map_tag,json=joinMapTag,proto3" json:"join_map_tag,omitempty"`
	ShuffleIdx             int32                     `protobuf:"varint,9,opt,name=shuffle_idx,json=shuffleIdx,proto3" json:"shuffle_idx,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                  `json:"-"`
	XXX_unrecognized       []byte                    `json:"-"`
	XXX_sizecache          int32                     `json:"-"`
}

func (m *AntiJoin) Reset()         { *m = AntiJoin{} }
func (m *AntiJoin) String() string { return proto.CompactTextString(m) }
func (*AntiJoin) ProtoMessage()    {}
func (*AntiJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{21}
}
func (m *AntiJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AntiJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AntiJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AntiJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AntiJoin.Merge(m, src)
}
func (m *AntiJoin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AntiJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_AntiJoin.DiscardUnknown(m)
}

var xxx_messageInfo_AntiJoin proto.InternalMessageInfo

func (m *AntiJoin) GetResult() []int32 {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *AntiJoin) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *AntiJoin) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *AntiJoin) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

func (m *AntiJoin) GetHashOnPk() bool {
	if m != nil {
		return m.HashOnPk
	}
	return false
}

func (m *AntiJoin) GetIsShuffle() bool {
	if m != nil {
		return m.IsShuffle
	}
	return false
}

func (m *AntiJoin) GetRuntimeFilterBuildList() []*plan.RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterBuildList
	}
	return nil
}

func (m *AntiJoin) GetJoinMapTag() int32 {
	if m != nil {
		return m.JoinMapTag
	}
	return 0
}

func (m *AntiJoin) GetShuffleIdx() int32 {
	if m != nil {
		return m.ShuffleIdx
	}
	return 0
}

type LeftJoin struct {
	RelList                []int32                   `protobuf:"varint,1,rep,packed,name=rel_list,json=relList,proto3" json:"rel_list,omitempty"`
	ColList                []int32                   `protobuf:"varint,2,rep,packed,name=col_list,json=colList,proto3" json:"col_list,omitempty"`
	Expr                   *plan.Expr                `protobuf:"bytes,3,opt,name=expr,proto3" json:"expr,omitempty"`
	Types                  []plan.Type               `protobuf:"bytes,4,rep,name=types,proto3" json:"types"`
	LeftCond               []*plan.Expr              `protobuf:"bytes,5,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond              []*plan.Expr              `protobuf:"bytes,6,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	RuntimeFilterBuildList []*plan.RuntimeFilterSpec `protobuf:"bytes,7,rep,name=runtime_filter_build_list,json=runtimeFilterBuildList,proto3" json:"runtime_filter_build_list,omitempty"`
	HashOnPk               bool                      `protobuf:"varint,8,opt,name=hash_on_pk,json=hashOnPk,proto3" json:"hash_on_pk,omitempty"`
	IsShuffle              bool                      `protobuf:"varint,9,opt,name=is_shuffle,json=isShuffle,proto3" json:"is_shuffle,omitempty"`
	JoinMapTag             int32                     `protobuf:"varint,10,opt,name=join_map_tag,json=joinMapTag,proto3" json:"join_map_tag,omitempty"`
	ShuffleIdx             int32                     `protobuf:"varint,11,opt,name=shuffle_idx,json=shuffleIdx,proto3" json:"shuffle_idx,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                  `json:"-"`
	XXX_unrecognized       []byte                    `json:"-"`
	XXX_sizecache          int32                     `json:"-"`
}

func (m *LeftJoin) Reset()         { *m = LeftJoin{} }
func (m *LeftJoin) String() string { return proto.CompactTextString(m) }
func (*LeftJoin) ProtoMessage()    {}
func (*LeftJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{22}
}
func (m *LeftJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeftJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeftJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeftJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeftJoin.Merge(m, src)
}
func (m *LeftJoin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LeftJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_LeftJoin.DiscardUnknown(m)
}

var xxx_messageInfo_LeftJoin proto.InternalMessageInfo

func (m *LeftJoin) GetRelList() []int32 {
	if m != nil {
		return m.RelList
	}
	return nil
}

func (m *LeftJoin) GetColList() []int32 {
	if m != nil {
		return m.ColList
	}
	return nil
}

func (m *LeftJoin) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *LeftJoin) GetTypes() []plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *LeftJoin) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *LeftJoin) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

func (m *LeftJoin) GetRuntimeFilterBuildList() []*plan.RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterBuildList
	}
	return nil
}

func (m *LeftJoin) GetHashOnPk() bool {
	if m != nil {
		return m.HashOnPk
	}
	return false
}

func (m *LeftJoin) GetIsShuffle() bool {
	if m != nil {
		return m.IsShuffle
	}
	return false
}

func (m *LeftJoin) GetJoinMapTag() int32 {
	if m != nil {
		return m.JoinMapTag
	}
	return 0
}

func (m *LeftJoin) GetShuffleIdx() int32 {
	if m != nil {
		return m.ShuffleIdx
	}
	return 0
}

type RightJoin struct {
	RelList                []int32                   `protobuf:"varint,1,rep,packed,name=rel_list,json=relList,proto3" json:"rel_list,omitempty"`
	ColList                []int32                   `protobuf:"varint,2,rep,packed,name=col_list,json=colList,proto3" json:"col_list,omitempty"`
	Expr                   *plan.Expr                `protobuf:"bytes,3,opt,name=expr,proto3" json:"expr,omitempty"`
	LeftTypes              []plan.Type               `protobuf:"bytes,4,rep,name=left_types,json=leftTypes,proto3" json:"left_types"`
	RightTypes             []plan.Type               `protobuf:"bytes,5,rep,name=right_types,json=rightTypes,proto3" json:"right_types"`
	LeftCond               []*plan.Expr              `protobuf:"bytes,6,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond              []*plan.Expr              `protobuf:"bytes,7,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	RuntimeFilterBuildList []*plan.RuntimeFilterSpec `protobuf:"bytes,8,rep,name=runtime_filter_build_list,json=runtimeFilterBuildList,proto3" json:"runtime_filter_build_list,omitempty"`
	HashOnPk               bool                      `protobuf:"varint,9,opt,name=hash_on_pk,json=hashOnPk,proto3" json:"hash_on_pk,omitempty"`
	IsShuffle              bool                      `protobuf:"varint,10,opt,name=is_shuffle,json=isShuffle,proto3" json:"is_shuffle,omitempty"`
	JoinMapTag             int32                     `protobuf:"varint,11,opt,name=join_map_tag,json=joinMapTag,proto3" json:"join_map_tag,omitempty"`
	ShuffleIdx             int32                     `protobuf:"varint,12,opt,name=shuffle_idx,json=shuffleIdx,proto3" json:"shuffle_idx,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                  `json:"-"`
	XXX_unrecognized       []byte                    `json:"-"`
	XXX_sizecache          int32                     `json:"-"`
}

func (m *RightJoin) Reset()         { *m = RightJoin{} }
func (m *RightJoin) String() string { return proto.CompactTextString(m) }
func (*RightJoin) ProtoMessage()    {}
func (*RightJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{23}
}
func (m *RightJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RightJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RightJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RightJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RightJoin.Merge(m, src)
}
func (m *RightJoin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RightJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_RightJoin.DiscardUnknown(m)
}

var xxx_messageInfo_RightJoin proto.InternalMessageInfo

func (m *RightJoin) GetRelList() []int32 {
	if m != nil {
		return m.RelList
	}
	return nil
}

func (m *RightJoin) GetColList() []int32 {
	if m != nil {
		return m.ColList
	}
	return nil
}

func (m *RightJoin) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *RightJoin) GetLeftTypes() []plan.Type {
	if m != nil {
		return m.LeftTypes
	}
	return nil
}

func (m *RightJoin) GetRightTypes() []plan.Type {
	if m != nil {
		return m.RightTypes
	}
	return nil
}

func (m *RightJoin) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *RightJoin) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

func (m *RightJoin) GetRuntimeFilterBuildList() []*plan.RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterBuildList
	}
	return nil
}

func (m *RightJoin) GetHashOnPk() bool {
	if m != nil {
		return m.HashOnPk
	}
	return false
}

func (m *RightJoin) GetIsShuffle() bool {
	if m != nil {
		return m.IsShuffle
	}
	return false
}

func (m *RightJoin) GetJoinMapTag() int32 {
	if m != nil {
		return m.JoinMapTag
	}
	return 0
}

func (m *RightJoin) GetShuffleIdx() int32 {
	if m != nil {
		return m.ShuffleIdx
	}
	return 0
}

type RightSemiJoin struct {
	Result                 []int32                   `protobuf:"varint,1,rep,packed,name=result,proto3" json:"result,omitempty"`
	Expr                   *plan.Expr                `protobuf:"bytes,2,opt,name=expr,proto3" json:"expr,omitempty"`
	RightTypes             []plan.Type               `protobuf:"bytes,3,rep,name=right_types,json=rightTypes,proto3" json:"right_types"`
	LeftCond               []*plan.Expr              `protobuf:"bytes,4,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond              []*plan.Expr              `protobuf:"bytes,5,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	RuntimeFilterBuildList []*plan.RuntimeFilterSpec `protobuf:"bytes,6,rep,name=runtime_filter_build_list,json=runtimeFilterBuildList,proto3" json:"runtime_filter_build_list,omitempty"`
	HashOnPk               bool                      `protobuf:"varint,7,opt,name=hash_on_pk,json=hashOnPk,proto3" json:"hash_on_pk,omitempty"`
	IsShuffle              bool                      `protobuf:"varint,8,opt,name=is_shuffle,json=isShuffle,proto3" json:"is_shuffle,omitempty"`
	JoinMapTag             int32                     `protobuf:"varint,9,opt,name=join_map_tag,json=joinMapTag,proto3" json:"join_map_tag,omitempty"`
	ShuffleIdx             int32                     `protobuf:"varint,11,opt,name=shuffle_idx,json=shuffleIdx,proto3" json:"shuffle_idx,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                  `json:"-"`
	XXX_unrecognized       []byte                    `json:"-"`
	XXX_sizecache          int32                     `json:"-"`
}

func (m *RightSemiJoin) Reset()         { *m = RightSemiJoin{} }
func (m *RightSemiJoin) String() string { return proto.CompactTextString(m) }
func (*RightSemiJoin) ProtoMessage()    {}
func (*RightSemiJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{24}
}
func (m *RightSemiJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RightSemiJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RightSemiJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RightSemiJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RightSemiJoin.Merge(m, src)
}
func (m *RightSemiJoin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RightSemiJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_RightSemiJoin.DiscardUnknown(m)
}

var xxx_messageInfo_RightSemiJoin proto.InternalMessageInfo

func (m *RightSemiJoin) GetResult() []int32 {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *RightSemiJoin) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *RightSemiJoin) GetRightTypes() []plan.Type {
	if m != nil {
		return m.RightTypes
	}
	return nil
}

func (m *RightSemiJoin) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *RightSemiJoin) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

func (m *RightSemiJoin) GetRuntimeFilterBuildList() []*plan.RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterBuildList
	}
	return nil
}

func (m *RightSemiJoin) GetHashOnPk() bool {
	if m != nil {
		return m.HashOnPk
	}
	return false
}

func (m *RightSemiJoin) GetIsShuffle() bool {
	if m != nil {
		return m.IsShuffle
	}
	return false
}

func (m *RightSemiJoin) GetJoinMapTag() int32 {
	if m != nil {
		return m.JoinMapTag
	}
	return 0
}

func (m *RightSemiJoin) GetShuffleIdx() int32 {
	if m != nil {
		return m.ShuffleIdx
	}
	return 0
}

type RightAntiJoin struct {
	Result                 []int32                   `protobuf:"varint,1,rep,packed,name=result,proto3" json:"result,omitempty"`
	Expr                   *plan.Expr                `protobuf:"bytes,2,opt,name=expr,proto3" json:"expr,omitempty"`
	RightTypes             []plan.Type               `protobuf:"bytes,3,rep,name=right_types,json=rightTypes,proto3" json:"right_types"`
	LeftCond               []*plan.Expr              `protobuf:"bytes,4,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond              []*plan.Expr              `protobuf:"bytes,5,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	RuntimeFilterBuildList []*plan.RuntimeFilterSpec `protobuf:"bytes,6,rep,name=runtime_filter_build_list,json=runtimeFilterBuildList,proto3" json:"runtime_filter_build_list,omitempty"`
	HashOnPk               bool                      `protobuf:"varint,7,opt,name=hash_on_pk,json=hashOnPk,proto3" json:"hash_on_pk,omitempty"`
	IsShuffle              bool                      `protobuf:"varint,8,opt,name=is_shuffle,json=isShuffle,proto3" json:"is_shuffle,omitempty"`
	JoinMapTag             int32                     `protobuf:"varint,9,opt,name=join_map_tag,json=joinMapTag,proto3" json:"join_map_tag,omitempty"`
	ShuffleIdx             int32                     `protobuf:"varint,10,opt,name=shuffle_idx,json=shuffleIdx,proto3" json:"shuffle_idx,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                  `json:"-"`
	XXX_unrecognized       []byte                    `json:"-"`
	XXX_sizecache          int32                     `json:"-"`
}

func (m *RightAntiJoin) Reset()         { *m = RightAntiJoin{} }
func (m *RightAntiJoin) String() string { return proto.CompactTextString(m) }
func (*RightAntiJoin) ProtoMessage()    {}
func (*RightAntiJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{25}
}
func (m *RightAntiJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RightAntiJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RightAntiJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RightAntiJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RightAntiJoin.Merge(m, src)
}
func (m *RightAntiJoin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RightAntiJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_RightAntiJoin.DiscardUnknown(m)
}

var xxx_messageInfo_RightAntiJoin proto.InternalMessageInfo

func (m *RightAntiJoin) GetResult() []int32 {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *RightAntiJoin) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *RightAntiJoin) GetRightTypes() []plan.Type {
	if m != nil {
		return m.RightTypes
	}
	return nil
}

func (m *RightAntiJoin) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *RightAntiJoin) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

func (m *RightAntiJoin) GetRuntimeFilterBuildList() []*plan.RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterBuildList
	}
	return nil
}

func (m *RightAntiJoin) GetHashOnPk() bool {
	if m != nil {
		return m.HashOnPk
	}
	return false
}

func (m *RightAntiJoin) GetIsShuffle() bool {
	if m != nil {
		return m.IsShuffle
	}
	return false
}

func (m *RightAntiJoin) GetJoinMapTag() int32 {
	if m != nil {
		return m.JoinMapTag
	}
	return 0
}

func (m *RightAntiJoin) GetShuffleIdx() int32 {
	if m != nil {
		return m.ShuffleIdx
	}
	return 0
}

type SemiJoin struct {
	Result                 []int32                   `protobuf:"varint,1,rep,packed,name=result,proto3" json:"result,omitempty"`
	Expr                   *plan.Expr                `protobuf:"bytes,2,opt,name=expr,proto3" json:"expr,omitempty"`
	LeftCond               []*plan.Expr              `protobuf:"bytes,3,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond              []*plan.Expr              `protobuf:"bytes,4,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	RuntimeFilterBuildList []*plan.RuntimeFilterSpec `protobuf:"bytes,5,rep,name=runtime_filter_build_list,json=runtimeFilterBuildList,proto3" json:"runtime_filter_build_list,omitempty"`
	HashOnPk               bool                      `protobuf:"varint,6,opt,name=hash_on_pk,json=hashOnPk,proto3" json:"hash_on_pk,omitempty"`
	IsShuffle              bool                      `protobuf:"varint,7,opt,name=is_shuffle,json=isShuffle,proto3" json:"is_shuffle,omitempty"`
	JoinMapTag             int32                     `protobuf:"varint,8,opt,name=join_map_tag,json=joinMapTag,proto3" json:"join_map_tag,omitempty"`
	ShuffleIdx             int32                     `protobuf:"varint,9,opt,name=shuffle_idx,json=shuffleIdx,proto3" json:"shuffle_idx,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                  `json:"-"`
	XXX_unrecognized       []byte                    `json:"-"`
	XXX_sizecache          int32                     `json:"-"`
}

func (m *SemiJoin) Reset()         { *m = SemiJoin{} }
func (m *SemiJoin) String() string { return proto.CompactTextString(m) }
func (*SemiJoin) ProtoMessage()    {}
func (*SemiJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{26}
}
func (m *SemiJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SemiJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SemiJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SemiJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SemiJoin.Merge(m, src)
}
func (m *SemiJoin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SemiJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_SemiJoin.DiscardUnknown(m)
}

var xxx_messageInfo_SemiJoin proto.InternalMessageInfo

func (m *SemiJoin) GetResult() []int32 {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *SemiJoin) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *SemiJoin) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *SemiJoin) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

func (m *SemiJoin) GetRuntimeFilterBuildList() []*plan.RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterBuildList
	}
	return nil
}

func (m *SemiJoin) GetHashOnPk() bool {
	if m != nil {
		return m.HashOnPk
	}
	return false
}

func (m *SemiJoin) GetIsShuffle() bool {
	if m != nil {
		return m.IsShuffle
	}
	return false
}

func (m *SemiJoin) GetJoinMapTag() int32 {
	if m != nil {
		return m.JoinMapTag
	}
	return 0
}

func (m *SemiJoin) GetShuffleIdx() int32 {
	if m != nil {
		return m.ShuffleIdx
	}
	return 0
}

type SingleJoin struct {
	RelList                []int32                   `protobuf:"varint,1,rep,packed,name=rel_list,json=relList,proto3" json:"rel_list,omitempty"`
	ColList                []int32                   `protobuf:"varint,2,rep,packed,name=col_list,json=colList,proto3" json:"col_list,omitempty"`
	Expr                   *plan.Expr                `protobuf:"bytes,3,opt,name=expr,proto3" json:"expr,omitempty"`
	Types                  []plan.Type               `protobuf:"bytes,4,rep,name=types,proto3" json:"types"`
	LeftCond               []*plan.Expr              `protobuf:"bytes,5,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond              []*plan.Expr              `protobuf:"bytes,6,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	RuntimeFilterBuildList []*plan.RuntimeFilterSpec `protobuf:"bytes,7,rep,name=runtime_filter_build_list,json=runtimeFilterBuildList,proto3" json:"runtime_filter_build_list,omitempty"`
	HashOnPk               bool                      `protobuf:"varint,8,opt,name=hash_on_pk,json=hashOnPk,proto3" json:"hash_on_pk,omitempty"`
	IsShuffle              bool                      `protobuf:"varint,9,opt,name=is_shuffle,json=isShuffle,proto3" json:"is_shuffle,omitempty"`
	JoinMapTag             int32                     `protobuf:"varint,10,opt,name=join_map_tag,json=joinMapTag,proto3" json:"join_map_tag,omitempty"`
	ShuffleIdx             int32                     `protobuf:"varint,11,opt,name=shuffle_idx,json=shuffleIdx,proto3" json:"shuffle_idx,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                  `json:"-"`
	XXX_unrecognized       []byte                    `json:"-"`
	XXX_sizecache          int32                     `json:"-"`
}

func (m *SingleJoin) Reset()         { *m = SingleJoin{} }
func (m *SingleJoin) String() string { return proto.CompactTextString(m) }
func (*SingleJoin) ProtoMessage()    {}
func (*SingleJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{27}
}
func (m *SingleJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SingleJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SingleJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SingleJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SingleJoin.Merge(m, src)
}
func (m *SingleJoin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SingleJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_SingleJoin.DiscardUnknown(m)
}

var xxx_messageInfo_SingleJoin proto.InternalMessageInfo

func (m *SingleJoin) GetRelList() []int32 {
	if m != nil {
		return m.RelList
	}
	return nil
}

func (m *SingleJoin) GetColList() []int32 {
	if m != nil {
		return m.ColList
	}
	return nil
}

func (m *SingleJoin) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *SingleJoin) GetTypes() []plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *SingleJoin) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *SingleJoin) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

func (m *SingleJoin) GetRuntimeFilterBuildList() []*plan.RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterBuildList
	}
	return nil
}

func (m *SingleJoin) GetHashOnPk() bool {
	if m != nil {
		return m.HashOnPk
	}
	return false
}

func (m *SingleJoin) GetIsShuffle() bool {
	if m != nil {
		return m.IsShuffle
	}
	return false
}

func (m *SingleJoin) GetJoinMapTag() int32 {
	if m != nil {
		return m.JoinMapTag
	}
	return 0
}

func (m *SingleJoin) GetShuffleIdx() int32 {
	if m != nil {
		return m.ShuffleIdx
	}
	return 0
}

type MarkJoin struct {
	Result               []int32      `protobuf:"varint,1,rep,packed,name=result,proto3" json:"result,omitempty"`
	Expr                 *plan.Expr   `protobuf:"bytes,2,opt,name=expr,proto3" json:"expr,omitempty"`
	LeftCond             []*plan.Expr `protobuf:"bytes,3,rep,name=left_cond,json=leftCond,proto3" json:"left_cond,omitempty"`
	RightCond            []*plan.Expr `protobuf:"bytes,4,rep,name=right_cond,json=rightCond,proto3" json:"right_cond,omitempty"`
	OnList               []*plan.Expr `protobuf:"bytes,5,rep,name=on_list,json=onList,proto3" json:"on_list,omitempty"`
	HashOnPk             bool         `protobuf:"varint,6,opt,name=hash_on_pk,json=hashOnPk,proto3" json:"hash_on_pk,omitempty"`
	IsShuffle            bool         `protobuf:"varint,7,opt,name=is_shuffle,json=isShuffle,proto3" json:"is_shuffle,omitempty"`
	JoinMapTag           int32        `protobuf:"varint,8,opt,name=join_map_tag,json=joinMapTag,proto3" json:"join_map_tag,omitempty"`
	ShuffleIdx           int32        `protobuf:"varint,9,opt,name=shuffle_idx,json=shuffleIdx,proto3" json:"shuffle_idx,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *MarkJoin) Reset()         { *m = MarkJoin{} }
func (m *MarkJoin) String() string { return proto.CompactTextString(m) }
func (*MarkJoin) ProtoMessage()    {}
func (*MarkJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{28}
}
func (m *MarkJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarkJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkJoin.Merge(m, src)
}
func (m *MarkJoin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MarkJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkJoin.DiscardUnknown(m)
}

var xxx_messageInfo_MarkJoin proto.InternalMessageInfo

func (m *MarkJoin) GetResult() []int32 {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *MarkJoin) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *MarkJoin) GetLeftCond() []*plan.Expr {
	if m != nil {
		return m.LeftCond
	}
	return nil
}

func (m *MarkJoin) GetRightCond() []*plan.Expr {
	if m != nil {
		return m.RightCond
	}
	return nil
}

func (m *MarkJoin) GetOnList() []*plan.Expr {
	if m != nil {
		return m.OnList
	}
	return nil
}

func (m *MarkJoin) GetHashOnPk() bool {
	if m != nil {
		return m.HashOnPk
	}
	return false
}

func (m *MarkJoin) GetIsShuffle() bool {
	if m != nil {
		return m.IsShuffle
	}
	return false
}

func (m *MarkJoin) GetJoinMapTag() int32 {
	if m != nil {
		return m.JoinMapTag
	}
	return 0
}

func (m *MarkJoin) GetShuffleIdx() int32 {
	if m != nil {
		return m.ShuffleIdx
	}
	return 0
}

type Product struct {
	RelList              []int32  `protobuf:"varint,1,rep,packed,name=rel_list,json=relList,proto3" json:"rel_list,omitempty"`
	ColList              []int32  `protobuf:"varint,2,rep,packed,name=col_list,json=colList,proto3" json:"col_list,omitempty"`
	IsShuffle            bool     `protobuf:"varint,3,opt,name=is_shuffle,json=isShuffle,proto3" json:"is_shuffle,omitempty"`
	JoinMapTag           int32    `protobuf:"varint,4,opt,name=join_map_tag,json=joinMapTag,proto3" json:"join_map_tag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Product) Reset()         { *m = Product{} }
func (m *Product) String() string { return proto.CompactTextString(m) }
func (*Product) ProtoMessage()    {}
func (*Product) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{29}
}
func (m *Product) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Product) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Product.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Product) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Product.Merge(m, src)
}
func (m *Product) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Product) XXX_DiscardUnknown() {
	xxx_messageInfo_Product.DiscardUnknown(m)
}

var xxx_messageInfo_Product proto.InternalMessageInfo

func (m *Product) GetRelList() []int32 {
	if m != nil {
		return m.RelList
	}
	return nil
}

func (m *Product) GetColList() []int32 {
	if m != nil {
		return m.ColList
	}
	return nil
}

func (m *Product) GetIsShuffle() bool {
	if m != nil {
		return m.IsShuffle
	}
	return false
}

func (m *Product) GetJoinMapTag() int32 {
	if m != nil {
		return m.JoinMapTag
	}
	return 0
}

type ProductL2 struct {
	RelList              []int32    `protobuf:"varint,1,rep,packed,name=rel_list,json=relList,proto3" json:"rel_list,omitempty"`
	ColList              []int32    `protobuf:"varint,2,rep,packed,name=col_list,json=colList,proto3" json:"col_list,omitempty"`
	Expr                 *plan.Expr `protobuf:"bytes,3,opt,name=expr,proto3" json:"expr,omitempty"`
	JoinMapTag           int32      `protobuf:"varint,4,opt,name=join_map_tag,json=joinMapTag,proto3" json:"join_map_tag,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ProductL2) Reset()         { *m = ProductL2{} }
func (m *ProductL2) String() string { return proto.CompactTextString(m) }
func (*ProductL2) ProtoMessage()    {}
func (*ProductL2) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{30}
}
func (m *ProductL2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductL2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductL2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProductL2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductL2.Merge(m, src)
}
func (m *ProductL2) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ProductL2) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductL2.DiscardUnknown(m)
}

var xxx_messageInfo_ProductL2 proto.InternalMessageInfo

func (m *ProductL2) GetRelList() []int32 {
	if m != nil {
		return m.RelList
	}
	return nil
}

func (m *ProductL2) GetColList() []int32 {
	if m != nil {
		return m.ColList
	}
	return nil
}

func (m *ProductL2) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *ProductL2) GetJoinMapTag() int32 {
	if m != nil {
		return m.JoinMapTag
	}
	return 0
}

type IndexJoin struct {
	Result                 []int32                   `protobuf:"varint,1,rep,packed,name=result,proto3" json:"result,omitempty"`
	RuntimeFilterBuildList []*plan.RuntimeFilterSpec `protobuf:"bytes,2,rep,name=runtime_filter_build_list,json=runtimeFilterBuildList,proto3" json:"runtime_filter_build_list,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                  `json:"-"`
	XXX_unrecognized       []byte                    `json:"-"`
	XXX_sizecache          int32                     `json:"-"`
}

func (m *IndexJoin) Reset()         { *m = IndexJoin{} }
func (m *IndexJoin) String() string { return proto.CompactTextString(m) }
func (*IndexJoin) ProtoMessage()    {}
func (*IndexJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{31}
}
func (m *IndexJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexJoin.Merge(m, src)
}
func (m *IndexJoin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *IndexJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexJoin.DiscardUnknown(m)
}

var xxx_messageInfo_IndexJoin proto.InternalMessageInfo

func (m *IndexJoin) GetResult() []int32 {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *IndexJoin) GetRuntimeFilterBuildList() []*plan.RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterBuildList
	}
	return nil
}

type TableFunction struct {
	Attrs                []string       `protobuf:"bytes,1,rep,name=attrs,proto3" json:"attrs,omitempty"`
	Rets                 []*plan.ColDef `protobuf:"bytes,2,rep,name=rets,proto3" json:"rets,omitempty"`
	Args                 []*plan.Expr   `protobuf:"bytes,3,rep,name=args,proto3" json:"args,omitempty"`
	Params               []byte         `protobuf:"bytes,4,opt,name=params,proto3" json:"params,omitempty"`
	Name                 string         `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TableFunction) Reset()         { *m = TableFunction{} }
func (m *TableFunction) String() string { return proto.CompactTextString(m) }
func (*TableFunction) ProtoMessage()    {}
func (*TableFunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{32}
}
func (m *TableFunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableFunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableFunction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableFunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableFunction.Merge(m, src)
}
func (m *TableFunction) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableFunction) XXX_DiscardUnknown() {
	xxx_messageInfo_TableFunction.DiscardUnknown(m)
}

var xxx_messageInfo_TableFunction proto.InternalMessageInfo

func (m *TableFunction) GetAttrs() []string {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *TableFunction) GetRets() []*plan.ColDef {
	if m != nil {
		return m.Rets
	}
	return nil
}

func (m *TableFunction) GetArgs() []*plan.Expr {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *TableFunction) GetParams() []byte {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *TableFunction) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ExternalName2ColIndex struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Index                int32    `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExternalName2ColIndex) Reset()         { *m = ExternalName2ColIndex{} }
func (m *ExternalName2ColIndex) String() string { return proto.CompactTextString(m) }
func (*ExternalName2ColIndex) ProtoMessage()    {}
func (*ExternalName2ColIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{33}
}
func (m *ExternalName2ColIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalName2ColIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExternalName2ColIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExternalName2ColIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalName2ColIndex.Merge(m, src)
}
func (m *ExternalName2ColIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExternalName2ColIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalName2ColIndex.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalName2ColIndex proto.InternalMessageInfo

func (m *ExternalName2ColIndex) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ExternalName2ColIndex) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

type FileOffset struct {
	Offset               []int64  `protobuf:"varint,1,rep,packed,name=offset,proto3" json:"offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileOffset) Reset()         { *m = FileOffset{} }
func (m *FileOffset) String() string { return proto.CompactTextString(m) }
func (*FileOffset) ProtoMessage()    {}
func (*FileOffset) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{34}
}
func (m *FileOffset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileOffset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileOffset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileOffset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileOffset.Merge(m, src)
}
func (m *FileOffset) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FileOffset) XXX_DiscardUnknown() {
	xxx_messageInfo_FileOffset.DiscardUnknown(m)
}

var xxx_messageInfo_FileOffset proto.InternalMessageInfo

func (m *FileOffset) GetOffset() []int64 {
	if m != nil {
		return m.Offset
	}
	return nil
}

type ExternalScan struct {
	Attrs                []string                 `protobuf:"bytes,1,rep,name=attrs,proto3" json:"attrs,omitempty"`
	FileSize             []int64                  `protobuf:"varint,2,rep,packed,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
	FileOffsetTotal      []*FileOffset            `protobuf:"bytes,3,rep,name=file_offset_total,json=fileOffsetTotal,proto3" json:"file_offset_total,omitempty"`
	Cols                 []*plan.ColDef           `protobuf:"bytes,4,rep,name=cols,proto3" json:"cols,omitempty"`
	Name2ColIndex        []*ExternalName2ColIndex `protobuf:"bytes,5,rep,name=name2_col_index,json=name2ColIndex,proto3" json:"name2_col_index,omitempty"`
	CreateSql            string                   `protobuf:"bytes,6,opt,name=create_sql,json=createSql,proto3" json:"create_sql,omitempty"`
	FileList             []string                 `protobuf:"bytes,7,rep,name=file_list,json=fileList,proto3" json:"file_list,omitempty"`
	OriginCols           []*plan.ColDef           `protobuf:"bytes,8,rep,name=origin_cols,json=originCols,proto3" json:"origin_cols,omitempty"`
	Filter               *plan.Expr               `protobuf:"bytes,9,opt,name=filter,proto3" json:"filter,omitempty"`
	TbColToDataCol       map[string]int32         `protobuf:"bytes,10,rep,name=TbColToDataCol,proto3" json:"TbColToDataCol,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	StrictSqlMode        bool                     `protobuf:"varint,11,opt,name=strict_sql_mode,json=strictSqlMode,proto3" json:"strict_sql_mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *ExternalScan) Reset()         { *m = ExternalScan{} }
func (m *ExternalScan) String() string { return proto.CompactTextString(m) }
func (*ExternalScan) ProtoMessage()    {}
func (*ExternalScan) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{35}
}
func (m *ExternalScan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalScan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExternalScan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExternalScan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalScan.Merge(m, src)
}
func (m *ExternalScan) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExternalScan) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalScan.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalScan proto.InternalMessageInfo

func (m *ExternalScan) GetAttrs() []string {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *ExternalScan) GetFileSize() []int64 {
	if m != nil {
		return m.FileSize
	}
	return nil
}

func (m *ExternalScan) GetFileOffsetTotal() []*FileOffset {
	if m != nil {
		return m.FileOffsetTotal
	}
	return nil
}

func (m *ExternalScan) GetCols() []*plan.ColDef {
	if m != nil {
		return m.Cols
	}
	return nil
}

func (m *ExternalScan) GetName2ColIndex() []*ExternalName2ColIndex {
	if m != nil {
		return m.Name2ColIndex
	}
	return nil
}

func (m *ExternalScan) GetCreateSql() string {
	if m != nil {
		return m.CreateSql
	}
	return ""
}

func (m *ExternalScan) GetFileList() []string {
	if m != nil {
		return m.FileList
	}
	return nil
}

func (m *ExternalScan) GetOriginCols() []*plan.ColDef {
	if m != nil {
		return m.OriginCols
	}
	return nil
}

func (m *ExternalScan) GetFilter() *plan.Expr {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *ExternalScan) GetTbColToDataCol() map[string]int32 {
	if m != nil {
		return m.TbColToDataCol
	}
	return nil
}

func (m *ExternalScan) GetStrictSqlMode() bool {
	if m != nil {
		return m.StrictSqlMode
	}
	return false
}

type StreamScan struct {
	TblDef               *plan.TableDef `protobuf:"bytes,1,opt,name=tbl_def,json=tblDef,proto3" json:"tbl_def,omitempty"`
	Offset               int64          `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	Limit                int64          `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *StreamScan) Reset()         { *m = StreamScan{} }
func (m *StreamScan) String() string { return proto.CompactTextString(m) }
func (*StreamScan) ProtoMessage()    {}
func (*StreamScan) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{36}
}
func (m *StreamScan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamScan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamScan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamScan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamScan.Merge(m, src)
}
func (m *StreamScan) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StreamScan) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamScan.DiscardUnknown(m)
}

var xxx_messageInfo_StreamScan proto.InternalMessageInfo

func (m *StreamScan) GetTblDef() *plan.TableDef {
	if m != nil {
		return m.TblDef
	}
	return nil
}

func (m *StreamScan) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *StreamScan) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type TableScan struct {
	Types                []plan.Type `protobuf:"bytes,1,rep,name=types,proto3" json:"types"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *TableScan) Reset()         { *m = TableScan{} }
func (m *TableScan) String() string { return proto.CompactTextString(m) }
func (*TableScan) ProtoMessage()    {}
func (*TableScan) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{37}
}
func (m *TableScan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableScan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableScan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableScan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableScan.Merge(m, src)
}
func (m *TableScan) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableScan) XXX_DiscardUnknown() {
	xxx_messageInfo_TableScan.DiscardUnknown(m)
}

var xxx_messageInfo_TableScan proto.InternalMessageInfo

func (m *TableScan) GetTypes() []plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

type ValueScan struct {
	BatchBlock           string   `protobuf:"bytes,1,opt,name=batch_block,json=batchBlock,proto3" json:"batch_block,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ValueScan) Reset()         { *m = ValueScan{} }
func (m *ValueScan) String() string { return proto.CompactTextString(m) }
func (*ValueScan) ProtoMessage()    {}
func (*ValueScan) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{38}
}
func (m *ValueScan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValueScan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValueScan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValueScan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValueScan.Merge(m, src)
}
func (m *ValueScan) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ValueScan) XXX_DiscardUnknown() {
	xxx_messageInfo_ValueScan.DiscardUnknown(m)
}

var xxx_messageInfo_ValueScan proto.InternalMessageInfo

func (m *ValueScan) GetBatchBlock() string {
	if m != nil {
		return m.BatchBlock
	}
	return ""
}

type UnionAll struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnionAll) Reset()         { *m = UnionAll{} }
func (m *UnionAll) String() string { return proto.CompactTextString(m) }
func (*UnionAll) ProtoMessage()    {}
func (*UnionAll) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{39}
}
func (m *UnionAll) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnionAll) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnionAll.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnionAll) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnionAll.Merge(m, src)
}
func (m *UnionAll) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnionAll) XXX_DiscardUnknown() {
	xxx_messageInfo_UnionAll.DiscardUnknown(m)
}

var xxx_messageInfo_UnionAll proto.InternalMessageInfo

type HashBuild struct {
	NeedHashMap          bool                    `protobuf:"varint,1,opt,name=NeedHashMap,proto3" json:"NeedHashMap,omitempty"`
	HashOnPK             bool                    `protobuf:"varint,2,opt,name=HashOnPK,proto3" json:"HashOnPK,omitempty"`
	NeedBatches          bool                    `protobuf:"varint,3,opt,name=NeedBatches,proto3" json:"NeedBatches,omitempty"`
	NeedAllocateSels     bool                    `protobuf:"varint,4,opt,name=NeedAllocateSels,proto3" json:"NeedAllocateSels,omitempty"`
	Conditions           []*plan.Expr            `protobuf:"bytes,5,rep,name=Conditions,proto3" json:"Conditions,omitempty"`
	JoinMapTag           int32                   `protobuf:"varint,6,opt,name=JoinMapTag,proto3" json:"JoinMapTag,omitempty"`
	JoinMapRefCnt        int32                   `protobuf:"varint,7,opt,name=JoinMapRefCnt,proto3" json:"JoinMapRefCnt,omitempty"`
	RuntimeFilterSpec    *plan.RuntimeFilterSpec `protobuf:"bytes,8,opt,name=RuntimeFilterSpec,proto3" json:"RuntimeFilterSpec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *HashBuild) Reset()         { *m = HashBuild{} }
func (m *HashBuild) String() string { return proto.CompactTextString(m) }
func (*HashBuild) ProtoMessage()    {}
func (*HashBuild) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{40}
}
func (m *HashBuild) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HashBuild) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HashBuild.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HashBuild) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HashBuild.Merge(m, src)
}
func (m *HashBuild) XXX_Size() int {
	return m.ProtoSize()
}
func (m *HashBuild) XXX_DiscardUnknown() {
	xxx_messageInfo_HashBuild.DiscardUnknown(m)
}

var xxx_messageInfo_HashBuild proto.InternalMessageInfo

func (m *HashBuild) GetNeedHashMap() bool {
	if m != nil {
		return m.NeedHashMap
	}
	return false
}

func (m *HashBuild) GetHashOnPK() bool {
	if m != nil {
		return m.HashOnPK
	}
	return false
}

func (m *HashBuild) GetNeedBatches() bool {
	if m != nil {
		return m.NeedBatches
	}
	return false
}

func (m *HashBuild) GetNeedAllocateSels() bool {
	if m != nil {
		return m.NeedAllocateSels
	}
	return false
}

func (m *HashBuild) GetConditions() []*plan.Expr {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *HashBuild) GetJoinMapTag() int32 {
	if m != nil {
		return m.JoinMapTag
	}
	return 0
}

func (m *HashBuild) GetJoinMapRefCnt() int32 {
	if m != nil {
		return m.JoinMapRefCnt
	}
	return 0
}

func (m *HashBuild) GetRuntimeFilterSpec() *plan.RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterSpec
	}
	return nil
}

type Shufflebuild struct {
	HashOnPK             bool                    `protobuf:"varint,1,opt,name=HashOnPK,proto3" json:"HashOnPK,omitempty"`
	NeedBatches          bool                    `protobuf:"varint,2,opt,name=NeedBatches,proto3" json:"NeedBatches,omitempty"`
	NeedAllocateSels     bool                    `protobuf:"varint,3,opt,name=NeedAllocateSels,proto3" json:"NeedAllocateSels,omitempty"`
	Conditions           []*plan.Expr            `protobuf:"bytes,4,rep,name=Conditions,proto3" json:"Conditions,omitempty"`
	RuntimeFilterSpec    *plan.RuntimeFilterSpec `protobuf:"bytes,5,opt,name=RuntimeFilterSpec,proto3" json:"RuntimeFilterSpec,omitempty"`
	JoinMapTag           int32                   `protobuf:"varint,6,opt,name=JoinMapTag,proto3" json:"JoinMapTag,omitempty"`
	ShuffleIdx           int32                   `protobuf:"varint,7,opt,name=ShuffleIdx,proto3" json:"ShuffleIdx,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *Shufflebuild) Reset()         { *m = Shufflebuild{} }
func (m *Shufflebuild) String() string { return proto.CompactTextString(m) }
func (*Shufflebuild) ProtoMessage()    {}
func (*Shufflebuild) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{41}
}
func (m *Shufflebuild) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Shufflebuild) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Shufflebuild.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Shufflebuild) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Shufflebuild.Merge(m, src)
}
func (m *Shufflebuild) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Shufflebuild) XXX_DiscardUnknown() {
	xxx_messageInfo_Shufflebuild.DiscardUnknown(m)
}

var xxx_messageInfo_Shufflebuild proto.InternalMessageInfo

func (m *Shufflebuild) GetHashOnPK() bool {
	if m != nil {
		return m.HashOnPK
	}
	return false
}

func (m *Shufflebuild) GetNeedBatches() bool {
	if m != nil {
		return m.NeedBatches
	}
	return false
}

func (m *Shufflebuild) GetNeedAllocateSels() bool {
	if m != nil {
		return m.NeedAllocateSels
	}
	return false
}

func (m *Shufflebuild) GetConditions() []*plan.Expr {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *Shufflebuild) GetRuntimeFilterSpec() *plan.RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterSpec
	}
	return nil
}

func (m *Shufflebuild) GetJoinMapTag() int32 {
	if m != nil {
		return m.JoinMapTag
	}
	return 0
}

func (m *Shufflebuild) GetShuffleIdx() int32 {
	if m != nil {
		return m.ShuffleIdx
	}
	return 0
}

type Indexbuild struct {
	RuntimeFilterSpec    *plan.RuntimeFilterSpec `protobuf:"bytes,1,opt,name=RuntimeFilterSpec,proto3" json:"RuntimeFilterSpec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *Indexbuild) Reset()         { *m = Indexbuild{} }
func (m *Indexbuild) String() string { return proto.CompactTextString(m) }
func (*Indexbuild) ProtoMessage()    {}
func (*Indexbuild) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{42}
}
func (m *Indexbuild) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Indexbuild) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Indexbuild.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Indexbuild) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Indexbuild.Merge(m, src)
}
func (m *Indexbuild) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Indexbuild) XXX_DiscardUnknown() {
	xxx_messageInfo_Indexbuild.DiscardUnknown(m)
}

var xxx_messageInfo_Indexbuild proto.InternalMessageInfo

func (m *Indexbuild) GetRuntimeFilterSpec() *plan.RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterSpec
	}
	return nil
}

type SampleFunc struct {
	SampleType           SampleFunc_SampleType `protobuf:"varint,1,opt,name=sample_type,json=sampleType,proto3,enum=pipeline.SampleFunc_SampleType" json:"sample_type,omitempty"`
	SampleRows           int32                 `protobuf:"varint,2,opt,name=sample_rows,json=sampleRows,proto3" json:"sample_rows,omitempty"`
	SamplePercent        float64               `protobuf:"fixed64,3,opt,name=sample_percent,json=samplePercent,proto3" json:"sample_percent,omitempty"`
	SampleColumns        []*plan.Expr          `protobuf:"bytes,4,rep,name=sample_columns,json=sampleColumns,proto3" json:"sample_columns,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *SampleFunc) Reset()         { *m = SampleFunc{} }
func (m *SampleFunc) String() string { return proto.CompactTextString(m) }
func (*SampleFunc) ProtoMessage()    {}
func (*SampleFunc) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{43}
}
func (m *SampleFunc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SampleFunc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SampleFunc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SampleFunc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SampleFunc.Merge(m, src)
}
func (m *SampleFunc) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SampleFunc) XXX_DiscardUnknown() {
	xxx_messageInfo_SampleFunc.DiscardUnknown(m)
}

var xxx_messageInfo_SampleFunc proto.InternalMessageInfo

func (m *SampleFunc) GetSampleType() SampleFunc_SampleType {
	if m != nil {
		return m.SampleType
	}
	return SampleFunc_Rows
}

func (m *SampleFunc) GetSampleRows() int32 {
	if m != nil {
		return m.SampleRows
	}
	return 0
}

func (m *SampleFunc) GetSamplePercent() float64 {
	if m != nil {
		return m.SamplePercent
	}
	return 0
}

func (m *SampleFunc) GetSampleColumns() []*plan.Expr {
	if m != nil {
		return m.SampleColumns
	}
	return nil
}

type Instruction struct {
	// Op specified the operator code of an instruction.
	Op int32 `protobuf:"varint,1,opt,name=op,proto3" json:"op,omitempty"`
	// Idx specified the anaylze information index.
	Idx             int32               `protobuf:"varint,2,opt,name=idx,proto3" json:"idx,omitempty"`
	Anti            *AntiJoin           `protobuf:"bytes,3,opt,name=anti,proto3" json:"anti,omitempty"`
	Connect         *Connector          `protobuf:"bytes,4,opt,name=connect,proto3" json:"connect,omitempty"`
	Dispatch        *Dispatch           `protobuf:"bytes,5,opt,name=dispatch,proto3" json:"dispatch,omitempty"`
	Agg             *Group              `protobuf:"bytes,6,opt,name=agg,proto3" json:"agg,omitempty"`
	LeftJoin        *LeftJoin           `protobuf:"bytes,8,opt,name=left_join,json=leftJoin,proto3" json:"left_join,omitempty"`
	SemiJoin        *SemiJoin           `protobuf:"bytes,9,opt,name=semi_join,json=semiJoin,proto3" json:"semi_join,omitempty"`
	SingleJoin      *SingleJoin         `protobuf:"bytes,10,opt,name=single_join,json=singleJoin,proto3" json:"single_join,omitempty"`
	MarkJoin        *MarkJoin           `protobuf:"bytes,11,opt,name=mark_join,json=markJoin,proto3" json:"mark_join,omitempty"`
	Join            *Join               `protobuf:"bytes,12,opt,name=join,proto3" json:"join,omitempty"`
	Product         *Product            `protobuf:"bytes,13,opt,name=product,proto3" json:"product,omitempty"`
	TableFunction   *TableFunction      `protobuf:"bytes,14,opt,name=table_function,json=tableFunction,proto3" json:"table_function,omitempty"`
	ExternalScan    *ExternalScan       `protobuf:"bytes,16,opt,name=external_scan,json=externalScan,proto3" json:"external_scan,omitempty"`
	Insert          *Insert             `protobuf:"bytes,17,opt,name=insert,proto3" json:"insert,omitempty"`
	OnDuplicateKey  *OnDuplicateKey     `protobuf:"bytes,18,opt,name=on_duplicate_key,json=onDuplicateKey,proto3" json:"on_duplicate_key,omitempty"`
	PreInsert       *PreInsert          `protobuf:"bytes,19,opt,name=pre_insert,json=preInsert,proto3" json:"pre_insert,omitempty"`
	PreInsertUnique *PreInsertUnique    `protobuf:"bytes,20,opt,name=pre_insert_unique,json=preInsertUnique,proto3" json:"pre_insert_unique,omitempty"`
	OrderBy         []*plan.OrderBySpec `protobuf:"bytes,21,rep,name=order_by,json=orderBy,proto3" json:"order_by,omitempty"`
	ProjectList     []*plan.Expr        `protobuf:"bytes,22,rep,name=project_list,json=projectList,proto3" json:"project_list,omitempty"`
	Filter          *plan.Expr          `protobuf:"bytes,23,opt,name=filter,proto3" json:"filter,omitempty"`
	Limit           *plan.Expr          `protobuf:"bytes,24,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset          *plan.Expr          `protobuf:"bytes,25,opt,name=offset,proto3" json:"offset,omitempty"`
	// isFirst identifies whether it is the first instruction of analyzeInfo corresponding to idx
	IsFirst bool `protobuf:"varint,26,opt,name=isFirst,proto3" json:"isFirst,omitempty"`
	// isLast identifies whether it is the last instruction of analyzeInfo corresponding to idx
	IsLast                  bool                     `protobuf:"varint,27,opt,name=isLast,proto3" json:"isLast,omitempty"`
	RightJoin               *RightJoin               `protobuf:"bytes,28,opt,name=right_join,json=rightJoin,proto3" json:"right_join,omitempty"`
	RightSemiJoin           *RightSemiJoin           `protobuf:"bytes,29,opt,name=right_semi_join,json=rightSemiJoin,proto3" json:"right_semi_join,omitempty"`
	RightAntiJoin           *RightAntiJoin           `protobuf:"bytes,30,opt,name=right_anti_join,json=rightAntiJoin,proto3" json:"right_anti_join,omitempty"`
	Delete                  *Deletion                `protobuf:"bytes,31,opt,name=delete,proto3" json:"delete,omitempty"`
	LockOp                  *LockOp                  `protobuf:"bytes,32,opt,name=lock_op,json=lockOp,proto3" json:"lock_op,omitempty"`
	Shuffle                 *Shuffle                 `protobuf:"bytes,33,opt,name=shuffle,proto3" json:"shuffle,omitempty"`
	Merge                   *Merge                   `protobuf:"bytes,34,opt,name=merge,proto3" json:"merge,omitempty"`
	StreamScan              *StreamScan              `protobuf:"bytes,35,opt,name=stream_scan,json=streamScan,proto3" json:"stream_scan,omitempty"`
	PreInsertSecondaryIndex *PreInsertSecondaryIndex `protobuf:"bytes,36,opt,name=pre_insert_secondary_index,json=preInsertSecondaryIndex,proto3" json:"pre_insert_secondary_index,omitempty"`
	SampleFunc              *SampleFunc              `protobuf:"bytes,37,opt,name=sample_func,json=sampleFunc,proto3" json:"sample_func,omitempty"`
	FuzzyFilter             *FuzzyFilter             `protobuf:"bytes,38,opt,name=fuzzy_filter,json=fuzzyFilter,proto3" json:"fuzzy_filter,omitempty"`
	CnAddr                  string                   `protobuf:"bytes,39,opt,name=cn_addr,json=cnAddr,proto3" json:"cn_addr,omitempty"`
	OperatorId              int32                    `protobuf:"varint,40,opt,name=operator_id,json=operatorId,proto3" json:"operator_id,omitempty"`
	ParallelId              int32                    `protobuf:"varint,41,opt,name=parallel_id,json=parallelId,proto3" json:"parallel_id,omitempty"`
	MaxParallel             int32                    `protobuf:"varint,42,opt,name=max_parallel,json=maxParallel,proto3" json:"max_parallel,omitempty"`
	IndexJoin               *IndexJoin               `protobuf:"bytes,43,opt,name=index_join,json=indexJoin,proto3" json:"index_join,omitempty"`
	ProductL2               *ProductL2               `protobuf:"bytes,44,opt,name=product_l2,json=productL2,proto3" json:"product_l2,omitempty"`
	TableScan               *TableScan               `protobuf:"bytes,45,opt,name=table_scan,json=tableScan,proto3" json:"table_scan,omitempty"`
	ValueScan               *ValueScan               `protobuf:"bytes,46,opt,name=value_scan,json=valueScan,proto3" json:"value_scan,omitempty"`
	UnionAll                *UnionAll                `protobuf:"bytes,47,opt,name=union_all,json=unionAll,proto3" json:"union_all,omitempty"`
	HashBuild               *HashBuild               `protobuf:"bytes,48,opt,name=hash_build,json=hashBuild,proto3" json:"hash_build,omitempty"`
	ShuffleBuild            *Shufflebuild            `protobuf:"bytes,49,opt,name=shuffle_build,json=shuffleBuild,proto3" json:"shuffle_build,omitempty"`
	IndexBuild              *Indexbuild              `protobuf:"bytes,50,opt,name=index_build,json=indexBuild,proto3" json:"index_build,omitempty"`
	Apply                   *Apply                   `protobuf:"bytes,51,opt,name=apply,proto3" json:"apply,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}                 `json:"-"`
	XXX_unrecognized        []byte                   `json:"-"`
	XXX_sizecache           int32                    `json:"-"`
}

func (m *Instruction) Reset()         { *m = Instruction{} }
func (m *Instruction) String() string { return proto.CompactTextString(m) }
func (*Instruction) ProtoMessage()    {}
func (*Instruction) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{44}
}
func (m *Instruction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Instruction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Instruction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Instruction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Instruction.Merge(m, src)
}
func (m *Instruction) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Instruction) XXX_DiscardUnknown() {
	xxx_messageInfo_Instruction.DiscardUnknown(m)
}

var xxx_messageInfo_Instruction proto.InternalMessageInfo

func (m *Instruction) GetOp() int32 {
	if m != nil {
		return m.Op
	}
	return 0
}

func (m *Instruction) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *Instruction) GetAnti() *AntiJoin {
	if m != nil {
		return m.Anti
	}
	return nil
}

func (m *Instruction) GetConnect() *Connector {
	if m != nil {
		return m.Connect
	}
	return nil
}

func (m *Instruction) GetDispatch() *Dispatch {
	if m != nil {
		return m.Dispatch
	}
	return nil
}

func (m *Instruction) GetAgg() *Group {
	if m != nil {
		return m.Agg
	}
	return nil
}

func (m *Instruction) GetLeftJoin() *LeftJoin {
	if m != nil {
		return m.LeftJoin
	}
	return nil
}

func (m *Instruction) GetSemiJoin() *SemiJoin {
	if m != nil {
		return m.SemiJoin
	}
	return nil
}

func (m *Instruction) GetSingleJoin() *SingleJoin {
	if m != nil {
		return m.SingleJoin
	}
	return nil
}

func (m *Instruction) GetMarkJoin() *MarkJoin {
	if m != nil {
		return m.MarkJoin
	}
	return nil
}

func (m *Instruction) GetJoin() *Join {
	if m != nil {
		return m.Join
	}
	return nil
}

func (m *Instruction) GetProduct() *Product {
	if m != nil {
		return m.Product
	}
	return nil
}

func (m *Instruction) GetTableFunction() *TableFunction {
	if m != nil {
		return m.TableFunction
	}
	return nil
}

func (m *Instruction) GetExternalScan() *ExternalScan {
	if m != nil {
		return m.ExternalScan
	}
	return nil
}

func (m *Instruction) GetInsert() *Insert {
	if m != nil {
		return m.Insert
	}
	return nil
}

func (m *Instruction) GetOnDuplicateKey() *OnDuplicateKey {
	if m != nil {
		return m.OnDuplicateKey
	}
	return nil
}

func (m *Instruction) GetPreInsert() *PreInsert {
	if m != nil {
		return m.PreInsert
	}
	return nil
}

func (m *Instruction) GetPreInsertUnique() *PreInsertUnique {
	if m != nil {
		return m.PreInsertUnique
	}
	return nil
}

func (m *Instruction) GetOrderBy() []*plan.OrderBySpec {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *Instruction) GetProjectList() []*plan.Expr {
	if m != nil {
		return m.ProjectList
	}
	return nil
}

func (m *Instruction) GetFilter() *plan.Expr {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *Instruction) GetLimit() *plan.Expr {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *Instruction) GetOffset() *plan.Expr {
	if m != nil {
		return m.Offset
	}
	return nil
}

func (m *Instruction) GetIsFirst() bool {
	if m != nil {
		return m.IsFirst
	}
	return false
}

func (m *Instruction) GetIsLast() bool {
	if m != nil {
		return m.IsLast
	}
	return false
}

func (m *Instruction) GetRightJoin() *RightJoin {
	if m != nil {
		return m.RightJoin
	}
	return nil
}

func (m *Instruction) GetRightSemiJoin() *RightSemiJoin {
	if m != nil {
		return m.RightSemiJoin
	}
	return nil
}

func (m *Instruction) GetRightAntiJoin() *RightAntiJoin {
	if m != nil {
		return m.RightAntiJoin
	}
	return nil
}

func (m *Instruction) GetDelete() *Deletion {
	if m != nil {
		return m.Delete
	}
	return nil
}

func (m *Instruction) GetLockOp() *LockOp {
	if m != nil {
		return m.LockOp
	}
	return nil
}

func (m *Instruction) GetShuffle() *Shuffle {
	if m != nil {
		return m.Shuffle
	}
	return nil
}

func (m *Instruction) GetMerge() *Merge {
	if m != nil {
		return m.Merge
	}
	return nil
}

func (m *Instruction) GetStreamScan() *StreamScan {
	if m != nil {
		return m.StreamScan
	}
	return nil
}

func (m *Instruction) GetPreInsertSecondaryIndex() *PreInsertSecondaryIndex {
	if m != nil {
		return m.PreInsertSecondaryIndex
	}
	return nil
}

func (m *Instruction) GetSampleFunc() *SampleFunc {
	if m != nil {
		return m.SampleFunc
	}
	return nil
}

func (m *Instruction) GetFuzzyFilter() *FuzzyFilter {
	if m != nil {
		return m.FuzzyFilter
	}
	return nil
}

func (m *Instruction) GetCnAddr() string {
	if m != nil {
		return m.CnAddr
	}
	return ""
}

func (m *Instruction) GetOperatorId() int32 {
	if m != nil {
		return m.OperatorId
	}
	return 0
}

func (m *Instruction) GetParallelId() int32 {
	if m != nil {
		return m.ParallelId
	}
	return 0
}

func (m *Instruction) GetMaxParallel() int32 {
	if m != nil {
		return m.MaxParallel
	}
	return 0
}

func (m *Instruction) GetIndexJoin() *IndexJoin {
	if m != nil {
		return m.IndexJoin
	}
	return nil
}

func (m *Instruction) GetProductL2() *ProductL2 {
	if m != nil {
		return m.ProductL2
	}
	return nil
}

func (m *Instruction) GetTableScan() *TableScan {
	if m != nil {
		return m.TableScan
	}
	return nil
}

func (m *Instruction) GetValueScan() *ValueScan {
	if m != nil {
		return m.ValueScan
	}
	return nil
}

func (m *Instruction) GetUnionAll() *UnionAll {
	if m != nil {
		return m.UnionAll
	}
	return nil
}

func (m *Instruction) GetHashBuild() *HashBuild {
	if m != nil {
		return m.HashBuild
	}
	return nil
}

func (m *Instruction) GetShuffleBuild() *Shufflebuild {
	if m != nil {
		return m.ShuffleBuild
	}
	return nil
}

func (m *Instruction) GetIndexBuild() *Indexbuild {
	if m != nil {
		return m.IndexBuild
	}
	return nil
}

func (m *Instruction) GetApply() *Apply {
	if m != nil {
		return m.Apply
	}
	return nil
}

type AnalysisList struct {
	List                 []*plan.AnalyzeInfo `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *AnalysisList) Reset()         { *m = AnalysisList{} }
func (m *AnalysisList) String() string { return proto.CompactTextString(m) }
func (*AnalysisList) ProtoMessage()    {}
func (*AnalysisList) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{45}
}
func (m *AnalysisList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnalysisList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnalysisList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AnalysisList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnalysisList.Merge(m, src)
}
func (m *AnalysisList) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AnalysisList) XXX_DiscardUnknown() {
	xxx_messageInfo_AnalysisList.DiscardUnknown(m)
}

var xxx_messageInfo_AnalysisList proto.InternalMessageInfo

func (m *AnalysisList) GetList() []*plan.AnalyzeInfo {
	if m != nil {
		return m.List
	}
	return nil
}

type Source struct {
	SchemaName             string                    `protobuf:"bytes,1,opt,name=schema_name,json=schemaName,proto3" json:"schema_name,omitempty"`
	TableName              string                    `protobuf:"bytes,2,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	ColList                []string                  `protobuf:"bytes,3,rep,name=col_list,json=colList,proto3" json:"col_list,omitempty"`
	Block                  string                    `protobuf:"bytes,4,opt,name=block,proto3" json:"block,omitempty"`
	PushdownId             uint64                    `protobuf:"varint,5,opt,name=pushdown_id,json=pushdownId,proto3" json:"pushdown_id,omitempty"`
	PushdownAddr           string                    `protobuf:"bytes,6,opt,name=pushdown_addr,json=pushdownAddr,proto3" json:"pushdown_addr,omitempty"`
	Expr                   *plan.Expr                `protobuf:"bytes,7,opt,name=expr,proto3" json:"expr,omitempty"`
	TableDef               *plan.TableDef            `protobuf:"bytes,8,opt,name=tableDef,proto3" json:"tableDef,omitempty"`
	Timestamp              *timestamp.Timestamp      `protobuf:"bytes,9,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	RuntimeFilterProbeList []*plan.RuntimeFilterSpec `protobuf:"bytes,10,rep,name=runtime_filter_probe_list,json=runtimeFilterProbeList,proto3" json:"runtime_filter_probe_list,omitempty"`
	IsConst                bool                      `protobuf:"varint,11,opt,name=is_const,json=isConst,proto3" json:"is_const,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                  `json:"-"`
	XXX_unrecognized       []byte                    `json:"-"`
	XXX_sizecache          int32                     `json:"-"`
}

func (m *Source) Reset()         { *m = Source{} }
func (m *Source) String() string { return proto.CompactTextString(m) }
func (*Source) ProtoMessage()    {}
func (*Source) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{46}
}
func (m *Source) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Source) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Source.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Source) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Source.Merge(m, src)
}
func (m *Source) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Source) XXX_DiscardUnknown() {
	xxx_messageInfo_Source.DiscardUnknown(m)
}

var xxx_messageInfo_Source proto.InternalMessageInfo

func (m *Source) GetSchemaName() string {
	if m != nil {
		return m.SchemaName
	}
	return ""
}

func (m *Source) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *Source) GetColList() []string {
	if m != nil {
		return m.ColList
	}
	return nil
}

func (m *Source) GetBlock() string {
	if m != nil {
		return m.Block
	}
	return ""
}

func (m *Source) GetPushdownId() uint64 {
	if m != nil {
		return m.PushdownId
	}
	return 0
}

func (m *Source) GetPushdownAddr() string {
	if m != nil {
		return m.PushdownAddr
	}
	return ""
}

func (m *Source) GetExpr() *plan.Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Source) GetTableDef() *plan.TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *Source) GetTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *Source) GetRuntimeFilterProbeList() []*plan.RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterProbeList
	}
	return nil
}

func (m *Source) GetIsConst() bool {
	if m != nil {
		return m.IsConst
	}
	return false
}

type NodeInfo struct {
	Mcpu                 int32    `protobuf:"varint,1,opt,name=mcpu,proto3" json:"mcpu,omitempty"`
	Id                   string   `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	Addr                 string   `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
	Payload              string   `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeInfo) Reset()         { *m = NodeInfo{} }
func (m *NodeInfo) String() string { return proto.CompactTextString(m) }
func (*NodeInfo) ProtoMessage()    {}
func (*NodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{47}
}
func (m *NodeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInfo.Merge(m, src)
}
func (m *NodeInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *NodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInfo proto.InternalMessageInfo

func (m *NodeInfo) GetMcpu() int32 {
	if m != nil {
		return m.Mcpu
	}
	return 0
}

func (m *NodeInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NodeInfo) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *NodeInfo) GetPayload() string {
	if m != nil {
		return m.Payload
	}
	return ""
}

type ProcessLimitation struct {
	Size                 int64    `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
	BatchRows            int64    `protobuf:"varint,2,opt,name=batch_rows,json=batchRows,proto3" json:"batch_rows,omitempty"`
	BatchSize            int64    `protobuf:"varint,3,opt,name=batch_size,json=batchSize,proto3" json:"batch_size,omitempty"`
	PartitionRows        int64    `protobuf:"varint,4,opt,name=partition_rows,json=partitionRows,proto3" json:"partition_rows,omitempty"`
	ReaderSize           int64    `protobuf:"varint,5,opt,name=reader_size,json=readerSize,proto3" json:"reader_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProcessLimitation) Reset()         { *m = ProcessLimitation{} }
func (m *ProcessLimitation) String() string { return proto.CompactTextString(m) }
func (*ProcessLimitation) ProtoMessage()    {}
func (*ProcessLimitation) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{48}
}
func (m *ProcessLimitation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessLimitation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessLimitation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessLimitation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessLimitation.Merge(m, src)
}
func (m *ProcessLimitation) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ProcessLimitation) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessLimitation.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessLimitation proto.InternalMessageInfo

func (m *ProcessLimitation) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *ProcessLimitation) GetBatchRows() int64 {
	if m != nil {
		return m.BatchRows
	}
	return 0
}

func (m *ProcessLimitation) GetBatchSize() int64 {
	if m != nil {
		return m.BatchSize
	}
	return 0
}

func (m *ProcessLimitation) GetPartitionRows() int64 {
	if m != nil {
		return m.PartitionRows
	}
	return 0
}

func (m *ProcessLimitation) GetReaderSize() int64 {
	if m != nil {
		return m.ReaderSize
	}
	return 0
}

type PrepareParamInfo struct {
	Length               int64    `protobuf:"varint,1,opt,name=length,proto3" json:"length,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	Area                 []byte   `protobuf:"bytes,3,opt,name=area,proto3" json:"area,omitempty"`
	Nulls                []bool   `protobuf:"varint,4,rep,packed,name=nulls,proto3" json:"nulls,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PrepareParamInfo) Reset()         { *m = PrepareParamInfo{} }
func (m *PrepareParamInfo) String() string { return proto.CompactTextString(m) }
func (*PrepareParamInfo) ProtoMessage()    {}
func (*PrepareParamInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{49}
}
func (m *PrepareParamInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepareParamInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepareParamInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepareParamInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepareParamInfo.Merge(m, src)
}
func (m *PrepareParamInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PrepareParamInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepareParamInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PrepareParamInfo proto.InternalMessageInfo

func (m *PrepareParamInfo) GetLength() int64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *PrepareParamInfo) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *PrepareParamInfo) GetArea() []byte {
	if m != nil {
		return m.Area
	}
	return nil
}

func (m *PrepareParamInfo) GetNulls() []bool {
	if m != nil {
		return m.Nulls
	}
	return nil
}

type ProcessInfo struct {
	Id                   string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Sql                  string            `protobuf:"bytes,2,opt,name=sql,proto3" json:"sql,omitempty"`
	Lim                  ProcessLimitation `protobuf:"bytes,3,opt,name=lim,proto3" json:"lim"`
	UnixTime             int64             `protobuf:"varint,4,opt,name=unix_time,json=unixTime,proto3" json:"unix_time,omitempty"`
	AccountId            uint32            `protobuf:"varint,5,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
	Snapshot             txn.CNTxnSnapshot `protobuf:"bytes,6,opt,name=snapshot,proto3" json:"snapshot"`
	SessionInfo          SessionInfo       `protobuf:"bytes,7,opt,name=session_info,json=sessionInfo,proto3" json:"session_info"`
	SessionLogger        SessionLoggerInfo `protobuf:"bytes,8,opt,name=session_logger,json=sessionLogger,proto3" json:"session_logger"`
	PrepareParams        PrepareParamInfo  `protobuf:"bytes,9,opt,name=prepare_params,json=prepareParams,proto3" json:"prepare_params"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ProcessInfo) Reset()         { *m = ProcessInfo{} }
func (m *ProcessInfo) String() string { return proto.CompactTextString(m) }
func (*ProcessInfo) ProtoMessage()    {}
func (*ProcessInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{50}
}
func (m *ProcessInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessInfo.Merge(m, src)
}
func (m *ProcessInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ProcessInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessInfo proto.InternalMessageInfo

func (m *ProcessInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ProcessInfo) GetSql() string {
	if m != nil {
		return m.Sql
	}
	return ""
}

func (m *ProcessInfo) GetLim() ProcessLimitation {
	if m != nil {
		return m.Lim
	}
	return ProcessLimitation{}
}

func (m *ProcessInfo) GetUnixTime() int64 {
	if m != nil {
		return m.UnixTime
	}
	return 0
}

func (m *ProcessInfo) GetAccountId() uint32 {
	if m != nil {
		return m.AccountId
	}
	return 0
}

func (m *ProcessInfo) GetSnapshot() txn.CNTxnSnapshot {
	if m != nil {
		return m.Snapshot
	}
	return txn.CNTxnSnapshot{}
}

func (m *ProcessInfo) GetSessionInfo() SessionInfo {
	if m != nil {
		return m.SessionInfo
	}
	return SessionInfo{}
}

func (m *ProcessInfo) GetSessionLogger() SessionLoggerInfo {
	if m != nil {
		return m.SessionLogger
	}
	return SessionLoggerInfo{}
}

func (m *ProcessInfo) GetPrepareParams() PrepareParamInfo {
	if m != nil {
		return m.PrepareParams
	}
	return PrepareParamInfo{}
}

type SessionInfo struct {
	User                 string   `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	Host                 string   `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	Role                 string   `protobuf:"bytes,3,opt,name=role,proto3" json:"role,omitempty"`
	ConnectionId         uint64   `protobuf:"varint,4,opt,name=connection_id,json=connectionId,proto3" json:"connection_id,omitempty"`
	Database             string   `protobuf:"bytes,5,opt,name=database,proto3" json:"database,omitempty"`
	Version              string   `protobuf:"bytes,6,opt,name=version,proto3" json:"version,omitempty"`
	TimeZone             []byte   `protobuf:"bytes,7,opt,name=time_zone,json=timeZone,proto3" json:"time_zone,omitempty"`
	Account              string   `protobuf:"bytes,8,opt,name=account,proto3" json:"account,omitempty"`
	QueryId              []string `protobuf:"bytes,9,rep,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SessionInfo) Reset()         { *m = SessionInfo{} }
func (m *SessionInfo) String() string { return proto.CompactTextString(m) }
func (*SessionInfo) ProtoMessage()    {}
func (*SessionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{51}
}
func (m *SessionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionInfo.Merge(m, src)
}
func (m *SessionInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SessionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SessionInfo proto.InternalMessageInfo

func (m *SessionInfo) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *SessionInfo) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *SessionInfo) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *SessionInfo) GetConnectionId() uint64 {
	if m != nil {
		return m.ConnectionId
	}
	return 0
}

func (m *SessionInfo) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *SessionInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *SessionInfo) GetTimeZone() []byte {
	if m != nil {
		return m.TimeZone
	}
	return nil
}

func (m *SessionInfo) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *SessionInfo) GetQueryId() []string {
	if m != nil {
		return m.QueryId
	}
	return nil
}

type SessionLoggerInfo struct {
	SessId               []byte                     `protobuf:"bytes,1,opt,name=sess_id,json=sessId,proto3" json:"sess_id,omitempty"`
	StmtId               []byte                     `protobuf:"bytes,2,opt,name=stmt_id,json=stmtId,proto3" json:"stmt_id,omitempty"`
	TxnId                []byte                     `protobuf:"bytes,3,opt,name=txn_id,json=txnId,proto3" json:"txn_id,omitempty"`
	LogLevel             SessionLoggerInfo_LogLevel `protobuf:"varint,4,opt,name=log_level,json=logLevel,proto3,enum=pipeline.SessionLoggerInfo_LogLevel" json:"log_level,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *SessionLoggerInfo) Reset()         { *m = SessionLoggerInfo{} }
func (m *SessionLoggerInfo) String() string { return proto.CompactTextString(m) }
func (*SessionLoggerInfo) ProtoMessage()    {}
func (*SessionLoggerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{52}
}
func (m *SessionLoggerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionLoggerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionLoggerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionLoggerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionLoggerInfo.Merge(m, src)
}
func (m *SessionLoggerInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SessionLoggerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionLoggerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SessionLoggerInfo proto.InternalMessageInfo

func (m *SessionLoggerInfo) GetSessId() []byte {
	if m != nil {
		return m.SessId
	}
	return nil
}

func (m *SessionLoggerInfo) GetStmtId() []byte {
	if m != nil {
		return m.StmtId
	}
	return nil
}

func (m *SessionLoggerInfo) GetTxnId() []byte {
	if m != nil {
		return m.TxnId
	}
	return nil
}

func (m *SessionLoggerInfo) GetLogLevel() SessionLoggerInfo_LogLevel {
	if m != nil {
		return m.LogLevel
	}
	return SessionLoggerInfo_Debug
}

type Pipeline struct {
	PipelineType         Pipeline_PipelineType `protobuf:"varint,1,opt,name=pipeline_type,json=pipelineType,proto3,enum=pipeline.Pipeline_PipelineType" json:"pipeline_type,omitempty"`
	PipelineId           int32                 `protobuf:"varint,2,opt,name=pipeline_id,json=pipelineId,proto3" json:"pipeline_id,omitempty"`
	Qry                  *plan.Plan            `protobuf:"bytes,3,opt,name=qry,proto3" json:"qry,omitempty"`
	DataSource           *Source               `protobuf:"bytes,4,opt,name=data_source,json=dataSource,proto3" json:"data_source,omitempty"`
	Children             []*Pipeline           `protobuf:"bytes,5,rep,name=children,proto3" json:"children,omitempty"`
	InstructionList      []*Instruction        `protobuf:"bytes,6,rep,name=instruction_list,json=instructionList,proto3" json:"instruction_list,omitempty"`
	IsEnd                bool                  `protobuf:"varint,7,opt,name=is_end,json=isEnd,proto3" json:"is_end,omitempty"`
	IsLoad               bool                  `protobuf:"varint,8,opt,name=is_load,json=isLoad,proto3" json:"is_load,omitempty"`
	Node                 *NodeInfo             `protobuf:"bytes,9,opt,name=node,proto3" json:"node,omitempty"`
	PushDownInfo         int32                 `protobuf:"varint,10,opt,name=push_down_info,json=pushDownInfo,proto3" json:"push_down_info,omitempty"`
	ChildrenCount        int32                 `protobuf:"varint,11,opt,name=children_count,json=childrenCount,proto3" json:"children_count,omitempty"`
	ChannelBufferSize    []int32               `protobuf:"varint,12,rep,packed,name=channel_buffer_size,json=channelBufferSize,proto3" json:"channel_buffer_size,omitempty"`
	NilBatchCnt          []int32               `protobuf:"varint,13,rep,packed,name=nil_batch_cnt,json=nilBatchCnt,proto3" json:"nil_batch_cnt,omitempty"`
	UuidsToRegIdx        []*UuidToRegIdx       `protobuf:"bytes,14,rep,name=uuids_to_reg_idx,json=uuidsToRegIdx,proto3" json:"uuids_to_reg_idx,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Pipeline) Reset()         { *m = Pipeline{} }
func (m *Pipeline) String() string { return proto.CompactTextString(m) }
func (*Pipeline) ProtoMessage()    {}
func (*Pipeline) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{53}
}
func (m *Pipeline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pipeline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pipeline.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pipeline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pipeline.Merge(m, src)
}
func (m *Pipeline) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Pipeline) XXX_DiscardUnknown() {
	xxx_messageInfo_Pipeline.DiscardUnknown(m)
}

var xxx_messageInfo_Pipeline proto.InternalMessageInfo

func (m *Pipeline) GetPipelineType() Pipeline_PipelineType {
	if m != nil {
		return m.PipelineType
	}
	return Pipeline_Merge
}

func (m *Pipeline) GetPipelineId() int32 {
	if m != nil {
		return m.PipelineId
	}
	return 0
}

func (m *Pipeline) GetQry() *plan.Plan {
	if m != nil {
		return m.Qry
	}
	return nil
}

func (m *Pipeline) GetDataSource() *Source {
	if m != nil {
		return m.DataSource
	}
	return nil
}

func (m *Pipeline) GetChildren() []*Pipeline {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *Pipeline) GetInstructionList() []*Instruction {
	if m != nil {
		return m.InstructionList
	}
	return nil
}

func (m *Pipeline) GetIsEnd() bool {
	if m != nil {
		return m.IsEnd
	}
	return false
}

func (m *Pipeline) GetIsLoad() bool {
	if m != nil {
		return m.IsLoad
	}
	return false
}

func (m *Pipeline) GetNode() *NodeInfo {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *Pipeline) GetPushDownInfo() int32 {
	if m != nil {
		return m.PushDownInfo
	}
	return 0
}

func (m *Pipeline) GetChildrenCount() int32 {
	if m != nil {
		return m.ChildrenCount
	}
	return 0
}

func (m *Pipeline) GetChannelBufferSize() []int32 {
	if m != nil {
		return m.ChannelBufferSize
	}
	return nil
}

func (m *Pipeline) GetNilBatchCnt() []int32 {
	if m != nil {
		return m.NilBatchCnt
	}
	return nil
}

func (m *Pipeline) GetUuidsToRegIdx() []*UuidToRegIdx {
	if m != nil {
		return m.UuidsToRegIdx
	}
	return nil
}

type WrapNode struct {
	NodeAddr             string   `protobuf:"bytes,1,opt,name=node_addr,json=nodeAddr,proto3" json:"node_addr,omitempty"`
	Uuid                 []byte   `protobuf:"bytes,2,opt,name=uuid,proto3" json:"uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WrapNode) Reset()         { *m = WrapNode{} }
func (m *WrapNode) String() string { return proto.CompactTextString(m) }
func (*WrapNode) ProtoMessage()    {}
func (*WrapNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{54}
}
func (m *WrapNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WrapNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WrapNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WrapNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WrapNode.Merge(m, src)
}
func (m *WrapNode) XXX_Size() int {
	return m.ProtoSize()
}
func (m *WrapNode) XXX_DiscardUnknown() {
	xxx_messageInfo_WrapNode.DiscardUnknown(m)
}

var xxx_messageInfo_WrapNode proto.InternalMessageInfo

func (m *WrapNode) GetNodeAddr() string {
	if m != nil {
		return m.NodeAddr
	}
	return ""
}

func (m *WrapNode) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

type UuidToRegIdx struct {
	Idx                  int32    `protobuf:"varint,1,opt,name=idx,proto3" json:"idx,omitempty"`
	Uuid                 []byte   `protobuf:"bytes,2,opt,name=uuid,proto3" json:"uuid,omitempty"`
	FromAddr             string   `protobuf:"bytes,3,opt,name=from_addr,json=fromAddr,proto3" json:"from_addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UuidToRegIdx) Reset()         { *m = UuidToRegIdx{} }
func (m *UuidToRegIdx) String() string { return proto.CompactTextString(m) }
func (*UuidToRegIdx) ProtoMessage()    {}
func (*UuidToRegIdx) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{55}
}
func (m *UuidToRegIdx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UuidToRegIdx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UuidToRegIdx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UuidToRegIdx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UuidToRegIdx.Merge(m, src)
}
func (m *UuidToRegIdx) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UuidToRegIdx) XXX_DiscardUnknown() {
	xxx_messageInfo_UuidToRegIdx.DiscardUnknown(m)
}

var xxx_messageInfo_UuidToRegIdx proto.InternalMessageInfo

func (m *UuidToRegIdx) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *UuidToRegIdx) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *UuidToRegIdx) GetFromAddr() string {
	if m != nil {
		return m.FromAddr
	}
	return ""
}

type Apply struct {
	ApplyType            int32       `protobuf:"varint,1,opt,name=apply_type,json=applyType,proto3" json:"apply_type,omitempty"`
	RelList              []int32     `protobuf:"varint,2,rep,packed,name=rel_list,json=relList,proto3" json:"rel_list,omitempty"`
	ColList              []int32     `protobuf:"varint,3,rep,packed,name=col_list,json=colList,proto3" json:"col_list,omitempty"`
	Types                []plan.Type `protobuf:"bytes,4,rep,name=types,proto3" json:"types"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Apply) Reset()         { *m = Apply{} }
func (m *Apply) String() string { return proto.CompactTextString(m) }
func (*Apply) ProtoMessage()    {}
func (*Apply) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ac67a7adf3df9c7, []int{56}
}
func (m *Apply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Apply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Apply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Apply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Apply.Merge(m, src)
}
func (m *Apply) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Apply) XXX_DiscardUnknown() {
	xxx_messageInfo_Apply.DiscardUnknown(m)
}

var xxx_messageInfo_Apply proto.InternalMessageInfo

func (m *Apply) GetApplyType() int32 {
	if m != nil {
		return m.ApplyType
	}
	return 0
}

func (m *Apply) GetRelList() []int32 {
	if m != nil {
		return m.RelList
	}
	return nil
}

func (m *Apply) GetColList() []int32 {
	if m != nil {
		return m.ColList
	}
	return nil
}

func (m *Apply) GetTypes() []plan.Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func init() {
	proto.RegisterEnum("pipeline.Method", Method_name, Method_value)
	proto.RegisterEnum("pipeline.Status", Status_name, Status_value)
	proto.RegisterEnum("pipeline.SampleFunc_SampleType", SampleFunc_SampleType_name, SampleFunc_SampleType_value)
	proto.RegisterEnum("pipeline.SessionLoggerInfo_LogLevel", SessionLoggerInfo_LogLevel_name, SessionLoggerInfo_LogLevel_value)
	proto.RegisterEnum("pipeline.Pipeline_PipelineType", Pipeline_PipelineType_name, Pipeline_PipelineType_value)
	proto.RegisterType((*Message)(nil), "pipeline.Message")
	proto.RegisterType((*Connector)(nil), "pipeline.Connector")
	proto.RegisterType((*Shuffle)(nil), "pipeline.Shuffle")
	proto.RegisterType((*Dispatch)(nil), "pipeline.Dispatch")
	proto.RegisterType((*Merge)(nil), "pipeline.Merge")
	proto.RegisterType((*MultiArguemnt)(nil), "pipeline.MultiArguemnt")
	proto.RegisterType((*Aggregate)(nil), "pipeline.Aggregate")
	proto.RegisterType((*Group)(nil), "pipeline.Group")
	proto.RegisterType((*Insert)(nil), "pipeline.Insert")
	proto.RegisterType((*MultiUpdate)(nil), "pipeline.MultiUpdate")
	proto.RegisterMapType((map[string]int32)(nil), "pipeline.MultiUpdate.SegmentMapEntry")
	proto.RegisterType((*Array)(nil), "pipeline.Array")
	proto.RegisterType((*Map)(nil), "pipeline.Map")
	proto.RegisterMapType((map[string]int32)(nil), "pipeline.Map.MpEntry")
	proto.RegisterType((*Deletion)(nil), "pipeline.Deletion")
	proto.RegisterMapType((map[string]int32)(nil), "pipeline.Deletion.SegmentMapEntry")
	proto.RegisterType((*PreInsert)(nil), "pipeline.PreInsert")
	proto.RegisterType((*LockTarget)(nil), "pipeline.LockTarget")
	proto.RegisterType((*LockOp)(nil), "pipeline.LockOp")
	proto.RegisterType((*PreInsertUnique)(nil), "pipeline.PreInsertUnique")
	proto.RegisterType((*PreInsertSecondaryIndex)(nil), "pipeline.PreInsertSecondaryIndex")
	proto.RegisterType((*OnDuplicateKey)(nil), "pipeline.OnDuplicateKey")
	proto.RegisterMapType((map[string]*plan.Expr)(nil), "pipeline.OnDuplicateKey.OnDuplicateExprEntry")
	proto.RegisterType((*FuzzyFilter)(nil), "pipeline.FuzzyFilter")
	proto.RegisterType((*Join)(nil), "pipeline.Join")
	proto.RegisterType((*AntiJoin)(nil), "pipeline.AntiJoin")
	proto.RegisterType((*LeftJoin)(nil), "pipeline.LeftJoin")
	proto.RegisterType((*RightJoin)(nil), "pipeline.RightJoin")
	proto.RegisterType((*RightSemiJoin)(nil), "pipeline.RightSemiJoin")
	proto.RegisterType((*RightAntiJoin)(nil), "pipeline.RightAntiJoin")
	proto.RegisterType((*SemiJoin)(nil), "pipeline.SemiJoin")
	proto.RegisterType((*SingleJoin)(nil), "pipeline.SingleJoin")
	proto.RegisterType((*MarkJoin)(nil), "pipeline.MarkJoin")
	proto.RegisterType((*Product)(nil), "pipeline.Product")
	proto.RegisterType((*ProductL2)(nil), "pipeline.ProductL2")
	proto.RegisterType((*IndexJoin)(nil), "pipeline.IndexJoin")
	proto.RegisterType((*TableFunction)(nil), "pipeline.TableFunction")
	proto.RegisterType((*ExternalName2ColIndex)(nil), "pipeline.ExternalName2ColIndex")
	proto.RegisterType((*FileOffset)(nil), "pipeline.file_offset")
	proto.RegisterType((*ExternalScan)(nil), "pipeline.ExternalScan")
	proto.RegisterMapType((map[string]int32)(nil), "pipeline.ExternalScan.TbColToDataColEntry")
	proto.RegisterType((*StreamScan)(nil), "pipeline.StreamScan")
	proto.RegisterType((*TableScan)(nil), "pipeline.TableScan")
	proto.RegisterType((*ValueScan)(nil), "pipeline.ValueScan")
	proto.RegisterType((*UnionAll)(nil), "pipeline.UnionAll")
	proto.RegisterType((*HashBuild)(nil), "pipeline.HashBuild")
	proto.RegisterType((*Shufflebuild)(nil), "pipeline.Shufflebuild")
	proto.RegisterType((*Indexbuild)(nil), "pipeline.Indexbuild")
	proto.RegisterType((*SampleFunc)(nil), "pipeline.SampleFunc")
	proto.RegisterType((*Instruction)(nil), "pipeline.Instruction")
	proto.RegisterType((*AnalysisList)(nil), "pipeline.AnalysisList")
	proto.RegisterType((*Source)(nil), "pipeline.Source")
	proto.RegisterType((*NodeInfo)(nil), "pipeline.NodeInfo")
	proto.RegisterType((*ProcessLimitation)(nil), "pipeline.ProcessLimitation")
	proto.RegisterType((*PrepareParamInfo)(nil), "pipeline.PrepareParamInfo")
	proto.RegisterType((*ProcessInfo)(nil), "pipeline.ProcessInfo")
	proto.RegisterType((*SessionInfo)(nil), "pipeline.SessionInfo")
	proto.RegisterType((*SessionLoggerInfo)(nil), "pipeline.SessionLoggerInfo")
	proto.RegisterType((*Pipeline)(nil), "pipeline.Pipeline")
	proto.RegisterType((*WrapNode)(nil), "pipeline.WrapNode")
	proto.RegisterType((*UuidToRegIdx)(nil), "pipeline.UuidToRegIdx")
	proto.RegisterType((*Apply)(nil), "pipeline.Apply")
}

func init() { proto.RegisterFile("pipeline.proto", fileDescriptor_7ac67a7adf3df9c7) }

var fileDescriptor_7ac67a7adf3df9c7 = []byte{
	// 5373 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x3b, 0x4d, 0x8f, 0x1c, 0x49,
	0x56, 0xae, 0xef, 0xcc, 0x57, 0x1f, 0x5d, 0x1d, 0xfe, 0xaa, 0xb1, 0x67, 0xec, 0x76, 0xce, 0xd8,
	0xd3, 0xeb, 0x99, 0x69, 0xcf, 0xf4, 0xec, 0xc0, 0x8a, 0x65, 0x77, 0xb6, 0xdd, 0xb6, 0x77, 0x6b,
	0xc7, 0xdd, 0xd3, 0x44, 0xb7, 0x19, 0xb1, 0x42, 0xa4, 0xb2, 0x33, 0xa3, 0xaa, 0x73, 0x3b, 0x2b,
	0x23, 0x9d, 0x99, 0x65, 0x77, 0xfb, 0x84, 0x04, 0x27, 0xae, 0xfc, 0x01, 0xb4, 0x17, 0x84, 0x10,
	0x1f, 0x82, 0x1b, 0x88, 0xfb, 0x72, 0xdb, 0x13, 0x07, 0x0e, 0x08, 0x2d, 0x17, 0xc4, 0xc7, 0x0d,
	0x10, 0x17, 0x04, 0x7a, 0x2f, 0x22, 0x3f, 0xea, 0xc3, 0xed, 0xb1, 0x67, 0x06, 0xed, 0x4a, 0x7b,
	0x8b, 0x78, 0xef, 0x45, 0x64, 0xc6, 0xfb, 0x8a, 0x17, 0x2f, 0x5e, 0x40, 0x2f, 0xf2, 0x23, 0x11,
	0xf8, 0xa1, 0xd8, 0x88, 0x62, 0x99, 0x4a, 0x66, 0x64, 0xfd, 0x2b, 0xef, 0x8d, 0xfd, 0xf4, 0x68,
	0x7a, 0xb8, 0xe1, 0xca, 0xc9, 0x9d, 0xb1, 0x1c, 0xcb, 0x3b, 0x44, 0x70, 0x38, 0x1d, 0x51, 0x8f,
	0x3a, 0xd4, 0x52, 0x03, 0xaf, 0x40, 0x14, 0x38, 0xa1, 0x6e, 0xaf, 0xa4, 0xfe, 0x44, 0x24, 0xa9,
	0x33, 0x89, 0x32, 0x64, 0x20, 0xdd, 0x63, 0xdd, 0x36, 0xd3, 0x13, 0x4d, 0x67, 0xfd, 0x6f, 0x05,
	0x5a, 0x3b, 0x22, 0x49, 0x9c, 0xb1, 0x60, 0x16, 0xd4, 0x12, 0xdf, 0x1b, 0x54, 0xd6, 0x2a, 0xeb,
	0xbd, 0xcd, 0xfe, 0x46, 0xfe, 0x5b, 0xfb, 0xa9, 0x93, 0x4e, 0x13, 0x8e, 0x48, 0xa4, 0x71, 0x27,
	0xde, 0xa0, 0x3a, 0x4f, 0xb3, 0x23, 0xd2, 0x23, 0xe9, 0x71, 0x44, 0xb2, 0x3e, 0xd4, 0x44, 0x1c,
	0x0f, 0x6a, 0x6b, 0x95, 0xf5, 0x0e, 0xc7, 0x26, 0x63, 0x50, 0xf7, 0x9c, 0xd4, 0x19, 0xd4, 0x09,
	0x44, 0x6d, 0xf6, 0x16, 0xf4, 0xa2, 0x58, 0xba, 0xb6, 0x1f, 0x8e, 0xa4, 0x4d, 0xd8, 0x06, 0x61,
	0x3b, 0x08, 0x1d, 0x86, 0x23, 0x79, 0x0f, 0xa9, 0x06, 0xd0, 0x72, 0x42, 0x27, 0x38, 0x4d, 0xc4,
	0xa0, 0x49, 0xe8, 0xac, 0xcb, 0x7a, 0x50, 0xf5, 0xbd, 0x41, 0x6b, 0xad, 0xb2, 0x5e, 0xe7, 0x55,
	0xdf, 0xc3, 0x6f, 0x4c, 0xa7, 0xbe, 0x37, 0x30, 0xd4, 0x37, 0xb0, 0xcd, 0x2c, 0xe8, 0x84, 0x42,
	0x78, 0xbb, 0x32, 0xe5, 0x22, 0x0a, 0x4e, 0x07, 0xe6, 0x5a, 0x65, 0xdd, 0xe0, 0x33, 0x30, 0xeb,
	0x11, 0x98, 0xdb, 0x32, 0x0c, 0x85, 0x9b, 0xca, 0x98, 0x5d, 0x87, 0x76, 0xb6, 0x24, 0x5b, 0xb3,
	0xa2, 0xc1, 0x21, 0x03, 0x0d, 0x3d, 0xf6, 0x36, 0xac, 0xb8, 0x19, 0xb5, 0xed, 0x87, 0x9e, 0x38,
	0x21, 0x5e, 0x34, 0x78, 0x2f, 0x07, 0x0f, 0x11, 0x6a, 0xfd, 0x5b, 0x15, 0x5a, 0xfb, 0x47, 0xd3,
	0xd1, 0x28, 0x10, 0xec, 0x2d, 0xe8, 0xea, 0xe6, 0xb6, 0x0c, 0x86, 0xde, 0x89, 0x9e, 0x77, 0x16,
	0xc8, 0xd6, 0xa0, 0xad, 0x01, 0x07, 0xa7, 0x91, 0xd0, 0xd3, 0x96, 0x41, 0xb3, 0xf3, 0xec, 0xf8,
	0x21, 0xb1, 0xb8, 0xc6, 0x67, 0x81, 0x73, 0x54, 0xce, 0x09, 0x71, 0x7d, 0x96, 0xca, 0xa1, 0xaf,
	0x6d, 0x05, 0xfe, 0x13, 0xc1, 0xc5, 0x78, 0x3b, 0x4c, 0x89, 0xf7, 0x0d, 0x5e, 0x06, 0xb1, 0x4d,
	0xb8, 0x98, 0xa8, 0x21, 0x76, 0xec, 0x84, 0x63, 0x91, 0xd8, 0x53, 0x3f, 0x4c, 0x7f, 0xe9, 0xeb,
	0x83, 0xe6, 0x5a, 0x6d, 0xbd, 0xce, 0xcf, 0x6b, 0x24, 0x27, 0xdc, 0x23, 0x42, 0xb1, 0xf7, 0xe1,
	0xc2, 0xdc, 0x18, 0x35, 0xa4, 0xb5, 0x56, 0x5b, 0xaf, 0x71, 0x36, 0x33, 0x64, 0x48, 0x23, 0xee,
	0xc3, 0x6a, 0x3c, 0x0d, 0x51, 0x5b, 0x1f, 0xf8, 0x41, 0x2a, 0xe2, 0xfd, 0x48, 0xb8, 0x24, 0xc3,
	0xf6, 0xe6, 0xe5, 0x0d, 0x52, 0x68, 0x3e, 0x8f, 0xe6, 0x8b, 0x23, 0xac, 0xff, 0xae, 0x82, 0x71,
	0xcf, 0x4f, 0x22, 0x27, 0x75, 0x8f, 0xd8, 0x65, 0x68, 0x8d, 0xa6, 0xa1, 0x5b, 0x48, 0xb0, 0x89,
	0xdd, 0xa1, 0xc7, 0x7e, 0x15, 0x56, 0x02, 0xe9, 0x3a, 0x81, 0x9d, 0x0b, 0x6b, 0x50, 0x5d, 0xab,
	0xad, 0xb7, 0x37, 0xcf, 0x17, 0x9a, 0x9c, 0x2b, 0x03, 0xef, 0x11, 0x6d, 0xa1, 0x1c, 0xdf, 0x82,
	0x7e, 0x2c, 0x26, 0x32, 0x15, 0xa5, 0xe1, 0x35, 0x1a, 0xce, 0x8a, 0xe1, 0x9f, 0xc5, 0x4e, 0xb4,
	0x2b, 0x3d, 0xc1, 0x57, 0x14, 0x6d, 0x31, 0xfc, 0x83, 0x12, 0x3f, 0xc5, 0xd8, 0xf6, 0xbd, 0x13,
	0x9b, 0x3e, 0x30, 0xa8, 0xaf, 0xd5, 0xd6, 0x1b, 0x05, 0x73, 0xc4, 0x78, 0xe8, 0x9d, 0x3c, 0x44,
	0x0c, 0xfb, 0x10, 0x2e, 0xcd, 0x0f, 0x51, 0xb3, 0x0e, 0x1a, 0x34, 0xe6, 0xfc, 0xcc, 0x18, 0x4e,
	0x28, 0x76, 0x03, 0x3a, 0xd9, 0xa0, 0x14, 0x15, 0xa9, 0xa9, 0x44, 0x9b, 0x94, 0x14, 0xe9, 0x32,
	0xb4, 0xfc, 0xc4, 0x4e, 0xfc, 0xf0, 0x98, 0x0c, 0xc8, 0xe0, 0x4d, 0x3f, 0xd9, 0xf7, 0xc3, 0x63,
	0xf6, 0x1a, 0x18, 0xb1, 0x70, 0x15, 0xc6, 0x20, 0x4c, 0x2b, 0x16, 0x2e, 0xa1, 0x2e, 0x03, 0x36,
	0x6d, 0x37, 0x15, 0xda, 0x8c, 0x9a, 0xb1, 0x70, 0xb7, 0x53, 0x61, 0x25, 0xd0, 0xd8, 0x11, 0xf1,
	0x58, 0xb0, 0x2b, 0x60, 0xe0, 0xc0, 0x7d, 0xd7, 0x09, 0x89, 0xef, 0x06, 0xcf, 0xfb, 0x68, 0xc7,
	0x91, 0x13, 0xa7, 0xbe, 0x13, 0x90, 0x62, 0x1b, 0x3c, 0xeb, 0xb2, 0xab, 0x60, 0x26, 0xa9, 0x13,
	0xa7, 0xb8, 0x3a, 0x52, 0xe8, 0x06, 0x37, 0x08, 0x80, 0x36, 0x71, 0x19, 0x5a, 0x22, 0xf4, 0x08,
	0x55, 0x57, 0x92, 0x14, 0xa1, 0x37, 0xf4, 0x4e, 0xac, 0xbf, 0xac, 0x40, 0x77, 0x67, 0x1a, 0xa4,
	0xfe, 0x56, 0x3c, 0x9e, 0x8a, 0x49, 0x98, 0xa2, 0xfd, 0xdf, 0xf3, 0x93, 0x54, 0x7f, 0x99, 0xda,
	0x6c, 0x1d, 0xcc, 0xef, 0xc6, 0x72, 0x1a, 0xdd, 0x3f, 0x89, 0x32, 0x49, 0x83, 0x52, 0x2a, 0x84,
	0xf0, 0x02, 0xc9, 0xde, 0x85, 0xf6, 0xa7, 0xb1, 0x27, 0xe2, 0xbb, 0xa7, 0x44, 0x5b, 0x5b, 0xa0,
	0x2d, 0xa3, 0xd9, 0xeb, 0x60, 0xee, 0x8b, 0xc8, 0x89, 0x1d, 0x54, 0x01, 0xfc, 0x31, 0x93, 0x17,
	0x00, 0x5c, 0x2b, 0x11, 0x0f, 0x3d, 0x6d, 0x56, 0x59, 0xd7, 0x1a, 0x83, 0xb9, 0x35, 0x1e, 0xc7,
	0x62, 0xec, 0xa4, 0xe4, 0xc0, 0x64, 0x44, 0xbf, 0x5b, 0xe3, 0x55, 0x19, 0x91, 0x93, 0xc4, 0x05,
	0x28, 0xfe, 0x50, 0x9b, 0x5d, 0x83, 0xba, 0x58, 0xfe, 0x3f, 0x04, 0x67, 0x97, 0xa0, 0xe9, 0xca,
	0x70, 0xe4, 0x8f, 0xb5, 0x6b, 0xd5, 0x3d, 0xeb, 0x9f, 0xab, 0xd0, 0xa0, 0xc5, 0x21, 0x7b, 0xd1,
	0xdd, 0xd9, 0xe2, 0x89, 0x13, 0x64, 0x52, 0x41, 0xc0, 0xfd, 0x27, 0x4e, 0xc0, 0xd6, 0xa0, 0x81,
	0xd3, 0x24, 0x4b, 0x78, 0xa3, 0x10, 0xec, 0x16, 0x34, 0x50, 0x89, 0x92, 0xd9, 0x3f, 0x40, 0x25,
	0xba, 0x5b, 0xff, 0xf1, 0x3f, 0x5c, 0x3f, 0xc7, 0x15, 0x9a, 0xbd, 0x0d, 0x75, 0x67, 0x3c, 0x4e,
	0x48, 0x97, 0x67, 0xcc, 0x29, 0x5f, 0x2f, 0x27, 0x02, 0xf6, 0x11, 0x98, 0x4a, 0x6e, 0x48, 0xdd,
	0x20, 0xea, 0xcb, 0xa5, 0x6d, 0xa4, 0x2c, 0x52, 0x5e, 0x50, 0x22, 0xc7, 0xfd, 0x44, 0x7b, 0x30,
	0xd2, 0x68, 0x83, 0x17, 0x00, 0xf4, 0xf3, 0x51, 0x2c, 0xb6, 0x82, 0x40, 0xba, 0xfb, 0xfe, 0x33,
	0xa1, 0x77, 0x85, 0x19, 0x18, 0xbb, 0x05, 0xbd, 0x3d, 0xa5, 0x72, 0x5c, 0x24, 0xd3, 0x20, 0x4d,
	0xf4, 0x4e, 0x31, 0x07, 0x65, 0x1b, 0xc0, 0x66, 0x20, 0x07, 0xb4, 0x7c, 0x73, 0xad, 0xb6, 0xde,
	0xe5, 0x4b, 0x30, 0xd6, 0x7f, 0x54, 0xa1, 0x39, 0x0c, 0x13, 0x11, 0xa7, 0x68, 0x00, 0xce, 0x68,
	0x24, 0xdc, 0x54, 0x28, 0xc7, 0x53, 0xe7, 0x79, 0x1f, 0x17, 0x70, 0x20, 0x3f, 0x8b, 0xfd, 0x54,
	0xec, 0x7f, 0xa8, 0x45, 0x5c, 0x00, 0xd8, 0x6d, 0x58, 0x75, 0x3c, 0xcf, 0xce, 0xa8, 0xed, 0x58,
	0x3e, 0x4d, 0xc8, 0x18, 0x0c, 0xbe, 0xe2, 0x78, 0xde, 0x96, 0x86, 0x73, 0xf9, 0x34, 0x61, 0x37,
	0xa0, 0x16, 0x8b, 0x11, 0x09, 0xbc, 0xbd, 0xb9, 0xa2, 0x04, 0xf2, 0xe9, 0xe1, 0x0f, 0x85, 0x9b,
	0x72, 0x31, 0xe2, 0x88, 0x63, 0x17, 0xa0, 0xe1, 0xa4, 0x69, 0xac, 0x18, 0x6c, 0x72, 0xd5, 0x61,
	0x1b, 0x70, 0x9e, 0x8c, 0x2e, 0xf5, 0x65, 0x68, 0xa7, 0xce, 0x61, 0x80, 0x7b, 0x5c, 0xa2, 0xdd,
	0xf9, 0x6a, 0x8e, 0x3a, 0x40, 0xcc, 0xd0, 0x4b, 0x70, 0x03, 0x98, 0xa7, 0x0f, 0x9d, 0x89, 0x48,
	0xc8, 0x9b, 0x9b, 0xfc, 0xfc, 0xec, 0x88, 0x5d, 0x44, 0xb1, 0x37, 0xa1, 0x5b, 0x8c, 0x41, 0xb3,
	0x35, 0xc8, 0x02, 0x3a, 0x39, 0x10, 0xad, 0xfa, 0x22, 0x34, 0xfd, 0xc4, 0x16, 0xa1, 0xa7, 0x3d,
	0x49, 0xc3, 0x4f, 0xee, 0x87, 0x1e, 0x7b, 0x07, 0x4c, 0xf5, 0x15, 0x4f, 0x8c, 0x06, 0x40, 0xcb,
	0xeb, 0x69, 0x7d, 0x43, 0xf0, 0x3d, 0x31, 0xe2, 0x46, 0xaa, 0x5b, 0xd6, 0x5f, 0x55, 0xa1, 0x4d,
	0xea, 0xf1, 0x28, 0xf2, 0xd0, 0x9a, 0xde, 0x84, 0xee, 0x2c, 0xf7, 0x94, 0x00, 0x3a, 0x4e, 0x99,
	0x75, 0x67, 0x0b, 0x61, 0x00, 0xad, 0xe1, 0xdd, 0xa9, 0x7b, 0x2c, 0x52, 0x62, 0x7d, 0x97, 0x67,
	0x5d, 0xc4, 0xec, 0x6a, 0x4c, 0x5d, 0x61, 0x74, 0x97, 0xdd, 0x07, 0xd8, 0x17, 0xe3, 0x89, 0x08,
	0xd3, 0x1d, 0x27, 0xd2, 0xfa, 0x7c, 0x73, 0x4e, 0x9f, 0xd5, 0x1f, 0x6e, 0x14, 0x74, 0xf7, 0xc3,
	0x34, 0x3e, 0xe5, 0xa5, 0x81, 0x6c, 0x03, 0x60, 0x4a, 0x54, 0xb6, 0x9b, 0x9e, 0x90, 0x44, 0x72,
	0xd1, 0xaa, 0xd1, 0xdb, 0xe9, 0x09, 0x37, 0xa7, 0x59, 0xf3, 0xca, 0xb7, 0x60, 0x65, 0x6e, 0x3a,
	0x8c, 0xba, 0x8e, 0xc5, 0x29, 0x2d, 0xdb, 0xe4, 0xd8, 0x44, 0x2d, 0x78, 0xe2, 0x04, 0xd3, 0x2c,
	0x94, 0x50, 0x9d, 0x5f, 0xa9, 0x7e, 0xa3, 0x62, 0xbd, 0x01, 0x8d, 0xad, 0x38, 0x76, 0x88, 0xc4,
	0xc1, 0xc6, 0xa0, 0x42, 0xfb, 0x89, 0xea, 0x58, 0x2e, 0xd4, 0xf0, 0xa7, 0x6e, 0x42, 0x75, 0x12,
	0x11, 0xa6, 0xbd, 0x79, 0xb1, 0xb4, 0x26, 0x27, 0xda, 0xd8, 0xd1, 0x6b, 0xa8, 0x4e, 0xa2, 0x2b,
	0x1f, 0x41, 0x6b, 0xe7, 0x15, 0xfe, 0xe1, 0x3f, 0xeb, 0x60, 0xdc, 0x13, 0x81, 0x40, 0xa5, 0x40,
	0x03, 0x2e, 0xeb, 0x78, 0x26, 0xbc, 0x19, 0xbd, 0xb7, 0xa0, 0xa3, 0x76, 0x38, 0x1a, 0x25, 0xb4,
	0xfc, 0x66, 0x60, 0xaf, 0x24, 0xc2, 0xd7, 0x01, 0x62, 0xf9, 0xd4, 0xf6, 0xd5, 0x36, 0xa3, 0x3c,
	0xb6, 0x11, 0xcb, 0xa7, 0x43, 0xdc, 0x68, 0xfe, 0x5f, 0x8c, 0xe6, 0x97, 0x61, 0x50, 0x32, 0x1a,
	0x0c, 0x1f, 0x6d, 0x3f, 0xb4, 0x0f, 0x31, 0x96, 0xd1, 0xf6, 0x53, 0xcc, 0x49, 0xd1, 0xe5, 0x30,
	0xbc, 0x4b, 0x81, 0x8e, 0x76, 0x05, 0xe6, 0x19, 0xae, 0x60, 0xa9, 0x67, 0x81, 0xe5, 0x9e, 0xe5,
	0xee, 0x8c, 0x32, 0xb7, 0x49, 0xf0, 0x56, 0x21, 0xf8, 0x4c, 0x5a, 0x67, 0x6a, 0xf2, 0x0d, 0xe8,
	0xb8, 0x4e, 0x68, 0xa7, 0xf1, 0x34, 0x74, 0x9d, 0x54, 0x0c, 0x3a, 0xf4, 0xa9, 0xb6, 0xeb, 0x84,
	0x07, 0x1a, 0x54, 0x32, 0xff, 0x6e, 0xd9, 0xfc, 0x6f, 0xc1, 0x4a, 0x14, 0xfb, 0x13, 0x27, 0x3e,
	0xb5, 0x8f, 0xc5, 0x29, 0x09, 0xa3, 0xa7, 0xe2, 0x64, 0x0d, 0xfe, 0x44, 0x9c, 0x0e, 0xbd, 0x2f,
	0xac, 0xfb, 0x7f, 0x57, 0x05, 0x73, 0x2f, 0x16, 0xda, 0x65, 0x5f, 0x87, 0x76, 0xe2, 0x1e, 0x89,
	0x89, 0x43, 0x52, 0xd2, 0x33, 0x80, 0x02, 0xa1, 0x70, 0x66, 0x9d, 0x52, 0xf5, 0x6c, 0xa7, 0x84,
	0xff, 0xa1, 0xa2, 0x18, 0x34, 0x26, 0x6c, 0x16, 0x9e, 0xb8, 0x5e, 0xf6, 0xc4, 0x6b, 0xd0, 0x39,
	0x72, 0x12, 0xdb, 0x99, 0xa6, 0xd2, 0x76, 0x65, 0x40, 0x4a, 0x67, 0x70, 0x38, 0x72, 0x92, 0xad,
	0x69, 0x2a, 0xb7, 0x25, 0x45, 0x45, 0x7e, 0x62, 0x2b, 0x83, 0xd7, 0xfb, 0x9d, 0xe1, 0x27, 0xda,
	0xd7, 0x6d, 0xc0, 0x79, 0x91, 0xa4, 0xfe, 0xc4, 0xd1, 0x02, 0xb5, 0x5d, 0x39, 0x0d, 0x53, 0xda,
	0xf5, 0x6a, 0x7c, 0x35, 0x47, 0x71, 0xf9, 0x74, 0x1b, 0x11, 0xec, 0x7d, 0xe8, 0xb9, 0x72, 0x12,
	0xd9, 0x11, 0xf2, 0x95, 0xe2, 0x09, 0x15, 0x60, 0x97, 0xf7, 0xfb, 0x0e, 0x52, 0xec, 0x1d, 0x0b,
	0x15, 0xe0, 0x6c, 0xc2, 0x8a, 0x1b, 0x4c, 0x93, 0x54, 0xc4, 0xf6, 0xa1, 0x1e, 0x62, 0x2e, 0x0c,
	0xe9, 0x6a, 0x12, 0x15, 0x14, 0x59, 0x7f, 0x5f, 0x05, 0x78, 0x28, 0xdd, 0xe3, 0x03, 0x27, 0x1e,
	0x8b, 0x14, 0x43, 0xc9, 0xcc, 0x5c, 0xb4, 0x39, 0xb7, 0x52, 0x65, 0x24, 0x6c, 0x13, 0x2e, 0x65,
	0x92, 0x76, 0x65, 0x40, 0x61, 0xad, 0xd2, 0x77, 0x2d, 0x2d, 0xa6, 0xb1, 0xea, 0x60, 0x44, 0xca,
	0xce, 0xbe, 0x51, 0x68, 0x07, 0x8e, 0x49, 0x4f, 0x23, 0xb2, 0xf0, 0x65, 0x21, 0x49, 0xb7, 0x18,
	0x7e, 0x70, 0x1a, 0xb1, 0xf7, 0xe1, 0x62, 0x2c, 0x46, 0xb1, 0x48, 0x8e, 0xec, 0x34, 0x29, 0x7f,
	0x4c, 0x45, 0x94, 0xab, 0x1a, 0x79, 0x90, 0xe4, 0xdf, 0x7a, 0x1f, 0x2e, 0x8e, 0xe8, 0x68, 0x31,
	0xff, 0x7b, 0xca, 0x39, 0xac, 0x2a, 0x64, 0xf9, 0xef, 0xde, 0x00, 0x3a, 0x5f, 0x2b, 0x83, 0xcf,
	0xe2, 0x93, 0x80, 0x98, 0x71, 0x18, 0x08, 0xdc, 0x77, 0xb6, 0x8f, 0xf0, 0xd0, 0x73, 0x4f, 0x8c,
	0x74, 0xc4, 0x5d, 0x00, 0x98, 0x05, 0xf5, 0x1d, 0xe9, 0x09, 0x12, 0x4a, 0x6f, 0xb3, 0xb7, 0x41,
	0x27, 0x75, 0xe4, 0x24, 0x42, 0x39, 0xe1, 0xac, 0x5d, 0x68, 0x22, 0xe4, 0x53, 0xdc, 0x2a, 0x5a,
	0x29, 0x71, 0x38, 0xd1, 0xae, 0xf9, 0x42, 0x61, 0xa1, 0x05, 0xfb, 0x79, 0x46, 0x84, 0x1a, 0x78,
	0x88, 0x33, 0x6a, 0x7f, 0xa9, 0x3a, 0x16, 0x87, 0x95, 0xdc, 0x08, 0x1e, 0x85, 0xfe, 0xe3, 0xa9,
	0x60, 0x1f, 0xc3, 0x6a, 0x14, 0x0b, 0xdb, 0x27, 0x98, 0x3d, 0x3d, 0xa6, 0xad, 0xa8, 0x42, 0x3c,
	0xbe, 0xa0, 0x78, 0x5c, 0x8c, 0x38, 0xc6, 0xfd, 0xa8, 0x17, 0xcd, 0xf4, 0xad, 0x1f, 0xc0, 0xe5,
	0x9c, 0x62, 0x5f, 0xb8, 0x32, 0xf4, 0x9c, 0xf8, 0x94, 0xfc, 0xd5, 0xdc, 0xdc, 0xc9, 0xcb, 0xcc,
	0xbd, 0x4f, 0x73, 0xff, 0xa8, 0x06, 0xbd, 0x4f, 0xc3, 0x7b, 0xd3, 0x28, 0xf0, 0xd1, 0x87, 0x7c,
	0xa2, 0x4c, 0x5c, 0x99, 0x56, 0xa5, 0x6c, 0x5a, 0xeb, 0xd0, 0xd7, 0x5f, 0x41, 0xd9, 0x29, 0xc3,
	0xd0, 0x27, 0x74, 0x05, 0xdf, 0x96, 0x81, 0xb2, 0x8a, 0x6f, 0xc1, 0xc5, 0x29, 0xad, 0x5c, 0x51,
	0x1e, 0x09, 0xf7, 0xd8, 0x7e, 0x4e, 0xb0, 0xcd, 0x14, 0x21, 0x0e, 0x45, 0x32, 0x32, 0x91, 0xeb,
	0xd0, 0x2e, 0x86, 0x67, 0xf6, 0x0d, 0x39, 0x21, 0xfd, 0x89, 0x0c, 0x6d, 0x2f, 0xfb, 0x65, 0xbd,
	0xbb, 0xa0, 0x67, 0xe8, 0xc9, 0x62, 0x25, 0xb8, 0xc7, 0xfc, 0x06, 0xac, 0xce, 0x50, 0xd2, 0x5f,
	0xa8, 0x20, 0xe0, 0xbd, 0x42, 0xb8, 0xb3, 0xcb, 0x2f, 0x77, 0xf1, 0x7f, 0x94, 0x27, 0x5e, 0x91,
	0xb3, 0x50, 0xed, 0x47, 0xfc, 0x71, 0x28, 0x63, 0xa1, 0x35, 0xcf, 0xf0, 0x93, 0x21, 0xf5, 0xaf,
	0xec, 0xc2, 0x85, 0x65, 0xb3, 0x2c, 0x71, 0xa7, 0x6b, 0x65, 0x77, 0x3a, 0x77, 0x50, 0x28, 0x5c,
	0xeb, 0x1f, 0x56, 0xa0, 0xfd, 0x60, 0xfa, 0xec, 0xd9, 0xa9, 0x3a, 0x98, 0xb3, 0x0e, 0x54, 0x76,
	0x69, 0x96, 0x2a, 0xaf, 0xec, 0xe2, 0x59, 0x65, 0xef, 0x18, 0x7d, 0x2a, 0x4d, 0x62, 0x72, 0xdd,
	0xc3, 0x23, 0xc6, 0xde, 0xf1, 0xc1, 0x19, 0xf6, 0xac, 0xd0, 0x18, 0x5d, 0xdf, 0x9d, 0xfa, 0x01,
	0xee, 0xca, 0xda, 0x74, 0xf3, 0x3e, 0x06, 0xed, 0xc3, 0x91, 0xd2, 0x97, 0x07, 0xb1, 0x9c, 0x28,
	0x8d, 0xd6, 0x6e, 0x75, 0x09, 0xc6, 0xfa, 0xdb, 0x1a, 0xd4, 0xbf, 0x2f, 0xfd, 0x50, 0x1d, 0x78,
	0x03, 0x3b, 0x50, 0x27, 0x47, 0x14, 0x4e, 0x2b, 0x16, 0xc1, 0x43, 0x3c, 0x7b, 0xbd, 0x06, 0x06,
	0x2a, 0x46, 0xa0, 0xce, 0x64, 0x84, 0x72, 0xa5, 0x42, 0x15, 0xc7, 0xb2, 0xca, 0xd2, 0x63, 0x59,
	0x7e, 0x6a, 0xaa, 0xbf, 0xe8, 0xd4, 0x64, 0x06, 0x62, 0x84, 0xaa, 0x1a, 0x7a, 0x3a, 0x78, 0x2c,
	0x4f, 0x66, 0x20, 0x72, 0x5b, 0x86, 0x1e, 0xfb, 0x1a, 0x40, 0xec, 0x8f, 0x8f, 0x34, 0x65, 0x73,
	0xf1, 0x24, 0x4b, 0x58, 0x22, 0xe5, 0xf0, 0x9a, 0x4e, 0x8f, 0xd8, 0xda, 0x89, 0x1d, 0x22, 0x97,
	0xd4, 0x3a, 0x5a, 0xd9, 0x81, 0x6b, 0x79, 0x62, 0xe5, 0xd2, 0x4c, 0x62, 0x85, 0xb8, 0x4b, 0xeb,
	0x7d, 0x1d, 0x70, 0x6f, 0x3a, 0xb2, 0x65, 0x68, 0x47, 0x59, 0x62, 0xc0, 0x40, 0xc8, 0xa7, 0xe1,
	0xde, 0x31, 0x3a, 0x3f, 0x3f, 0xb1, 0x75, 0x7e, 0x41, 0x87, 0xf4, 0xa5, 0xc3, 0xd9, 0x1a, 0x74,
	0x7e, 0x28, 0xfd, 0xd0, 0x9e, 0x38, 0x91, 0x9d, 0x3a, 0x63, 0x0a, 0x3e, 0x1a, 0x1c, 0x10, 0xb6,
	0xe3, 0x44, 0x07, 0xce, 0x98, 0x36, 0x61, 0x9d, 0xb1, 0x40, 0x23, 0x69, 0x2b, 0x02, 0x0d, 0x42,
	0xf1, 0x5e, 0x05, 0x93, 0xa6, 0xa0, 0x7c, 0x46, 0x47, 0xc9, 0x1e, 0x01, 0xc8, 0x51, 0xeb, 0x5f,
	0xaa, 0x60, 0x6c, 0x85, 0xa9, 0x4f, 0xf2, 0xbc, 0x04, 0xcd, 0x98, 0x0e, 0x67, 0x5a, 0x9a, 0xba,
	0x97, 0x4b, 0xac, 0xfa, 0x1c, 0x89, 0xcd, 0x48, 0xa2, 0xf6, 0xb9, 0x25, 0x51, 0x3f, 0x4b, 0x12,
	0xb3, 0x5c, 0x6b, 0x9c, 0xc9, 0xb5, 0x85, 0x23, 0xed, 0x57, 0x21, 0xc6, 0x79, 0x49, 0x18, 0x2f,
	0x92, 0x84, 0x39, 0x2f, 0x09, 0xeb, 0xcf, 0x6b, 0x60, 0x3c, 0x14, 0xa3, 0xf4, 0x17, 0xc6, 0xf3,
	0xf3, 0x62, 0x3c, 0xd6, 0xbf, 0xd7, 0xc0, 0xe4, 0xb8, 0xc2, 0xaf, 0x50, 0x66, 0x77, 0x00, 0x48,
	0x16, 0x67, 0x0b, 0x8e, 0xe4, 0x45, 0x59, 0x13, 0xf6, 0x01, 0xb4, 0x95, 0x4c, 0xd4, 0x88, 0xc6,
	0x73, 0x46, 0x28, 0xc1, 0x1d, 0x2c, 0xca, 0xbb, 0xf9, 0xb9, 0xe5, 0xdd, 0x7a, 0x65, 0x79, 0x1b,
	0x5f, 0x86, 0xbc, 0xcd, 0x33, 0xe5, 0x0d, 0x2f, 0x92, 0x77, 0xfb, 0x45, 0xf2, 0xee, 0x2c, 0xc8,
	0xfb, 0x47, 0x35, 0xe8, 0x92, 0xbc, 0xf7, 0xc5, 0xe4, 0x8b, 0x39, 0xc5, 0x39, 0x21, 0xd5, 0x5e,
	0x56, 0x48, 0xf5, 0xcf, 0x2d, 0xa4, 0xc6, 0x2b, 0x0b, 0xa9, 0xf9, 0x65, 0x08, 0xa9, 0x75, 0xa6,
	0x90, 0x8c, 0x17, 0x09, 0xc9, 0x7c, 0x79, 0xa3, 0xcc, 0x85, 0xf4, 0x85, 0x77, 0xae, 0x5f, 0x08,
	0xe9, 0x4b, 0x12, 0x12, 0x2c, 0x08, 0x09, 0x23, 0x8b, 0x2f, 0x6c, 0x44, 0x5f, 0x45, 0x64, 0x71,
	0x26, 0xb3, 0x1b, 0x5f, 0x06, 0xb3, 0x9b, 0x67, 0x32, 0xbb, 0xf5, 0x22, 0x66, 0xbf, 0x42, 0x64,
	0xf1, 0x17, 0x35, 0x80, 0x7d, 0x3f, 0x1c, 0x07, 0xe2, 0x17, 0xb1, 0xc5, 0xcf, 0x4d, 0x6c, 0xf1,
	0xd7, 0x55, 0x30, 0x76, 0x9c, 0xf8, 0xf8, 0x67, 0xce, 0x42, 0xde, 0x84, 0x96, 0x0c, 0xcb, 0xf6,
	0x50, 0xa6, 0x6b, 0xca, 0xf0, 0x67, 0x42, 0xe5, 0x7f, 0xbb, 0x02, 0xad, 0xbd, 0x58, 0x7a, 0x53,
	0x37, 0x7d, 0x45, 0x7d, 0x9f, 0xfd, 0xc7, 0xda, 0x8b, 0xfe, 0xb1, 0x3e, 0xff, 0x8f, 0xd6, 0xef,
	0x54, 0xc0, 0xd4, 0xbf, 0xf0, 0x70, 0xf3, 0x2b, 0x32, 0xba, 0x17, 0xff, 0xc5, 0x53, 0x30, 0x29,
	0x4f, 0x74, 0xa6, 0x1a, 0x9d, 0x69, 0x3f, 0xd5, 0x57, 0xb2, 0x1f, 0xeb, 0xf7, 0x2b, 0xd0, 0xa5,
	0x14, 0xdd, 0x83, 0x69, 0xe8, 0xd2, 0x4d, 0xc4, 0xf2, 0xac, 0xd2, 0x1a, 0xd4, 0x63, 0x91, 0x66,
	0xf7, 0xa4, 0x1d, 0xf5, 0x99, 0x6d, 0x19, 0xdc, 0x13, 0x23, 0x4e, 0x18, 0x64, 0x82, 0x13, 0x8f,
	0x93, 0x65, 0x37, 0xb5, 0x08, 0xc7, 0x55, 0x45, 0x4e, 0xec, 0x4c, 0x92, 0xec, 0xa6, 0x56, 0xf5,
	0x18, 0x83, 0x3a, 0x65, 0x9e, 0x1b, 0x94, 0x13, 0xa1, 0xb6, 0xb5, 0x05, 0x17, 0xef, 0x9f, 0xa4,
	0x22, 0x0e, 0x9d, 0x60, 0xd7, 0x99, 0x88, 0xcd, 0x6d, 0x19, 0xa8, 0x34, 0x5a, 0x46, 0x5c, 0x29,
	0x88, 0xf1, 0x87, 0xcb, 0x75, 0x28, 0xaa, 0x63, 0xdd, 0x84, 0xf6, 0xc8, 0x0f, 0x84, 0x2d, 0x47,
	0xa3, 0x44, 0xa4, 0xf8, 0x75, 0xd5, 0xa2, 0x65, 0xd5, 0xb8, 0xee, 0x59, 0x7f, 0x53, 0x87, 0x4e,
	0xf6, 0x29, 0xba, 0xa7, 0x5f, 0xbe, 0xfc, 0xab, 0x60, 0xd2, 0x6c, 0x89, 0xff, 0x4c, 0x10, 0x0f,
	0x6a, 0xdc, 0x40, 0x00, 0x5d, 0xac, 0x6e, 0xc1, 0x6a, 0xe9, 0x53, 0x76, 0x2a, 0x53, 0x27, 0xd0,
	0x6c, 0x28, 0xdd, 0x1a, 0x95, 0x48, 0xf8, 0x0a, 0x76, 0x3e, 0xa5, 0xf6, 0x01, 0x52, 0x23, 0x7b,
	0xf3, 0x24, 0xda, 0x02, 0x7b, 0x11, 0xc3, 0xbe, 0x0b, 0x2b, 0xb8, 0xda, 0x4d, 0x95, 0x91, 0xa5,
	0xf5, 0x2a, 0xbb, 0xbe, 0x5e, 0x7c, 0x62, 0x29, 0xcf, 0x78, 0x37, 0x9c, 0x61, 0xe1, 0x1b, 0x00,
	0x6e, 0x2c, 0x9c, 0x54, 0xd8, 0xc9, 0xe3, 0x80, 0x6c, 0xde, 0xe4, 0xa6, 0x82, 0xec, 0x3f, 0x0e,
	0xf2, 0x95, 0xe6, 0x4e, 0xd9, 0x54, 0x2b, 0x25, 0x45, 0x7f, 0x0f, 0xda, 0x32, 0xf6, 0xc7, 0x7e,
	0xa8, 0x52, 0x7e, 0xc6, 0x92, 0xbf, 0x05, 0x45, 0x40, 0x09, 0x40, 0x0b, 0x9a, 0x4a, 0x51, 0x97,
	0xe4, 0xce, 0x35, 0x86, 0x71, 0xe8, 0x1d, 0x1c, 0x6e, 0xcb, 0xe0, 0x80, 0xca, 0x9d, 0xb6, 0x65,
	0x30, 0x00, 0x9a, 0xf5, 0xf6, 0xe2, 0xb2, 0x50, 0x3e, 0x1b, 0xb3, 0xc4, 0x2a, 0xe9, 0x37, 0x37,
	0x03, 0xbb, 0x05, 0x2b, 0x49, 0x1a, 0xfb, 0x6e, 0x8a, 0x4b, 0xb4, 0x27, 0xd2, 0x13, 0xe4, 0xb9,
	0x0d, 0xde, 0x55, 0xe0, 0xfd, 0xc7, 0xc1, 0x8e, 0xf4, 0xc4, 0x95, 0x2d, 0x38, 0xbf, 0x64, 0xba,
	0x97, 0xba, 0x4c, 0x71, 0x01, 0xf6, 0xd3, 0x58, 0x38, 0x13, 0x52, 0x9e, 0xb7, 0xa1, 0x95, 0x1e,
	0x06, 0x74, 0x53, 0x52, 0x59, 0x7a, 0x53, 0xd2, 0x4c, 0x0f, 0x91, 0x4b, 0x25, 0x75, 0xac, 0xd2,
	0x9d, 0x85, 0xee, 0xe1, 0x87, 0x02, 0x7f, 0xe2, 0xa7, 0xba, 0xb0, 0x49, 0x75, 0xac, 0x0f, 0xc1,
	0xa4, 0x19, 0xe8, 0x1b, 0xf9, 0x0e, 0x5e, 0x39, 0x73, 0x07, 0xb7, 0xde, 0x05, 0xf3, 0xd7, 0xf1,
	0x37, 0x69, 0xd0, 0x75, 0x68, 0xd3, 0x6d, 0x9a, 0xad, 0x32, 0xe1, 0xfa, 0x96, 0x87, 0x40, 0x77,
	0x29, 0x1d, 0x0e, 0x60, 0x3c, 0x0a, 0x7d, 0x19, 0x6e, 0x05, 0x81, 0xf5, 0x93, 0x2a, 0x98, 0xdf,
	0x73, 0x92, 0x23, 0xf2, 0x12, 0x6c, 0x0d, 0xda, 0xbb, 0x42, 0x78, 0x08, 0xd8, 0x71, 0x22, 0x5d,
	0x41, 0x51, 0x06, 0xb1, 0x2b, 0x60, 0x7c, 0x4f, 0xed, 0x19, 0x9f, 0xe8, 0x1c, 0x7b, 0xde, 0xcf,
	0x46, 0xd3, 0x6d, 0x9d, 0xc8, 0x6e, 0xf4, 0xcb, 0x20, 0x76, 0x1b, 0xfa, 0xd8, 0xa5, 0x3a, 0x05,
	0xd4, 0x41, 0x11, 0x28, 0x0f, 0x61, 0xf0, 0x05, 0x38, 0xbb, 0x0d, 0x80, 0x9b, 0x1b, 0xdd, 0x03,
	0x26, 0x4b, 0xf6, 0xb5, 0x12, 0x96, 0x5d, 0x03, 0xf8, 0x7e, 0xee, 0x60, 0x75, 0x0d, 0x50, 0x09,
	0xc2, 0xde, 0x82, 0xae, 0xee, 0x71, 0x31, 0xda, 0xd6, 0xb7, 0x47, 0x0d, 0x3e, 0x0b, 0x64, 0xf7,
	0x61, 0x95, 0xbf, 0x74, 0x75, 0xd6, 0x02, 0xc8, 0xfa, 0xe3, 0x2a, 0x74, 0xf4, 0x9e, 0x44, 0x3e,
	0x7b, 0x86, 0x67, 0x95, 0xb3, 0x79, 0x56, 0xfd, 0x7c, 0x3c, 0xab, 0x7d, 0x2e, 0x9e, 0xd5, 0xcf,
	0xe4, 0xd9, 0xd2, 0xd5, 0x36, 0x5e, 0x76, 0xb5, 0x2f, 0x64, 0xfd, 0x35, 0x80, 0xfd, 0x3c, 0x08,
	0xd0, 0x7c, 0x2f, 0x41, 0xac, 0x7d, 0x00, 0xf2, 0x55, 0x8a, 0x55, 0x4b, 0x7f, 0xaa, 0xf2, 0xd2,
	0x22, 0xf8, 0x9f, 0x0a, 0xc0, 0xbe, 0x33, 0x89, 0xd4, 0x56, 0xc7, 0xbe, 0x03, 0xed, 0x84, 0x7a,
	0x2a, 0xa7, 0xaa, 0x6a, 0x3e, 0x4b, 0xbe, 0xb4, 0x20, 0xd5, 0x4d, 0xb4, 0x30, 0x0e, 0x49, 0xde,
	0xa6, 0xe8, 0x46, 0xcd, 0x40, 0x57, 0xca, 0x55, 0x1d, 0xdd, 0x10, 0x88, 0x6e, 0x93, 0x6f, 0x42,
	0x4f, 0x13, 0x44, 0x22, 0x76, 0x45, 0xa8, 0xac, 0xba, 0xc2, 0xbb, 0x0a, 0xba, 0xa7, 0x80, 0xec,
	0x83, 0x9c, 0xcc, 0x95, 0xc1, 0x74, 0xb2, 0x54, 0x48, 0x7a, 0xc8, 0xb6, 0x22, 0xb0, 0x36, 0xb3,
	0xa5, 0xd0, 0x8f, 0x18, 0x50, 0xc7, 0xef, 0xf5, 0xcf, 0xb1, 0x36, 0xb4, 0xf4, 0xac, 0xfd, 0x0a,
	0xeb, 0x82, 0x49, 0x65, 0x69, 0x84, 0xab, 0x5a, 0xbf, 0xc7, 0xa0, 0x3d, 0x0c, 0x93, 0x34, 0x9e,
	0xaa, 0x7d, 0xbe, 0xa8, 0xbe, 0x6a, 0x50, 0xf5, 0x95, 0xbe, 0xba, 0x55, 0xcb, 0xa0, 0xab, 0xdb,
	0x5b, 0x50, 0x77, 0xc2, 0xd4, 0xd7, 0x61, 0x4d, 0xa9, 0xc4, 0x2f, 0x3b, 0xb2, 0x73, 0xc2, 0xb3,
	0xf7, 0xa0, 0xa5, 0xeb, 0x01, 0x75, 0x4d, 0xce, 0xd2, 0x62, 0xc2, 0x8c, 0x86, 0x6d, 0x80, 0xe1,
	0xe9, 0x42, 0x45, 0xad, 0x5b, 0xa5, 0xa9, 0xb3, 0x12, 0x46, 0x9e, 0xd3, 0xb0, 0x1b, 0x50, 0x73,
	0xc6, 0x4a, 0x8d, 0xe8, 0x8e, 0x3f, 0x23, 0xa5, 0xf2, 0x2e, 0x8e, 0x38, 0x76, 0x47, 0x07, 0xd0,
	0x18, 0x51, 0x69, 0xeb, 0x2c, 0xcd, 0x99, 0xa5, 0x6b, 0x55, 0x20, 0x4d, 0x21, 0xd6, 0x1d, 0x30,
	0x13, 0x31, 0xf1, 0xd5, 0x00, 0x73, 0x7e, 0x40, 0x76, 0xe4, 0xe5, 0x46, 0x92, 0x1d, 0x7e, 0x3f,
	0x82, 0x76, 0x42, 0x67, 0x33, 0x35, 0x04, 0xb2, 0x9b, 0xbb, 0x7c, 0x48, 0x7e, 0x70, 0xe3, 0x90,
	0x14, 0x87, 0xb8, 0x3b, 0x60, 0x4e, 0x9c, 0xf8, 0x58, 0x0d, 0x6a, 0xcf, 0x7f, 0x27, 0x3b, 0x38,
	0x70, 0x63, 0x92, 0x1d, 0x21, 0x2c, 0xa8, 0x13, 0x6d, 0x27, 0xdb, 0x3e, 0x32, 0x5a, 0xc5, 0x6f,
	0xc4, 0xb1, 0x77, 0xa0, 0x15, 0xa9, 0x88, 0x95, 0xea, 0x07, 0xda, 0x9b, 0xab, 0x05, 0x99, 0x0e,
	0x65, 0x79, 0x46, 0xc1, 0xbe, 0x0d, 0x3d, 0x75, 0x0b, 0x3d, 0xd2, 0x01, 0x1e, 0xd5, 0x14, 0xcc,
	0xd4, 0x9c, 0xcd, 0xc4, 0x7f, 0xbc, 0x9b, 0xce, 0x84, 0x83, 0xdf, 0x84, 0xae, 0xd0, 0xfb, 0xaf,
	0x9d, 0xb8, 0x4e, 0x38, 0xe8, 0xd3, 0xf0, 0x4b, 0xcb, 0xb7, 0x67, 0xde, 0x11, 0xe5, 0x60, 0x6a,
	0x1d, 0x9a, 0xea, 0xce, 0x71, 0xb0, 0x4a, 0xa3, 0x4a, 0xf5, 0xd2, 0xea, 0x46, 0x8a, 0x6b, 0x3c,
	0xbb, 0x3b, 0x77, 0x57, 0x88, 0x1b, 0x30, 0xa3, 0x31, 0x83, 0xe7, 0x5d, 0x00, 0xce, 0xdc, 0x22,
	0x7e, 0x22, 0x4e, 0xd9, 0x26, 0x40, 0x71, 0xc7, 0x3a, 0x38, 0x3f, 0xaf, 0x8a, 0xf9, 0x05, 0x2b,
	0x37, 0xf3, 0xbb, 0x55, 0x74, 0x2e, 0xe5, 0x3b, 0x5f, 0x75, 0x6d, 0x76, 0x81, 0x86, 0xbe, 0xb6,
	0x64, 0xa8, 0xba, 0x3d, 0xe3, 0x2b, 0xd1, 0xdc, 0xd5, 0xf1, 0xbb, 0x60, 0xc8, 0xd8, 0xa3, 0x62,
	0x81, 0xc1, 0x45, 0xb2, 0xde, 0x55, 0x5d, 0x8c, 0xa2, 0x8a, 0x26, 0xc9, 0x29, 0xb5, 0xa4, 0xea,
	0xb0, 0xf7, 0xa0, 0x13, 0xc5, 0xf2, 0x87, 0xc2, 0x4d, 0x55, 0x98, 0x75, 0x69, 0xb1, 0xd8, 0x52,
	0xe3, 0x29, 0xea, 0x2a, 0xc2, 0xa8, 0xcb, 0xcf, 0x0d, 0xa3, 0xd6, 0xb2, 0xc0, 0x61, 0xb0, 0x78,
	0x3f, 0x49, 0x08, 0x9c, 0x45, 0x87, 0x1c, 0xaf, 0x2d, 0xce, 0xa2, 0xc3, 0x8f, 0x01, 0xb4, 0xfc,
	0xe4, 0x81, 0x1f, 0x27, 0xe9, 0xe0, 0x8a, 0x2a, 0x52, 0xd5, 0x5d, 0x0c, 0x58, 0xfc, 0xe4, 0xa1,
	0x93, 0xa4, 0x83, 0xab, 0x59, 0xbd, 0x2c, 0xf6, 0x90, 0xe7, 0xea, 0x44, 0x4a, 0x5a, 0xfb, 0xfa,
	0x3c, 0xcf, 0xf3, 0xb4, 0xbb, 0x3e, 0x9a, 0x92, 0x8e, 0x7f, 0x0c, 0x2b, 0x6a, 0x4c, 0x61, 0x82,
	0x6f, 0xcc, 0xeb, 0xe4, 0x4c, 0xfe, 0x96, 0x77, 0xe3, 0x99, 0x74, 0x6e, 0x3e, 0x01, 0xba, 0x1f,
	0x35, 0xc1, 0xb5, 0xa5, 0x13, 0xe4, 0x8e, 0x4a, 0x4d, 0x90, 0xa7, 0x1a, 0x6f, 0x43, 0xd3, 0x53,
	0x35, 0x54, 0xd7, 0x17, 0x1c, 0x90, 0xae, 0xf1, 0xe1, 0x9a, 0x82, 0x7d, 0x0d, 0x5a, 0x54, 0xd9,
	0x20, 0xa3, 0xc1, 0xda, 0xbc, 0x12, 0xab, 0x8a, 0x04, 0xde, 0x0c, 0x54, 0x65, 0xc2, 0x3b, 0xd0,
	0xca, 0x4e, 0xa2, 0x37, 0xe6, 0x0d, 0x53, 0x6f, 0x6f, 0x3c, 0xa3, 0x60, 0x37, 0xa1, 0x31, 0x41,
	0xf7, 0x3c, 0xb0, 0xe6, 0x1d, 0x9b, 0xf2, 0xda, 0x0a, 0x4b, 0x8e, 0x87, 0x02, 0x4c, 0x65, 0x7d,
	0x6f, 0x2e, 0x38, 0x9e, 0x3c, 0xfa, 0xe4, 0x90, 0x14, 0x91, 0xe8, 0x6f, 0xc1, 0x95, 0x72, 0xbd,
	0x41, 0x56, 0x8c, 0xa0, 0x4f, 0x0e, 0x6f, 0xd1, 0x2c, 0x37, 0x96, 0x28, 0xf8, 0x6c, 0xd9, 0x02,
	0xbf, 0x1c, 0x3d, 0xa7, 0x9e, 0xe1, 0xa3, 0x7c, 0xf3, 0x43, 0xbf, 0x32, 0xb8, 0xb9, 0xf0, 0x5b,
	0xf9, 0xf6, 0x99, 0x6d, 0x89, 0xb4, 0xeb, 0x7e, 0x03, 0x3a, 0xa3, 0xe9, 0xb3, 0x67, 0xa7, 0xfa,
	0x00, 0x3b, 0xb8, 0x45, 0xe3, 0x4a, 0xa7, 0xa4, 0xd2, 0xed, 0x39, 0x6f, 0x8f, 0x4a, 0x57, 0xe9,
	0x97, 0xa1, 0xe5, 0x86, 0xb6, 0xe3, 0x79, 0xf1, 0xe0, 0x6d, 0x75, 0x7b, 0xee, 0x86, 0x5b, 0x9e,
	0x47, 0x65, 0x08, 0x32, 0x12, 0x54, 0x78, 0x6c, 0xfb, 0xde, 0x60, 0x5d, 0x6d, 0xc3, 0x19, 0x68,
	0xe8, 0xd1, 0x93, 0x06, 0x27, 0x76, 0x82, 0x40, 0x04, 0x48, 0xf0, 0x35, 0xfd, 0xa4, 0x41, 0x83,
	0x86, 0x1e, 0xbb, 0x01, 0x9d, 0x89, 0x73, 0x62, 0x67, 0x90, 0xc1, 0x6d, 0x55, 0x2f, 0x3e, 0x71,
	0x4e, 0xf6, 0x34, 0x08, 0xd5, 0x5c, 0x95, 0xa5, 0x91, 0xb2, 0xbd, 0x33, 0xaf, 0xe6, 0xf9, 0xd9,
	0x9d, 0x9b, 0x7e, 0x7e, 0x8c, 0x27, 0x77, 0x44, 0x4e, 0xd8, 0x0e, 0x36, 0x07, 0xef, 0x2e, 0xba,
	0x23, 0x9d, 0x74, 0x40, 0x77, 0x94, 0xe5, 0x1f, 0x36, 0x01, 0x94, 0xb7, 0x26, 0x61, 0xbf, 0x37,
	0x3f, 0x26, 0x3f, 0x05, 0x70, 0x55, 0x93, 0x45, 0xa2, 0xde, 0x04, 0xa0, 0xf3, 0x88, 0x1a, 0xb3,
	0x31, 0x3f, 0x26, 0x3f, 0x04, 0x70, 0xf3, 0x49, 0x7e, 0x1e, 0xb8, 0x03, 0xe6, 0x14, 0xc3, 0x7d,
	0xdb, 0x09, 0x82, 0xc1, 0x9d, 0x79, 0x1b, 0xc8, 0x4e, 0x02, 0xdc, 0x98, 0xea, 0x16, 0x7e, 0x84,
	0x32, 0x45, 0x14, 0x92, 0x0d, 0xde, 0x9f, 0xff, 0x48, 0x7e, 0x5c, 0xe0, 0xe6, 0x51, 0x7e, 0x72,
	0xf8, 0x26, 0x74, 0xb3, 0xf4, 0x8f, 0x1a, 0xf6, 0xc1, 0xfc, 0xd6, 0x51, 0x0e, 0x89, 0x79, 0x56,
	0xb4, 0xaf, 0x06, 0x7f, 0x04, 0x6d, 0xc5, 0x71, 0x35, 0x74, 0x73, 0x5e, 0xc1, 0x8a, 0x00, 0x91,
	0x2b, 0xd1, 0xa8, 0x61, 0x37, 0xa1, 0xe1, 0x44, 0x51, 0x70, 0x3a, 0xf8, 0x70, 0xde, 0xaa, 0xb6,
	0x10, 0xcc, 0x15, 0xd6, 0xfa, 0x08, 0x3a, 0x5b, 0xf4, 0x8c, 0xc6, 0x4f, 0xc8, 0xc5, 0xde, 0x84,
	0x7a, 0x9e, 0xf3, 0xc9, 0x7d, 0x37, 0x51, 0x3c, 0x13, 0xc3, 0x70, 0x24, 0x39, 0xa1, 0xad, 0x3f,
	0xad, 0x41, 0x73, 0x5f, 0x4e, 0x63, 0x57, 0xbc, 0xb8, 0x6e, 0xee, 0x8d, 0x4c, 0x94, 0x61, 0x51,
	0xf1, 0xa1, 0xa4, 0x46, 0xe8, 0x72, 0x3a, 0xa9, 0x46, 0xc7, 0xec, 0x3c, 0x9d, 0x94, 0x17, 0x2c,
	0xa9, 0xc2, 0x7a, 0xd5, 0x21, 0x35, 0x9e, 0x26, 0x47, 0x9e, 0x7c, 0x1a, 0xa2, 0x1a, 0x37, 0xa8,
	0xa2, 0x0c, 0x32, 0xd0, 0xd0, 0xa3, 0xca, 0xe3, 0x8c, 0x80, 0xec, 0x44, 0x9d, 0xed, 0x3b, 0x19,
	0x90, 0xac, 0x25, 0x4b, 0x55, 0xb5, 0x9e, 0x93, 0xaa, 0xba, 0x0d, 0x79, 0x31, 0x9f, 0x0e, 0xa4,
	0x9e, 0x5f, 0xec, 0xb7, 0x09, 0x66, 0xfe, 0xc8, 0x4a, 0x07, 0x51, 0x17, 0x36, 0x8a, 0x67, 0x57,
	0x07, 0x59, 0x8b, 0x17, 0x64, 0x4b, 0x72, 0x58, 0x51, 0x2c, 0x0f, 0x75, 0xba, 0x01, 0x5e, 0x26,
	0x87, 0xb5, 0x87, 0xe3, 0xb2, 0xcc, 0x9c, 0x9f, 0xd8, 0xae, 0x0c, 0x93, 0x54, 0x9f, 0xf3, 0x5b,
	0x7e, 0xb2, 0x8d, 0x5d, 0xeb, 0x37, 0xc1, 0xd8, 0x95, 0x1e, 0x89, 0x90, 0x31, 0xa8, 0x4f, 0xdc,
	0x68, 0xaa, 0x43, 0x5e, 0x6a, 0xeb, 0x37, 0x54, 0x4a, 0x38, 0xfa, 0x0d, 0x15, 0xb1, 0xae, 0xa6,
	0xf2, 0x4b, 0xd8, 0x56, 0x2f, 0x37, 0x4e, 0x03, 0xe9, 0x78, 0x5a, 0x20, 0x59, 0xd7, 0xfa, 0x93,
	0x0a, 0xac, 0xee, 0xc5, 0xd2, 0x15, 0x49, 0xf2, 0x10, 0xf7, 0x58, 0x87, 0x22, 0x26, 0x06, 0x75,
	0x4a, 0x13, 0xa9, 0x87, 0x0d, 0xd4, 0x46, 0x65, 0x50, 0xe7, 0xef, 0xfc, 0xa8, 0x50, 0xe3, 0x26,
	0x41, 0xe8, 0xa4, 0x90, 0xa3, 0x69, 0x60, 0xad, 0x84, 0xa6, 0x04, 0xd3, 0x4d, 0xe8, 0x15, 0xe5,
	0xb1, 0x34, 0x83, 0x7e, 0xd1, 0x94, 0x43, 0x69, 0x96, 0xeb, 0xd0, 0x8e, 0x85, 0x83, 0x51, 0x08,
	0x4d, 0xd3, 0x20, 0x1a, 0x50, 0x20, 0x9c, 0xc7, 0x3a, 0x82, 0xfe, 0x5e, 0x2c, 0x22, 0x27, 0x16,
	0xe8, 0xd8, 0x26, 0xc4, 0x95, 0x4b, 0xd0, 0x0c, 0x44, 0x38, 0x4e, 0x8f, 0xf4, 0xff, 0xea, 0x5e,
	0xfe, 0x62, 0xad, 0x5a, 0x7a, 0xb1, 0x86, 0xdc, 0x89, 0x85, 0xa3, 0x1f, 0xb6, 0x51, 0x1b, 0x95,
	0x35, 0x9c, 0x06, 0x3a, 0x75, 0x65, 0x70, 0xd5, 0xb1, 0xfe, 0xa8, 0x06, 0x6d, 0xcd, 0x19, 0xfa,
	0x8a, 0xe2, 0x73, 0x25, 0xe7, 0x73, 0x1f, 0x6a, 0xc9, 0xe3, 0x40, 0x33, 0x1e, 0x9b, 0xec, 0x43,
	0xa8, 0x05, 0xfe, 0x44, 0x9f, 0x35, 0xae, 0xce, 0xb8, 0xc9, 0x59, 0xfe, 0xea, 0x2c, 0x07, 0x52,
	0xb3, 0xab, 0xe4, 0xc6, 0x4e, 0x6c, 0xd4, 0x0a, 0xcd, 0x13, 0x74, 0x59, 0x27, 0xa8, 0x7a, 0xc8,
	0x54, 0xc7, 0xa5, 0xfa, 0xb7, 0xcc, 0x5e, 0xba, 0xdc, 0xd4, 0x90, 0xa1, 0xc7, 0xbe, 0x0e, 0x46,
	0x12, 0x3a, 0x51, 0x72, 0x24, 0x53, 0x7d, 0xb6, 0x60, 0x1b, 0xe9, 0x49, 0xb8, 0xb1, 0xbd, 0x7b,
	0x70, 0x12, 0xee, 0x6b, 0x8c, 0xfe, 0x58, 0x4e, 0xc9, 0xbe, 0x0d, 0x9d, 0x44, 0x24, 0x89, 0xaa,
	0x53, 0x1e, 0x49, 0x6d, 0x47, 0x17, 0xcb, 0x67, 0x07, 0xc2, 0xe2, 0xaa, 0xf5, 0xe0, 0x76, 0x52,
	0x80, 0xd8, 0xf7, 0xa0, 0x97, 0x8d, 0x0f, 0xe4, 0x78, 0x2c, 0xb2, 0x4a, 0xd4, 0xab, 0x0b, 0x33,
	0x3c, 0x24, 0x74, 0x69, 0x9e, 0x6e, 0x52, 0x46, 0xb0, 0xef, 0x42, 0x2f, 0x52, 0xc2, 0xb4, 0x75,
	0x5e, 0x55, 0x99, 0xe0, 0x95, 0x99, 0x5d, 0x7d, 0x46, 0xd8, 0x45, 0x79, 0x68, 0x01, 0x4f, 0xac,
	0xff, 0xaa, 0x40, 0xbb, 0xf4, 0xd7, 0xf4, 0x8e, 0x30, 0x11, 0x71, 0x96, 0x63, 0xc5, 0x36, 0xc2,
	0x8e, 0xa4, 0x7e, 0x9a, 0x63, 0x72, 0x6a, 0x23, 0x2c, 0x96, 0x3a, 0xe9, 0x6e, 0x72, 0x6a, 0xa3,
	0x0f, 0xd2, 0xc7, 0x3c, 0xf5, 0xfc, 0x81, 0x84, 0x52, 0xe7, 0x9d, 0x02, 0x38, 0xa4, 0xdc, 0x07,
	0xaa, 0xd3, 0xa1, 0x93, 0x64, 0x59, 0xdf, 0xbc, 0x8f, 0xc6, 0xf6, 0x44, 0xc4, 0xf8, 0x2f, 0xda,
	0x7d, 0x65, 0x5d, 0x94, 0x35, 0xb9, 0x8d, 0x67, 0x32, 0x54, 0x97, 0x11, 0x1d, 0x6e, 0x20, 0xe0,
	0x07, 0x32, 0xa4, 0x61, 0x5a, 0xb2, 0xc4, 0x4f, 0x93, 0x67, 0x5d, 0x74, 0x0e, 0x8f, 0xa7, 0x02,
	0x23, 0x1f, 0x8f, 0xde, 0xb0, 0x98, 0xbc, 0x45, 0xfd, 0xa1, 0x67, 0xfd, 0x6b, 0x05, 0x56, 0x17,
	0x98, 0x8d, 0x81, 0x06, 0x32, 0x3a, 0xab, 0xda, 0xed, 0xf0, 0x26, 0x76, 0x87, 0x1e, 0x21, 0xd2,
	0x09, 0x29, 0x53, 0x55, 0x23, 0xd2, 0x09, 0x6a, 0xd2, 0x45, 0x68, 0xa6, 0x27, 0xb4, 0x5a, 0x65,
	0x18, 0x8d, 0xf4, 0x04, 0x97, 0xb9, 0x05, 0x66, 0x20, 0xc7, 0x76, 0x20, 0x9e, 0x88, 0x80, 0xf8,
	0xd0, 0xdb, 0x7c, 0xeb, 0x0c, 0x29, 0x6f, 0x3c, 0x94, 0xe3, 0x87, 0x48, 0xcb, 0x8d, 0x40, 0xb7,
	0xac, 0xef, 0x83, 0x91, 0x41, 0x99, 0x09, 0x8d, 0x7b, 0xe2, 0x70, 0x3a, 0xee, 0x9f, 0xc3, 0x03,
	0x3f, 0x8e, 0xe8, 0x57, 0xb0, 0xf5, 0x99, 0x13, 0x87, 0xfd, 0x2a, 0xa2, 0xef, 0xc7, 0xb1, 0x8c,
	0xfb, 0x35, 0x6c, 0xee, 0x39, 0xa1, 0xef, 0xf6, 0xeb, 0xd8, 0x7c, 0xe0, 0xa4, 0x4e, 0xd0, 0x6f,
	0x58, 0x7f, 0xd6, 0x00, 0x63, 0x4f, 0x7f, 0x9d, 0xdd, 0x83, 0x6e, 0xfe, 0xcc, 0x73, 0x79, 0xfe,
	0x63, 0x6f, 0xbe, 0x41, 0xf9, 0x8f, 0x4e, 0x54, 0xea, 0xcd, 0x3f, 0x16, 0xad, 0x2e, 0x3c, 0x16,
	0x7d, 0x1d, 0x6a, 0x8f, 0xe3, 0xd3, 0xd9, 0x7b, 0x91, 0xbd, 0xc0, 0x09, 0x39, 0x82, 0xd9, 0x07,
	0xd0, 0x46, 0xb9, 0xdb, 0x09, 0xed, 0xa8, 0x3a, 0x77, 0x50, 0x7e, 0x76, 0x4b, 0x70, 0x0e, 0x48,
	0xa4, 0x77, 0xdd, 0x0d, 0x30, 0xdc, 0x23, 0x3f, 0xf0, 0x62, 0x11, 0xea, 0xf4, 0x1f, 0x5b, 0xfc,
	0x65, 0x9e, 0xd3, 0xb0, 0xef, 0x50, 0x31, 0x6c, 0x96, 0xf3, 0x28, 0xdf, 0xc5, 0x5f, 0x9c, 0x39,
	0x8a, 0x66, 0x14, 0x7c, 0xa5, 0x44, 0x4e, 0x9b, 0x4b, 0x51, 0xab, 0xdf, 0x2a, 0xd7, 0xea, 0xab,
	0x07, 0x84, 0xb4, 0x29, 0x18, 0xf9, 0x81, 0x48, 0x3a, 0x1e, 0xbb, 0x05, 0xf5, 0x50, 0x7a, 0x62,
	0x31, 0xa9, 0x90, 0xed, 0x43, 0x9c, 0xf0, 0xf4, 0xfa, 0x77, 0x9a, 0x1c, 0xd9, 0x6a, 0x3f, 0x47,
	0x57, 0x02, 0xfa, 0xa1, 0xd0, 0x34, 0x39, 0xba, 0x87, 0x3b, 0x3a, 0x2a, 0xe3, 0x4d, 0xe8, 0x65,
	0x6b, 0xd1, 0xa5, 0xbc, 0xea, 0x0a, 0xb2, 0x9b, 0x41, 0x55, 0x25, 0xef, 0x06, 0x9c, 0x77, 0x8f,
	0x9c, 0x30, 0x14, 0x81, 0x7d, 0x38, 0x1d, 0x8d, 0xb2, 0x1d, 0xa0, 0x43, 0xd7, 0x47, 0xab, 0x1a,
	0x75, 0x97, 0x30, 0xb4, 0xa1, 0x58, 0xd0, 0x0d, 0xfd, 0x40, 0x3d, 0xb0, 0xb0, 0xdd, 0x30, 0x1d,
	0x74, 0x89, 0xb2, 0x1d, 0xfa, 0x01, 0xa5, 0x18, 0xb7, 0xc3, 0x94, 0x7d, 0x0c, 0xfd, 0xe9, 0xd4,
	0xf7, 0x12, 0x3b, 0x95, 0xd9, 0xdb, 0xcb, 0x41, 0x8f, 0x58, 0x57, 0x0a, 0xe0, 0x1e, 0x4d, 0x7d,
	0xef, 0x40, 0xea, 0xd7, 0x97, 0x5d, 0xa2, 0xcf, 0xba, 0xd6, 0xc7, 0xd0, 0x29, 0xeb, 0x0e, 0xea,
	0x22, 0x9d, 0x6c, 0xfa, 0xe7, 0x18, 0x40, 0x73, 0x57, 0xc6, 0x13, 0x27, 0xe8, 0x57, 0xb0, 0xad,
	0x5e, 0xb0, 0xf4, 0xab, 0xac, 0x03, 0x46, 0x16, 0x72, 0xf7, 0x6b, 0xd6, 0x37, 0xc1, 0xc8, 0x1e,
	0x93, 0xd2, 0x2b, 0x3e, 0xe9, 0x09, 0x15, 0xd8, 0x28, 0xcf, 0x64, 0x20, 0x80, 0x82, 0x9a, 0xec,
	0xe5, 0x73, 0xb5, 0x78, 0xf9, 0x6c, 0xfd, 0x1a, 0x74, 0xca, 0x3f, 0x97, 0xa5, 0xb7, 0x2a, 0x45,
	0x7a, 0x6b, 0xc9, 0x28, 0xba, 0xfd, 0x88, 0xe5, 0xc4, 0x2e, 0x05, 0x01, 0x06, 0x02, 0xf0, 0x33,
	0xd6, 0xef, 0x56, 0xa0, 0x41, 0x51, 0x24, 0x6d, 0x2d, 0xd8, 0x28, 0x6c, 0xa7, 0xc1, 0x4d, 0x82,
	0xd0, 0x4a, 0xcb, 0xb7, 0x88, 0xd5, 0xe7, 0xdf, 0x22, 0xd6, 0x66, 0x6f, 0x11, 0x3f, 0xe7, 0xd5,
	0xfc, 0xed, 0xc7, 0xd0, 0x54, 0x8f, 0xcd, 0xd9, 0x2a, 0x74, 0x1f, 0x85, 0xc7, 0xa1, 0x7c, 0x1a,
	0x2a, 0x40, 0xff, 0x1c, 0x3b, 0x0f, 0x2b, 0x19, 0xd3, 0xf5, 0xab, 0xf6, 0x7e, 0x85, 0xf5, 0xa1,
	0x43, 0x62, 0xcd, 0x20, 0x55, 0xf6, 0x3a, 0x0c, 0xf4, 0xe6, 0x70, 0x4f, 0x86, 0x62, 0x57, 0xa6,
	0xfe, 0xe8, 0x34, 0xc3, 0xd6, 0xd8, 0x0a, 0xb4, 0xf7, 0x53, 0x19, 0xed, 0x8b, 0xd0, 0xf3, 0xc3,
	0x71, 0xbf, 0x7e, 0xfb, 0x01, 0x34, 0xd5, 0x1b, 0xf8, 0xd2, 0x27, 0x15, 0xa0, 0x7f, 0x0e, 0xa9,
	0x3f, 0x73, 0xfc, 0xd4, 0x0f, 0xc7, 0xbb, 0xe2, 0x24, 0x55, 0x4e, 0xe9, 0xa1, 0x93, 0xa4, 0xfd,
	0x2a, 0xeb, 0x01, 0xe8, 0x59, 0xef, 0x87, 0x5e, 0xbf, 0x76, 0x77, 0xfb, 0xc7, 0x3f, 0xbd, 0x56,
	0xf9, 0xc9, 0x4f, 0xaf, 0x55, 0xfe, 0xf1, 0xa7, 0xd7, 0xce, 0xfd, 0xc1, 0x3f, 0x5d, 0xab, 0xfc,
	0xe0, 0x83, 0xd2, 0x0b, 0xff, 0x89, 0x93, 0xc6, 0xfe, 0x89, 0xba, 0x3f, 0xca, 0x3a, 0xa1, 0xb8,
	0x13, 0x1d, 0x8f, 0xef, 0x44, 0x87, 0x77, 0x32, 0x9d, 0x3b, 0x6c, 0xd2, 0xc3, 0xfd, 0x0f, 0xff,
	0x2f, 0x00, 0x00, 0xff, 0xff, 0x60, 0xd7, 0x54, 0x1a, 0x37, 0x40, 0x00, 0x00,
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NeedNotReply {
		i--
		if m.NeedNotReply {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x42
	}
	if m.Id != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Analyse) > 0 {
		i -= len(m.Analyse)
		copy(dAtA[i:], m.Analyse)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Analyse)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ProcInfoData) > 0 {
		i -= len(m.ProcInfoData)
		copy(dAtA[i:], m.ProcInfoData)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.ProcInfoData)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Err) > 0 {
		i -= len(m.Err)
		copy(dAtA[i:], m.Err)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Err)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Cmd != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x10
	}
	if m.Sid != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Sid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Connector) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Connector) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Connector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ConnectorIndex != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ConnectorIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.PipelineId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PipelineId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Shuffle) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Shuffle) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Shuffle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RuntimeFilterSpec != nil {
		{
			size, err := m.RuntimeFilterSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.ShuffleRangesInt64) > 0 {
		dAtA3 := make([]byte, len(m.ShuffleRangesInt64)*10)
		var j2 int
		for _, num1 := range m.ShuffleRangesInt64 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintPipeline(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ShuffleRangesUint64) > 0 {
		dAtA5 := make([]byte, len(m.ShuffleRangesUint64)*10)
		var j4 int
		for _, num := range m.ShuffleRangesUint64 {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintPipeline(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x32
	}
	if m.AliveRegCnt != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.AliveRegCnt))
		i--
		dAtA[i] = 0x28
	}
	if m.ShuffleColMax != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ShuffleColMax))
		i--
		dAtA[i] = 0x20
	}
	if m.ShuffleColMin != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ShuffleColMin))
		i--
		dAtA[i] = 0x18
	}
	if m.ShuffleType != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ShuffleType))
		i--
		dAtA[i] = 0x10
	}
	if m.ShuffleColIdx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ShuffleColIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Dispatch) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dispatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dispatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RecCte {
		i--
		if m.RecCte {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.RecSink {
		i--
		if m.RecSink {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.IsSink {
		i--
		if m.IsSink {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.ShuffleType != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ShuffleType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ShuffleRegIdxRemote) > 0 {
		dAtA7 := make([]byte, len(m.ShuffleRegIdxRemote)*10)
		var j6 int
		for _, num1 := range m.ShuffleRegIdxRemote {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintPipeline(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ShuffleRegIdxLocal) > 0 {
		dAtA9 := make([]byte, len(m.ShuffleRegIdxLocal)*10)
		var j8 int
		for _, num1 := range m.ShuffleRegIdxLocal {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintPipeline(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RemoteConnector) > 0 {
		for iNdEx := len(m.RemoteConnector) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RemoteConnector[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.LocalConnector) > 0 {
		for iNdEx := len(m.LocalConnector) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LocalConnector[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.FuncId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.FuncId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Merge) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Merge) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Merge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EndIdx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.EndIdx))
		i--
		dAtA[i] = 0x20
	}
	if m.StartIdx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.StartIdx))
		i--
		dAtA[i] = 0x18
	}
	if m.Partial {
		i--
		if m.Partial {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.SinkScan {
		i--
		if m.SinkScan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MultiArguemnt) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiArguemnt) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiArguemnt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OrderId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.OrderId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Separator) > 0 {
		i -= len(m.Separator)
		copy(dAtA[i:], m.Separator)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Separator)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OrderByExpr) > 0 {
		for iNdEx := len(m.OrderByExpr) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OrderByExpr[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.GroupExpr) > 0 {
		for iNdEx := len(m.GroupExpr) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GroupExpr[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Dist {
		i--
		if m.Dist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Aggregate) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Aggregate) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Aggregate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Config) > 0 {
		i -= len(m.Config)
		copy(dAtA[i:], m.Config)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Config)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Expr) > 0 {
		for iNdEx := len(m.Expr) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Expr[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Dist {
		i--
		if m.Dist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Op != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Group) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Group) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Group) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PartialResultTypes) > 0 {
		dAtA11 := make([]byte, len(m.PartialResultTypes)*10)
		var j10 int
		for _, num := range m.PartialResultTypes {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintPipeline(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.PartialResults) > 0 {
		i -= len(m.PartialResults)
		copy(dAtA[i:], m.PartialResults)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.PartialResults)))
		i--
		dAtA[i] = 0x42
	}
	if m.PreAllocSize != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PreAllocSize))
		i--
		dAtA[i] = 0x38
	}
	if m.IsShuffle {
		i--
		if m.IsShuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.MultiAggs) > 0 {
		for iNdEx := len(m.MultiAggs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MultiAggs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Aggs) > 0 {
		for iNdEx := len(m.Aggs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Aggs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Exprs) > 0 {
		for iNdEx := len(m.Exprs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Exprs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.NeedEval {
		i--
		if m.NeedEval {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Insert) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Insert) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Insert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.IsEnd {
		i--
		if m.IsEnd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.PartitionIdx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PartitionIdx))
		i--
		dAtA[i] = 0x40
	}
	if len(m.PartitionTableNames) > 0 {
		for iNdEx := len(m.PartitionTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionTableNames[iNdEx])
			copy(dAtA[i:], m.PartitionTableNames[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.PartitionTableNames[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.PartitionTableIds) > 0 {
		dAtA14 := make([]byte, len(m.PartitionTableIds)*10)
		var j13 int
		for _, num := range m.PartitionTableIds {
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintPipeline(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Attrs) > 0 {
		for iNdEx := len(m.Attrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Attrs[iNdEx])
			copy(dAtA[i:], m.Attrs[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.Attrs[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Ref != nil {
		{
			size, err := m.Ref.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.AddAffectedRows {
		i--
		if m.AddAffectedRows {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ToWriteS3 {
		i--
		if m.ToWriteS3 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Affected != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Affected))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MultiUpdate) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpdateCtx) > 0 {
		for iNdEx := len(m.UpdateCtx) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UpdateCtx[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.SegmentMap) > 0 {
		for k := range m.SegmentMap {
			v := m.SegmentMap[k]
			baseI := i
			i = encodeVarintPipeline(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPipeline(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPipeline(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.NBucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.NBucket))
		i--
		dAtA[i] = 0x20
	}
	if m.IBucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.IBucket))
		i--
		dAtA[i] = 0x18
	}
	if m.ToWriteS3 {
		i--
		if m.ToWriteS3 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.AffectedRows != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.AffectedRows))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Array) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Array) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Array) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Array) > 0 {
		dAtA17 := make([]byte, len(m.Array)*10)
		var j16 int
		for _, num1 := range m.Array {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		i -= j16
		copy(dAtA[i:], dAtA17[:j16])
		i = encodeVarintPipeline(dAtA, i, uint64(j16))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Map) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Map) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Map) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Mp) > 0 {
		for k := range m.Mp {
			v := m.Mp[k]
			baseI := i
			i = encodeVarintPipeline(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPipeline(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPipeline(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Deletion) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deletion) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Deletion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PrimaryKeyIdx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PrimaryKeyIdx))
		i--
		dAtA[i] = 0x70
	}
	if m.IsEnd {
		i--
		if m.IsEnd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.CanTruncate {
		i--
		if m.CanTruncate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if len(m.SegmentMap) > 0 {
		for k := range m.SegmentMap {
			v := m.SegmentMap[k]
			baseI := i
			i = encodeVarintPipeline(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPipeline(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPipeline(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.AddAffectedRows {
		i--
		if m.AddAffectedRows {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Ref != nil {
		{
			size, err := m.Ref.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.PartitionIndexInBatch != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PartitionIndexInBatch))
		i--
		dAtA[i] = 0x40
	}
	if len(m.PartitionTableNames) > 0 {
		for iNdEx := len(m.PartitionTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionTableNames[iNdEx])
			copy(dAtA[i:], m.PartitionTableNames[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.PartitionTableNames[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.PartitionTableIds) > 0 {
		dAtA20 := make([]byte, len(m.PartitionTableIds)*10)
		var j19 int
		for _, num := range m.PartitionTableIds {
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		i -= j19
		copy(dAtA[i:], dAtA20[:j19])
		i = encodeVarintPipeline(dAtA, i, uint64(j19))
		i--
		dAtA[i] = 0x32
	}
	if m.RowIdIdx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.RowIdIdx))
		i--
		dAtA[i] = 0x28
	}
	if m.NBucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.NBucket))
		i--
		dAtA[i] = 0x20
	}
	if m.IBucket != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.IBucket))
		i--
		dAtA[i] = 0x18
	}
	if m.RemoteDelete {
		i--
		if m.RemoteDelete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.AffectedRows != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.AffectedRows))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PreInsert) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreInsert) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PreInsert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ClusterByExpr != nil {
		{
			size, err := m.ClusterByExpr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.CompPkeyExpr != nil {
		{
			size, err := m.CompPkeyExpr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.EstimatedRowCount != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.EstimatedRowCount))
		i--
		dAtA[i] = 0x38
	}
	if m.IsUpdate {
		i--
		if m.IsUpdate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.HasAutoCol {
		i--
		if m.HasAutoCol {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Attrs) > 0 {
		for iNdEx := len(m.Attrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Attrs[iNdEx])
			copy(dAtA[i:], m.Attrs[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.Attrs[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Idx) > 0 {
		dAtA24 := make([]byte, len(m.Idx)*10)
		var j23 int
		for _, num1 := range m.Idx {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA24[j23] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j23++
			}
			dAtA24[j23] = uint8(num)
			j23++
		}
		i -= j23
		copy(dAtA[i:], dAtA24[:j23])
		i = encodeVarintPipeline(dAtA, i, uint64(j23))
		i--
		dAtA[i] = 0x1a
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.SchemaName) > 0 {
		i -= len(m.SchemaName)
		copy(dAtA[i:], m.SchemaName)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.SchemaName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LockTarget) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mode != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x40
	}
	if m.ChangeDef {
		i--
		if m.ChangeDef {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.LockTable {
		i--
		if m.LockTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.FilterColIdxInBat != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.FilterColIdxInBat))
		i--
		dAtA[i] = 0x28
	}
	if m.RefreshTsIdxInBat != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.RefreshTsIdxInBat))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.PrimaryColTyp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPipeline(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.PrimaryColIdxInBat != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PrimaryColIdxInBat))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LockOp) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Block {
		i--
		if m.Block {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Targets) > 0 {
		for iNdEx := len(m.Targets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Targets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PreInsertUnique) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreInsertUnique) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PreInsertUnique) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PreInsertUkCtx != nil {
		{
			size, err := m.PreInsertUkCtx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PreInsertSecondaryIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreInsertSecondaryIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PreInsertSecondaryIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PreInsertSkCtx != nil {
		{
			size, err := m.PreInsertSkCtx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OnDuplicateKey) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnDuplicateKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OnDuplicateKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsIgnore {
		i--
		if m.IsIgnore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.OnDuplicateExpr) > 0 {
		for k := range m.OnDuplicateExpr {
			v := m.OnDuplicateExpr[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPipeline(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPipeline(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPipeline(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.OnDuplicateIdx) > 0 {
		dAtA31 := make([]byte, len(m.OnDuplicateIdx)*10)
		var j30 int
		for _, num1 := range m.OnDuplicateIdx {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA31[j30] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j30++
			}
			dAtA31[j30] = uint8(num)
			j30++
		}
		i -= j30
		copy(dAtA[i:], dAtA31[:j30])
		i = encodeVarintPipeline(dAtA, i, uint64(j30))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.UniqueCols) > 0 {
		for iNdEx := len(m.UniqueCols) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UniqueCols[iNdEx])
			copy(dAtA[i:], m.UniqueCols[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.UniqueCols[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.UniqueColCheckExpr) > 0 {
		for iNdEx := len(m.UniqueColCheckExpr) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UniqueColCheckExpr[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.InsertColCount != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.InsertColCount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Attrs) > 0 {
		for iNdEx := len(m.Attrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Attrs[iNdEx])
			copy(dAtA[i:], m.Attrs[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.Attrs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FuzzyFilter) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FuzzyFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FuzzyFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IfInsertFromUnique {
		i--
		if m.IfInsertFromUnique {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.BuildIdx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.BuildIdx))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.PkTyp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPipeline(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.PkName) > 0 {
		i -= len(m.PkName)
		copy(dAtA[i:], m.PkName)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.PkName)))
		i--
		dAtA[i] = 0x12
	}
	if m.N != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.N))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *Join) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Join) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Join) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.JoinType != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.JoinType))
		i--
		dAtA[i] = 0x60
	}
	if m.ShuffleIdx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ShuffleIdx))
		i--
		dAtA[i] = 0x58
	}
	if m.JoinMapTag != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.JoinMapTag))
		i--
		dAtA[i] = 0x50
	}
	if m.IsShuffle {
		i--
		if m.IsShuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.HashOnPk {
		i--
		if m.HashOnPk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for iNdEx := len(m.RuntimeFilterBuildList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterBuildList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ColList) > 0 {
		dAtA35 := make([]byte, len(m.ColList)*10)
		var j34 int
		for _, num1 := range m.ColList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA35[j34] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j34++
			}
			dAtA35[j34] = uint8(num)
			j34++
		}
		i -= j34
		copy(dAtA[i:], dAtA35[:j34])
		i = encodeVarintPipeline(dAtA, i, uint64(j34))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RelList) > 0 {
		dAtA37 := make([]byte, len(m.RelList)*10)
		var j36 int
		for _, num1 := range m.RelList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA37[j36] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j36++
			}
			dAtA37[j36] = uint8(num)
			j36++
		}
		i -= j36
		copy(dAtA[i:], dAtA37[:j36])
		i = encodeVarintPipeline(dAtA, i, uint64(j36))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AntiJoin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AntiJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AntiJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ShuffleIdx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ShuffleIdx))
		i--
		dAtA[i] = 0x48
	}
	if m.JoinMapTag != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.JoinMapTag))
		i--
		dAtA[i] = 0x40
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for iNdEx := len(m.RuntimeFilterBuildList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterBuildList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.IsShuffle {
		i--
		if m.IsShuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.HashOnPk {
		i--
		if m.HashOnPk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Result) > 0 {
		dAtA40 := make([]byte, len(m.Result)*10)
		var j39 int
		for _, num1 := range m.Result {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA40[j39] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j39++
			}
			dAtA40[j39] = uint8(num)
			j39++
		}
		i -= j39
		copy(dAtA[i:], dAtA40[:j39])
		i = encodeVarintPipeline(dAtA, i, uint64(j39))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LeftJoin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeftJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeftJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ShuffleIdx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ShuffleIdx))
		i--
		dAtA[i] = 0x58
	}
	if m.JoinMapTag != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.JoinMapTag))
		i--
		dAtA[i] = 0x50
	}
	if m.IsShuffle {
		i--
		if m.IsShuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.HashOnPk {
		i--
		if m.HashOnPk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for iNdEx := len(m.RuntimeFilterBuildList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterBuildList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ColList) > 0 {
		dAtA43 := make([]byte, len(m.ColList)*10)
		var j42 int
		for _, num1 := range m.ColList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA43[j42] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j42++
			}
			dAtA43[j42] = uint8(num)
			j42++
		}
		i -= j42
		copy(dAtA[i:], dAtA43[:j42])
		i = encodeVarintPipeline(dAtA, i, uint64(j42))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RelList) > 0 {
		dAtA45 := make([]byte, len(m.RelList)*10)
		var j44 int
		for _, num1 := range m.RelList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA45[j44] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j44++
			}
			dAtA45[j44] = uint8(num)
			j44++
		}
		i -= j44
		copy(dAtA[i:], dAtA45[:j44])
		i = encodeVarintPipeline(dAtA, i, uint64(j44))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RightJoin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RightJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RightJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ShuffleIdx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ShuffleIdx))
		i--
		dAtA[i] = 0x60
	}
	if m.JoinMapTag != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.JoinMapTag))
		i--
		dAtA[i] = 0x58
	}
	if m.IsShuffle {
		i--
		if m.IsShuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.HashOnPk {
		i--
		if m.HashOnPk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for iNdEx := len(m.RuntimeFilterBuildList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterBuildList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.RightTypes) > 0 {
		for iNdEx := len(m.RightTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.LeftTypes) > 0 {
		for iNdEx := len(m.LeftTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ColList) > 0 {
		dAtA48 := make([]byte, len(m.ColList)*10)
		var j47 int
		for _, num1 := range m.ColList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA48[j47] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j47++
			}
			dAtA48[j47] = uint8(num)
			j47++
		}
		i -= j47
		copy(dAtA[i:], dAtA48[:j47])
		i = encodeVarintPipeline(dAtA, i, uint64(j47))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RelList) > 0 {
		dAtA50 := make([]byte, len(m.RelList)*10)
		var j49 int
		for _, num1 := range m.RelList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA50[j49] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j49++
			}
			dAtA50[j49] = uint8(num)
			j49++
		}
		i -= j49
		copy(dAtA[i:], dAtA50[:j49])
		i = encodeVarintPipeline(dAtA, i, uint64(j49))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RightSemiJoin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RightSemiJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RightSemiJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ShuffleIdx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ShuffleIdx))
		i--
		dAtA[i] = 0x58
	}
	if m.JoinMapTag != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.JoinMapTag))
		i--
		dAtA[i] = 0x48
	}
	if m.IsShuffle {
		i--
		if m.IsShuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.HashOnPk {
		i--
		if m.HashOnPk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for iNdEx := len(m.RuntimeFilterBuildList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterBuildList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.RightTypes) > 0 {
		for iNdEx := len(m.RightTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Result) > 0 {
		dAtA53 := make([]byte, len(m.Result)*10)
		var j52 int
		for _, num1 := range m.Result {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA53[j52] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j52++
			}
			dAtA53[j52] = uint8(num)
			j52++
		}
		i -= j52
		copy(dAtA[i:], dAtA53[:j52])
		i = encodeVarintPipeline(dAtA, i, uint64(j52))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RightAntiJoin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RightAntiJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RightAntiJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ShuffleIdx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ShuffleIdx))
		i--
		dAtA[i] = 0x50
	}
	if m.JoinMapTag != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.JoinMapTag))
		i--
		dAtA[i] = 0x48
	}
	if m.IsShuffle {
		i--
		if m.IsShuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.HashOnPk {
		i--
		if m.HashOnPk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for iNdEx := len(m.RuntimeFilterBuildList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterBuildList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.RightTypes) > 0 {
		for iNdEx := len(m.RightTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Result) > 0 {
		dAtA56 := make([]byte, len(m.Result)*10)
		var j55 int
		for _, num1 := range m.Result {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA56[j55] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j55++
			}
			dAtA56[j55] = uint8(num)
			j55++
		}
		i -= j55
		copy(dAtA[i:], dAtA56[:j55])
		i = encodeVarintPipeline(dAtA, i, uint64(j55))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SemiJoin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SemiJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SemiJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ShuffleIdx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ShuffleIdx))
		i--
		dAtA[i] = 0x48
	}
	if m.JoinMapTag != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.JoinMapTag))
		i--
		dAtA[i] = 0x40
	}
	if m.IsShuffle {
		i--
		if m.IsShuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.HashOnPk {
		i--
		if m.HashOnPk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for iNdEx := len(m.RuntimeFilterBuildList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterBuildList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Result) > 0 {
		dAtA59 := make([]byte, len(m.Result)*10)
		var j58 int
		for _, num1 := range m.Result {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA59[j58] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j58++
			}
			dAtA59[j58] = uint8(num)
			j58++
		}
		i -= j58
		copy(dAtA[i:], dAtA59[:j58])
		i = encodeVarintPipeline(dAtA, i, uint64(j58))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SingleJoin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SingleJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SingleJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ShuffleIdx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ShuffleIdx))
		i--
		dAtA[i] = 0x58
	}
	if m.JoinMapTag != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.JoinMapTag))
		i--
		dAtA[i] = 0x50
	}
	if m.IsShuffle {
		i--
		if m.IsShuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.HashOnPk {
		i--
		if m.HashOnPk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for iNdEx := len(m.RuntimeFilterBuildList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterBuildList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ColList) > 0 {
		dAtA62 := make([]byte, len(m.ColList)*10)
		var j61 int
		for _, num1 := range m.ColList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA62[j61] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j61++
			}
			dAtA62[j61] = uint8(num)
			j61++
		}
		i -= j61
		copy(dAtA[i:], dAtA62[:j61])
		i = encodeVarintPipeline(dAtA, i, uint64(j61))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RelList) > 0 {
		dAtA64 := make([]byte, len(m.RelList)*10)
		var j63 int
		for _, num1 := range m.RelList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA64[j63] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j63++
			}
			dAtA64[j63] = uint8(num)
			j63++
		}
		i -= j63
		copy(dAtA[i:], dAtA64[:j63])
		i = encodeVarintPipeline(dAtA, i, uint64(j63))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarkJoin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarkJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ShuffleIdx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ShuffleIdx))
		i--
		dAtA[i] = 0x48
	}
	if m.JoinMapTag != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.JoinMapTag))
		i--
		dAtA[i] = 0x40
	}
	if m.IsShuffle {
		i--
		if m.IsShuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.HashOnPk {
		i--
		if m.HashOnPk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.OnList) > 0 {
		for iNdEx := len(m.OnList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OnList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.RightCond) > 0 {
		for iNdEx := len(m.RightCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RightCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.LeftCond) > 0 {
		for iNdEx := len(m.LeftCond) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LeftCond[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Result) > 0 {
		dAtA67 := make([]byte, len(m.Result)*10)
		var j66 int
		for _, num1 := range m.Result {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA67[j66] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j66++
			}
			dAtA67[j66] = uint8(num)
			j66++
		}
		i -= j66
		copy(dAtA[i:], dAtA67[:j66])
		i = encodeVarintPipeline(dAtA, i, uint64(j66))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Product) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Product) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Product) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.JoinMapTag != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.JoinMapTag))
		i--
		dAtA[i] = 0x20
	}
	if m.IsShuffle {
		i--
		if m.IsShuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ColList) > 0 {
		dAtA69 := make([]byte, len(m.ColList)*10)
		var j68 int
		for _, num1 := range m.ColList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA69[j68] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j68++
			}
			dAtA69[j68] = uint8(num)
			j68++
		}
		i -= j68
		copy(dAtA[i:], dAtA69[:j68])
		i = encodeVarintPipeline(dAtA, i, uint64(j68))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RelList) > 0 {
		dAtA71 := make([]byte, len(m.RelList)*10)
		var j70 int
		for _, num1 := range m.RelList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA71[j70] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j70++
			}
			dAtA71[j70] = uint8(num)
			j70++
		}
		i -= j70
		copy(dAtA[i:], dAtA71[:j70])
		i = encodeVarintPipeline(dAtA, i, uint64(j70))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProductL2) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductL2) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProductL2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.JoinMapTag != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.JoinMapTag))
		i--
		dAtA[i] = 0x20
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ColList) > 0 {
		dAtA74 := make([]byte, len(m.ColList)*10)
		var j73 int
		for _, num1 := range m.ColList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA74[j73] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j73++
			}
			dAtA74[j73] = uint8(num)
			j73++
		}
		i -= j73
		copy(dAtA[i:], dAtA74[:j73])
		i = encodeVarintPipeline(dAtA, i, uint64(j73))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RelList) > 0 {
		dAtA76 := make([]byte, len(m.RelList)*10)
		var j75 int
		for _, num1 := range m.RelList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA76[j75] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j75++
			}
			dAtA76[j75] = uint8(num)
			j75++
		}
		i -= j75
		copy(dAtA[i:], dAtA76[:j75])
		i = encodeVarintPipeline(dAtA, i, uint64(j75))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IndexJoin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for iNdEx := len(m.RuntimeFilterBuildList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterBuildList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Result) > 0 {
		dAtA78 := make([]byte, len(m.Result)*10)
		var j77 int
		for _, num1 := range m.Result {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA78[j77] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j77++
			}
			dAtA78[j77] = uint8(num)
			j77++
		}
		i -= j77
		copy(dAtA[i:], dAtA78[:j77])
		i = encodeVarintPipeline(dAtA, i, uint64(j77))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableFunction) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableFunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableFunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Params) > 0 {
		i -= len(m.Params)
		copy(dAtA[i:], m.Params)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Params)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Args[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Rets) > 0 {
		for iNdEx := len(m.Rets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Attrs) > 0 {
		for iNdEx := len(m.Attrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Attrs[iNdEx])
			copy(dAtA[i:], m.Attrs[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.Attrs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ExternalName2ColIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalName2ColIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalName2ColIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Index != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileOffset) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileOffset) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileOffset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Offset) > 0 {
		dAtA80 := make([]byte, len(m.Offset)*10)
		var j79 int
		for _, num1 := range m.Offset {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA80[j79] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j79++
			}
			dAtA80[j79] = uint8(num)
			j79++
		}
		i -= j79
		copy(dAtA[i:], dAtA80[:j79])
		i = encodeVarintPipeline(dAtA, i, uint64(j79))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExternalScan) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalScan) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalScan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StrictSqlMode {
		i--
		if m.StrictSqlMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.TbColToDataCol) > 0 {
		for k := range m.TbColToDataCol {
			v := m.TbColToDataCol[k]
			baseI := i
			i = encodeVarintPipeline(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPipeline(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPipeline(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.OriginCols) > 0 {
		for iNdEx := len(m.OriginCols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OriginCols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.FileList) > 0 {
		for iNdEx := len(m.FileList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FileList[iNdEx])
			copy(dAtA[i:], m.FileList[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.FileList[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.CreateSql) > 0 {
		i -= len(m.CreateSql)
		copy(dAtA[i:], m.CreateSql)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.CreateSql)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Name2ColIndex) > 0 {
		for iNdEx := len(m.Name2ColIndex) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Name2ColIndex[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Cols) > 0 {
		for iNdEx := len(m.Cols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.FileOffsetTotal) > 0 {
		for iNdEx := len(m.FileOffsetTotal) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FileOffsetTotal[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.FileSize) > 0 {
		dAtA83 := make([]byte, len(m.FileSize)*10)
		var j82 int
		for _, num1 := range m.FileSize {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA83[j82] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j82++
			}
			dAtA83[j82] = uint8(num)
			j82++
		}
		i -= j82
		copy(dAtA[i:], dAtA83[:j82])
		i = encodeVarintPipeline(dAtA, i, uint64(j82))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Attrs) > 0 {
		for iNdEx := len(m.Attrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Attrs[iNdEx])
			copy(dAtA[i:], m.Attrs[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.Attrs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StreamScan) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamScan) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamScan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if m.Offset != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x10
	}
	if m.TblDef != nil {
		{
			size, err := m.TblDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableScan) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableScan) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableScan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ValueScan) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValueScan) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValueScan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.BatchBlock) > 0 {
		i -= len(m.BatchBlock)
		copy(dAtA[i:], m.BatchBlock)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.BatchBlock)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnionAll) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnionAll) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnionAll) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *HashBuild) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HashBuild) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HashBuild) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RuntimeFilterSpec != nil {
		{
			size, err := m.RuntimeFilterSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.JoinMapRefCnt != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.JoinMapRefCnt))
		i--
		dAtA[i] = 0x38
	}
	if m.JoinMapTag != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.JoinMapTag))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.NeedAllocateSels {
		i--
		if m.NeedAllocateSels {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.NeedBatches {
		i--
		if m.NeedBatches {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.HashOnPK {
		i--
		if m.HashOnPK {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.NeedHashMap {
		i--
		if m.NeedHashMap {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Shufflebuild) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Shufflebuild) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Shufflebuild) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ShuffleIdx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ShuffleIdx))
		i--
		dAtA[i] = 0x38
	}
	if m.JoinMapTag != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.JoinMapTag))
		i--
		dAtA[i] = 0x30
	}
	if m.RuntimeFilterSpec != nil {
		{
			size, err := m.RuntimeFilterSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.NeedAllocateSels {
		i--
		if m.NeedAllocateSels {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.NeedBatches {
		i--
		if m.NeedBatches {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.HashOnPK {
		i--
		if m.HashOnPK {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Indexbuild) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Indexbuild) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Indexbuild) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RuntimeFilterSpec != nil {
		{
			size, err := m.RuntimeFilterSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SampleFunc) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SampleFunc) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SampleFunc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SampleColumns) > 0 {
		for iNdEx := len(m.SampleColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SampleColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.SamplePercent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SamplePercent))))
		i--
		dAtA[i] = 0x19
	}
	if m.SampleRows != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.SampleRows))
		i--
		dAtA[i] = 0x10
	}
	if m.SampleType != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.SampleType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Instruction) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Instruction) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Instruction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Apply != nil {
		{
			size, err := m.Apply.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	if m.IndexBuild != nil {
		{
			size, err := m.IndexBuild.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if m.ShuffleBuild != nil {
		{
			size, err := m.ShuffleBuild.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x8a
	}
	if m.HashBuild != nil {
		{
			size, err := m.HashBuild.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x82
	}
	if m.UnionAll != nil {
		{
			size, err := m.UnionAll.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xfa
	}
	if m.ValueScan != nil {
		{
			size, err := m.ValueScan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf2
	}
	if m.TableScan != nil {
		{
			size, err := m.TableScan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	if m.ProductL2 != nil {
		{
			size, err := m.ProductL2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	if m.IndexJoin != nil {
		{
			size, err := m.IndexJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	if m.MaxParallel != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.MaxParallel))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.ParallelId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ParallelId))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.OperatorId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.OperatorId))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if len(m.CnAddr) > 0 {
		i -= len(m.CnAddr)
		copy(dAtA[i:], m.CnAddr)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.CnAddr)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if m.FuzzyFilter != nil {
		{
			size, err := m.FuzzyFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	if m.SampleFunc != nil {
		{
			size, err := m.SampleFunc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	if m.PreInsertSecondaryIndex != nil {
		{
			size, err := m.PreInsertSecondaryIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if m.StreamScan != nil {
		{
			size, err := m.StreamScan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.Merge != nil {
		{
			size, err := m.Merge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if m.Shuffle != nil {
		{
			size, err := m.Shuffle.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if m.LockOp != nil {
		{
			size, err := m.LockOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if m.Delete != nil {
		{
			size, err := m.Delete.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.RightAntiJoin != nil {
		{
			size, err := m.RightAntiJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.RightSemiJoin != nil {
		{
			size, err := m.RightSemiJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if m.RightJoin != nil {
		{
			size, err := m.RightJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.IsLast {
		i--
		if m.IsLast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.IsFirst {
		i--
		if m.IsFirst {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.Offset != nil {
		{
			size, err := m.Offset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.Limit != nil {
		{
			size, err := m.Limit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.ProjectList) > 0 {
		for iNdEx := len(m.ProjectList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProjectList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.OrderBy) > 0 {
		for iNdEx := len(m.OrderBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OrderBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if m.PreInsertUnique != nil {
		{
			size, err := m.PreInsertUnique.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.PreInsert != nil {
		{
			size, err := m.PreInsert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.OnDuplicateKey != nil {
		{
			size, err := m.OnDuplicateKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.Insert != nil {
		{
			size, err := m.Insert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.ExternalScan != nil {
		{
			size, err := m.ExternalScan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.TableFunction != nil {
		{
			size, err := m.TableFunction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Product != nil {
		{
			size, err := m.Product.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Join != nil {
		{
			size, err := m.Join.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.MarkJoin != nil {
		{
			size, err := m.MarkJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.SingleJoin != nil {
		{
			size, err := m.SingleJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.SemiJoin != nil {
		{
			size, err := m.SemiJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.LeftJoin != nil {
		{
			size, err := m.LeftJoin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Agg != nil {
		{
			size, err := m.Agg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Dispatch != nil {
		{
			size, err := m.Dispatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Connect != nil {
		{
			size, err := m.Connect.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Anti != nil {
		{
			size, err := m.Anti.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Idx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Idx))
		i--
		dAtA[i] = 0x10
	}
	if m.Op != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AnalysisList) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalysisList) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnalysisList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Source) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Source) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Source) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsConst {
		i--
		if m.IsConst {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.RuntimeFilterProbeList) > 0 {
		for iNdEx := len(m.RuntimeFilterProbeList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterProbeList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PushdownAddr) > 0 {
		i -= len(m.PushdownAddr)
		copy(dAtA[i:], m.PushdownAddr)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.PushdownAddr)))
		i--
		dAtA[i] = 0x32
	}
	if m.PushdownId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PushdownId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Block) > 0 {
		i -= len(m.Block)
		copy(dAtA[i:], m.Block)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Block)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ColList) > 0 {
		for iNdEx := len(m.ColList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ColList[iNdEx])
			copy(dAtA[i:], m.ColList[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.ColList[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SchemaName) > 0 {
		i -= len(m.SchemaName)
		copy(dAtA[i:], m.SchemaName)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.SchemaName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if m.Mcpu != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Mcpu))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProcessLimitation) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessLimitation) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessLimitation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReaderSize != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ReaderSize))
		i--
		dAtA[i] = 0x28
	}
	if m.PartitionRows != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PartitionRows))
		i--
		dAtA[i] = 0x20
	}
	if m.BatchSize != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.BatchSize))
		i--
		dAtA[i] = 0x18
	}
	if m.BatchRows != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.BatchRows))
		i--
		dAtA[i] = 0x10
	}
	if m.Size != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Size))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PrepareParamInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepareParamInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepareParamInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Nulls) > 0 {
		for iNdEx := len(m.Nulls) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.Nulls[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Nulls)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Area) > 0 {
		i -= len(m.Area)
		copy(dAtA[i:], m.Area)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Area)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Length != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProcessInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.PrepareParams.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPipeline(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.SessionLogger.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPipeline(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.SessionInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPipeline(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.Snapshot.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPipeline(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.AccountId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.AccountId))
		i--
		dAtA[i] = 0x28
	}
	if m.UnixTime != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.UnixTime))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Lim.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPipeline(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Sql) > 0 {
		i -= len(m.Sql)
		copy(dAtA[i:], m.Sql)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Sql)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SessionInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.QueryId) > 0 {
		for iNdEx := len(m.QueryId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.QueryId[iNdEx])
			copy(dAtA[i:], m.QueryId[iNdEx])
			i = encodeVarintPipeline(dAtA, i, uint64(len(m.QueryId[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.TimeZone) > 0 {
		i -= len(m.TimeZone)
		copy(dAtA[i:], m.TimeZone)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.TimeZone)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ConnectionId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ConnectionId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SessionLoggerInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionLoggerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionLoggerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LogLevel != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.LogLevel))
		i--
		dAtA[i] = 0x20
	}
	if len(m.TxnId) > 0 {
		i -= len(m.TxnId)
		copy(dAtA[i:], m.TxnId)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.TxnId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StmtId) > 0 {
		i -= len(m.StmtId)
		copy(dAtA[i:], m.StmtId)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.StmtId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SessId) > 0 {
		i -= len(m.SessId)
		copy(dAtA[i:], m.SessId)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.SessId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Pipeline) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pipeline) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pipeline) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UuidsToRegIdx) > 0 {
		for iNdEx := len(m.UuidsToRegIdx) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UuidsToRegIdx[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.NilBatchCnt) > 0 {
		dAtA136 := make([]byte, len(m.NilBatchCnt)*10)
		var j135 int
		for _, num1 := range m.NilBatchCnt {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA136[j135] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j135++
			}
			dAtA136[j135] = uint8(num)
			j135++
		}
		i -= j135
		copy(dAtA[i:], dAtA136[:j135])
		i = encodeVarintPipeline(dAtA, i, uint64(j135))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.ChannelBufferSize) > 0 {
		dAtA138 := make([]byte, len(m.ChannelBufferSize)*10)
		var j137 int
		for _, num1 := range m.ChannelBufferSize {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA138[j137] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j137++
			}
			dAtA138[j137] = uint8(num)
			j137++
		}
		i -= j137
		copy(dAtA[i:], dAtA138[:j137])
		i = encodeVarintPipeline(dAtA, i, uint64(j137))
		i--
		dAtA[i] = 0x62
	}
	if m.ChildrenCount != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ChildrenCount))
		i--
		dAtA[i] = 0x58
	}
	if m.PushDownInfo != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PushDownInfo))
		i--
		dAtA[i] = 0x50
	}
	if m.Node != nil {
		{
			size, err := m.Node.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.IsLoad {
		i--
		if m.IsLoad {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.IsEnd {
		i--
		if m.IsEnd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.InstructionList) > 0 {
		for iNdEx := len(m.InstructionList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InstructionList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.DataSource != nil {
		{
			size, err := m.DataSource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Qry != nil {
		{
			size, err := m.Qry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PipelineId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PipelineId))
		i--
		dAtA[i] = 0x10
	}
	if m.PipelineType != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.PipelineType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WrapNode) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WrapNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WrapNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeAddr) > 0 {
		i -= len(m.NodeAddr)
		copy(dAtA[i:], m.NodeAddr)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.NodeAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UuidToRegIdx) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UuidToRegIdx) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UuidToRegIdx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FromAddr) > 0 {
		i -= len(m.FromAddr)
		copy(dAtA[i:], m.FromAddr)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.FromAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x12
	}
	if m.Idx != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Idx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Apply) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Apply) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Apply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Types[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPipeline(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ColList) > 0 {
		dAtA143 := make([]byte, len(m.ColList)*10)
		var j142 int
		for _, num1 := range m.ColList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA143[j142] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j142++
			}
			dAtA143[j142] = uint8(num)
			j142++
		}
		i -= j142
		copy(dAtA[i:], dAtA143[:j142])
		i = encodeVarintPipeline(dAtA, i, uint64(j142))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RelList) > 0 {
		dAtA145 := make([]byte, len(m.RelList)*10)
		var j144 int
		for _, num1 := range m.RelList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA145[j144] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j144++
			}
			dAtA145[j144] = uint8(num)
			j144++
		}
		i -= j144
		copy(dAtA[i:], dAtA145[:j144])
		i = encodeVarintPipeline(dAtA, i, uint64(j144))
		i--
		dAtA[i] = 0x12
	}
	if m.ApplyType != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.ApplyType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintPipeline(dAtA []byte, offset int, v uint64) int {
	offset -= sovPipeline(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Message) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sid != 0 {
		n += 1 + sovPipeline(uint64(m.Sid))
	}
	if m.Cmd != 0 {
		n += 1 + sovPipeline(uint64(m.Cmd))
	}
	l = len(m.Err)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.ProcInfoData)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Analyse)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovPipeline(uint64(m.Id))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.NeedNotReply {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Connector) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PipelineId != 0 {
		n += 1 + sovPipeline(uint64(m.PipelineId))
	}
	if m.ConnectorIndex != 0 {
		n += 1 + sovPipeline(uint64(m.ConnectorIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Shuffle) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShuffleColIdx != 0 {
		n += 1 + sovPipeline(uint64(m.ShuffleColIdx))
	}
	if m.ShuffleType != 0 {
		n += 1 + sovPipeline(uint64(m.ShuffleType))
	}
	if m.ShuffleColMin != 0 {
		n += 1 + sovPipeline(uint64(m.ShuffleColMin))
	}
	if m.ShuffleColMax != 0 {
		n += 1 + sovPipeline(uint64(m.ShuffleColMax))
	}
	if m.AliveRegCnt != 0 {
		n += 1 + sovPipeline(uint64(m.AliveRegCnt))
	}
	if len(m.ShuffleRangesUint64) > 0 {
		l = 0
		for _, e := range m.ShuffleRangesUint64 {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.ShuffleRangesInt64) > 0 {
		l = 0
		for _, e := range m.ShuffleRangesInt64 {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.RuntimeFilterSpec != nil {
		l = m.RuntimeFilterSpec.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Dispatch) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FuncId != 0 {
		n += 1 + sovPipeline(uint64(m.FuncId))
	}
	if len(m.LocalConnector) > 0 {
		for _, e := range m.LocalConnector {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RemoteConnector) > 0 {
		for _, e := range m.RemoteConnector {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.ShuffleRegIdxLocal) > 0 {
		l = 0
		for _, e := range m.ShuffleRegIdxLocal {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.ShuffleRegIdxRemote) > 0 {
		l = 0
		for _, e := range m.ShuffleRegIdxRemote {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.ShuffleType != 0 {
		n += 1 + sovPipeline(uint64(m.ShuffleType))
	}
	if m.IsSink {
		n += 2
	}
	if m.RecSink {
		n += 2
	}
	if m.RecCte {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Merge) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SinkScan {
		n += 2
	}
	if m.Partial {
		n += 2
	}
	if m.StartIdx != 0 {
		n += 1 + sovPipeline(uint64(m.StartIdx))
	}
	if m.EndIdx != 0 {
		n += 1 + sovPipeline(uint64(m.EndIdx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MultiArguemnt) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dist {
		n += 2
	}
	if len(m.GroupExpr) > 0 {
		for _, e := range m.GroupExpr {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.OrderByExpr) > 0 {
		for _, e := range m.OrderByExpr {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	l = len(m.Separator)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.OrderId != 0 {
		n += 1 + sovPipeline(uint64(m.OrderId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Aggregate) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovPipeline(uint64(m.Op))
	}
	if m.Dist {
		n += 2
	}
	if len(m.Expr) > 0 {
		for _, e := range m.Expr {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	l = len(m.Config)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Group) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NeedEval {
		n += 2
	}
	if len(m.Exprs) > 0 {
		for _, e := range m.Exprs {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.Aggs) > 0 {
		for _, e := range m.Aggs {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.MultiAggs) > 0 {
		for _, e := range m.MultiAggs {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.IsShuffle {
		n += 2
	}
	if m.PreAllocSize != 0 {
		n += 1 + sovPipeline(uint64(m.PreAllocSize))
	}
	l = len(m.PartialResults)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.PartialResultTypes) > 0 {
		l = 0
		for _, e := range m.PartialResultTypes {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Insert) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Affected != 0 {
		n += 1 + sovPipeline(uint64(m.Affected))
	}
	if m.ToWriteS3 {
		n += 2
	}
	if m.AddAffectedRows {
		n += 2
	}
	if m.Ref != nil {
		l = m.Ref.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Attrs) > 0 {
		for _, s := range m.Attrs {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.PartitionTableIds) > 0 {
		l = 0
		for _, e := range m.PartitionTableIds {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.PartitionTableNames) > 0 {
		for _, s := range m.PartitionTableNames {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.PartitionIdx != 0 {
		n += 1 + sovPipeline(uint64(m.PartitionIdx))
	}
	if m.IsEnd {
		n += 2
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MultiUpdate) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AffectedRows != 0 {
		n += 1 + sovPipeline(uint64(m.AffectedRows))
	}
	if m.ToWriteS3 {
		n += 2
	}
	if m.IBucket != 0 {
		n += 1 + sovPipeline(uint64(m.IBucket))
	}
	if m.NBucket != 0 {
		n += 1 + sovPipeline(uint64(m.NBucket))
	}
	if len(m.SegmentMap) > 0 {
		for k, v := range m.SegmentMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPipeline(uint64(len(k))) + 1 + sovPipeline(uint64(v))
			n += mapEntrySize + 1 + sovPipeline(uint64(mapEntrySize))
		}
	}
	if len(m.UpdateCtx) > 0 {
		for _, e := range m.UpdateCtx {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Array) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Array) > 0 {
		l = 0
		for _, e := range m.Array {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Map) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Mp) > 0 {
		for k, v := range m.Mp {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPipeline(uint64(len(k))) + 1 + sovPipeline(uint64(v))
			n += mapEntrySize + 1 + sovPipeline(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Deletion) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AffectedRows != 0 {
		n += 1 + sovPipeline(uint64(m.AffectedRows))
	}
	if m.RemoteDelete {
		n += 2
	}
	if m.IBucket != 0 {
		n += 1 + sovPipeline(uint64(m.IBucket))
	}
	if m.NBucket != 0 {
		n += 1 + sovPipeline(uint64(m.NBucket))
	}
	if m.RowIdIdx != 0 {
		n += 1 + sovPipeline(uint64(m.RowIdIdx))
	}
	if len(m.PartitionTableIds) > 0 {
		l = 0
		for _, e := range m.PartitionTableIds {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.PartitionTableNames) > 0 {
		for _, s := range m.PartitionTableNames {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.PartitionIndexInBatch != 0 {
		n += 1 + sovPipeline(uint64(m.PartitionIndexInBatch))
	}
	if m.Ref != nil {
		l = m.Ref.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.AddAffectedRows {
		n += 2
	}
	if len(m.SegmentMap) > 0 {
		for k, v := range m.SegmentMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPipeline(uint64(len(k))) + 1 + sovPipeline(uint64(v))
			n += mapEntrySize + 1 + sovPipeline(uint64(mapEntrySize))
		}
	}
	if m.CanTruncate {
		n += 2
	}
	if m.IsEnd {
		n += 2
	}
	if m.PrimaryKeyIdx != 0 {
		n += 1 + sovPipeline(uint64(m.PrimaryKeyIdx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PreInsert) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SchemaName)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Idx) > 0 {
		l = 0
		for _, e := range m.Idx {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.Attrs) > 0 {
		for _, s := range m.Attrs {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.HasAutoCol {
		n += 2
	}
	if m.IsUpdate {
		n += 2
	}
	if m.EstimatedRowCount != 0 {
		n += 1 + sovPipeline(uint64(m.EstimatedRowCount))
	}
	if m.CompPkeyExpr != nil {
		l = m.CompPkeyExpr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.ClusterByExpr != nil {
		l = m.ClusterByExpr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LockTarget) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovPipeline(uint64(m.TableId))
	}
	if m.PrimaryColIdxInBat != 0 {
		n += 1 + sovPipeline(uint64(m.PrimaryColIdxInBat))
	}
	l = m.PrimaryColTyp.ProtoSize()
	n += 1 + l + sovPipeline(uint64(l))
	if m.RefreshTsIdxInBat != 0 {
		n += 1 + sovPipeline(uint64(m.RefreshTsIdxInBat))
	}
	if m.FilterColIdxInBat != 0 {
		n += 1 + sovPipeline(uint64(m.FilterColIdxInBat))
	}
	if m.LockTable {
		n += 2
	}
	if m.ChangeDef {
		n += 2
	}
	if m.Mode != 0 {
		n += 1 + sovPipeline(uint64(m.Mode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LockOp) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Targets) > 0 {
		for _, e := range m.Targets {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.Block {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PreInsertUnique) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PreInsertUkCtx != nil {
		l = m.PreInsertUkCtx.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PreInsertSecondaryIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PreInsertSkCtx != nil {
		l = m.PreInsertSkCtx.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OnDuplicateKey) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attrs) > 0 {
		for _, s := range m.Attrs {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.InsertColCount != 0 {
		n += 1 + sovPipeline(uint64(m.InsertColCount))
	}
	if len(m.UniqueColCheckExpr) > 0 {
		for _, e := range m.UniqueColCheckExpr {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.UniqueCols) > 0 {
		for _, s := range m.UniqueCols {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.OnDuplicateIdx) > 0 {
		l = 0
		for _, e := range m.OnDuplicateIdx {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.OnDuplicateExpr) > 0 {
		for k, v := range m.OnDuplicateExpr {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.ProtoSize()
				l += 1 + sovPipeline(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPipeline(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPipeline(uint64(mapEntrySize))
		}
	}
	if m.IsIgnore {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FuzzyFilter) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.N != 0 {
		n += 5
	}
	l = len(m.PkName)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = m.PkTyp.ProtoSize()
	n += 1 + l + sovPipeline(uint64(l))
	if m.BuildIdx != 0 {
		n += 1 + sovPipeline(uint64(m.BuildIdx))
	}
	if m.IfInsertFromUnique {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Join) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RelList) > 0 {
		l = 0
		for _, e := range m.RelList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.ColList) > 0 {
		l = 0
		for _, e := range m.ColList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for _, e := range m.RuntimeFilterBuildList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.HashOnPk {
		n += 2
	}
	if m.IsShuffle {
		n += 2
	}
	if m.JoinMapTag != 0 {
		n += 1 + sovPipeline(uint64(m.JoinMapTag))
	}
	if m.ShuffleIdx != 0 {
		n += 1 + sovPipeline(uint64(m.ShuffleIdx))
	}
	if m.JoinType != 0 {
		n += 1 + sovPipeline(uint64(m.JoinType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AntiJoin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Result) > 0 {
		l = 0
		for _, e := range m.Result {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.HashOnPk {
		n += 2
	}
	if m.IsShuffle {
		n += 2
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for _, e := range m.RuntimeFilterBuildList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.JoinMapTag != 0 {
		n += 1 + sovPipeline(uint64(m.JoinMapTag))
	}
	if m.ShuffleIdx != 0 {
		n += 1 + sovPipeline(uint64(m.ShuffleIdx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LeftJoin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RelList) > 0 {
		l = 0
		for _, e := range m.RelList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.ColList) > 0 {
		l = 0
		for _, e := range m.ColList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for _, e := range m.RuntimeFilterBuildList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.HashOnPk {
		n += 2
	}
	if m.IsShuffle {
		n += 2
	}
	if m.JoinMapTag != 0 {
		n += 1 + sovPipeline(uint64(m.JoinMapTag))
	}
	if m.ShuffleIdx != 0 {
		n += 1 + sovPipeline(uint64(m.ShuffleIdx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RightJoin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RelList) > 0 {
		l = 0
		for _, e := range m.RelList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.ColList) > 0 {
		l = 0
		for _, e := range m.ColList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.LeftTypes) > 0 {
		for _, e := range m.LeftTypes {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightTypes) > 0 {
		for _, e := range m.RightTypes {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for _, e := range m.RuntimeFilterBuildList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.HashOnPk {
		n += 2
	}
	if m.IsShuffle {
		n += 2
	}
	if m.JoinMapTag != 0 {
		n += 1 + sovPipeline(uint64(m.JoinMapTag))
	}
	if m.ShuffleIdx != 0 {
		n += 1 + sovPipeline(uint64(m.ShuffleIdx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RightSemiJoin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Result) > 0 {
		l = 0
		for _, e := range m.Result {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.RightTypes) > 0 {
		for _, e := range m.RightTypes {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for _, e := range m.RuntimeFilterBuildList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.HashOnPk {
		n += 2
	}
	if m.IsShuffle {
		n += 2
	}
	if m.JoinMapTag != 0 {
		n += 1 + sovPipeline(uint64(m.JoinMapTag))
	}
	if m.ShuffleIdx != 0 {
		n += 1 + sovPipeline(uint64(m.ShuffleIdx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RightAntiJoin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Result) > 0 {
		l = 0
		for _, e := range m.Result {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.RightTypes) > 0 {
		for _, e := range m.RightTypes {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for _, e := range m.RuntimeFilterBuildList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.HashOnPk {
		n += 2
	}
	if m.IsShuffle {
		n += 2
	}
	if m.JoinMapTag != 0 {
		n += 1 + sovPipeline(uint64(m.JoinMapTag))
	}
	if m.ShuffleIdx != 0 {
		n += 1 + sovPipeline(uint64(m.ShuffleIdx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SemiJoin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Result) > 0 {
		l = 0
		for _, e := range m.Result {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for _, e := range m.RuntimeFilterBuildList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.HashOnPk {
		n += 2
	}
	if m.IsShuffle {
		n += 2
	}
	if m.JoinMapTag != 0 {
		n += 1 + sovPipeline(uint64(m.JoinMapTag))
	}
	if m.ShuffleIdx != 0 {
		n += 1 + sovPipeline(uint64(m.ShuffleIdx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SingleJoin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RelList) > 0 {
		l = 0
		for _, e := range m.RelList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.ColList) > 0 {
		l = 0
		for _, e := range m.ColList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for _, e := range m.RuntimeFilterBuildList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.HashOnPk {
		n += 2
	}
	if m.IsShuffle {
		n += 2
	}
	if m.JoinMapTag != 0 {
		n += 1 + sovPipeline(uint64(m.JoinMapTag))
	}
	if m.ShuffleIdx != 0 {
		n += 1 + sovPipeline(uint64(m.ShuffleIdx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MarkJoin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Result) > 0 {
		l = 0
		for _, e := range m.Result {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.LeftCond) > 0 {
		for _, e := range m.LeftCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.RightCond) > 0 {
		for _, e := range m.RightCond {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.OnList) > 0 {
		for _, e := range m.OnList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.HashOnPk {
		n += 2
	}
	if m.IsShuffle {
		n += 2
	}
	if m.JoinMapTag != 0 {
		n += 1 + sovPipeline(uint64(m.JoinMapTag))
	}
	if m.ShuffleIdx != 0 {
		n += 1 + sovPipeline(uint64(m.ShuffleIdx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Product) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RelList) > 0 {
		l = 0
		for _, e := range m.RelList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.ColList) > 0 {
		l = 0
		for _, e := range m.ColList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.IsShuffle {
		n += 2
	}
	if m.JoinMapTag != 0 {
		n += 1 + sovPipeline(uint64(m.JoinMapTag))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProductL2) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RelList) > 0 {
		l = 0
		for _, e := range m.RelList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.ColList) > 0 {
		l = 0
		for _, e := range m.ColList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.JoinMapTag != 0 {
		n += 1 + sovPipeline(uint64(m.JoinMapTag))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IndexJoin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Result) > 0 {
		l = 0
		for _, e := range m.Result {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for _, e := range m.RuntimeFilterBuildList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableFunction) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attrs) > 0 {
		for _, s := range m.Attrs {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.Rets) > 0 {
		for _, e := range m.Rets {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.Args) > 0 {
		for _, e := range m.Args {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	l = len(m.Params)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExternalName2ColIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovPipeline(uint64(m.Index))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileOffset) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Offset) > 0 {
		l = 0
		for _, e := range m.Offset {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExternalScan) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attrs) > 0 {
		for _, s := range m.Attrs {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.FileSize) > 0 {
		l = 0
		for _, e := range m.FileSize {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.FileOffsetTotal) > 0 {
		for _, e := range m.FileOffsetTotal {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.Cols) > 0 {
		for _, e := range m.Cols {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.Name2ColIndex) > 0 {
		for _, e := range m.Name2ColIndex {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	l = len(m.CreateSql)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.FileList) > 0 {
		for _, s := range m.FileList {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.OriginCols) > 0 {
		for _, e := range m.OriginCols {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.Filter != nil {
		l = m.Filter.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.TbColToDataCol) > 0 {
		for k, v := range m.TbColToDataCol {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPipeline(uint64(len(k))) + 1 + sovPipeline(uint64(v))
			n += mapEntrySize + 1 + sovPipeline(uint64(mapEntrySize))
		}
	}
	if m.StrictSqlMode {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamScan) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TblDef != nil {
		l = m.TblDef.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovPipeline(uint64(m.Offset))
	}
	if m.Limit != 0 {
		n += 1 + sovPipeline(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableScan) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValueScan) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BatchBlock)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnionAll) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HashBuild) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NeedHashMap {
		n += 2
	}
	if m.HashOnPK {
		n += 2
	}
	if m.NeedBatches {
		n += 2
	}
	if m.NeedAllocateSels {
		n += 2
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.JoinMapTag != 0 {
		n += 1 + sovPipeline(uint64(m.JoinMapTag))
	}
	if m.JoinMapRefCnt != 0 {
		n += 1 + sovPipeline(uint64(m.JoinMapRefCnt))
	}
	if m.RuntimeFilterSpec != nil {
		l = m.RuntimeFilterSpec.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Shufflebuild) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HashOnPK {
		n += 2
	}
	if m.NeedBatches {
		n += 2
	}
	if m.NeedAllocateSels {
		n += 2
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.RuntimeFilterSpec != nil {
		l = m.RuntimeFilterSpec.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.JoinMapTag != 0 {
		n += 1 + sovPipeline(uint64(m.JoinMapTag))
	}
	if m.ShuffleIdx != 0 {
		n += 1 + sovPipeline(uint64(m.ShuffleIdx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Indexbuild) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RuntimeFilterSpec != nil {
		l = m.RuntimeFilterSpec.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SampleFunc) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SampleType != 0 {
		n += 1 + sovPipeline(uint64(m.SampleType))
	}
	if m.SampleRows != 0 {
		n += 1 + sovPipeline(uint64(m.SampleRows))
	}
	if m.SamplePercent != 0 {
		n += 9
	}
	if len(m.SampleColumns) > 0 {
		for _, e := range m.SampleColumns {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Instruction) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovPipeline(uint64(m.Op))
	}
	if m.Idx != 0 {
		n += 1 + sovPipeline(uint64(m.Idx))
	}
	if m.Anti != nil {
		l = m.Anti.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Connect != nil {
		l = m.Connect.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Dispatch != nil {
		l = m.Dispatch.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Agg != nil {
		l = m.Agg.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.LeftJoin != nil {
		l = m.LeftJoin.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.SemiJoin != nil {
		l = m.SemiJoin.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.SingleJoin != nil {
		l = m.SingleJoin.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.MarkJoin != nil {
		l = m.MarkJoin.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Join != nil {
		l = m.Join.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Product != nil {
		l = m.Product.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.TableFunction != nil {
		l = m.TableFunction.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.ExternalScan != nil {
		l = m.ExternalScan.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.Insert != nil {
		l = m.Insert.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.OnDuplicateKey != nil {
		l = m.OnDuplicateKey.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.PreInsert != nil {
		l = m.PreInsert.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.PreInsertUnique != nil {
		l = m.PreInsertUnique.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if len(m.OrderBy) > 0 {
		for _, e := range m.OrderBy {
			l = e.ProtoSize()
			n += 2 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.ProjectList) > 0 {
		for _, e := range m.ProjectList {
			l = e.ProtoSize()
			n += 2 + l + sovPipeline(uint64(l))
		}
	}
	if m.Filter != nil {
		l = m.Filter.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.Limit != nil {
		l = m.Limit.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.Offset != nil {
		l = m.Offset.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.IsFirst {
		n += 3
	}
	if m.IsLast {
		n += 3
	}
	if m.RightJoin != nil {
		l = m.RightJoin.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.RightSemiJoin != nil {
		l = m.RightSemiJoin.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.RightAntiJoin != nil {
		l = m.RightAntiJoin.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.Delete != nil {
		l = m.Delete.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.LockOp != nil {
		l = m.LockOp.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.Shuffle != nil {
		l = m.Shuffle.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.Merge != nil {
		l = m.Merge.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.StreamScan != nil {
		l = m.StreamScan.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.PreInsertSecondaryIndex != nil {
		l = m.PreInsertSecondaryIndex.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.SampleFunc != nil {
		l = m.SampleFunc.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.FuzzyFilter != nil {
		l = m.FuzzyFilter.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	l = len(m.CnAddr)
	if l > 0 {
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.OperatorId != 0 {
		n += 2 + sovPipeline(uint64(m.OperatorId))
	}
	if m.ParallelId != 0 {
		n += 2 + sovPipeline(uint64(m.ParallelId))
	}
	if m.MaxParallel != 0 {
		n += 2 + sovPipeline(uint64(m.MaxParallel))
	}
	if m.IndexJoin != nil {
		l = m.IndexJoin.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.ProductL2 != nil {
		l = m.ProductL2.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.TableScan != nil {
		l = m.TableScan.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.ValueScan != nil {
		l = m.ValueScan.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.UnionAll != nil {
		l = m.UnionAll.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.HashBuild != nil {
		l = m.HashBuild.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.ShuffleBuild != nil {
		l = m.ShuffleBuild.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.IndexBuild != nil {
		l = m.IndexBuild.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.Apply != nil {
		l = m.Apply.ProtoSize()
		n += 2 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnalysisList) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Source) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SchemaName)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.ColList) > 0 {
		for _, s := range m.ColList {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	l = len(m.Block)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.PushdownId != 0 {
		n += 1 + sovPipeline(uint64(m.PushdownId))
	}
	l = len(m.PushdownAddr)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.RuntimeFilterProbeList) > 0 {
		for _, e := range m.RuntimeFilterProbeList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.IsConst {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mcpu != 0 {
		n += 1 + sovPipeline(uint64(m.Mcpu))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProcessLimitation) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Size != 0 {
		n += 1 + sovPipeline(uint64(m.Size))
	}
	if m.BatchRows != 0 {
		n += 1 + sovPipeline(uint64(m.BatchRows))
	}
	if m.BatchSize != 0 {
		n += 1 + sovPipeline(uint64(m.BatchSize))
	}
	if m.PartitionRows != 0 {
		n += 1 + sovPipeline(uint64(m.PartitionRows))
	}
	if m.ReaderSize != 0 {
		n += 1 + sovPipeline(uint64(m.ReaderSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrepareParamInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Length != 0 {
		n += 1 + sovPipeline(uint64(m.Length))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Area)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Nulls) > 0 {
		n += 1 + sovPipeline(uint64(len(m.Nulls))) + len(m.Nulls)*1
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProcessInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Sql)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = m.Lim.ProtoSize()
	n += 1 + l + sovPipeline(uint64(l))
	if m.UnixTime != 0 {
		n += 1 + sovPipeline(uint64(m.UnixTime))
	}
	if m.AccountId != 0 {
		n += 1 + sovPipeline(uint64(m.AccountId))
	}
	l = m.Snapshot.ProtoSize()
	n += 1 + l + sovPipeline(uint64(l))
	l = m.SessionInfo.ProtoSize()
	n += 1 + l + sovPipeline(uint64(l))
	l = m.SessionLogger.ProtoSize()
	n += 1 + l + sovPipeline(uint64(l))
	l = m.PrepareParams.ProtoSize()
	n += 1 + l + sovPipeline(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.ConnectionId != 0 {
		n += 1 + sovPipeline(uint64(m.ConnectionId))
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.TimeZone)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.QueryId) > 0 {
		for _, s := range m.QueryId {
			l = len(s)
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionLoggerInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessId)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.StmtId)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.TxnId)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.LogLevel != 0 {
		n += 1 + sovPipeline(uint64(m.LogLevel))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Pipeline) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PipelineType != 0 {
		n += 1 + sovPipeline(uint64(m.PipelineType))
	}
	if m.PipelineId != 0 {
		n += 1 + sovPipeline(uint64(m.PipelineId))
	}
	if m.Qry != nil {
		l = m.Qry.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.DataSource != nil {
		l = m.DataSource.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if len(m.InstructionList) > 0 {
		for _, e := range m.InstructionList {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.IsEnd {
		n += 2
	}
	if m.IsLoad {
		n += 2
	}
	if m.Node != nil {
		l = m.Node.ProtoSize()
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.PushDownInfo != 0 {
		n += 1 + sovPipeline(uint64(m.PushDownInfo))
	}
	if m.ChildrenCount != 0 {
		n += 1 + sovPipeline(uint64(m.ChildrenCount))
	}
	if len(m.ChannelBufferSize) > 0 {
		l = 0
		for _, e := range m.ChannelBufferSize {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.NilBatchCnt) > 0 {
		l = 0
		for _, e := range m.NilBatchCnt {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.UuidsToRegIdx) > 0 {
		for _, e := range m.UuidsToRegIdx {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WrapNode) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeAddr)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UuidToRegIdx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Idx != 0 {
		n += 1 + sovPipeline(uint64(m.Idx))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.FromAddr)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Apply) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApplyType != 0 {
		n += 1 + sovPipeline(uint64(m.ApplyType))
	}
	if len(m.RelList) > 0 {
		l = 0
		for _, e := range m.RelList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.ColList) > 0 {
		l = 0
		for _, e := range m.ColList {
			l += sovPipeline(uint64(e))
		}
		n += 1 + sovPipeline(uint64(l)) + l
	}
	if len(m.Types) > 0 {
		for _, e := range m.Types {
			l = e.ProtoSize()
			n += 1 + l + sovPipeline(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPipeline(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPipeline(x uint64) (n int) {
	return sovPipeline(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= Method(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Err = append(m.Err[:0], dAtA[iNdEx:postIndex]...)
			if m.Err == nil {
				m.Err = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcInfoData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcInfoData = append(m.ProcInfoData[:0], dAtA[iNdEx:postIndex]...)
			if m.ProcInfoData == nil {
				m.ProcInfoData = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Analyse", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Analyse = append(m.Analyse[:0], dAtA[iNdEx:postIndex]...)
			if m.Analyse == nil {
				m.Analyse = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedNotReply", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedNotReply = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Connector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Connector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Connector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineId", wireType)
			}
			m.PipelineId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PipelineId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorIndex", wireType)
			}
			m.ConnectorIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectorIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Shuffle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Shuffle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Shuffle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleColIdx", wireType)
			}
			m.ShuffleColIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleColIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleType", wireType)
			}
			m.ShuffleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleColMin", wireType)
			}
			m.ShuffleColMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleColMin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleColMax", wireType)
			}
			m.ShuffleColMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleColMax |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliveRegCnt", wireType)
			}
			m.AliveRegCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AliveRegCnt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ShuffleRangesUint64 = append(m.ShuffleRangesUint64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ShuffleRangesUint64) == 0 {
					m.ShuffleRangesUint64 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ShuffleRangesUint64 = append(m.ShuffleRangesUint64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleRangesUint64", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ShuffleRangesInt64 = append(m.ShuffleRangesInt64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ShuffleRangesInt64) == 0 {
					m.ShuffleRangesInt64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ShuffleRangesInt64 = append(m.ShuffleRangesInt64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleRangesInt64", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RuntimeFilterSpec == nil {
				m.RuntimeFilterSpec = &plan.RuntimeFilterSpec{}
			}
			if err := m.RuntimeFilterSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dispatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dispatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dispatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuncId", wireType)
			}
			m.FuncId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FuncId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalConnector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalConnector = append(m.LocalConnector, &Connector{})
			if err := m.LocalConnector[len(m.LocalConnector)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteConnector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteConnector = append(m.RemoteConnector, &WrapNode{})
			if err := m.RemoteConnector[len(m.RemoteConnector)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ShuffleRegIdxLocal = append(m.ShuffleRegIdxLocal, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ShuffleRegIdxLocal) == 0 {
					m.ShuffleRegIdxLocal = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ShuffleRegIdxLocal = append(m.ShuffleRegIdxLocal, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleRegIdxLocal", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ShuffleRegIdxRemote = append(m.ShuffleRegIdxRemote, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ShuffleRegIdxRemote) == 0 {
					m.ShuffleRegIdxRemote = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ShuffleRegIdxRemote = append(m.ShuffleRegIdxRemote, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleRegIdxRemote", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleType", wireType)
			}
			m.ShuffleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSink", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSink = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecSink", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RecSink = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecCte", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RecCte = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Merge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Merge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Merge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SinkScan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SinkScan = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partial", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Partial = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartIdx", wireType)
			}
			m.StartIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndIdx", wireType)
			}
			m.EndIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiArguemnt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiArguemnt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiArguemnt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dist = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupExpr = append(m.GroupExpr, &plan.Expr{})
			if err := m.GroupExpr[len(m.GroupExpr)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderByExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderByExpr = append(m.OrderByExpr, &plan.Expr{})
			if err := m.OrderByExpr[len(m.OrderByExpr)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Separator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Separator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			m.OrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Aggregate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aggregate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aggregate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dist = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expr = append(m.Expr, &plan.Expr{})
			if err := m.Expr[len(m.Expr)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = append(m.Config[:0], dAtA[iNdEx:postIndex]...)
			if m.Config == nil {
				m.Config = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Group) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedEval", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedEval = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exprs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exprs = append(m.Exprs, &plan.Expr{})
			if err := m.Exprs[len(m.Exprs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aggs = append(m.Aggs, &Aggregate{})
			if err := m.Aggs[len(m.Aggs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiAggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultiAggs = append(m.MultiAggs, &MultiArguemnt{})
			if err := m.MultiAggs[len(m.MultiAggs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShuffle = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreAllocSize", wireType)
			}
			m.PreAllocSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreAllocSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialResults", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartialResults = append(m.PartialResults[:0], dAtA[iNdEx:postIndex]...)
			if m.PartialResults == nil {
				m.PartialResults = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartialResultTypes = append(m.PartialResultTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PartialResultTypes) == 0 {
					m.PartialResultTypes = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartialResultTypes = append(m.PartialResultTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialResultTypes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Insert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Insert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Insert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Affected", wireType)
			}
			m.Affected = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Affected |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToWriteS3", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ToWriteS3 = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddAffectedRows", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddAffectedRows = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ref == nil {
				m.Ref = &plan.ObjectRef{}
			}
			if err := m.Ref.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attrs = append(m.Attrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartitionTableIds = append(m.PartitionTableIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PartitionTableIds) == 0 {
					m.PartitionTableIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartitionTableIds = append(m.PartitionTableIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableIds", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTableNames = append(m.PartitionTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionIdx", wireType)
			}
			m.PartitionIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEnd = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &plan.TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffectedRows", wireType)
			}
			m.AffectedRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AffectedRows |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToWriteS3", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ToWriteS3 = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IBucket", wireType)
			}
			m.IBucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IBucket |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NBucket", wireType)
			}
			m.NBucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NBucket |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SegmentMap == nil {
				m.SegmentMap = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPipeline
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPipeline
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPipeline(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPipeline
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SegmentMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdateCtx = append(m.UpdateCtx, &plan.UpdateCtx{})
			if err := m.UpdateCtx[len(m.UpdateCtx)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Array) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Array: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Array: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Array = append(m.Array, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Array) == 0 {
					m.Array = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Array = append(m.Array, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Array", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Map) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Map: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Map: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mp == nil {
				m.Mp = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPipeline
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPipeline
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPipeline(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPipeline
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Mp[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deletion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deletion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deletion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffectedRows", wireType)
			}
			m.AffectedRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AffectedRows |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteDelete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RemoteDelete = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IBucket", wireType)
			}
			m.IBucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IBucket |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NBucket", wireType)
			}
			m.NBucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NBucket |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowIdIdx", wireType)
			}
			m.RowIdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowIdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartitionTableIds = append(m.PartitionTableIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PartitionTableIds) == 0 {
					m.PartitionTableIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartitionTableIds = append(m.PartitionTableIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableIds", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTableNames = append(m.PartitionTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionIndexInBatch", wireType)
			}
			m.PartitionIndexInBatch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionIndexInBatch |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ref == nil {
				m.Ref = &plan.ObjectRef{}
			}
			if err := m.Ref.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddAffectedRows", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddAffectedRows = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SegmentMap == nil {
				m.SegmentMap = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPipeline
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPipeline
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPipeline(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPipeline
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SegmentMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanTruncate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanTruncate = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEnd = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKeyIdx", wireType)
			}
			m.PrimaryKeyIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryKeyIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreInsert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreInsert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreInsert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &plan.TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Idx = append(m.Idx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Idx) == 0 {
					m.Idx = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Idx = append(m.Idx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attrs = append(m.Attrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasAutoCol", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasAutoCol = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUpdate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUpdate = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedRowCount", wireType)
			}
			m.EstimatedRowCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EstimatedRowCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompPkeyExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompPkeyExpr == nil {
				m.CompPkeyExpr = &plan.Expr{}
			}
			if err := m.CompPkeyExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterByExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterByExpr == nil {
				m.ClusterByExpr = &plan.Expr{}
			}
			if err := m.ClusterByExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryColIdxInBat", wireType)
			}
			m.PrimaryColIdxInBat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryColIdxInBat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryColTyp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrimaryColTyp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshTsIdxInBat", wireType)
			}
			m.RefreshTsIdxInBat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefreshTsIdxInBat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterColIdxInBat", wireType)
			}
			m.FilterColIdxInBat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilterColIdxInBat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LockTable = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeDef", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChangeDef = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= lock.LockMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Targets = append(m.Targets, &LockTarget{})
			if err := m.Targets[len(m.Targets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Block = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreInsertUnique) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreInsertUnique: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreInsertUnique: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreInsertUkCtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreInsertUkCtx == nil {
				m.PreInsertUkCtx = &plan.PreInsertUkCtx{}
			}
			if err := m.PreInsertUkCtx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreInsertSecondaryIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreInsertSecondaryIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreInsertSecondaryIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreInsertSkCtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreInsertSkCtx == nil {
				m.PreInsertSkCtx = &plan.PreInsertUkCtx{}
			}
			if err := m.PreInsertSkCtx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnDuplicateKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnDuplicateKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnDuplicateKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attrs = append(m.Attrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertColCount", wireType)
			}
			m.InsertColCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InsertColCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueColCheckExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueColCheckExpr = append(m.UniqueColCheckExpr, &plan.Expr{})
			if err := m.UniqueColCheckExpr[len(m.UniqueColCheckExpr)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueCols", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueCols = append(m.UniqueCols, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OnDuplicateIdx = append(m.OnDuplicateIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OnDuplicateIdx) == 0 {
					m.OnDuplicateIdx = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OnDuplicateIdx = append(m.OnDuplicateIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDuplicateIdx", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDuplicateExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OnDuplicateExpr == nil {
				m.OnDuplicateExpr = make(map[string]*plan.Expr)
			}
			var mapkey string
			var mapvalue *plan.Expr
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPipeline
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPipeline
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPipeline
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPipeline
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &plan.Expr{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPipeline(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPipeline
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.OnDuplicateExpr[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsIgnore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsIgnore = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FuzzyFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FuzzyFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FuzzyFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.N = float32(math.Float32frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PkName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkTyp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PkTyp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildIdx", wireType)
			}
			m.BuildIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfInsertFromUnique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfInsertFromUnique = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Join) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Join: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Join: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelList = append(m.RelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelList) == 0 {
					m.RelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelList = append(m.RelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelList", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColList = append(m.ColList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColList) == 0 {
					m.ColList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColList = append(m.ColList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColList", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterBuildList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterBuildList = append(m.RuntimeFilterBuildList, &plan.RuntimeFilterSpec{})
			if err := m.RuntimeFilterBuildList[len(m.RuntimeFilterBuildList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOnPk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashOnPk = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShuffle = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinMapTag", wireType)
			}
			m.JoinMapTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinMapTag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleIdx", wireType)
			}
			m.ShuffleIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinType", wireType)
			}
			m.JoinType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AntiJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AntiJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AntiJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Result = append(m.Result, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Result) == 0 {
					m.Result = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Result = append(m.Result, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOnPk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashOnPk = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShuffle = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterBuildList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterBuildList = append(m.RuntimeFilterBuildList, &plan.RuntimeFilterSpec{})
			if err := m.RuntimeFilterBuildList[len(m.RuntimeFilterBuildList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinMapTag", wireType)
			}
			m.JoinMapTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinMapTag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleIdx", wireType)
			}
			m.ShuffleIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeftJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeftJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeftJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelList = append(m.RelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelList) == 0 {
					m.RelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelList = append(m.RelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelList", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColList = append(m.ColList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColList) == 0 {
					m.ColList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColList = append(m.ColList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColList", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterBuildList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterBuildList = append(m.RuntimeFilterBuildList, &plan.RuntimeFilterSpec{})
			if err := m.RuntimeFilterBuildList[len(m.RuntimeFilterBuildList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOnPk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashOnPk = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShuffle = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinMapTag", wireType)
			}
			m.JoinMapTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinMapTag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleIdx", wireType)
			}
			m.ShuffleIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RightJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RightJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RightJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelList = append(m.RelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelList) == 0 {
					m.RelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelList = append(m.RelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelList", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColList = append(m.ColList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColList) == 0 {
					m.ColList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColList = append(m.ColList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColList", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftTypes = append(m.LeftTypes, plan.Type{})
			if err := m.LeftTypes[len(m.LeftTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightTypes = append(m.RightTypes, plan.Type{})
			if err := m.RightTypes[len(m.RightTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterBuildList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterBuildList = append(m.RuntimeFilterBuildList, &plan.RuntimeFilterSpec{})
			if err := m.RuntimeFilterBuildList[len(m.RuntimeFilterBuildList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOnPk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashOnPk = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShuffle = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinMapTag", wireType)
			}
			m.JoinMapTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinMapTag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleIdx", wireType)
			}
			m.ShuffleIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RightSemiJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RightSemiJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RightSemiJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Result = append(m.Result, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Result) == 0 {
					m.Result = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Result = append(m.Result, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightTypes = append(m.RightTypes, plan.Type{})
			if err := m.RightTypes[len(m.RightTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterBuildList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterBuildList = append(m.RuntimeFilterBuildList, &plan.RuntimeFilterSpec{})
			if err := m.RuntimeFilterBuildList[len(m.RuntimeFilterBuildList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOnPk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashOnPk = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShuffle = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinMapTag", wireType)
			}
			m.JoinMapTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinMapTag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleIdx", wireType)
			}
			m.ShuffleIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RightAntiJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RightAntiJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RightAntiJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Result = append(m.Result, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Result) == 0 {
					m.Result = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Result = append(m.Result, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightTypes = append(m.RightTypes, plan.Type{})
			if err := m.RightTypes[len(m.RightTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterBuildList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterBuildList = append(m.RuntimeFilterBuildList, &plan.RuntimeFilterSpec{})
			if err := m.RuntimeFilterBuildList[len(m.RuntimeFilterBuildList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOnPk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashOnPk = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShuffle = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinMapTag", wireType)
			}
			m.JoinMapTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinMapTag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleIdx", wireType)
			}
			m.ShuffleIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SemiJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SemiJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SemiJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Result = append(m.Result, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Result) == 0 {
					m.Result = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Result = append(m.Result, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterBuildList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterBuildList = append(m.RuntimeFilterBuildList, &plan.RuntimeFilterSpec{})
			if err := m.RuntimeFilterBuildList[len(m.RuntimeFilterBuildList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOnPk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashOnPk = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShuffle = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinMapTag", wireType)
			}
			m.JoinMapTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinMapTag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleIdx", wireType)
			}
			m.ShuffleIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SingleJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelList = append(m.RelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelList) == 0 {
					m.RelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelList = append(m.RelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelList", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColList = append(m.ColList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColList) == 0 {
					m.ColList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColList = append(m.ColList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColList", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterBuildList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterBuildList = append(m.RuntimeFilterBuildList, &plan.RuntimeFilterSpec{})
			if err := m.RuntimeFilterBuildList[len(m.RuntimeFilterBuildList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOnPk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashOnPk = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShuffle = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinMapTag", wireType)
			}
			m.JoinMapTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinMapTag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleIdx", wireType)
			}
			m.ShuffleIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Result = append(m.Result, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Result) == 0 {
					m.Result = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Result = append(m.Result, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeftCond = append(m.LeftCond, &plan.Expr{})
			if err := m.LeftCond[len(m.LeftCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightCond", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RightCond = append(m.RightCond, &plan.Expr{})
			if err := m.RightCond[len(m.RightCond)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnList = append(m.OnList, &plan.Expr{})
			if err := m.OnList[len(m.OnList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOnPk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashOnPk = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShuffle = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinMapTag", wireType)
			}
			m.JoinMapTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinMapTag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleIdx", wireType)
			}
			m.ShuffleIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Product) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Product: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Product: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelList = append(m.RelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelList) == 0 {
					m.RelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelList = append(m.RelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelList", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColList = append(m.ColList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColList) == 0 {
					m.ColList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColList = append(m.ColList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColList", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsShuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsShuffle = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinMapTag", wireType)
			}
			m.JoinMapTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinMapTag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductL2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductL2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductL2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelList = append(m.RelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelList) == 0 {
					m.RelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelList = append(m.RelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelList", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColList = append(m.ColList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColList) == 0 {
					m.ColList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColList = append(m.ColList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColList", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinMapTag", wireType)
			}
			m.JoinMapTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinMapTag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Result = append(m.Result, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Result) == 0 {
					m.Result = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Result = append(m.Result, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterBuildList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterBuildList = append(m.RuntimeFilterBuildList, &plan.RuntimeFilterSpec{})
			if err := m.RuntimeFilterBuildList[len(m.RuntimeFilterBuildList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableFunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableFunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableFunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attrs = append(m.Attrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rets = append(m.Rets, &plan.ColDef{})
			if err := m.Rets[len(m.Rets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, &plan.Expr{})
			if err := m.Args[len(m.Args)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params[:0], dAtA[iNdEx:postIndex]...)
			if m.Params == nil {
				m.Params = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalName2ColIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalName2ColIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalName2ColIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileOffset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: file_offset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: file_offset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Offset = append(m.Offset, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Offset) == 0 {
					m.Offset = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Offset = append(m.Offset, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalScan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalScan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalScan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attrs = append(m.Attrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FileSize = append(m.FileSize, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FileSize) == 0 {
					m.FileSize = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FileSize = append(m.FileSize, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileOffsetTotal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileOffsetTotal = append(m.FileOffsetTotal, &FileOffset{})
			if err := m.FileOffsetTotal[len(m.FileOffsetTotal)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cols = append(m.Cols, &plan.ColDef{})
			if err := m.Cols[len(m.Cols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name2ColIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name2ColIndex = append(m.Name2ColIndex, &ExternalName2ColIndex{})
			if err := m.Name2ColIndex[len(m.Name2ColIndex)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateSql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreateSql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileList = append(m.FileList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginCols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginCols = append(m.OriginCols, &plan.ColDef{})
			if err := m.OriginCols[len(m.OriginCols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &plan.Expr{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TbColToDataCol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TbColToDataCol == nil {
				m.TbColToDataCol = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPipeline
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPipeline
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPipeline(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPipeline
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TbColToDataCol[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrictSqlMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StrictSqlMode = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamScan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamScan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamScan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TblDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TblDef == nil {
				m.TblDef = &plan.TableDef{}
			}
			if err := m.TblDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableScan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableScan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableScan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValueScan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValueScan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValueScan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchBlock", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchBlock = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnionAll) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnionAll: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnionAll: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HashBuild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HashBuild: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HashBuild: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedHashMap", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedHashMap = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOnPK", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashOnPK = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedBatches", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedBatches = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedAllocateSels", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedAllocateSels = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &plan.Expr{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinMapTag", wireType)
			}
			m.JoinMapTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinMapTag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinMapRefCnt", wireType)
			}
			m.JoinMapRefCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinMapRefCnt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RuntimeFilterSpec == nil {
				m.RuntimeFilterSpec = &plan.RuntimeFilterSpec{}
			}
			if err := m.RuntimeFilterSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Shufflebuild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Shufflebuild: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Shufflebuild: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOnPK", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashOnPK = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedBatches", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedBatches = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedAllocateSels", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedAllocateSels = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &plan.Expr{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RuntimeFilterSpec == nil {
				m.RuntimeFilterSpec = &plan.RuntimeFilterSpec{}
			}
			if err := m.RuntimeFilterSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinMapTag", wireType)
			}
			m.JoinMapTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinMapTag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleIdx", wireType)
			}
			m.ShuffleIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Indexbuild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Indexbuild: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Indexbuild: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RuntimeFilterSpec == nil {
				m.RuntimeFilterSpec = &plan.RuntimeFilterSpec{}
			}
			if err := m.RuntimeFilterSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SampleFunc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SampleFunc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SampleFunc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleType", wireType)
			}
			m.SampleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleType |= SampleFunc_SampleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleRows", wireType)
			}
			m.SampleRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleRows |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SamplePercent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SamplePercent = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SampleColumns = append(m.SampleColumns, &plan.Expr{})
			if err := m.SampleColumns[len(m.SampleColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Instruction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Instruction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Instruction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anti", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anti == nil {
				m.Anti = &AntiJoin{}
			}
			if err := m.Anti.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connect == nil {
				m.Connect = &Connector{}
			}
			if err := m.Connect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dispatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dispatch == nil {
				m.Dispatch = &Dispatch{}
			}
			if err := m.Dispatch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Agg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Agg == nil {
				m.Agg = &Group{}
			}
			if err := m.Agg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeftJoin == nil {
				m.LeftJoin = &LeftJoin{}
			}
			if err := m.LeftJoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemiJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SemiJoin == nil {
				m.SemiJoin = &SemiJoin{}
			}
			if err := m.SemiJoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SingleJoin == nil {
				m.SingleJoin = &SingleJoin{}
			}
			if err := m.SingleJoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MarkJoin == nil {
				m.MarkJoin = &MarkJoin{}
			}
			if err := m.MarkJoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Join", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Join == nil {
				m.Join = &Join{}
			}
			if err := m.Join.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Product == nil {
				m.Product = &Product{}
			}
			if err := m.Product.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableFunction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableFunction == nil {
				m.TableFunction = &TableFunction{}
			}
			if err := m.TableFunction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalScan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExternalScan == nil {
				m.ExternalScan = &ExternalScan{}
			}
			if err := m.ExternalScan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Insert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Insert == nil {
				m.Insert = &Insert{}
			}
			if err := m.Insert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDuplicateKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OnDuplicateKey == nil {
				m.OnDuplicateKey = &OnDuplicateKey{}
			}
			if err := m.OnDuplicateKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreInsert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreInsert == nil {
				m.PreInsert = &PreInsert{}
			}
			if err := m.PreInsert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreInsertUnique", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreInsertUnique == nil {
				m.PreInsertUnique = &PreInsertUnique{}
			}
			if err := m.PreInsertUnique.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBy = append(m.OrderBy, &plan.OrderBySpec{})
			if err := m.OrderBy[len(m.OrderBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectList = append(m.ProjectList, &plan.Expr{})
			if err := m.ProjectList[len(m.ProjectList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &plan.Expr{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limit == nil {
				m.Limit = &plan.Expr{}
			}
			if err := m.Limit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Offset == nil {
				m.Offset = &plan.Expr{}
			}
			if err := m.Offset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFirst", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFirst = bool(v != 0)
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLast = bool(v != 0)
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightJoin == nil {
				m.RightJoin = &RightJoin{}
			}
			if err := m.RightJoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightSemiJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightSemiJoin == nil {
				m.RightSemiJoin = &RightSemiJoin{}
			}
			if err := m.RightSemiJoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightAntiJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightAntiJoin == nil {
				m.RightAntiJoin = &RightAntiJoin{}
			}
			if err := m.RightAntiJoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delete == nil {
				m.Delete = &Deletion{}
			}
			if err := m.Delete.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LockOp == nil {
				m.LockOp = &LockOp{}
			}
			if err := m.LockOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shuffle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shuffle == nil {
				m.Shuffle = &Shuffle{}
			}
			if err := m.Shuffle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Merge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Merge == nil {
				m.Merge = &Merge{}
			}
			if err := m.Merge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamScan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StreamScan == nil {
				m.StreamScan = &StreamScan{}
			}
			if err := m.StreamScan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreInsertSecondaryIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreInsertSecondaryIndex == nil {
				m.PreInsertSecondaryIndex = &PreInsertSecondaryIndex{}
			}
			if err := m.PreInsertSecondaryIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleFunc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SampleFunc == nil {
				m.SampleFunc = &SampleFunc{}
			}
			if err := m.SampleFunc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuzzyFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FuzzyFilter == nil {
				m.FuzzyFilter = &FuzzyFilter{}
			}
			if err := m.FuzzyFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CnAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CnAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorId", wireType)
			}
			m.OperatorId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperatorId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParallelId", wireType)
			}
			m.ParallelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParallelId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxParallel", wireType)
			}
			m.MaxParallel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxParallel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IndexJoin == nil {
				m.IndexJoin = &IndexJoin{}
			}
			if err := m.IndexJoin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductL2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProductL2 == nil {
				m.ProductL2 = &ProductL2{}
			}
			if err := m.ProductL2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableScan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableScan == nil {
				m.TableScan = &TableScan{}
			}
			if err := m.TableScan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueScan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValueScan == nil {
				m.ValueScan = &ValueScan{}
			}
			if err := m.ValueScan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnionAll", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnionAll == nil {
				m.UnionAll = &UnionAll{}
			}
			if err := m.UnionAll.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashBuild", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HashBuild == nil {
				m.HashBuild = &HashBuild{}
			}
			if err := m.HashBuild.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleBuild", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShuffleBuild == nil {
				m.ShuffleBuild = &Shufflebuild{}
			}
			if err := m.ShuffleBuild.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexBuild", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IndexBuild == nil {
				m.IndexBuild = &Indexbuild{}
			}
			if err := m.IndexBuild.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Apply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Apply == nil {
				m.Apply = &Apply{}
			}
			if err := m.Apply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnalysisList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalysisList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalysisList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &plan.AnalyzeInfo{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Source) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Source: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Source: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColList = append(m.ColList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Block = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushdownId", wireType)
			}
			m.PushdownId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PushdownId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushdownAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PushdownAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &plan.Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &plan.TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &timestamp.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterProbeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterProbeList = append(m.RuntimeFilterProbeList, &plan.RuntimeFilterSpec{})
			if err := m.RuntimeFilterProbeList[len(m.RuntimeFilterProbeList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsConst", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsConst = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mcpu", wireType)
			}
			m.Mcpu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mcpu |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessLimitation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessLimitation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessLimitation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size", wireType)
			}
			m.Size = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchRows", wireType)
			}
			m.BatchRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchRows |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSize", wireType)
			}
			m.BatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionRows", wireType)
			}
			m.PartitionRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionRows |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReaderSize", wireType)
			}
			m.ReaderSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReaderSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepareParamInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrepareParamInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrepareParamInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Area = append(m.Area[:0], dAtA[iNdEx:postIndex]...)
			if m.Area == nil {
				m.Area = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Nulls = append(m.Nulls, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.Nulls) == 0 {
					m.Nulls = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Nulls = append(m.Nulls, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Nulls", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Lim.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnixTime", wireType)
			}
			m.UnixTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnixTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			m.AccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Snapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SessionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionLogger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SessionLogger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrepareParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionId", wireType)
			}
			m.ConnectionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeZone", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimeZone = append(m.TimeZone[:0], dAtA[iNdEx:postIndex]...)
			if m.TimeZone == nil {
				m.TimeZone = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryId = append(m.QueryId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionLoggerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionLoggerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionLoggerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessId = append(m.SessId[:0], dAtA[iNdEx:postIndex]...)
			if m.SessId == nil {
				m.SessId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StmtId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StmtId = append(m.StmtId[:0], dAtA[iNdEx:postIndex]...)
			if m.StmtId == nil {
				m.StmtId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxnId = append(m.TxnId[:0], dAtA[iNdEx:postIndex]...)
			if m.TxnId == nil {
				m.TxnId = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogLevel", wireType)
			}
			m.LogLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogLevel |= SessionLoggerInfo_LogLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pipeline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pipeline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pipeline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineType", wireType)
			}
			m.PipelineType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PipelineType |= Pipeline_PipelineType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineId", wireType)
			}
			m.PipelineId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PipelineId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Qry == nil {
				m.Qry = &plan.Plan{}
			}
			if err := m.Qry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataSource == nil {
				m.DataSource = &Source{}
			}
			if err := m.DataSource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &Pipeline{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstructionList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstructionList = append(m.InstructionList, &Instruction{})
			if err := m.InstructionList[len(m.InstructionList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEnd = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLoad", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLoad = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &NodeInfo{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushDownInfo", wireType)
			}
			m.PushDownInfo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PushDownInfo |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildrenCount", wireType)
			}
			m.ChildrenCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChildrenCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ChannelBufferSize = append(m.ChannelBufferSize, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ChannelBufferSize) == 0 {
					m.ChannelBufferSize = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ChannelBufferSize = append(m.ChannelBufferSize, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelBufferSize", wireType)
			}
		case 13:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NilBatchCnt = append(m.NilBatchCnt, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NilBatchCnt) == 0 {
					m.NilBatchCnt = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NilBatchCnt = append(m.NilBatchCnt, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NilBatchCnt", wireType)
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UuidsToRegIdx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UuidsToRegIdx = append(m.UuidsToRegIdx, &UuidToRegIdx{})
			if err := m.UuidsToRegIdx[len(m.UuidsToRegIdx)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WrapNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WrapNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WrapNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UuidToRegIdx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UuidToRegIdx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UuidToRegIdx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Apply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Apply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Apply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyType", wireType)
			}
			m.ApplyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelList = append(m.RelList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelList) == 0 {
					m.RelList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelList = append(m.RelList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelList", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColList = append(m.ColList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPipeline
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPipeline
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPipeline
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColList) == 0 {
					m.ColList = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPipeline
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColList = append(m.ColList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColList", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, plan.Type{})
			if err := m.Types[len(m.Types)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPipeline(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPipeline
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPipeline
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPipeline
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPipeline        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPipeline          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPipeline = fmt.Errorf("proto: unexpected end of group")
)
