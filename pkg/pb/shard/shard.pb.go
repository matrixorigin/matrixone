// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: shard.proto

package shard

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Policy shard policy for a table.
type Policy int32

const (
	// None no sharding for the current table.
	Policy_None Policy = 0
	// Partition the user-defined way of sharding data for a partitioned table.
	//
	// The number of Shards is determined when the table is created. It does not
	// change with the number of CN nodes in the MO cluster.
	//
	// The number of shards is only changed when the user changes the table definition
	// by using alter table.
	//
	// len(Shards) == len(Partitions).
	Policy_Partition Policy = 1
	// Hash auto-sharding data in a way that is based on primary key hash.
	//
	// In this mode, the number of shards of the table changes with the number of
	// nodes of CN in the mo cluster. len(shards) >= len(CN nodes).
	Policy_Hash Policy = 2
)

var Policy_name = map[int32]string{
	0: "None",
	1: "Partition",
	2: "Hash",
}

var Policy_value = map[string]int32{
	"None":      0,
	"Partition": 1,
	"Hash":      2,
}

func (x Policy) String() string {
	return proto.EnumName(Policy_name, int32(x))
}

func (Policy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{0}
}

// CmdType cmd type. Add or remove shard
type CmdType int32

const (
	CmdType_AddShard    CmdType = 0
	CmdType_DeleteShard CmdType = 1
	CmdType_DeleteALL   CmdType = 2
)

var CmdType_name = map[int32]string{
	0: "AddShard",
	1: "DeleteShard",
	2: "DeleteALL",
}

var CmdType_value = map[string]int32{
	"AddShard":    0,
	"DeleteShard": 1,
	"DeleteALL":   2,
}

func (x CmdType) String() string {
	return proto.EnumName(CmdType_name, int32(x))
}

func (CmdType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{1}
}

type CNState int32

const (
	CNState_Up   CNState = 0
	CNState_Down CNState = 1
)

var CNState_name = map[int32]string{
	0: "Up",
	1: "Down",
}

var CNState_value = map[string]int32{
	"Up":   0,
	"Down": 1,
}

func (x CNState) String() string {
	return proto.EnumName(CNState_name, int32(x))
}

func (CNState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{2}
}

type ShardState int32

const (
	ShardState_Allocating ShardState = 0
	ShardState_Allocated  ShardState = 1
	ShardState_Running    ShardState = 2
	ShardState_Tombstone  ShardState = 3
)

var ShardState_name = map[int32]string{
	0: "Allocating",
	1: "Allocated",
	2: "Running",
	3: "Tombstone",
}

var ShardState_value = map[string]int32{
	"Allocating": 0,
	"Allocated":  1,
	"Running":    2,
	"Tombstone":  3,
}

func (x ShardState) String() string {
	return proto.EnumName(ShardState_name, int32(x))
}

func (ShardState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{3}
}

// Method sharding operations
type Method int32

const (
	Method_Heartbeat    Method = 0
	Method_CreateShards Method = 1
	Method_DeleteShards Method = 2
)

var Method_name = map[int32]string{
	0: "Heartbeat",
	1: "CreateShards",
	2: "DeleteShards",
}

var Method_value = map[string]int32{
	"Heartbeat":    0,
	"CreateShards": 1,
	"DeleteShards": 2,
}

func (x Method) String() string {
	return proto.EnumName(Method_name, int32(x))
}

func (Method) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{4}
}

// TableShards table shards metadata. When a Table is created, metadata for the
// corresponding shards is created and serialized and stored in MO_TABLES.
type TableShards struct {
	Policy               Policy   `protobuf:"varint,1,opt,name=Policy,proto3,enum=shard.Policy" json:"Policy,omitempty"`
	ShardsCount          uint32   `protobuf:"varint,2,opt,name=ShardsCount,proto3" json:"ShardsCount,omitempty"`
	Version              uint32   `protobuf:"varint,3,opt,name=Version,proto3" json:"Version,omitempty"`
	TenantID             uint32   `protobuf:"varint,4,opt,name=TenantID,proto3" json:"TenantID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TableShards) Reset()         { *m = TableShards{} }
func (m *TableShards) String() string { return proto.CompactTextString(m) }
func (*TableShards) ProtoMessage()    {}
func (*TableShards) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{0}
}
func (m *TableShards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableShards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableShards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableShards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableShards.Merge(m, src)
}
func (m *TableShards) XXX_Size() int {
	return m.Size()
}
func (m *TableShards) XXX_DiscardUnknown() {
	xxx_messageInfo_TableShards.DiscardUnknown(m)
}

var xxx_messageInfo_TableShards proto.InternalMessageInfo

func (m *TableShards) GetPolicy() Policy {
	if m != nil {
		return m.Policy
	}
	return Policy_None
}

func (m *TableShards) GetShardsCount() uint32 {
	if m != nil {
		return m.ShardsCount
	}
	return 0
}

func (m *TableShards) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *TableShards) GetTenantID() uint32 {
	if m != nil {
		return m.TenantID
	}
	return 0
}

// TableShard when TableShards are created, the Shards corresponding to a table
// are determined, and each Shard is assigned a corresponding CN node to handle requests
// for that Shard.
//
// The binding relationship between CN and Shard changes dynamically during the runtime, and
// presumably if the corresponding CN goes offline, or if a new CN comes online and causes
// an imbalance between Shard and CN, then the binding relationship will be readjusted.
//
// When the Table's shards count changed, the corresponding Version field increments itself.
// This makes it easy to found expired information.
type TableShard struct {
	TableID uint64 `protobuf:"varint,1,opt,name=TableID,proto3" json:"TableID,omitempty"`
	ShardID uint64 `protobuf:"varint,2,opt,name=ShardID,proto3" json:"ShardID,omitempty"`
	CN      string `protobuf:"bytes,3,opt,name=CN,proto3" json:"CN,omitempty"`
	// Version incrments when shards count changed
	ShardsVersion uint32 `protobuf:"varint,4,opt,name=ShardsVersion,proto3" json:"ShardsVersion,omitempty"`
	// BindVersion incrments when the cn changed
	BindVersion          uint32     `protobuf:"varint,5,opt,name=BindVersion,proto3" json:"BindVersion,omitempty"`
	State                ShardState `protobuf:"varint,6,opt,name=State,proto3,enum=shard.ShardState" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *TableShard) Reset()         { *m = TableShard{} }
func (m *TableShard) String() string { return proto.CompactTextString(m) }
func (*TableShard) ProtoMessage()    {}
func (*TableShard) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{1}
}
func (m *TableShard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableShard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableShard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableShard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableShard.Merge(m, src)
}
func (m *TableShard) XXX_Size() int {
	return m.Size()
}
func (m *TableShard) XXX_DiscardUnknown() {
	xxx_messageInfo_TableShard.DiscardUnknown(m)
}

var xxx_messageInfo_TableShard proto.InternalMessageInfo

func (m *TableShard) GetTableID() uint64 {
	if m != nil {
		return m.TableID
	}
	return 0
}

func (m *TableShard) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *TableShard) GetCN() string {
	if m != nil {
		return m.CN
	}
	return ""
}

func (m *TableShard) GetShardsVersion() uint32 {
	if m != nil {
		return m.ShardsVersion
	}
	return 0
}

func (m *TableShard) GetBindVersion() uint32 {
	if m != nil {
		return m.BindVersion
	}
	return 0
}

func (m *TableShard) GetState() ShardState {
	if m != nil {
		return m.State
	}
	return ShardState_Allocating
}

type Request struct {
	RequestID            uint64              `protobuf:"varint,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	RPCMethod            Method              `protobuf:"varint,2,opt,name=RPCMethod,proto3,enum=shard.Method" json:"RPCMethod,omitempty"`
	CreateShards         CreateShardsRequest `protobuf:"bytes,3,opt,name=CreateShards,proto3" json:"CreateShards"`
	DeleteShards         DeleteShardsRequest `protobuf:"bytes,4,opt,name=DeleteShards,proto3" json:"DeleteShards"`
	Heartbeat            HeartbeatRequest    `protobuf:"bytes,5,opt,name=Heartbeat,proto3" json:"Heartbeat"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{2}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetRequestID() uint64 {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *Request) GetRPCMethod() Method {
	if m != nil {
		return m.RPCMethod
	}
	return Method_Heartbeat
}

func (m *Request) GetCreateShards() CreateShardsRequest {
	if m != nil {
		return m.CreateShards
	}
	return CreateShardsRequest{}
}

func (m *Request) GetDeleteShards() DeleteShardsRequest {
	if m != nil {
		return m.DeleteShards
	}
	return DeleteShardsRequest{}
}

func (m *Request) GetHeartbeat() HeartbeatRequest {
	if m != nil {
		return m.Heartbeat
	}
	return HeartbeatRequest{}
}

type Response struct {
	RequestID uint64 `protobuf:"varint,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	RPCMethod Method `protobuf:"varint,2,opt,name=RPCMethod,proto3,enum=shard.Method" json:"RPCMethod,omitempty"`
	// Error we use this field to send moerr from service to another cn. Set with
	// moerr.MarshalBinary, and use moerr.UnmarshalBinary to restore moerr.
	Error                []byte               `protobuf:"bytes,3,opt,name=Error,proto3" json:"Error,omitempty"`
	CreateShards         CreateShardsResponse `protobuf:"bytes,4,opt,name=CreateShards,proto3" json:"CreateShards"`
	DeleteShards         DeleteShardsResponse `protobuf:"bytes,5,opt,name=DeleteShards,proto3" json:"DeleteShards"`
	Heartbeat            HeartbeatResponse    `protobuf:"bytes,6,opt,name=Heartbeat,proto3" json:"Heartbeat"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{3}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetRequestID() uint64 {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *Response) GetRPCMethod() Method {
	if m != nil {
		return m.RPCMethod
	}
	return Method_Heartbeat
}

func (m *Response) GetError() []byte {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *Response) GetCreateShards() CreateShardsResponse {
	if m != nil {
		return m.CreateShards
	}
	return CreateShardsResponse{}
}

func (m *Response) GetDeleteShards() DeleteShardsResponse {
	if m != nil {
		return m.DeleteShards
	}
	return DeleteShardsResponse{}
}

func (m *Response) GetHeartbeat() HeartbeatResponse {
	if m != nil {
		return m.Heartbeat
	}
	return HeartbeatResponse{}
}

type Cmd struct {
	Type                 CmdType    `protobuf:"varint,1,opt,name=Type,proto3,enum=shard.CmdType" json:"Type,omitempty"`
	TableShard           TableShard `protobuf:"bytes,2,opt,name=TableShard,proto3" json:"TableShard"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Cmd) Reset()         { *m = Cmd{} }
func (m *Cmd) String() string { return proto.CompactTextString(m) }
func (*Cmd) ProtoMessage()    {}
func (*Cmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{4}
}
func (m *Cmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cmd.Merge(m, src)
}
func (m *Cmd) XXX_Size() int {
	return m.Size()
}
func (m *Cmd) XXX_DiscardUnknown() {
	xxx_messageInfo_Cmd.DiscardUnknown(m)
}

var xxx_messageInfo_Cmd proto.InternalMessageInfo

func (m *Cmd) GetType() CmdType {
	if m != nil {
		return m.Type
	}
	return CmdType_AddShard
}

func (m *Cmd) GetTableShard() TableShard {
	if m != nil {
		return m.TableShard
	}
	return TableShard{}
}

type CreateShardsRequest struct {
	ID                   uint64      `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	TableShards          TableShards `protobuf:"bytes,2,opt,name=TableShards,proto3" json:"TableShards"`
	PhysicalShardIDs     []uint64    `protobuf:"varint,3,rep,packed,name=PhysicalShardIDs,proto3" json:"PhysicalShardIDs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *CreateShardsRequest) Reset()         { *m = CreateShardsRequest{} }
func (m *CreateShardsRequest) String() string { return proto.CompactTextString(m) }
func (*CreateShardsRequest) ProtoMessage()    {}
func (*CreateShardsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{5}
}
func (m *CreateShardsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateShardsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateShardsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateShardsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateShardsRequest.Merge(m, src)
}
func (m *CreateShardsRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateShardsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateShardsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateShardsRequest proto.InternalMessageInfo

func (m *CreateShardsRequest) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *CreateShardsRequest) GetTableShards() TableShards {
	if m != nil {
		return m.TableShards
	}
	return TableShards{}
}

func (m *CreateShardsRequest) GetPhysicalShardIDs() []uint64 {
	if m != nil {
		return m.PhysicalShardIDs
	}
	return nil
}

type CreateShardsResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateShardsResponse) Reset()         { *m = CreateShardsResponse{} }
func (m *CreateShardsResponse) String() string { return proto.CompactTextString(m) }
func (*CreateShardsResponse) ProtoMessage()    {}
func (*CreateShardsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{6}
}
func (m *CreateShardsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateShardsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateShardsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateShardsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateShardsResponse.Merge(m, src)
}
func (m *CreateShardsResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateShardsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateShardsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateShardsResponse proto.InternalMessageInfo

type DeleteShardsRequest struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteShardsRequest) Reset()         { *m = DeleteShardsRequest{} }
func (m *DeleteShardsRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteShardsRequest) ProtoMessage()    {}
func (*DeleteShardsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{7}
}
func (m *DeleteShardsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteShardsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteShardsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteShardsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteShardsRequest.Merge(m, src)
}
func (m *DeleteShardsRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteShardsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteShardsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteShardsRequest proto.InternalMessageInfo

func (m *DeleteShardsRequest) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type DeleteShardsResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteShardsResponse) Reset()         { *m = DeleteShardsResponse{} }
func (m *DeleteShardsResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteShardsResponse) ProtoMessage()    {}
func (*DeleteShardsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{8}
}
func (m *DeleteShardsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteShardsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteShardsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteShardsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteShardsResponse.Merge(m, src)
}
func (m *DeleteShardsResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteShardsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteShardsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteShardsResponse proto.InternalMessageInfo

type HeartbeatRequest struct {
	CN                   string       `protobuf:"bytes,1,opt,name=CN,proto3" json:"CN,omitempty"`
	Shards               []TableShard `protobuf:"bytes,2,rep,name=Shards,proto3" json:"Shards"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *HeartbeatRequest) Reset()         { *m = HeartbeatRequest{} }
func (m *HeartbeatRequest) String() string { return proto.CompactTextString(m) }
func (*HeartbeatRequest) ProtoMessage()    {}
func (*HeartbeatRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{9}
}
func (m *HeartbeatRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartbeatRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeartbeatRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeartbeatRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartbeatRequest.Merge(m, src)
}
func (m *HeartbeatRequest) XXX_Size() int {
	return m.Size()
}
func (m *HeartbeatRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartbeatRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HeartbeatRequest proto.InternalMessageInfo

func (m *HeartbeatRequest) GetCN() string {
	if m != nil {
		return m.CN
	}
	return ""
}

func (m *HeartbeatRequest) GetShards() []TableShard {
	if m != nil {
		return m.Shards
	}
	return nil
}

type HeartbeatResponse struct {
	CMDs                 []Cmd    `protobuf:"bytes,1,rep,name=CMDs,proto3" json:"CMDs"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HeartbeatResponse) Reset()         { *m = HeartbeatResponse{} }
func (m *HeartbeatResponse) String() string { return proto.CompactTextString(m) }
func (*HeartbeatResponse) ProtoMessage()    {}
func (*HeartbeatResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{10}
}
func (m *HeartbeatResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartbeatResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeartbeatResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeartbeatResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartbeatResponse.Merge(m, src)
}
func (m *HeartbeatResponse) XXX_Size() int {
	return m.Size()
}
func (m *HeartbeatResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartbeatResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HeartbeatResponse proto.InternalMessageInfo

func (m *HeartbeatResponse) GetCMDs() []Cmd {
	if m != nil {
		return m.CMDs
	}
	return nil
}

func init() {
	proto.RegisterEnum("shard.Policy", Policy_name, Policy_value)
	proto.RegisterEnum("shard.CmdType", CmdType_name, CmdType_value)
	proto.RegisterEnum("shard.CNState", CNState_name, CNState_value)
	proto.RegisterEnum("shard.ShardState", ShardState_name, ShardState_value)
	proto.RegisterEnum("shard.Method", Method_name, Method_value)
	proto.RegisterType((*TableShards)(nil), "shard.TableShards")
	proto.RegisterType((*TableShard)(nil), "shard.TableShard")
	proto.RegisterType((*Request)(nil), "shard.Request")
	proto.RegisterType((*Response)(nil), "shard.Response")
	proto.RegisterType((*Cmd)(nil), "shard.Cmd")
	proto.RegisterType((*CreateShardsRequest)(nil), "shard.CreateShardsRequest")
	proto.RegisterType((*CreateShardsResponse)(nil), "shard.CreateShardsResponse")
	proto.RegisterType((*DeleteShardsRequest)(nil), "shard.DeleteShardsRequest")
	proto.RegisterType((*DeleteShardsResponse)(nil), "shard.DeleteShardsResponse")
	proto.RegisterType((*HeartbeatRequest)(nil), "shard.HeartbeatRequest")
	proto.RegisterType((*HeartbeatResponse)(nil), "shard.HeartbeatResponse")
}

func init() { proto.RegisterFile("shard.proto", fileDescriptor_319ea41e44cdc364) }

var fileDescriptor_319ea41e44cdc364 = []byte{
	// 779 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0xd6, 0x52, 0xd4, 0xdf, 0xd0, 0x52, 0xe9, 0xb5, 0xd1, 0x12, 0x76, 0xa1, 0x1a, 0x84, 0x8d,
	0x1a, 0x32, 0x2a, 0x01, 0xee, 0xc1, 0x68, 0xdd, 0x43, 0x6d, 0xd2, 0xa8, 0x05, 0xd8, 0x82, 0x40,
	0xab, 0x3d, 0xf4, 0x46, 0x4a, 0x5b, 0x89, 0xa8, 0xc4, 0x55, 0xc9, 0x15, 0x1a, 0xbf, 0x43, 0xf2,
	0x08, 0x79, 0x8e, 0x9c, 0x73, 0xf3, 0xd1, 0x4f, 0x10, 0x24, 0x7e, 0x92, 0x60, 0x97, 0xcb, 0x3f,
	0x49, 0xc8, 0x29, 0x37, 0xce, 0x7c, 0x3b, 0xdf, 0xcc, 0x7c, 0xb3, 0x3b, 0x04, 0x2d, 0x9a, 0xb9,
	0xe1, 0xa4, 0xbb, 0x0c, 0x29, 0xa3, 0xb8, 0x22, 0x8c, 0x83, 0x9f, 0xa6, 0x3e, 0x9b, 0xad, 0xbc,
	0xee, 0x98, 0x2e, 0x7a, 0x53, 0x3a, 0xa5, 0x3d, 0x81, 0x7a, 0xab, 0x7f, 0x84, 0x25, 0x0c, 0xf1,
	0x15, 0x47, 0x99, 0xaf, 0x11, 0x68, 0x23, 0xd7, 0x9b, 0x93, 0x07, 0x1e, 0x1d, 0xe1, 0x13, 0xa8,
	0x0e, 0xe9, 0xdc, 0x1f, 0x3f, 0x1a, 0xe8, 0x08, 0x9d, 0xb6, 0xce, 0x9b, 0xdd, 0x38, 0x47, 0xec,
	0x74, 0x24, 0x88, 0x8f, 0x40, 0x8b, 0x03, 0x2c, 0xba, 0x0a, 0x98, 0xa1, 0x1c, 0xa1, 0xd3, 0xa6,
	0x93, 0x77, 0x61, 0x03, 0x6a, 0x7f, 0x91, 0x30, 0xf2, 0x69, 0x60, 0x94, 0x05, 0x9a, 0x98, 0xf8,
	0x00, 0xea, 0x23, 0x12, 0xb8, 0x01, 0xeb, 0xdb, 0x86, 0x2a, 0xa0, 0xd4, 0x36, 0xdf, 0x23, 0x80,
	0xac, 0x1c, 0x4e, 0x22, 0xac, 0xbe, 0x2d, 0xca, 0x51, 0x9d, 0xc4, 0xe4, 0x88, 0x38, 0xd2, 0xb7,
	0x45, 0x72, 0xd5, 0x49, 0x4c, 0xdc, 0x02, 0xc5, 0x1a, 0x88, 0x9c, 0x0d, 0x47, 0xb1, 0x06, 0xf8,
	0x18, 0x9a, 0x71, 0x5d, 0x49, 0x39, 0x71, 0xce, 0xa2, 0x93, 0x37, 0x74, 0xed, 0x07, 0x93, 0xe4,
	0x4c, 0x25, 0x6e, 0x28, 0xe7, 0xc2, 0x3f, 0x42, 0xe5, 0x81, 0xb9, 0x8c, 0x18, 0x55, 0x21, 0xcc,
	0xae, 0x14, 0x46, 0xd0, 0x08, 0xc0, 0x89, 0x71, 0xf3, 0xad, 0x02, 0x35, 0x87, 0xfc, 0xb7, 0x22,
	0x11, 0xc3, 0xdf, 0x43, 0x43, 0x7e, 0xa6, 0x2d, 0x64, 0x0e, 0x7c, 0x06, 0x0d, 0x67, 0x68, 0xdd,
	0x13, 0x36, 0xa3, 0x13, 0xd1, 0x46, 0xa6, 0x77, 0xec, 0x74, 0x32, 0x1c, 0xdb, 0xb0, 0x63, 0x85,
	0xc4, 0x65, 0x72, 0x52, 0xa2, 0x43, 0xed, 0xfc, 0x40, 0x9e, 0xcf, 0x43, 0x32, 0xc1, 0xb5, 0xfa,
	0xf4, 0xe1, 0x87, 0x92, 0x53, 0x88, 0xe2, 0x2c, 0x36, 0x99, 0x93, 0x94, 0x45, 0x2d, 0xb0, 0xe4,
	0xa1, 0x35, 0x96, 0x3c, 0x84, 0x2f, 0xa1, 0x71, 0x4b, 0xdc, 0x90, 0x79, 0xc4, 0x65, 0x42, 0x2b,
	0xed, 0xfc, 0x3b, 0x49, 0x91, 0xfa, 0x8b, 0xf1, 0xd9, 0x79, 0xf3, 0x9d, 0x02, 0x75, 0x87, 0x44,
	0x4b, 0x1a, 0x44, 0xe4, 0x6b, 0x0a, 0xb4, 0x0f, 0x95, 0x9b, 0x30, 0xa4, 0xa1, 0x50, 0x66, 0xc7,
	0x89, 0x0d, 0x7c, 0xb3, 0x26, 0x5b, 0xdc, 0xf0, 0xe1, 0x56, 0xd9, 0xe2, 0x9a, 0xb6, 0xea, 0x76,
	0xb3, 0xa6, 0x5b, 0xa5, 0x40, 0x53, 0xd4, 0xad, 0x48, 0x53, 0x10, 0xee, 0xb7, 0xbc, 0x70, 0x55,
	0xc1, 0x61, 0x6c, 0x0a, 0x57, 0x20, 0xc8, 0x29, 0xe7, 0x41, 0xd9, 0x5a, 0x4c, 0xb0, 0x09, 0xea,
	0xe8, 0x71, 0x49, 0xe4, 0x0b, 0x6d, 0x25, 0xad, 0x2c, 0x26, 0xdc, 0xeb, 0x08, 0x0c, 0x5f, 0xe4,
	0xdf, 0x91, 0x90, 0x4e, 0x4b, 0xaf, 0x6c, 0x06, 0xc8, 0x14, 0xb9, 0xa3, 0xe6, 0x1b, 0x04, 0x7b,
	0x5b, 0x2e, 0x13, 0x7f, 0x56, 0xe9, 0x84, 0x94, 0xbe, 0x8d, 0x7f, 0x2d, 0xec, 0x0d, 0x99, 0x01,
	0x6f, 0x64, 0x88, 0x64, 0x8a, 0xc2, 0x92, 0xe9, 0x80, 0x3e, 0x9c, 0x3d, 0x46, 0xfe, 0xd8, 0x9d,
	0xcb, 0x57, 0xcb, 0xaf, 0x73, 0xf9, 0x54, 0x75, 0x36, 0xfc, 0xe6, 0xb7, 0xb0, 0xbf, 0x6d, 0x48,
	0xe6, 0x09, 0xec, 0x6d, 0xb9, 0xad, 0xeb, 0x65, 0xf2, 0xf0, 0x6d, 0xc3, 0x31, 0x1f, 0x40, 0x5f,
	0xbf, 0xa9, 0x72, 0x73, 0xa0, 0x74, 0x73, 0xf4, 0xa0, 0x9a, 0x76, 0x57, 0xfe, 0x92, 0x7e, 0xf2,
	0x98, 0xf9, 0x0b, 0xec, 0x6e, 0x4c, 0x11, 0x1f, 0x83, 0x6a, 0xdd, 0xdb, 0x91, 0x81, 0x04, 0x07,
	0x64, 0xd3, 0x92, 0xc1, 0x02, 0xed, 0x9c, 0x25, 0x7b, 0x17, 0xd7, 0x41, 0x1d, 0xd0, 0x80, 0xe8,
	0x25, 0xdc, 0x84, 0xc6, 0xd0, 0x0d, 0x99, 0xcf, 0x7c, 0x1a, 0xe8, 0x88, 0x03, 0xb7, 0x6e, 0x34,
	0xd3, 0x95, 0xce, 0x05, 0xd4, 0xe4, 0xb4, 0xf1, 0x0e, 0xd4, 0xaf, 0x26, 0x13, 0x91, 0x5f, 0x2f,
	0xe1, 0x6f, 0x40, 0xcb, 0x75, 0xab, 0x23, 0x4e, 0x11, 0x3b, 0xae, 0xee, 0xee, 0x74, 0xa5, 0x73,
	0x08, 0x35, 0x6b, 0x20, 0xb6, 0x14, 0xae, 0x82, 0xf2, 0xe7, 0x52, 0x2f, 0x71, 0x56, 0x9b, 0xfe,
	0x1f, 0xe8, 0xa8, 0xf3, 0x07, 0x40, 0xb6, 0xcc, 0x70, 0x0b, 0xe0, 0x6a, 0x3e, 0xa7, 0x63, 0x97,
	0xf9, 0xc1, 0x34, 0x2e, 0x46, 0xda, 0x84, 0x13, 0x6b, 0x50, 0x73, 0x56, 0x41, 0xc0, 0x31, 0x85,
	0x63, 0x23, 0xba, 0xf0, 0x22, 0xc6, 0xeb, 0x2e, 0x77, 0x2e, 0xa1, 0x2a, 0x9f, 0x64, 0x33, 0x77,
	0xdd, 0xf5, 0x12, 0xd6, 0x8b, 0x6f, 0x51, 0x47, 0xdc, 0x93, 0x1f, 0x8f, 0xae, 0x5c, 0xff, 0xfe,
	0xfc, 0xa9, 0x8d, 0x9e, 0x5e, 0xda, 0xe8, 0xf9, 0xa5, 0x8d, 0x3e, 0xbe, 0xb4, 0xd1, 0xdf, 0xdd,
	0xdc, 0x1f, 0x6d, 0xe1, 0xb2, 0xd0, 0x7f, 0x45, 0x43, 0x7f, 0xea, 0x07, 0x89, 0x11, 0x90, 0xde,
	0xf2, 0xdf, 0x69, 0x6f, 0xe9, 0xf5, 0x84, 0xb4, 0x5e, 0x55, 0xfc, 0xd9, 0x7e, 0xfe, 0x1c, 0x00,
	0x00, 0xff, 0xff, 0xff, 0xeb, 0x60, 0x2b, 0x1e, 0x07, 0x00, 0x00,
}

func (m *TableShards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableShards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableShards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TenantID != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.TenantID))
		i--
		dAtA[i] = 0x20
	}
	if m.Version != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if m.ShardsCount != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.ShardsCount))
		i--
		dAtA[i] = 0x10
	}
	if m.Policy != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.Policy))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableShard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableShard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableShard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x30
	}
	if m.BindVersion != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.BindVersion))
		i--
		dAtA[i] = 0x28
	}
	if m.ShardsVersion != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.ShardsVersion))
		i--
		dAtA[i] = 0x20
	}
	if len(m.CN) > 0 {
		i -= len(m.CN)
		copy(dAtA[i:], m.CN)
		i = encodeVarintShard(dAtA, i, uint64(len(m.CN)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ShardID != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Heartbeat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.DeleteShards.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.CreateShards.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.RPCMethod != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.RPCMethod))
		i--
		dAtA[i] = 0x10
	}
	if m.RequestID != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Heartbeat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.DeleteShards.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.CreateShards.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintShard(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RPCMethod != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.RPCMethod))
		i--
		dAtA[i] = 0x10
	}
	if m.RequestID != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Cmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.TableShard.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Type != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateShardsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateShardsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateShardsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PhysicalShardIDs) > 0 {
		dAtA9 := make([]byte, len(m.PhysicalShardIDs)*10)
		var j8 int
		for _, num := range m.PhysicalShardIDs {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintShard(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.TableShards.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.ID != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateShardsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateShardsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateShardsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeleteShardsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteShardsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteShardsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteShardsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteShardsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteShardsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *HeartbeatRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartbeatRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeartbeatRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Shards) > 0 {
		for iNdEx := len(m.Shards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Shards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CN) > 0 {
		i -= len(m.CN)
		copy(dAtA[i:], m.CN)
		i = encodeVarintShard(dAtA, i, uint64(len(m.CN)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HeartbeatResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartbeatResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeartbeatResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CMDs) > 0 {
		for iNdEx := len(m.CMDs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CMDs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintShard(dAtA []byte, offset int, v uint64) int {
	offset -= sovShard(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TableShards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Policy != 0 {
		n += 1 + sovShard(uint64(m.Policy))
	}
	if m.ShardsCount != 0 {
		n += 1 + sovShard(uint64(m.ShardsCount))
	}
	if m.Version != 0 {
		n += 1 + sovShard(uint64(m.Version))
	}
	if m.TenantID != 0 {
		n += 1 + sovShard(uint64(m.TenantID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableShard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovShard(uint64(m.TableID))
	}
	if m.ShardID != 0 {
		n += 1 + sovShard(uint64(m.ShardID))
	}
	l = len(m.CN)
	if l > 0 {
		n += 1 + l + sovShard(uint64(l))
	}
	if m.ShardsVersion != 0 {
		n += 1 + sovShard(uint64(m.ShardsVersion))
	}
	if m.BindVersion != 0 {
		n += 1 + sovShard(uint64(m.BindVersion))
	}
	if m.State != 0 {
		n += 1 + sovShard(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestID != 0 {
		n += 1 + sovShard(uint64(m.RequestID))
	}
	if m.RPCMethod != 0 {
		n += 1 + sovShard(uint64(m.RPCMethod))
	}
	l = m.CreateShards.Size()
	n += 1 + l + sovShard(uint64(l))
	l = m.DeleteShards.Size()
	n += 1 + l + sovShard(uint64(l))
	l = m.Heartbeat.Size()
	n += 1 + l + sovShard(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestID != 0 {
		n += 1 + sovShard(uint64(m.RequestID))
	}
	if m.RPCMethod != 0 {
		n += 1 + sovShard(uint64(m.RPCMethod))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovShard(uint64(l))
	}
	l = m.CreateShards.Size()
	n += 1 + l + sovShard(uint64(l))
	l = m.DeleteShards.Size()
	n += 1 + l + sovShard(uint64(l))
	l = m.Heartbeat.Size()
	n += 1 + l + sovShard(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovShard(uint64(m.Type))
	}
	l = m.TableShard.Size()
	n += 1 + l + sovShard(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateShardsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovShard(uint64(m.ID))
	}
	l = m.TableShards.Size()
	n += 1 + l + sovShard(uint64(l))
	if len(m.PhysicalShardIDs) > 0 {
		l = 0
		for _, e := range m.PhysicalShardIDs {
			l += sovShard(uint64(e))
		}
		n += 1 + sovShard(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateShardsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteShardsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovShard(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteShardsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeartbeatRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CN)
	if l > 0 {
		n += 1 + l + sovShard(uint64(l))
	}
	if len(m.Shards) > 0 {
		for _, e := range m.Shards {
			l = e.Size()
			n += 1 + l + sovShard(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeartbeatResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CMDs) > 0 {
		for _, e := range m.CMDs {
			l = e.Size()
			n += 1 + l + sovShard(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovShard(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozShard(x uint64) (n int) {
	return sovShard(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TableShards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableShards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableShards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			m.Policy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Policy |= Policy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardsCount", wireType)
			}
			m.ShardsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardsCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantID", wireType)
			}
			m.TenantID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableShard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableShard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableShard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardsVersion", wireType)
			}
			m.ShardsVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardsVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindVersion", wireType)
			}
			m.BindVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BindVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ShardState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RPCMethod", wireType)
			}
			m.RPCMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RPCMethod |= Method(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateShards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DeleteShards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Heartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RPCMethod", wireType)
			}
			m.RPCMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RPCMethod |= Method(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = append(m.Error[:0], dAtA[iNdEx:postIndex]...)
			if m.Error == nil {
				m.Error = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateShards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DeleteShards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Heartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= CmdType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableShard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TableShard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateShardsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateShardsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateShardsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TableShards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowShard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PhysicalShardIDs = append(m.PhysicalShardIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowShard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthShard
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthShard
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PhysicalShardIDs) == 0 {
					m.PhysicalShardIDs = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowShard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PhysicalShardIDs = append(m.PhysicalShardIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalShardIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateShardsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateShardsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateShardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteShardsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteShardsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteShardsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteShardsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteShardsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteShardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartbeatRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartbeatRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartbeatRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, TableShard{})
			if err := m.Shards[len(m.Shards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartbeatResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartbeatResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartbeatResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CMDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CMDs = append(m.CMDs, Cmd{})
			if err := m.CMDs[len(m.CMDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipShard(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowShard
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowShard
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowShard
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthShard
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupShard
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthShard
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthShard        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowShard          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupShard = fmt.Errorf("proto: unexpected end of group")
)
