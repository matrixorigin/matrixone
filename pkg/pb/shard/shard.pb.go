// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: shard.proto

package shard

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Policy shard policy for a table.
type Policy int32

const (
	// None no sharding for the current table.
	Policy_None Policy = 0
	// Partition the user-defined way of sharding data for a partitioned table.
	//
	// The number of Shards is determined when the table is created. It does not
	// change with the number of CN nodes in the MO cluster.
	//
	// The number of shards is only changed when the user changes the table definition
	// by using alter table.
	//
	// len(Shards) == len(Partitions).
	Policy_Partition Policy = 1
	// Hash auto-sharding data in a way that is based on primary key hash.
	//
	// In this mode, the number of shards of the table changes with the number of
	// nodes of CN in the mo cluster. len(shards) >= len(CN nodes).
	Policy_Hash Policy = 2
)

var Policy_name = map[int32]string{
	0: "None",
	1: "Partition",
	2: "Hash",
}

var Policy_value = map[string]int32{
	"None":      0,
	"Partition": 1,
	"Hash":      2,
}

func (x Policy) String() string {
	return proto.EnumName(Policy_name, int32(x))
}

func (Policy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{0}
}

type CmdType int32

const (
	CmdType_AddShard    CmdType = 0
	CmdType_DeleteShard CmdType = 1
)

var CmdType_name = map[int32]string{
	0: "AddShard",
	1: "DeleteShard",
}

var CmdType_value = map[string]int32{
	"AddShard":    0,
	"DeleteShard": 1,
}

func (x CmdType) String() string {
	return proto.EnumName(CmdType_name, int32(x))
}

func (CmdType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{1}
}

// Method sharding operations
type Method int32

const (
	// Heartbeat heartbeat method
	Method_Heartbeat Method = 0
	// GetShardBinds get table bind shards
	Method_GetShardBinds Method = 1
)

var Method_name = map[int32]string{
	0: "Heartbeat",
	1: "GetShardBinds",
}

var Method_value = map[string]int32{
	"Heartbeat":     0,
	"GetShardBinds": 1,
}

func (x Method) String() string {
	return proto.EnumName(Method_name, int32(x))
}

func (Method) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{2}
}

// TableShards table shards metadata. When a Table is created, metadata for the
// corresponding shards is created and serialized and stored in MO_TABLES.
type TableShards struct {
	Policy               Policy   `protobuf:"varint,1,opt,name=Policy,proto3,enum=shard.Policy" json:"Policy,omitempty"`
	ShardsCount          uint32   `protobuf:"varint,2,opt,name=ShardsCount,proto3" json:"ShardsCount,omitempty"`
	Version              uint32   `protobuf:"varint,3,opt,name=Version,proto3" json:"Version,omitempty"`
	TenantID             uint32   `protobuf:"varint,4,opt,name=TenantID,proto3" json:"TenantID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TableShards) Reset()         { *m = TableShards{} }
func (m *TableShards) String() string { return proto.CompactTextString(m) }
func (*TableShards) ProtoMessage()    {}
func (*TableShards) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{0}
}
func (m *TableShards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableShards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableShards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableShards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableShards.Merge(m, src)
}
func (m *TableShards) XXX_Size() int {
	return m.Size()
}
func (m *TableShards) XXX_DiscardUnknown() {
	xxx_messageInfo_TableShards.DiscardUnknown(m)
}

var xxx_messageInfo_TableShards proto.InternalMessageInfo

func (m *TableShards) GetPolicy() Policy {
	if m != nil {
		return m.Policy
	}
	return Policy_None
}

func (m *TableShards) GetShardsCount() uint32 {
	if m != nil {
		return m.ShardsCount
	}
	return 0
}

func (m *TableShards) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *TableShards) GetTenantID() uint32 {
	if m != nil {
		return m.TenantID
	}
	return 0
}

// TableShardBind when TableShards are created, the Shards corresponding to a table
// are determined, and each Shard is assigned a corresponding CN node to handle requests
// for that Shard.
//
// The binding relationship between CN and Shard changes dynamically during the runtime, and
// presumably if the corresponding CN goes offline, or if a new CN comes online and causes
// an imbalance between Shard and CN, then the binding relationship will be readjusted.
//
// When the Table's shards count changed, the corresponding Version field increments itself.
// This makes it easy to found expired information.
type TableShardBind struct {
	ShardID uint64 `protobuf:"varint,1,opt,name=ShardID,proto3" json:"ShardID,omitempty"`
	CN      string `protobuf:"bytes,2,opt,name=CN,proto3" json:"CN,omitempty"`
	// Version icrements when shards count changed
	ShardsVersion uint32 `protobuf:"varint,3,opt,name=ShardsVersion,proto3" json:"ShardsVersion,omitempty"`
	// BindVersion icrements when the cn changed
	BindVersion          uint32   `protobuf:"varint,4,opt,name=BindVersion,proto3" json:"BindVersion,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TableShardBind) Reset()         { *m = TableShardBind{} }
func (m *TableShardBind) String() string { return proto.CompactTextString(m) }
func (*TableShardBind) ProtoMessage()    {}
func (*TableShardBind) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{1}
}
func (m *TableShardBind) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableShardBind) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableShardBind.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableShardBind) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableShardBind.Merge(m, src)
}
func (m *TableShardBind) XXX_Size() int {
	return m.Size()
}
func (m *TableShardBind) XXX_DiscardUnknown() {
	xxx_messageInfo_TableShardBind.DiscardUnknown(m)
}

var xxx_messageInfo_TableShardBind proto.InternalMessageInfo

func (m *TableShardBind) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *TableShardBind) GetCN() string {
	if m != nil {
		return m.CN
	}
	return ""
}

func (m *TableShardBind) GetShardsVersion() uint32 {
	if m != nil {
		return m.ShardsVersion
	}
	return 0
}

func (m *TableShardBind) GetBindVersion() uint32 {
	if m != nil {
		return m.BindVersion
	}
	return 0
}

type Request struct {
	RequestID            uint64   `protobuf:"varint,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	Method               Method   `protobuf:"varint,3,opt,name=Method,proto3,enum=shard.Method" json:"Method,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{2}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetRequestID() uint64 {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *Request) GetMethod() Method {
	if m != nil {
		return m.Method
	}
	return Method_Heartbeat
}

type Response struct {
	RequestID uint64 `protobuf:"varint,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	Method    Method `protobuf:"varint,2,opt,name=Method,proto3,enum=shard.Method" json:"Method,omitempty"`
	// Error we use this field to send moerr from service to another cn. Set with
	// moerr.MarshalBinary, and use moerr.UnmarshalBinary to restore moerr.
	Error                []byte   `protobuf:"bytes,3,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{3}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetRequestID() uint64 {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *Response) GetMethod() Method {
	if m != nil {
		return m.Method
	}
	return Method_Heartbeat
}

func (m *Response) GetError() []byte {
	if m != nil {
		return m.Error
	}
	return nil
}

type Cmd struct {
	Type                 CmdType        `protobuf:"varint,1,opt,name=Type,proto3,enum=shard.CmdType" json:"Type,omitempty"`
	TableShardBind       TableShardBind `protobuf:"bytes,2,opt,name=TableShardBind,proto3" json:"TableShardBind"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Cmd) Reset()         { *m = Cmd{} }
func (m *Cmd) String() string { return proto.CompactTextString(m) }
func (*Cmd) ProtoMessage()    {}
func (*Cmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{4}
}
func (m *Cmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cmd.Merge(m, src)
}
func (m *Cmd) XXX_Size() int {
	return m.Size()
}
func (m *Cmd) XXX_DiscardUnknown() {
	xxx_messageInfo_Cmd.DiscardUnknown(m)
}

var xxx_messageInfo_Cmd proto.InternalMessageInfo

func (m *Cmd) GetType() CmdType {
	if m != nil {
		return m.Type
	}
	return CmdType_AddShard
}

func (m *Cmd) GetTableShardBind() TableShardBind {
	if m != nil {
		return m.TableShardBind
	}
	return TableShardBind{}
}

func init() {
	proto.RegisterEnum("shard.Policy", Policy_name, Policy_value)
	proto.RegisterEnum("shard.CmdType", CmdType_name, CmdType_value)
	proto.RegisterEnum("shard.Method", Method_name, Method_value)
	proto.RegisterType((*TableShards)(nil), "shard.TableShards")
	proto.RegisterType((*TableShardBind)(nil), "shard.TableShardBind")
	proto.RegisterType((*Request)(nil), "shard.Request")
	proto.RegisterType((*Response)(nil), "shard.Response")
	proto.RegisterType((*Cmd)(nil), "shard.Cmd")
}

func init() { proto.RegisterFile("shard.proto", fileDescriptor_319ea41e44cdc364) }

var fileDescriptor_319ea41e44cdc364 = []byte{
	// 467 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x53, 0xcd, 0x6e, 0xd3, 0x40,
	0x18, 0xcc, 0xba, 0x6e, 0x93, 0x7c, 0xae, 0x83, 0x59, 0x81, 0x64, 0x55, 0x28, 0x44, 0x16, 0x48,
	0x51, 0x10, 0xb1, 0x54, 0x5e, 0x00, 0xe2, 0x20, 0xda, 0x03, 0x51, 0xb5, 0x44, 0x1c, 0xb8, 0xd9,
	0xf5, 0xe2, 0x58, 0x24, 0xbb, 0x66, 0xbd, 0x91, 0xe8, 0x95, 0x33, 0x0f, 0xd6, 0x63, 0x9f, 0x00,
	0x41, 0x9e, 0x04, 0xf9, 0x5b, 0x3b, 0x3f, 0x3d, 0xa0, 0xde, 0x76, 0x66, 0xf6, 0x9b, 0x99, 0x7c,
	0x59, 0x83, 0x53, 0x2e, 0x62, 0x95, 0x8e, 0x0b, 0x25, 0xb5, 0xa4, 0xc7, 0x08, 0xce, 0x5e, 0x67,
	0xb9, 0x5e, 0xac, 0x93, 0xf1, 0xb5, 0x5c, 0x85, 0x99, 0xcc, 0x64, 0x88, 0x6a, 0xb2, 0xfe, 0x8a,
	0x08, 0x01, 0x9e, 0xcc, 0x54, 0xf0, 0x8b, 0x80, 0x33, 0x8f, 0x93, 0x25, 0xff, 0x54, 0x4d, 0x97,
	0xf4, 0x25, 0x9c, 0x5c, 0xc9, 0x65, 0x7e, 0x7d, 0xe3, 0x93, 0x01, 0x19, 0xf6, 0xce, 0xdd, 0xb1,
	0xc9, 0x30, 0x24, 0xab, 0x45, 0x3a, 0x00, 0xc7, 0x0c, 0x44, 0x72, 0x2d, 0xb4, 0x6f, 0x0d, 0xc8,
	0xd0, 0x65, 0xfb, 0x14, 0xf5, 0xa1, 0xfd, 0x99, 0xab, 0x32, 0x97, 0xc2, 0x3f, 0x42, 0xb5, 0x81,
	0xf4, 0x0c, 0x3a, 0x73, 0x2e, 0x62, 0xa1, 0x2f, 0xa7, 0xbe, 0x8d, 0xd2, 0x16, 0x07, 0x3f, 0x09,
	0xf4, 0x76, 0x75, 0x26, 0xb9, 0x48, 0x2b, 0x23, 0x04, 0x97, 0x53, 0xac, 0x64, 0xb3, 0x06, 0xd2,
	0x1e, 0x58, 0xd1, 0x0c, 0xb3, 0xbb, 0xcc, 0x8a, 0x66, 0xf4, 0x05, 0xb8, 0xa6, 0xc1, 0x61, 0xf0,
	0x21, 0x59, 0x55, 0xaf, 0x7c, 0x9b, 0x3b, 0xa6, 0xc1, 0x3e, 0x15, 0xcc, 0xa0, 0xcd, 0xf8, 0xf7,
	0x35, 0x2f, 0x35, 0x7d, 0x06, 0xdd, 0xfa, 0xb8, 0x8d, 0xdf, 0x11, 0xd5, 0xb2, 0x3e, 0x72, 0xbd,
	0x90, 0x29, 0x26, 0xed, 0x96, 0x65, 0x48, 0x56, 0x8b, 0x01, 0x87, 0x0e, 0xe3, 0x65, 0x21, 0x45,
	0xc9, 0x1f, 0x6c, 0x68, 0xfd, 0xc7, 0x90, 0x3e, 0x81, 0xe3, 0xf7, 0x4a, 0x49, 0x85, 0xb1, 0xa7,
	0xcc, 0x80, 0x40, 0xc0, 0x51, 0xb4, 0x4a, 0x69, 0x00, 0xf6, 0xfc, 0xa6, 0xe0, 0xf5, 0xff, 0xd7,
	0xab, 0x1d, 0xa2, 0x55, 0x5a, 0xb1, 0x0c, 0x35, 0x1a, 0xdd, 0xdf, 0x32, 0xe6, 0x39, 0xe7, 0x4f,
	0xeb, 0xdb, 0x87, 0xe2, 0xc4, 0xbe, 0xfd, 0xfd, 0xbc, 0xc5, 0xee, 0x8d, 0x8c, 0x5e, 0x35, 0x4f,
	0x85, 0x76, 0xc0, 0x9e, 0x49, 0xc1, 0xbd, 0x16, 0x75, 0xa1, 0x7b, 0x15, 0x2b, 0x9d, 0xeb, 0x5c,
	0x0a, 0x8f, 0x54, 0xc2, 0x45, 0x5c, 0x2e, 0x3c, 0x6b, 0x34, 0x84, 0x76, 0x5d, 0x81, 0x9e, 0x42,
	0xe7, 0x5d, 0x9a, 0xa2, 0x8f, 0xd7, 0xa2, 0x8f, 0xc0, 0x99, 0xf2, 0x25, 0xd7, 0xc6, 0xd8, 0x23,
	0xa3, 0x51, 0xb3, 0x83, 0xca, 0xec, 0x82, 0xc7, 0x4a, 0x27, 0x3c, 0xd6, 0x5e, 0x8b, 0x3e, 0x06,
	0xf7, 0x03, 0xd7, 0xdb, 0xfc, 0xd2, 0x23, 0x93, 0xb7, 0x77, 0x7f, 0xfb, 0xe4, 0x76, 0xd3, 0x27,
	0x77, 0x9b, 0x3e, 0xf9, 0xb3, 0xe9, 0x93, 0x2f, 0xe3, 0xbd, 0xe7, 0xbf, 0x8a, 0xb5, 0xca, 0x7f,
	0x48, 0x95, 0x67, 0xb9, 0x68, 0x80, 0xe0, 0x61, 0xf1, 0x2d, 0x0b, 0x8b, 0x24, 0xc4, 0x5f, 0x9a,
	0x9c, 0xe0, 0x67, 0xf0, 0xe6, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x59, 0xfa, 0xae, 0x2b, 0x4b,
	0x03, 0x00, 0x00,
}

func (m *TableShards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableShards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableShards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TenantID != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.TenantID))
		i--
		dAtA[i] = 0x20
	}
	if m.Version != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if m.ShardsCount != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.ShardsCount))
		i--
		dAtA[i] = 0x10
	}
	if m.Policy != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.Policy))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableShardBind) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableShardBind) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableShardBind) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BindVersion != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.BindVersion))
		i--
		dAtA[i] = 0x20
	}
	if m.ShardsVersion != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.ShardsVersion))
		i--
		dAtA[i] = 0x18
	}
	if len(m.CN) > 0 {
		i -= len(m.CN)
		copy(dAtA[i:], m.CN)
		i = encodeVarintShard(dAtA, i, uint64(len(m.CN)))
		i--
		dAtA[i] = 0x12
	}
	if m.ShardID != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Method != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.Method))
		i--
		dAtA[i] = 0x18
	}
	if m.RequestID != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintShard(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Method != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.Method))
		i--
		dAtA[i] = 0x10
	}
	if m.RequestID != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Cmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.TableShardBind.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Type != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintShard(dAtA []byte, offset int, v uint64) int {
	offset -= sovShard(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TableShards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Policy != 0 {
		n += 1 + sovShard(uint64(m.Policy))
	}
	if m.ShardsCount != 0 {
		n += 1 + sovShard(uint64(m.ShardsCount))
	}
	if m.Version != 0 {
		n += 1 + sovShard(uint64(m.Version))
	}
	if m.TenantID != 0 {
		n += 1 + sovShard(uint64(m.TenantID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableShardBind) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardID != 0 {
		n += 1 + sovShard(uint64(m.ShardID))
	}
	l = len(m.CN)
	if l > 0 {
		n += 1 + l + sovShard(uint64(l))
	}
	if m.ShardsVersion != 0 {
		n += 1 + sovShard(uint64(m.ShardsVersion))
	}
	if m.BindVersion != 0 {
		n += 1 + sovShard(uint64(m.BindVersion))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestID != 0 {
		n += 1 + sovShard(uint64(m.RequestID))
	}
	if m.Method != 0 {
		n += 1 + sovShard(uint64(m.Method))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestID != 0 {
		n += 1 + sovShard(uint64(m.RequestID))
	}
	if m.Method != 0 {
		n += 1 + sovShard(uint64(m.Method))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovShard(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovShard(uint64(m.Type))
	}
	l = m.TableShardBind.Size()
	n += 1 + l + sovShard(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovShard(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozShard(x uint64) (n int) {
	return sovShard(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TableShards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableShards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableShards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			m.Policy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Policy |= Policy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardsCount", wireType)
			}
			m.ShardsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardsCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantID", wireType)
			}
			m.TenantID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableShardBind) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableShardBind: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableShardBind: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardsVersion", wireType)
			}
			m.ShardsVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardsVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindVersion", wireType)
			}
			m.BindVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BindVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			m.Method = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Method |= Method(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			m.Method = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Method |= Method(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = append(m.Error[:0], dAtA[iNdEx:postIndex]...)
			if m.Error == nil {
				m.Error = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= CmdType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableShardBind", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TableShardBind.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipShard(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowShard
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowShard
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowShard
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthShard
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupShard
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthShard
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthShard        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowShard          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupShard = fmt.Errorf("proto: unexpected end of group")
)
