// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: shard.proto

package shard

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Policy shard policy for a table.
type Policy int32

const (
	// None no sharding for the current table.
	Policy_None Policy = 0
	// Partition the user-defined way of sharding data for a partitioned table.
	//
	// The number of Shards is determined when the table is created. It does not
	// change with the number of CN nodes in the MO cluster.
	//
	// The number of shards is only changed when the user changes the table definition
	// by using alter table.
	//
	// len(Shards) == len(Partitions).
	Policy_Partition Policy = 1
	// Hash auto-sharding data in a way that is based on primary key hash.
	//
	// In this mode, the number of shards of the table changes with the number of
	// nodes of CN in the mo cluster. len(shards) >= len(CN nodes).
	Policy_Hash Policy = 2
)

var Policy_name = map[int32]string{
	0: "None",
	1: "Partition",
	2: "Hash",
}

var Policy_value = map[string]int32{
	"None":      0,
	"Partition": 1,
	"Hash":      2,
}

func (x Policy) String() string {
	return proto.EnumName(Policy_name, int32(x))
}

func (Policy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{0}
}

// OpType operator type.
type OpType int32

const (
	OpType_AddReplica    OpType = 0
	OpType_DeleteReplica OpType = 1
	OpType_DeleteAll     OpType = 2
	OpType_CreateTable   OpType = 3
)

var OpType_name = map[int32]string{
	0: "AddReplica",
	1: "DeleteReplica",
	2: "DeleteAll",
	3: "CreateTable",
}

var OpType_value = map[string]int32{
	"AddReplica":    0,
	"DeleteReplica": 1,
	"DeleteAll":     2,
	"CreateTable":   3,
}

func (x OpType) String() string {
	return proto.EnumName(OpType_name, int32(x))
}

func (OpType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{1}
}

type CNState int32

const (
	CNState_Up   CNState = 0
	CNState_Down CNState = 1
)

var CNState_name = map[int32]string{
	0: "Up",
	1: "Down",
}

var CNState_value = map[string]int32{
	"Up":   0,
	"Down": 1,
}

func (x CNState) String() string {
	return proto.EnumName(CNState_name, int32(x))
}

func (CNState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{2}
}

type ReplicaState int32

const (
	ReplicaState_Allocating ReplicaState = 0
	ReplicaState_Allocated  ReplicaState = 1
	ReplicaState_Running    ReplicaState = 2
	ReplicaState_Moving     ReplicaState = 3
	ReplicaState_Tombstone  ReplicaState = 4
)

var ReplicaState_name = map[int32]string{
	0: "Allocating",
	1: "Allocated",
	2: "Running",
	3: "Moving",
	4: "Tombstone",
}

var ReplicaState_value = map[string]int32{
	"Allocating": 0,
	"Allocated":  1,
	"Running":    2,
	"Moving":     3,
	"Tombstone":  4,
}

func (x ReplicaState) String() string {
	return proto.EnumName(ReplicaState_name, int32(x))
}

func (ReplicaState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{3}
}

// Method sharding operations
type Method int32

const (
	Method_Heartbeat    Method = 0
	Method_CreateShards Method = 1
	Method_DeleteShards Method = 2
	Method_GetShards    Method = 3
)

var Method_name = map[int32]string{
	0: "Heartbeat",
	1: "CreateShards",
	2: "DeleteShards",
	3: "GetShards",
}

var Method_value = map[string]int32{
	"Heartbeat":    0,
	"CreateShards": 1,
	"DeleteShards": 2,
	"GetShards":    3,
}

func (x Method) String() string {
	return proto.EnumName(Method_name, int32(x))
}

func (Method) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{4}
}

// ShardsMetadata table shards metadata. When a Table is created, metadata for the
// corresponding shards is created and serialized and stored in MO_TABLES.
type ShardsMetadata struct {
	Policy               Policy   `protobuf:"varint,1,opt,name=Policy,proto3,enum=shard.Policy" json:"Policy,omitempty"`
	ShardsCount          uint32   `protobuf:"varint,2,opt,name=ShardsCount,proto3" json:"ShardsCount,omitempty"`
	Version              uint32   `protobuf:"varint,3,opt,name=Version,proto3" json:"Version,omitempty"`
	TenantID             uint32   `protobuf:"varint,4,opt,name=TenantID,proto3" json:"TenantID,omitempty"`
	MaxReplicaCount      uint32   `protobuf:"varint,5,opt,name=MaxReplicaCount,proto3" json:"MaxReplicaCount,omitempty"`
	PhysicalShardIDs     []uint64 `protobuf:"varint,6,rep,packed,name=PhysicalShardIDs,proto3" json:"PhysicalShardIDs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShardsMetadata) Reset()         { *m = ShardsMetadata{} }
func (m *ShardsMetadata) String() string { return proto.CompactTextString(m) }
func (*ShardsMetadata) ProtoMessage()    {}
func (*ShardsMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{0}
}
func (m *ShardsMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardsMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardsMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardsMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardsMetadata.Merge(m, src)
}
func (m *ShardsMetadata) XXX_Size() int {
	return m.Size()
}
func (m *ShardsMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardsMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ShardsMetadata proto.InternalMessageInfo

func (m *ShardsMetadata) GetPolicy() Policy {
	if m != nil {
		return m.Policy
	}
	return Policy_None
}

func (m *ShardsMetadata) GetShardsCount() uint32 {
	if m != nil {
		return m.ShardsCount
	}
	return 0
}

func (m *ShardsMetadata) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *ShardsMetadata) GetTenantID() uint32 {
	if m != nil {
		return m.TenantID
	}
	return 0
}

func (m *ShardsMetadata) GetMaxReplicaCount() uint32 {
	if m != nil {
		return m.MaxReplicaCount
	}
	return 0
}

func (m *ShardsMetadata) GetPhysicalShardIDs() []uint64 {
	if m != nil {
		return m.PhysicalShardIDs
	}
	return nil
}

// TableShard when ShardsMetadata are created, the Shards corresponding to a table
// are determined, and each Shard is assigned a corresponding CN node to handle requests
// for that Shard.
//
// When the Table's shards count changed, the corresponding Version field increments itself.
// This makes it easy to found expired information.
type TableShard struct {
	TableID uint64 `protobuf:"varint,1,opt,name=TableID,proto3" json:"TableID,omitempty"`
	ShardID uint64 `protobuf:"varint,2,opt,name=ShardID,proto3" json:"ShardID,omitempty"`
	Policy  Policy `protobuf:"varint,3,opt,name=Policy,proto3,enum=shard.Policy" json:"Policy,omitempty"`
	// Version increment when shards count changed
	Version              uint32         `protobuf:"varint,4,opt,name=Version,proto3" json:"Version,omitempty"`
	Replicas             []ShardReplica `protobuf:"bytes,5,rep,name=Replicas,proto3" json:"Replicas"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TableShard) Reset()         { *m = TableShard{} }
func (m *TableShard) String() string { return proto.CompactTextString(m) }
func (*TableShard) ProtoMessage()    {}
func (*TableShard) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{1}
}
func (m *TableShard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableShard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableShard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableShard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableShard.Merge(m, src)
}
func (m *TableShard) XXX_Size() int {
	return m.Size()
}
func (m *TableShard) XXX_DiscardUnknown() {
	xxx_messageInfo_TableShard.DiscardUnknown(m)
}

var xxx_messageInfo_TableShard proto.InternalMessageInfo

func (m *TableShard) GetTableID() uint64 {
	if m != nil {
		return m.TableID
	}
	return 0
}

func (m *TableShard) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *TableShard) GetPolicy() Policy {
	if m != nil {
		return m.Policy
	}
	return Policy_None
}

func (m *TableShard) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *TableShard) GetReplicas() []ShardReplica {
	if m != nil {
		return m.Replicas
	}
	return nil
}

// ShardReplica a tableShard will have multiple replicas, the data of these replicas is exactly
// the same, each replica is a ShardReplica. ShardReplica can run on any available CN node.
//
// The binding relationship between CN and ShardReplica changes dynamically during the runtime,
// and presumably if the corresponding CN goes offline, or if a new CN comes online and causes
// an imbalance between ShardReplica and CN, then the binding relationship will be readjusted.
//
// The number of replicas is used to extend the read performance.
type ShardReplica struct {
	ReplicaID uint64       `protobuf:"varint,1,opt,name=ReplicaID,proto3" json:"ReplicaID,omitempty"`
	State     ReplicaState `protobuf:"varint,2,opt,name=State,proto3,enum=shard.ReplicaState" json:"State,omitempty"`
	CN        string       `protobuf:"bytes,3,opt,name=CN,proto3" json:"CN,omitempty"`
	// Version increment when the cn changed
	Version              uint64   `protobuf:"varint,4,opt,name=Version,proto3" json:"Version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShardReplica) Reset()         { *m = ShardReplica{} }
func (m *ShardReplica) String() string { return proto.CompactTextString(m) }
func (*ShardReplica) ProtoMessage()    {}
func (*ShardReplica) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{2}
}
func (m *ShardReplica) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardReplica) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardReplica.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardReplica) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardReplica.Merge(m, src)
}
func (m *ShardReplica) XXX_Size() int {
	return m.Size()
}
func (m *ShardReplica) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardReplica.DiscardUnknown(m)
}

var xxx_messageInfo_ShardReplica proto.InternalMessageInfo

func (m *ShardReplica) GetReplicaID() uint64 {
	if m != nil {
		return m.ReplicaID
	}
	return 0
}

func (m *ShardReplica) GetState() ReplicaState {
	if m != nil {
		return m.State
	}
	return ReplicaState_Allocating
}

func (m *ShardReplica) GetCN() string {
	if m != nil {
		return m.CN
	}
	return ""
}

func (m *ShardReplica) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type Request struct {
	RequestID            uint64              `protobuf:"varint,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	RPCMethod            Method              `protobuf:"varint,2,opt,name=RPCMethod,proto3,enum=shard.Method" json:"RPCMethod,omitempty"`
	CreateShards         CreateShardsRequest `protobuf:"bytes,3,opt,name=CreateShards,proto3" json:"CreateShards"`
	DeleteShards         DeleteShardsRequest `protobuf:"bytes,4,opt,name=DeleteShards,proto3" json:"DeleteShards"`
	Heartbeat            HeartbeatRequest    `protobuf:"bytes,5,opt,name=Heartbeat,proto3" json:"Heartbeat"`
	GetShards            GetShardsRequest    `protobuf:"bytes,6,opt,name=GetShards,proto3" json:"GetShards"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{3}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetRequestID() uint64 {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *Request) GetRPCMethod() Method {
	if m != nil {
		return m.RPCMethod
	}
	return Method_Heartbeat
}

func (m *Request) GetCreateShards() CreateShardsRequest {
	if m != nil {
		return m.CreateShards
	}
	return CreateShardsRequest{}
}

func (m *Request) GetDeleteShards() DeleteShardsRequest {
	if m != nil {
		return m.DeleteShards
	}
	return DeleteShardsRequest{}
}

func (m *Request) GetHeartbeat() HeartbeatRequest {
	if m != nil {
		return m.Heartbeat
	}
	return HeartbeatRequest{}
}

func (m *Request) GetGetShards() GetShardsRequest {
	if m != nil {
		return m.GetShards
	}
	return GetShardsRequest{}
}

type Response struct {
	RequestID uint64 `protobuf:"varint,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	RPCMethod Method `protobuf:"varint,2,opt,name=RPCMethod,proto3,enum=shard.Method" json:"RPCMethod,omitempty"`
	// Error we use this field to send moerr from service to another cn. Set with
	// moerr.MarshalBinary, and use moerr.UnmarshalBinary to restore moerr.
	Error                []byte               `protobuf:"bytes,3,opt,name=Error,proto3" json:"Error,omitempty"`
	CreateShards         CreateShardsResponse `protobuf:"bytes,4,opt,name=CreateShards,proto3" json:"CreateShards"`
	DeleteShards         DeleteShardsResponse `protobuf:"bytes,5,opt,name=DeleteShards,proto3" json:"DeleteShards"`
	Heartbeat            HeartbeatResponse    `protobuf:"bytes,6,opt,name=Heartbeat,proto3" json:"Heartbeat"`
	GetShards            GetShardsResponse    `protobuf:"bytes,7,opt,name=GetShards,proto3" json:"GetShards"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{4}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetRequestID() uint64 {
	if m != nil {
		return m.RequestID
	}
	return 0
}

func (m *Response) GetRPCMethod() Method {
	if m != nil {
		return m.RPCMethod
	}
	return Method_Heartbeat
}

func (m *Response) GetError() []byte {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *Response) GetCreateShards() CreateShardsResponse {
	if m != nil {
		return m.CreateShards
	}
	return CreateShardsResponse{}
}

func (m *Response) GetDeleteShards() DeleteShardsResponse {
	if m != nil {
		return m.DeleteShards
	}
	return DeleteShardsResponse{}
}

func (m *Response) GetHeartbeat() HeartbeatResponse {
	if m != nil {
		return m.Heartbeat
	}
	return HeartbeatResponse{}
}

func (m *Response) GetGetShards() GetShardsResponse {
	if m != nil {
		return m.GetShards
	}
	return GetShardsResponse{}
}

// Operator is a description of a command that needs to be sent down to CN for execution.
// The command needs to be executed within a specified time frame. If the timeout is
// exceeded, the command is automatically terminated and the ShardBalancer recalculates
// to use the another CN to execute the command.
type Operator struct {
	Type                 OpType       `protobuf:"varint,1,opt,name=Type,proto3,enum=shard.OpType" json:"Type,omitempty"`
	TableShard           TableShard   `protobuf:"bytes,2,opt,name=TableShard,proto3" json:"TableShard"`
	Replica              ShardReplica `protobuf:"bytes,3,opt,name=Replica,proto3" json:"Replica"`
	TableID              uint64       `protobuf:"varint,4,opt,name=TableID,proto3" json:"TableID,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Operator) Reset()         { *m = Operator{} }
func (m *Operator) String() string { return proto.CompactTextString(m) }
func (*Operator) ProtoMessage()    {}
func (*Operator) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{5}
}
func (m *Operator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Operator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Operator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Operator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Operator.Merge(m, src)
}
func (m *Operator) XXX_Size() int {
	return m.Size()
}
func (m *Operator) XXX_DiscardUnknown() {
	xxx_messageInfo_Operator.DiscardUnknown(m)
}

var xxx_messageInfo_Operator proto.InternalMessageInfo

func (m *Operator) GetType() OpType {
	if m != nil {
		return m.Type
	}
	return OpType_AddReplica
}

func (m *Operator) GetTableShard() TableShard {
	if m != nil {
		return m.TableShard
	}
	return TableShard{}
}

func (m *Operator) GetReplica() ShardReplica {
	if m != nil {
		return m.Replica
	}
	return ShardReplica{}
}

func (m *Operator) GetTableID() uint64 {
	if m != nil {
		return m.TableID
	}
	return 0
}

type CreateShardsRequest struct {
	ID                   uint64         `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Metadata             ShardsMetadata `protobuf:"bytes,2,opt,name=Metadata,proto3" json:"Metadata"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CreateShardsRequest) Reset()         { *m = CreateShardsRequest{} }
func (m *CreateShardsRequest) String() string { return proto.CompactTextString(m) }
func (*CreateShardsRequest) ProtoMessage()    {}
func (*CreateShardsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{6}
}
func (m *CreateShardsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateShardsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateShardsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateShardsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateShardsRequest.Merge(m, src)
}
func (m *CreateShardsRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateShardsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateShardsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateShardsRequest proto.InternalMessageInfo

func (m *CreateShardsRequest) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *CreateShardsRequest) GetMetadata() ShardsMetadata {
	if m != nil {
		return m.Metadata
	}
	return ShardsMetadata{}
}

type CreateShardsResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateShardsResponse) Reset()         { *m = CreateShardsResponse{} }
func (m *CreateShardsResponse) String() string { return proto.CompactTextString(m) }
func (*CreateShardsResponse) ProtoMessage()    {}
func (*CreateShardsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{7}
}
func (m *CreateShardsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateShardsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateShardsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateShardsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateShardsResponse.Merge(m, src)
}
func (m *CreateShardsResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateShardsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateShardsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateShardsResponse proto.InternalMessageInfo

type DeleteShardsRequest struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteShardsRequest) Reset()         { *m = DeleteShardsRequest{} }
func (m *DeleteShardsRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteShardsRequest) ProtoMessage()    {}
func (*DeleteShardsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{8}
}
func (m *DeleteShardsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteShardsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteShardsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteShardsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteShardsRequest.Merge(m, src)
}
func (m *DeleteShardsRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteShardsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteShardsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteShardsRequest proto.InternalMessageInfo

func (m *DeleteShardsRequest) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type DeleteShardsResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteShardsResponse) Reset()         { *m = DeleteShardsResponse{} }
func (m *DeleteShardsResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteShardsResponse) ProtoMessage()    {}
func (*DeleteShardsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{9}
}
func (m *DeleteShardsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteShardsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteShardsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteShardsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteShardsResponse.Merge(m, src)
}
func (m *DeleteShardsResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteShardsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteShardsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteShardsResponse proto.InternalMessageInfo

type HeartbeatRequest struct {
	CN                   string       `protobuf:"bytes,1,opt,name=CN,proto3" json:"CN,omitempty"`
	Shards               []TableShard `protobuf:"bytes,2,rep,name=Shards,proto3" json:"Shards"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *HeartbeatRequest) Reset()         { *m = HeartbeatRequest{} }
func (m *HeartbeatRequest) String() string { return proto.CompactTextString(m) }
func (*HeartbeatRequest) ProtoMessage()    {}
func (*HeartbeatRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{10}
}
func (m *HeartbeatRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartbeatRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeartbeatRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeartbeatRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartbeatRequest.Merge(m, src)
}
func (m *HeartbeatRequest) XXX_Size() int {
	return m.Size()
}
func (m *HeartbeatRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartbeatRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HeartbeatRequest proto.InternalMessageInfo

func (m *HeartbeatRequest) GetCN() string {
	if m != nil {
		return m.CN
	}
	return ""
}

func (m *HeartbeatRequest) GetShards() []TableShard {
	if m != nil {
		return m.Shards
	}
	return nil
}

type HeartbeatResponse struct {
	Operators            []Operator `protobuf:"bytes,1,rep,name=Operators,proto3" json:"Operators"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *HeartbeatResponse) Reset()         { *m = HeartbeatResponse{} }
func (m *HeartbeatResponse) String() string { return proto.CompactTextString(m) }
func (*HeartbeatResponse) ProtoMessage()    {}
func (*HeartbeatResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{11}
}
func (m *HeartbeatResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartbeatResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeartbeatResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeartbeatResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartbeatResponse.Merge(m, src)
}
func (m *HeartbeatResponse) XXX_Size() int {
	return m.Size()
}
func (m *HeartbeatResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartbeatResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HeartbeatResponse proto.InternalMessageInfo

func (m *HeartbeatResponse) GetOperators() []Operator {
	if m != nil {
		return m.Operators
	}
	return nil
}

type GetShardsRequest struct {
	ID                   uint64         `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Metadata             ShardsMetadata `protobuf:"bytes,2,opt,name=Metadata,proto3" json:"Metadata"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *GetShardsRequest) Reset()         { *m = GetShardsRequest{} }
func (m *GetShardsRequest) String() string { return proto.CompactTextString(m) }
func (*GetShardsRequest) ProtoMessage()    {}
func (*GetShardsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{12}
}
func (m *GetShardsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetShardsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetShardsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetShardsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetShardsRequest.Merge(m, src)
}
func (m *GetShardsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetShardsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetShardsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetShardsRequest proto.InternalMessageInfo

func (m *GetShardsRequest) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *GetShardsRequest) GetMetadata() ShardsMetadata {
	if m != nil {
		return m.Metadata
	}
	return ShardsMetadata{}
}

type GetShardsResponse struct {
	Shards               []TableShard `protobuf:"bytes,1,rep,name=Shards,proto3" json:"Shards"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *GetShardsResponse) Reset()         { *m = GetShardsResponse{} }
func (m *GetShardsResponse) String() string { return proto.CompactTextString(m) }
func (*GetShardsResponse) ProtoMessage()    {}
func (*GetShardsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_319ea41e44cdc364, []int{13}
}
func (m *GetShardsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetShardsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetShardsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetShardsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetShardsResponse.Merge(m, src)
}
func (m *GetShardsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetShardsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetShardsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetShardsResponse proto.InternalMessageInfo

func (m *GetShardsResponse) GetShards() []TableShard {
	if m != nil {
		return m.Shards
	}
	return nil
}

func init() {
	proto.RegisterEnum("shard.Policy", Policy_name, Policy_value)
	proto.RegisterEnum("shard.OpType", OpType_name, OpType_value)
	proto.RegisterEnum("shard.CNState", CNState_name, CNState_value)
	proto.RegisterEnum("shard.ReplicaState", ReplicaState_name, ReplicaState_value)
	proto.RegisterEnum("shard.Method", Method_name, Method_value)
	proto.RegisterType((*ShardsMetadata)(nil), "shard.ShardsMetadata")
	proto.RegisterType((*TableShard)(nil), "shard.TableShard")
	proto.RegisterType((*ShardReplica)(nil), "shard.ShardReplica")
	proto.RegisterType((*Request)(nil), "shard.Request")
	proto.RegisterType((*Response)(nil), "shard.Response")
	proto.RegisterType((*Operator)(nil), "shard.Operator")
	proto.RegisterType((*CreateShardsRequest)(nil), "shard.CreateShardsRequest")
	proto.RegisterType((*CreateShardsResponse)(nil), "shard.CreateShardsResponse")
	proto.RegisterType((*DeleteShardsRequest)(nil), "shard.DeleteShardsRequest")
	proto.RegisterType((*DeleteShardsResponse)(nil), "shard.DeleteShardsResponse")
	proto.RegisterType((*HeartbeatRequest)(nil), "shard.HeartbeatRequest")
	proto.RegisterType((*HeartbeatResponse)(nil), "shard.HeartbeatResponse")
	proto.RegisterType((*GetShardsRequest)(nil), "shard.GetShardsRequest")
	proto.RegisterType((*GetShardsResponse)(nil), "shard.GetShardsResponse")
}

func init() { proto.RegisterFile("shard.proto", fileDescriptor_319ea41e44cdc364) }

var fileDescriptor_319ea41e44cdc364 = []byte{
	// 930 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xcf, 0x6f, 0xe3, 0xc4,
	0x17, 0xcf, 0x38, 0x8e, 0x93, 0xbc, 0x34, 0xa9, 0x3b, 0xdd, 0xef, 0x17, 0xab, 0x8b, 0x4a, 0xb0,
	0xb4, 0x52, 0xc8, 0x8a, 0x46, 0x4a, 0x85, 0xf6, 0xc0, 0x1e, 0xd8, 0x4d, 0x2a, 0x5a, 0x50, 0xbb,
	0x95, 0xdb, 0xe5, 0x00, 0x12, 0xd2, 0x24, 0x19, 0x12, 0x0b, 0xd7, 0x63, 0xec, 0x09, 0x6c, 0x8f,
	0xfc, 0x51, 0x48, 0xfc, 0x09, 0x7b, 0xdc, 0x33, 0x07, 0x04, 0x95, 0xf8, 0x13, 0xb8, 0xa3, 0xf9,
	0x61, 0x67, 0xec, 0x86, 0x15, 0x87, 0xbd, 0xcd, 0xfb, 0xbc, 0x9f, 0xf3, 0x99, 0xf7, 0x9e, 0x0d,
	0x9d, 0x6c, 0x45, 0xd2, 0xc5, 0x51, 0x92, 0x32, 0xce, 0x70, 0x43, 0x0a, 0x07, 0x1f, 0x2f, 0x43,
	0xbe, 0x5a, 0xcf, 0x8e, 0xe6, 0xec, 0x66, 0xb4, 0x64, 0x4b, 0x36, 0x92, 0xda, 0xd9, 0xfa, 0x3b,
	0x29, 0x49, 0x41, 0x9e, 0x94, 0x97, 0xff, 0x17, 0x82, 0xde, 0x95, 0x70, 0xcc, 0xce, 0x29, 0x27,
	0x0b, 0xc2, 0x09, 0x7e, 0x04, 0xce, 0x25, 0x8b, 0xc2, 0xf9, 0xad, 0x87, 0xfa, 0x68, 0xd0, 0x1b,
	0x77, 0x8f, 0x54, 0x1a, 0x05, 0x06, 0x5a, 0x89, 0xfb, 0xd0, 0x51, 0x8e, 0x13, 0xb6, 0x8e, 0xb9,
	0x67, 0xf5, 0xd1, 0xa0, 0x1b, 0x98, 0x10, 0xf6, 0xa0, 0xf9, 0x15, 0x4d, 0xb3, 0x90, 0xc5, 0x5e,
	0x5d, 0x6a, 0x73, 0x11, 0x1f, 0x40, 0xeb, 0x9a, 0xc6, 0x24, 0xe6, 0x67, 0x53, 0xcf, 0x96, 0xaa,
	0x42, 0xc6, 0x03, 0xd8, 0x3d, 0x27, 0xaf, 0x02, 0x9a, 0x44, 0xe1, 0x9c, 0xa8, 0xd8, 0x0d, 0x69,
	0x52, 0x85, 0xf1, 0x10, 0xdc, 0xcb, 0xd5, 0x6d, 0x16, 0xce, 0x49, 0x24, 0xd3, 0x9e, 0x4d, 0x33,
	0xcf, 0xe9, 0xd7, 0x07, 0x76, 0x70, 0x0f, 0xf7, 0x7f, 0x45, 0x00, 0xd7, 0x64, 0x16, 0x51, 0x89,
	0x88, 0xd2, 0xa4, 0x74, 0x36, 0x95, 0x97, 0xb4, 0x83, 0x5c, 0x14, 0x1a, 0xed, 0x24, 0xaf, 0x64,
	0x07, 0xb9, 0x68, 0xf0, 0x52, 0x7f, 0x1b, 0x2f, 0xc6, 0xad, 0xed, 0xf2, 0xad, 0x3f, 0x81, 0x96,
	0xae, 0x3f, 0xf3, 0x1a, 0xfd, 0xfa, 0xa0, 0x33, 0xde, 0xd7, 0x21, 0x64, 0x0a, 0xad, 0x7b, 0x6e,
	0xbf, 0xfe, 0xfd, 0x83, 0x5a, 0x50, 0x98, 0xfa, 0x3f, 0x23, 0xd8, 0x31, 0x0d, 0xf0, 0xfb, 0xd0,
	0xd6, 0xc7, 0xa2, 0xfc, 0x0d, 0x80, 0x3f, 0x82, 0xc6, 0x15, 0x27, 0x9c, 0xca, 0xf2, 0x7b, 0x45,
	0x0a, 0x6d, 0x20, 0x55, 0x81, 0xb2, 0xc0, 0x3d, 0xb0, 0x26, 0x17, 0xf2, 0x36, 0xed, 0xc0, 0x9a,
	0x5c, 0x54, 0x4b, 0xb7, 0x8b, 0xd2, 0xfd, 0xdf, 0x2c, 0x68, 0x06, 0xf4, 0x87, 0x35, 0xcd, 0xb8,
	0x4a, 0x2f, 0x8f, 0x66, 0x7a, 0x0d, 0xe0, 0xc7, 0xd0, 0x0e, 0x2e, 0x27, 0xe7, 0x94, 0xaf, 0xd8,
	0x42, 0x97, 0x90, 0x13, 0xa5, 0xc0, 0x60, 0xa3, 0xc7, 0x53, 0xd8, 0x99, 0xa4, 0x94, 0x70, 0xf5,
	0x2a, 0x99, 0x2c, 0xa5, 0x33, 0x3e, 0xd0, 0xf6, 0xa6, 0x4a, 0x27, 0xd0, 0xe4, 0x94, 0xbc, 0x44,
	0x94, 0x29, 0x8d, 0x68, 0x11, 0xc5, 0x2e, 0x45, 0x31, 0x55, 0x95, 0x28, 0xa6, 0x0a, 0x7f, 0x0a,
	0xed, 0x53, 0x4a, 0x52, 0x3e, 0xa3, 0x44, 0x75, 0x5c, 0x67, 0xfc, 0x9e, 0x0e, 0x51, 0xe0, 0x65,
	0xff, 0x8d, 0xbd, 0x70, 0xfe, 0x9c, 0x72, 0x9d, 0xdf, 0x29, 0x39, 0x17, 0x78, 0xc5, 0xb9, 0xc0,
	0xfd, 0xbf, 0x2d, 0xd1, 0x18, 0x59, 0xc2, 0xe2, 0x8c, 0xbe, 0x4b, 0x76, 0x1f, 0x40, 0xe3, 0x24,
	0x4d, 0x59, 0x2a, 0x69, 0xdd, 0x09, 0x94, 0x80, 0x4f, 0x2a, 0x9c, 0x2b, 0xb6, 0x1e, 0x6e, 0xe5,
	0x5c, 0xd5, 0xb4, 0x95, 0xf4, 0x93, 0x0a, 0xe9, 0x8d, 0x52, 0x98, 0x32, 0xe9, 0xe5, 0x30, 0x25,
	0xd6, 0x9f, 0x9a, 0xac, 0x2b, 0xe2, 0xbc, 0xfb, 0xac, 0x97, 0x02, 0x18, 0xb4, 0x3f, 0x35, 0x69,
	0x6f, 0x96, 0xbc, 0x0d, 0xda, 0xcb, 0xde, 0x1b, 0xde, 0x7f, 0x41, 0xd0, 0x7a, 0x91, 0xd0, 0x94,
	0x70, 0x96, 0xe2, 0x0f, 0xc1, 0xbe, 0xbe, 0x4d, 0x68, 0x65, 0xe7, 0xbd, 0x48, 0x04, 0x18, 0x48,
	0x15, 0x7e, 0x62, 0xae, 0x10, 0xc9, 0x7e, 0x67, 0xbc, 0xa7, 0x0d, 0x37, 0x0a, 0x9d, 0xc7, 0xdc,
	0x36, 0xc7, 0x62, 0x78, 0xe4, 0xf8, 0xe9, 0x0e, 0x7f, 0xcb, 0xdc, 0xe7, 0x96, 0xe6, 0x8a, 0xb2,
	0x4b, 0x2b, 0xca, 0xff, 0x16, 0xf6, 0xb7, 0x8c, 0x86, 0x98, 0xe6, 0xa2, 0x65, 0xac, 0xb3, 0x29,
	0x7e, 0x02, 0xad, 0x7c, 0xa7, 0xeb, 0x62, 0xff, 0x67, 0xa6, 0x2d, 0x16, 0x7e, 0xbe, 0x70, 0x72,
	0xd9, 0xff, 0x3f, 0x3c, 0xd8, 0xd6, 0x06, 0xfe, 0x23, 0xd8, 0xdf, 0x32, 0x4c, 0xd5, 0xbc, 0xc2,
	0x7d, 0xdb, 0xf3, 0xfb, 0x57, 0xe0, 0x56, 0x07, 0x49, 0x6f, 0x20, 0x54, 0x6c, 0xa0, 0x11, 0x38,
	0xfa, 0x35, 0x2d, 0xb9, 0x20, 0xff, 0x95, 0x5e, 0x6d, 0xe6, 0x9f, 0xc2, 0xde, 0xbd, 0x3e, 0xc1,
	0xc7, 0xd0, 0xce, 0xdf, 0x35, 0xf3, 0x90, 0x0c, 0xb4, 0x5b, 0x3c, 0xa8, 0xc2, 0xf3, 0x6e, 0x28,
	0xec, 0xfc, 0x6f, 0xc0, 0xad, 0x8e, 0xea, 0xbb, 0xa3, 0x74, 0x0a, 0x7b, 0xf7, 0x1a, 0xd2, 0xb8,
	0x2c, 0xfa, 0x4f, 0x97, 0x1d, 0x3e, 0xce, 0xbf, 0x40, 0xb8, 0x05, 0xf6, 0x05, 0x8b, 0xa9, 0x5b,
	0xc3, 0x5d, 0x68, 0x5f, 0x92, 0x94, 0x87, 0x3c, 0x64, 0xb1, 0x8b, 0x84, 0xe2, 0x94, 0x64, 0x2b,
	0xd7, 0x1a, 0x7e, 0x09, 0x8e, 0xea, 0x5e, 0xdc, 0x03, 0x78, 0xb6, 0xc8, 0xdb, 0xcc, 0xad, 0xe1,
	0x3d, 0xe8, 0xaa, 0x07, 0xca, 0x21, 0x24, 0xa2, 0x28, 0xe8, 0x59, 0x14, 0xb9, 0x16, 0xde, 0x85,
	0x8e, 0xea, 0x00, 0x59, 0x8a, 0x5b, 0x1f, 0x3e, 0x84, 0xe6, 0xe4, 0x42, 0x7d, 0x34, 0x1c, 0xb0,
	0x5e, 0x26, 0x6e, 0x4d, 0x64, 0x9a, 0xb2, 0x9f, 0x62, 0x17, 0x0d, 0x5f, 0xc2, 0x8e, 0xf9, 0x75,
	0x91, 0xf9, 0xa2, 0x88, 0xcd, 0x09, 0x0f, 0xe3, 0xa5, 0x2a, 0x51, 0xcb, 0x74, 0xe1, 0x22, 0xdc,
	0x81, 0x66, 0xb0, 0x8e, 0x63, 0xa1, 0xb3, 0x30, 0x80, 0x73, 0xce, 0x7e, 0x14, 0xe7, 0xba, 0xb0,
	0xbb, 0x66, 0x37, 0xb3, 0x8c, 0x8b, 0x9b, 0xd9, 0xc3, 0x2f, 0xc0, 0xd1, 0x8b, 0xac, 0x6b, 0x2c,
	0x09, 0xb7, 0x86, 0xdd, 0xf2, 0x06, 0x73, 0x91, 0x40, 0xcc, 0x96, 0x73, 0x2d, 0xe1, 0x52, 0x10,
	0xee, 0xd6, 0x9f, 0x7f, 0xf6, 0xe6, 0xcf, 0x43, 0xf4, 0xfa, 0xee, 0x10, 0xbd, 0xb9, 0x3b, 0x44,
	0x7f, 0xdc, 0x1d, 0xa2, 0xaf, 0x8f, 0x8c, 0xff, 0xa4, 0x1b, 0xc2, 0xd3, 0xf0, 0x15, 0x4b, 0xc3,
	0x65, 0x18, 0xe7, 0x42, 0x4c, 0x47, 0xc9, 0xf7, 0xcb, 0x51, 0x32, 0x1b, 0xc9, 0x47, 0x99, 0x39,
	0xf2, 0x7f, 0xe9, 0xf8, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x2c, 0x7e, 0x19, 0xdc, 0x74, 0x09,
	0x00, 0x00,
}

func (m *ShardsMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardsMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardsMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PhysicalShardIDs) > 0 {
		dAtA2 := make([]byte, len(m.PhysicalShardIDs)*10)
		var j1 int
		for _, num := range m.PhysicalShardIDs {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintShard(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x32
	}
	if m.MaxReplicaCount != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.MaxReplicaCount))
		i--
		dAtA[i] = 0x28
	}
	if m.TenantID != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.TenantID))
		i--
		dAtA[i] = 0x20
	}
	if m.Version != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if m.ShardsCount != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.ShardsCount))
		i--
		dAtA[i] = 0x10
	}
	if m.Policy != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.Policy))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableShard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableShard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableShard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Replicas) > 0 {
		for iNdEx := len(m.Replicas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Replicas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Version != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x20
	}
	if m.Policy != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.Policy))
		i--
		dAtA[i] = 0x18
	}
	if m.ShardID != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShardReplica) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardReplica) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardReplica) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Version != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x20
	}
	if len(m.CN) > 0 {
		i -= len(m.CN)
		copy(dAtA[i:], m.CN)
		i = encodeVarintShard(dAtA, i, uint64(len(m.CN)))
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if m.ReplicaID != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.ReplicaID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.GetShards.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.Heartbeat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.DeleteShards.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.CreateShards.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.RPCMethod != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.RPCMethod))
		i--
		dAtA[i] = 0x10
	}
	if m.RequestID != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.GetShards.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.Heartbeat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.DeleteShards.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.CreateShards.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintShard(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RPCMethod != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.RPCMethod))
		i--
		dAtA[i] = 0x10
	}
	if m.RequestID != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.RequestID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Operator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Operator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Operator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableID != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Replica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.TableShard.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Type != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateShardsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateShardsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateShardsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.ID != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateShardsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateShardsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateShardsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeleteShardsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteShardsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteShardsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteShardsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteShardsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteShardsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *HeartbeatRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartbeatRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeartbeatRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Shards) > 0 {
		for iNdEx := len(m.Shards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Shards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CN) > 0 {
		i -= len(m.CN)
		copy(dAtA[i:], m.CN)
		i = encodeVarintShard(dAtA, i, uint64(len(m.CN)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HeartbeatResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartbeatResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeartbeatResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Operators) > 0 {
		for iNdEx := len(m.Operators) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Operators[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetShardsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetShardsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetShardsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintShard(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.ID != 0 {
		i = encodeVarintShard(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetShardsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetShardsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetShardsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Shards) > 0 {
		for iNdEx := len(m.Shards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Shards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShard(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintShard(dAtA []byte, offset int, v uint64) int {
	offset -= sovShard(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ShardsMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Policy != 0 {
		n += 1 + sovShard(uint64(m.Policy))
	}
	if m.ShardsCount != 0 {
		n += 1 + sovShard(uint64(m.ShardsCount))
	}
	if m.Version != 0 {
		n += 1 + sovShard(uint64(m.Version))
	}
	if m.TenantID != 0 {
		n += 1 + sovShard(uint64(m.TenantID))
	}
	if m.MaxReplicaCount != 0 {
		n += 1 + sovShard(uint64(m.MaxReplicaCount))
	}
	if len(m.PhysicalShardIDs) > 0 {
		l = 0
		for _, e := range m.PhysicalShardIDs {
			l += sovShard(uint64(e))
		}
		n += 1 + sovShard(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableShard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovShard(uint64(m.TableID))
	}
	if m.ShardID != 0 {
		n += 1 + sovShard(uint64(m.ShardID))
	}
	if m.Policy != 0 {
		n += 1 + sovShard(uint64(m.Policy))
	}
	if m.Version != 0 {
		n += 1 + sovShard(uint64(m.Version))
	}
	if len(m.Replicas) > 0 {
		for _, e := range m.Replicas {
			l = e.Size()
			n += 1 + l + sovShard(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardReplica) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaID != 0 {
		n += 1 + sovShard(uint64(m.ReplicaID))
	}
	if m.State != 0 {
		n += 1 + sovShard(uint64(m.State))
	}
	l = len(m.CN)
	if l > 0 {
		n += 1 + l + sovShard(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovShard(uint64(m.Version))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestID != 0 {
		n += 1 + sovShard(uint64(m.RequestID))
	}
	if m.RPCMethod != 0 {
		n += 1 + sovShard(uint64(m.RPCMethod))
	}
	l = m.CreateShards.Size()
	n += 1 + l + sovShard(uint64(l))
	l = m.DeleteShards.Size()
	n += 1 + l + sovShard(uint64(l))
	l = m.Heartbeat.Size()
	n += 1 + l + sovShard(uint64(l))
	l = m.GetShards.Size()
	n += 1 + l + sovShard(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestID != 0 {
		n += 1 + sovShard(uint64(m.RequestID))
	}
	if m.RPCMethod != 0 {
		n += 1 + sovShard(uint64(m.RPCMethod))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovShard(uint64(l))
	}
	l = m.CreateShards.Size()
	n += 1 + l + sovShard(uint64(l))
	l = m.DeleteShards.Size()
	n += 1 + l + sovShard(uint64(l))
	l = m.Heartbeat.Size()
	n += 1 + l + sovShard(uint64(l))
	l = m.GetShards.Size()
	n += 1 + l + sovShard(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Operator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovShard(uint64(m.Type))
	}
	l = m.TableShard.Size()
	n += 1 + l + sovShard(uint64(l))
	l = m.Replica.Size()
	n += 1 + l + sovShard(uint64(l))
	if m.TableID != 0 {
		n += 1 + sovShard(uint64(m.TableID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateShardsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovShard(uint64(m.ID))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovShard(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateShardsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteShardsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovShard(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteShardsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeartbeatRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CN)
	if l > 0 {
		n += 1 + l + sovShard(uint64(l))
	}
	if len(m.Shards) > 0 {
		for _, e := range m.Shards {
			l = e.Size()
			n += 1 + l + sovShard(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeartbeatResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Operators) > 0 {
		for _, e := range m.Operators {
			l = e.Size()
			n += 1 + l + sovShard(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetShardsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovShard(uint64(m.ID))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovShard(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetShardsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Shards) > 0 {
		for _, e := range m.Shards {
			l = e.Size()
			n += 1 + l + sovShard(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovShard(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozShard(x uint64) (n int) {
	return sovShard(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ShardsMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardsMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardsMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			m.Policy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Policy |= Policy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardsCount", wireType)
			}
			m.ShardsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardsCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantID", wireType)
			}
			m.TenantID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxReplicaCount", wireType)
			}
			m.MaxReplicaCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxReplicaCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowShard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PhysicalShardIDs = append(m.PhysicalShardIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowShard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthShard
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthShard
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PhysicalShardIDs) == 0 {
					m.PhysicalShardIDs = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowShard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PhysicalShardIDs = append(m.PhysicalShardIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalShardIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableShard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableShard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableShard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			m.Policy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Policy |= Policy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replicas = append(m.Replicas, ShardReplica{})
			if err := m.Replicas[len(m.Replicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardReplica) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardReplica: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardReplica: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaID", wireType)
			}
			m.ReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ReplicaState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RPCMethod", wireType)
			}
			m.RPCMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RPCMethod |= Method(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateShards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DeleteShards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Heartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetShards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			m.RequestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RPCMethod", wireType)
			}
			m.RPCMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RPCMethod |= Method(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = append(m.Error[:0], dAtA[iNdEx:postIndex]...)
			if m.Error == nil {
				m.Error = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateShards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DeleteShards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Heartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetShards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Operator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Operator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Operator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= OpType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableShard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TableShard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateShardsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateShardsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateShardsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateShardsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateShardsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateShardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteShardsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteShardsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteShardsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteShardsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteShardsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteShardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartbeatRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartbeatRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartbeatRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, TableShard{})
			if err := m.Shards[len(m.Shards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartbeatResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartbeatResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartbeatResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operators = append(m.Operators, Operator{})
			if err := m.Operators[len(m.Operators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetShardsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetShardsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetShardsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetShardsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetShardsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetShardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShard
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShard
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, TableShard{})
			if err := m.Shards[len(m.Shards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipShard(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowShard
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowShard
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowShard
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthShard
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupShard
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthShard
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthShard        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowShard          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupShard = fmt.Errorf("proto: unexpected end of group")
)
