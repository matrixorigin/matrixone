// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: plan.proto

package plan

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	lock "github.com/matrixorigin/matrixone/pkg/pb/lock"
	timestamp "github.com/matrixorigin/matrixone/pkg/pb/timestamp"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CompressType int32

const (
	CompressType_None CompressType = 0
	CompressType_Lz4  CompressType = 1
)

var CompressType_name = map[int32]string{
	0: "None",
	1: "Lz4",
}

var CompressType_value = map[string]int32{
	"None": 0,
	"Lz4":  1,
}

func (x CompressType) String() string {
	return proto.EnumName(CompressType_name, int32(x))
}

func (CompressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{0}
}

type PartitionType int32

const (
	PartitionType_KEY           PartitionType = 0
	PartitionType_LINEAR_KEY    PartitionType = 1
	PartitionType_HASH          PartitionType = 2
	PartitionType_LINEAR_HASH   PartitionType = 3
	PartitionType_RANGE         PartitionType = 4
	PartitionType_RANGE_COLUMNS PartitionType = 5
	PartitionType_LIST          PartitionType = 6
	PartitionType_LIST_COLUMNS  PartitionType = 7
)

var PartitionType_name = map[int32]string{
	0: "KEY",
	1: "LINEAR_KEY",
	2: "HASH",
	3: "LINEAR_HASH",
	4: "RANGE",
	5: "RANGE_COLUMNS",
	6: "LIST",
	7: "LIST_COLUMNS",
}

var PartitionType_value = map[string]int32{
	"KEY":           0,
	"LINEAR_KEY":    1,
	"HASH":          2,
	"LINEAR_HASH":   3,
	"RANGE":         4,
	"RANGE_COLUMNS": 5,
	"LIST":          6,
	"LIST_COLUMNS":  7,
}

func (x PartitionType) String() string {
	return proto.EnumName(PartitionType_name, int32(x))
}

func (PartitionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{1}
}

type ShuffleType int32

const (
	ShuffleType_Hash  ShuffleType = 0
	ShuffleType_Range ShuffleType = 1
)

var ShuffleType_name = map[int32]string{
	0: "Hash",
	1: "Range",
}

var ShuffleType_value = map[string]int32{
	"Hash":  0,
	"Range": 1,
}

func (x ShuffleType) String() string {
	return proto.EnumName(ShuffleType_name, int32(x))
}

func (ShuffleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{2}
}

type ShuffleMethod int32

const (
	ShuffleMethod_Normal    ShuffleMethod = 0
	ShuffleMethod_Reuse     ShuffleMethod = 1
	ShuffleMethod_Reshuffle ShuffleMethod = 2
)

var ShuffleMethod_name = map[int32]string{
	0: "Normal",
	1: "Reuse",
	2: "Reshuffle",
}

var ShuffleMethod_value = map[string]int32{
	"Normal":    0,
	"Reuse":     1,
	"Reshuffle": 2,
}

func (x ShuffleMethod) String() string {
	return proto.EnumName(ShuffleMethod_name, int32(x))
}

func (ShuffleMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{3}
}

type ShuffleTypeForMultiCN int32

const (
	ShuffleTypeForMultiCN_Simple ShuffleTypeForMultiCN = 0
	ShuffleTypeForMultiCN_Hybrid ShuffleTypeForMultiCN = 1
)

var ShuffleTypeForMultiCN_name = map[int32]string{
	0: "Simple",
	1: "Hybrid",
}

var ShuffleTypeForMultiCN_value = map[string]int32{
	"Simple": 0,
	"Hybrid": 1,
}

func (x ShuffleTypeForMultiCN) String() string {
	return proto.EnumName(ShuffleTypeForMultiCN_name, int32(x))
}

func (ShuffleTypeForMultiCN) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{4}
}

type TransationCompletionType int32

const (
	TransationCompletionType_CHAIN    TransationCompletionType = 0
	TransationCompletionType_NO_CHAIN TransationCompletionType = 1
	TransationCompletionType_RELEASE  TransationCompletionType = 2
)

var TransationCompletionType_name = map[int32]string{
	0: "CHAIN",
	1: "NO_CHAIN",
	2: "RELEASE",
}

var TransationCompletionType_value = map[string]int32{
	"CHAIN":    0,
	"NO_CHAIN": 1,
	"RELEASE":  2,
}

func (x TransationCompletionType) String() string {
	return proto.EnumName(TransationCompletionType_name, int32(x))
}

func (TransationCompletionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{5}
}

type TableLockType int32

const (
	TableLockType_TableLockNone             TableLockType = 0
	TableLockType_TableLockRead             TableLockType = 1
	TableLockType_TableLockReadLocal        TableLockType = 2
	TableLockType_TableLockWrite            TableLockType = 3
	TableLockType_TableLockLowPriorityWrite TableLockType = 4
)

var TableLockType_name = map[int32]string{
	0: "TableLockNone",
	1: "TableLockRead",
	2: "TableLockReadLocal",
	3: "TableLockWrite",
	4: "TableLockLowPriorityWrite",
}

var TableLockType_value = map[string]int32{
	"TableLockNone":             0,
	"TableLockRead":             1,
	"TableLockReadLocal":        2,
	"TableLockWrite":            3,
	"TableLockLowPriorityWrite": 4,
}

func (x TableLockType) String() string {
	return proto.EnumName(TableLockType_name, int32(x))
}

func (TableLockType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{6}
}

type SubqueryRef_Type int32

const (
	SubqueryRef_SCALAR     SubqueryRef_Type = 0
	SubqueryRef_EXISTS     SubqueryRef_Type = 1
	SubqueryRef_NOT_EXISTS SubqueryRef_Type = 2
	SubqueryRef_IN         SubqueryRef_Type = 3
	SubqueryRef_NOT_IN     SubqueryRef_Type = 4
	SubqueryRef_ANY        SubqueryRef_Type = 5
	SubqueryRef_ALL        SubqueryRef_Type = 6
)

var SubqueryRef_Type_name = map[int32]string{
	0: "SCALAR",
	1: "EXISTS",
	2: "NOT_EXISTS",
	3: "IN",
	4: "NOT_IN",
	5: "ANY",
	6: "ALL",
}

var SubqueryRef_Type_value = map[string]int32{
	"SCALAR":     0,
	"EXISTS":     1,
	"NOT_EXISTS": 2,
	"IN":         3,
	"NOT_IN":     4,
	"ANY":        5,
	"ALL":        6,
}

func (x SubqueryRef_Type) String() string {
	return proto.EnumName(SubqueryRef_Type_name, int32(x))
}

func (SubqueryRef_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{11, 0}
}

// Function flags
type Function_FuncFlag int32

const (
	Function_NONE Function_FuncFlag = 0
	// Internal function is generated by system, cannot
	// by called by user.
	Function_INTERNAL Function_FuncFlag = 1
	// Function, by default is immutable.
	Function_STABLE   Function_FuncFlag = 2
	Function_VOLATILE Function_FuncFlag = 4
	// Nulls
	Function_STRICT          Function_FuncFlag = 8
	Function_PRODUCE_NULL    Function_FuncFlag = 16
	Function_PRODUCE_NO_NULL Function_FuncFlag = 32
	// Vararg, all trailing args must be of the same type.
	Function_VARARG Function_FuncFlag = 64
	// Window and Agg
	Function_AGG       Function_FuncFlag = 128
	Function_WIN_VALUE Function_FuncFlag = 256
	Function_WIN_ORDER Function_FuncFlag = 512
	// Filter which can be applied on zonemaps
	Function_ZONEMAPPABLE Function_FuncFlag = 1024
)

var Function_FuncFlag_name = map[int32]string{
	0:    "NONE",
	1:    "INTERNAL",
	2:    "STABLE",
	4:    "VOLATILE",
	8:    "STRICT",
	16:   "PRODUCE_NULL",
	32:   "PRODUCE_NO_NULL",
	64:   "VARARG",
	128:  "AGG",
	256:  "WIN_VALUE",
	512:  "WIN_ORDER",
	1024: "ZONEMAPPABLE",
}

var Function_FuncFlag_value = map[string]int32{
	"NONE":            0,
	"INTERNAL":        1,
	"STABLE":          2,
	"VOLATILE":        4,
	"STRICT":          8,
	"PRODUCE_NULL":    16,
	"PRODUCE_NO_NULL": 32,
	"VARARG":          64,
	"AGG":             128,
	"WIN_VALUE":       256,
	"WIN_ORDER":       512,
	"ZONEMAPPABLE":    1024,
}

func (x Function_FuncFlag) String() string {
	return proto.EnumName(Function_FuncFlag_name, int32(x))
}

func (Function_FuncFlag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{15, 0}
}

type ForeignKeyDef_RefAction int32

const (
	ForeignKeyDef_RESTRICT    ForeignKeyDef_RefAction = 0
	ForeignKeyDef_CASCADE     ForeignKeyDef_RefAction = 1
	ForeignKeyDef_SET_NULL    ForeignKeyDef_RefAction = 2
	ForeignKeyDef_SET_DEFAULT ForeignKeyDef_RefAction = 3
	ForeignKeyDef_NO_ACTION   ForeignKeyDef_RefAction = 4
)

var ForeignKeyDef_RefAction_name = map[int32]string{
	0: "RESTRICT",
	1: "CASCADE",
	2: "SET_NULL",
	3: "SET_DEFAULT",
	4: "NO_ACTION",
}

var ForeignKeyDef_RefAction_value = map[string]int32{
	"RESTRICT":    0,
	"CASCADE":     1,
	"SET_NULL":    2,
	"SET_DEFAULT": 3,
	"NO_ACTION":   4,
}

func (x ForeignKeyDef_RefAction) String() string {
	return proto.EnumName(ForeignKeyDef_RefAction_name, int32(x))
}

func (ForeignKeyDef_RefAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{27, 0}
}

type OrderBySpec_OrderByFlag int32

const (
	OrderBySpec_INTERNAL    OrderBySpec_OrderByFlag = 0
	OrderBySpec_ASC         OrderBySpec_OrderByFlag = 1
	OrderBySpec_DESC        OrderBySpec_OrderByFlag = 2
	OrderBySpec_NULLS_FIRST OrderBySpec_OrderByFlag = 4
	OrderBySpec_NULLS_LAST  OrderBySpec_OrderByFlag = 8
	OrderBySpec_UNIQUE      OrderBySpec_OrderByFlag = 16
)

var OrderBySpec_OrderByFlag_name = map[int32]string{
	0:  "INTERNAL",
	1:  "ASC",
	2:  "DESC",
	4:  "NULLS_FIRST",
	8:  "NULLS_LAST",
	16: "UNIQUE",
}

var OrderBySpec_OrderByFlag_value = map[string]int32{
	"INTERNAL":    0,
	"ASC":         1,
	"DESC":        2,
	"NULLS_FIRST": 4,
	"NULLS_LAST":  8,
	"UNIQUE":      16,
}

func (x OrderBySpec_OrderByFlag) String() string {
	return proto.EnumName(OrderBySpec_OrderByFlag_name, int32(x))
}

func (OrderBySpec_OrderByFlag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{45, 0}
}

type FrameClause_FrameType int32

const (
	FrameClause_ROWS  FrameClause_FrameType = 0
	FrameClause_RANGE FrameClause_FrameType = 1
)

var FrameClause_FrameType_name = map[int32]string{
	0: "ROWS",
	1: "RANGE",
}

var FrameClause_FrameType_value = map[string]int32{
	"ROWS":  0,
	"RANGE": 1,
}

func (x FrameClause_FrameType) String() string {
	return proto.EnumName(FrameClause_FrameType_name, int32(x))
}

func (FrameClause_FrameType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{48, 0}
}

type FrameBound_BoundType int32

const (
	FrameBound_FOLLOWING   FrameBound_BoundType = 0
	FrameBound_PRECEDING   FrameBound_BoundType = 1
	FrameBound_CURRENT_ROW FrameBound_BoundType = 2
)

var FrameBound_BoundType_name = map[int32]string{
	0: "FOLLOWING",
	1: "PRECEDING",
	2: "CURRENT_ROW",
}

var FrameBound_BoundType_value = map[string]int32{
	"FOLLOWING":   0,
	"PRECEDING":   1,
	"CURRENT_ROW": 2,
}

func (x FrameBound_BoundType) String() string {
	return proto.EnumName(FrameBound_BoundType_name, int32(x))
}

func (FrameBound_BoundType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{49, 0}
}

type Node_NodeType int32

const (
	Node_UNKNOWN Node_NodeType = 0
	// Scans
	Node_VALUE_SCAN    Node_NodeType = 1
	Node_TABLE_SCAN    Node_NodeType = 2
	Node_FUNCTION_SCAN Node_NodeType = 3
	Node_EXTERNAL_SCAN Node_NodeType = 4
	Node_MATERIAL_SCAN Node_NodeType = 5
	Node_SOURCE_SCAN   Node_NodeType = 6
	// Proj, for convenience
	Node_PROJECT Node_NodeType = 10
	// External function call (UDF)
	Node_EXTERNAL_FUNCTION Node_NodeType = 11
	// Material, CTE, etc.
	Node_MATERIAL       Node_NodeType = 20
	Node_RECURSIVE_CTE  Node_NodeType = 21
	Node_SINK           Node_NodeType = 22
	Node_SINK_SCAN      Node_NodeType = 23
	Node_RECURSIVE_SCAN Node_NodeType = 24
	// Proper Relational Operators
	Node_AGG       Node_NodeType = 30
	Node_DISTINCT  Node_NodeType = 31
	Node_FILTER    Node_NodeType = 32
	Node_JOIN      Node_NodeType = 33
	Node_SAMPLE    Node_NodeType = 34
	Node_SORT      Node_NodeType = 35
	Node_UNION     Node_NodeType = 36
	Node_UNION_ALL Node_NodeType = 37
	Node_UNIQUE    Node_NodeType = 38
	Node_WINDOW    Node_NodeType = 39
	// Physical tuple mover
	Node_BROADCAST Node_NodeType = 40
	Node_SPLIT     Node_NodeType = 41
	Node_GATHER    Node_NodeType = 42
	// Misc
	Node_ASSERT Node_NodeType = 50
	//
	Node_INSERT  Node_NodeType = 51
	Node_DELETE  Node_NodeType = 52
	Node_REPLACE Node_NodeType = 53
	//
	Node_LOCK_OP Node_NodeType = 54
	//
	Node_INTERSECT     Node_NodeType = 55
	Node_INTERSECT_ALL Node_NodeType = 56
	Node_MINUS         Node_NodeType = 57
	Node_MINUS_ALL     Node_NodeType = 58
	//
	Node_ON_DUPLICATE_KEY Node_NodeType = 59
	Node_PRE_INSERT       Node_NodeType = 60
	Node_PRE_DELETE       Node_NodeType = 61
	// the node which build insert batch for hidden table(unique key)
	Node_PRE_INSERT_UK Node_NodeType = 62
	Node_PRE_INSERT_SK Node_NodeType = 63
	//
	Node_TIME_WINDOW  Node_NodeType = 64
	Node_FILL         Node_NodeType = 65
	Node_PARTITION    Node_NodeType = 66
	Node_FUZZY_FILTER Node_NodeType = 67
)

var Node_NodeType_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "VALUE_SCAN",
	2:  "TABLE_SCAN",
	3:  "FUNCTION_SCAN",
	4:  "EXTERNAL_SCAN",
	5:  "MATERIAL_SCAN",
	6:  "SOURCE_SCAN",
	10: "PROJECT",
	11: "EXTERNAL_FUNCTION",
	20: "MATERIAL",
	21: "RECURSIVE_CTE",
	22: "SINK",
	23: "SINK_SCAN",
	24: "RECURSIVE_SCAN",
	30: "AGG",
	31: "DISTINCT",
	32: "FILTER",
	33: "JOIN",
	34: "SAMPLE",
	35: "SORT",
	36: "UNION",
	37: "UNION_ALL",
	38: "UNIQUE",
	39: "WINDOW",
	40: "BROADCAST",
	41: "SPLIT",
	42: "GATHER",
	50: "ASSERT",
	51: "INSERT",
	52: "DELETE",
	53: "REPLACE",
	54: "LOCK_OP",
	55: "INTERSECT",
	56: "INTERSECT_ALL",
	57: "MINUS",
	58: "MINUS_ALL",
	59: "ON_DUPLICATE_KEY",
	60: "PRE_INSERT",
	61: "PRE_DELETE",
	62: "PRE_INSERT_UK",
	63: "PRE_INSERT_SK",
	64: "TIME_WINDOW",
	65: "FILL",
	66: "PARTITION",
	67: "FUZZY_FILTER",
}

var Node_NodeType_value = map[string]int32{
	"UNKNOWN":           0,
	"VALUE_SCAN":        1,
	"TABLE_SCAN":        2,
	"FUNCTION_SCAN":     3,
	"EXTERNAL_SCAN":     4,
	"MATERIAL_SCAN":     5,
	"SOURCE_SCAN":       6,
	"PROJECT":           10,
	"EXTERNAL_FUNCTION": 11,
	"MATERIAL":          20,
	"RECURSIVE_CTE":     21,
	"SINK":              22,
	"SINK_SCAN":         23,
	"RECURSIVE_SCAN":    24,
	"AGG":               30,
	"DISTINCT":          31,
	"FILTER":            32,
	"JOIN":              33,
	"SAMPLE":            34,
	"SORT":              35,
	"UNION":             36,
	"UNION_ALL":         37,
	"UNIQUE":            38,
	"WINDOW":            39,
	"BROADCAST":         40,
	"SPLIT":             41,
	"GATHER":            42,
	"ASSERT":            50,
	"INSERT":            51,
	"DELETE":            52,
	"REPLACE":           53,
	"LOCK_OP":           54,
	"INTERSECT":         55,
	"INTERSECT_ALL":     56,
	"MINUS":             57,
	"MINUS_ALL":         58,
	"ON_DUPLICATE_KEY":  59,
	"PRE_INSERT":        60,
	"PRE_DELETE":        61,
	"PRE_INSERT_UK":     62,
	"PRE_INSERT_SK":     63,
	"TIME_WINDOW":       64,
	"FILL":              65,
	"PARTITION":         66,
	"FUZZY_FILTER":      67,
}

func (x Node_NodeType) String() string {
	return proto.EnumName(Node_NodeType_name, int32(x))
}

func (Node_NodeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{56, 0}
}

type Node_JoinType int32

const (
	Node_INNER  Node_JoinType = 0
	Node_LEFT   Node_JoinType = 1
	Node_RIGHT  Node_JoinType = 2
	Node_OUTER  Node_JoinType = 3
	Node_SEMI   Node_JoinType = 4
	Node_ANTI   Node_JoinType = 5
	Node_SINGLE Node_JoinType = 6
	Node_MARK   Node_JoinType = 7
	Node_APPLY  Node_JoinType = 8
	Node_INDEX  Node_JoinType = 9
)

var Node_JoinType_name = map[int32]string{
	0: "INNER",
	1: "LEFT",
	2: "RIGHT",
	3: "OUTER",
	4: "SEMI",
	5: "ANTI",
	6: "SINGLE",
	7: "MARK",
	8: "APPLY",
	9: "INDEX",
}

var Node_JoinType_value = map[string]int32{
	"INNER":  0,
	"LEFT":   1,
	"RIGHT":  2,
	"OUTER":  3,
	"SEMI":   4,
	"ANTI":   5,
	"SINGLE": 6,
	"MARK":   7,
	"APPLY":  8,
	"INDEX":  9,
}

func (x Node_JoinType) String() string {
	return proto.EnumName(Node_JoinType_name, int32(x))
}

func (Node_JoinType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{56, 1}
}

type Node_AggMode int32

const (
	Node_FULL   Node_AggMode = 0
	Node_BOTTOM Node_AggMode = 1
	Node_TOP    Node_AggMode = 2
)

var Node_AggMode_name = map[int32]string{
	0: "FULL",
	1: "BOTTOM",
	2: "TOP",
}

var Node_AggMode_value = map[string]int32{
	"FULL":   0,
	"BOTTOM": 1,
	"TOP":    2,
}

func (x Node_AggMode) String() string {
	return proto.EnumName(Node_AggMode_name, int32(x))
}

func (Node_AggMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{56, 2}
}

type Node_FillType int32

const (
	Node_NONE   Node_FillType = 0
	Node_PREV   Node_FillType = 1
	Node_NEXT   Node_FillType = 2
	Node_NULL   Node_FillType = 3
	Node_VALUE  Node_FillType = 4
	Node_LINEAR Node_FillType = 5
)

var Node_FillType_name = map[int32]string{
	0: "NONE",
	1: "PREV",
	2: "NEXT",
	3: "NULL",
	4: "VALUE",
	5: "LINEAR",
}

var Node_FillType_value = map[string]int32{
	"NONE":   0,
	"PREV":   1,
	"NEXT":   2,
	"NULL":   3,
	"VALUE":  4,
	"LINEAR": 5,
}

func (x Node_FillType) String() string {
	return proto.EnumName(Node_FillType_name, int32(x))
}

func (Node_FillType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{56, 3}
}

type Query_StatementType int32

const (
	Query_UNKNOWN Query_StatementType = 0
	Query_SELECT  Query_StatementType = 1
	Query_INSERT  Query_StatementType = 2
	Query_REPLACE Query_StatementType = 3
	Query_DELETE  Query_StatementType = 4
	Query_UPDATE  Query_StatementType = 5
	Query_MERGE   Query_StatementType = 6
)

var Query_StatementType_name = map[int32]string{
	0: "UNKNOWN",
	1: "SELECT",
	2: "INSERT",
	3: "REPLACE",
	4: "DELETE",
	5: "UPDATE",
	6: "MERGE",
}

var Query_StatementType_value = map[string]int32{
	"UNKNOWN": 0,
	"SELECT":  1,
	"INSERT":  2,
	"REPLACE": 3,
	"DELETE":  4,
	"UPDATE":  5,
	"MERGE":   6,
}

func (x Query_StatementType) String() string {
	return proto.EnumName(Query_StatementType_name, int32(x))
}

func (Query_StatementType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{68, 0}
}

type TransationControl_TclType int32

const (
	TransationControl_BEGIN    TransationControl_TclType = 0
	TransationControl_COMMIT   TransationControl_TclType = 1
	TransationControl_ROLLBACK TransationControl_TclType = 2
)

var TransationControl_TclType_name = map[int32]string{
	0: "BEGIN",
	1: "COMMIT",
	2: "ROLLBACK",
}

var TransationControl_TclType_value = map[string]int32{
	"BEGIN":    0,
	"COMMIT":   1,
	"ROLLBACK": 2,
}

func (x TransationControl_TclType) String() string {
	return proto.EnumName(TransationControl_TclType_name, int32(x))
}

func (TransationControl_TclType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{69, 0}
}

type TransationBegin_TransationMode int32

const (
	TransationBegin_NONE       TransationBegin_TransationMode = 0
	TransationBegin_READ_ONLY  TransationBegin_TransationMode = 1
	TransationBegin_READ_WRITE TransationBegin_TransationMode = 2
)

var TransationBegin_TransationMode_name = map[int32]string{
	0: "NONE",
	1: "READ_ONLY",
	2: "READ_WRITE",
}

var TransationBegin_TransationMode_value = map[string]int32{
	"NONE":       0,
	"READ_ONLY":  1,
	"READ_WRITE": 2,
}

func (x TransationBegin_TransationMode) String() string {
	return proto.EnumName(TransationBegin_TransationMode_name, int32(x))
}

func (TransationBegin_TransationMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{70, 0}
}

type DataControl_DclType int32

const (
	DataControl_SET_VARIABLES  DataControl_DclType = 0
	DataControl_GRANT          DataControl_DclType = 1
	DataControl_REVOKE         DataControl_DclType = 2
	DataControl_DENY           DataControl_DclType = 3
	DataControl_PREPARE        DataControl_DclType = 4
	DataControl_EXECUTE        DataControl_DclType = 5
	DataControl_DEALLOCATE     DataControl_DclType = 6
	DataControl_CREATE_ACCOUNT DataControl_DclType = 7
	DataControl_ALTER_ACCOUNT  DataControl_DclType = 8
	DataControl_DROP_ACCOUNT   DataControl_DclType = 9
)

var DataControl_DclType_name = map[int32]string{
	0: "SET_VARIABLES",
	1: "GRANT",
	2: "REVOKE",
	3: "DENY",
	4: "PREPARE",
	5: "EXECUTE",
	6: "DEALLOCATE",
	7: "CREATE_ACCOUNT",
	8: "ALTER_ACCOUNT",
	9: "DROP_ACCOUNT",
}

var DataControl_DclType_value = map[string]int32{
	"SET_VARIABLES":  0,
	"GRANT":          1,
	"REVOKE":         2,
	"DENY":           3,
	"PREPARE":        4,
	"EXECUTE":        5,
	"DEALLOCATE":     6,
	"CREATE_ACCOUNT": 7,
	"ALTER_ACCOUNT":  8,
	"DROP_ACCOUNT":   9,
}

func (x DataControl_DclType) String() string {
	return proto.EnumName(DataControl_DclType_name, int32(x))
}

func (DataControl_DclType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{75, 0}
}

type DataDefinition_DdlType int32

const (
	DataDefinition_CREATE_DATABASE     DataDefinition_DdlType = 0
	DataDefinition_ALTER_DATABASE      DataDefinition_DdlType = 1
	DataDefinition_DROP_DATABASE       DataDefinition_DdlType = 2
	DataDefinition_CREATE_TABLE        DataDefinition_DdlType = 3
	DataDefinition_ALTER_TABLE         DataDefinition_DdlType = 4
	DataDefinition_DROP_TABLE          DataDefinition_DdlType = 5
	DataDefinition_CREATE_INDEX        DataDefinition_DdlType = 6
	DataDefinition_ALTER_INDEX         DataDefinition_DdlType = 7
	DataDefinition_DROP_INDEX          DataDefinition_DdlType = 8
	DataDefinition_TRUNCATE_TABLE      DataDefinition_DdlType = 9
	DataDefinition_CREATE_VIEW         DataDefinition_DdlType = 10
	DataDefinition_ALTER_VIEW          DataDefinition_DdlType = 11
	DataDefinition_DROP_VIEW           DataDefinition_DdlType = 12
	DataDefinition_SHOW_CREATEDATABASE DataDefinition_DdlType = 13
	DataDefinition_SHOW_CREATETABLE    DataDefinition_DdlType = 14
	DataDefinition_SHOW_DATABASES      DataDefinition_DdlType = 15
	DataDefinition_SHOW_TABLES         DataDefinition_DdlType = 16
	DataDefinition_SHOW_COLUMNS        DataDefinition_DdlType = 17
	DataDefinition_SHOW_INDEX          DataDefinition_DdlType = 18
	DataDefinition_SHOW_VARIABLES      DataDefinition_DdlType = 19
	DataDefinition_SHOW_WARNINGS       DataDefinition_DdlType = 20
	DataDefinition_SHOW_ERRORS         DataDefinition_DdlType = 21
	DataDefinition_SHOW_STATUS         DataDefinition_DdlType = 22
	DataDefinition_SHOW_PROCESSLIST    DataDefinition_DdlType = 23
	DataDefinition_SHOW_TABLE_STATUS   DataDefinition_DdlType = 24
	DataDefinition_SHOW_TARGET         DataDefinition_DdlType = 25
	DataDefinition_SHOW_COLLATION      DataDefinition_DdlType = 26
	DataDefinition_LOCK_TABLES         DataDefinition_DdlType = 27
	DataDefinition_UNLOCK_TABLES       DataDefinition_DdlType = 28
	DataDefinition_CREATE_SEQUENCE     DataDefinition_DdlType = 29
	DataDefinition_ALTER_SEQUENCE      DataDefinition_DdlType = 30
	DataDefinition_DROP_SEQUENCE       DataDefinition_DdlType = 31
	DataDefinition_SHOW_SEQUENCES      DataDefinition_DdlType = 32
	DataDefinition_SHOW_CONNECTORS     DataDefinition_DdlType = 33
	DataDefinition_SHOW_UPGRADE        DataDefinition_DdlType = 34
)

var DataDefinition_DdlType_name = map[int32]string{
	0:  "CREATE_DATABASE",
	1:  "ALTER_DATABASE",
	2:  "DROP_DATABASE",
	3:  "CREATE_TABLE",
	4:  "ALTER_TABLE",
	5:  "DROP_TABLE",
	6:  "CREATE_INDEX",
	7:  "ALTER_INDEX",
	8:  "DROP_INDEX",
	9:  "TRUNCATE_TABLE",
	10: "CREATE_VIEW",
	11: "ALTER_VIEW",
	12: "DROP_VIEW",
	13: "SHOW_CREATEDATABASE",
	14: "SHOW_CREATETABLE",
	15: "SHOW_DATABASES",
	16: "SHOW_TABLES",
	17: "SHOW_COLUMNS",
	18: "SHOW_INDEX",
	19: "SHOW_VARIABLES",
	20: "SHOW_WARNINGS",
	21: "SHOW_ERRORS",
	22: "SHOW_STATUS",
	23: "SHOW_PROCESSLIST",
	24: "SHOW_TABLE_STATUS",
	25: "SHOW_TARGET",
	26: "SHOW_COLLATION",
	27: "LOCK_TABLES",
	28: "UNLOCK_TABLES",
	29: "CREATE_SEQUENCE",
	30: "ALTER_SEQUENCE",
	31: "DROP_SEQUENCE",
	32: "SHOW_SEQUENCES",
	33: "SHOW_CONNECTORS",
	34: "SHOW_UPGRADE",
}

var DataDefinition_DdlType_value = map[string]int32{
	"CREATE_DATABASE":     0,
	"ALTER_DATABASE":      1,
	"DROP_DATABASE":       2,
	"CREATE_TABLE":        3,
	"ALTER_TABLE":         4,
	"DROP_TABLE":          5,
	"CREATE_INDEX":        6,
	"ALTER_INDEX":         7,
	"DROP_INDEX":          8,
	"TRUNCATE_TABLE":      9,
	"CREATE_VIEW":         10,
	"ALTER_VIEW":          11,
	"DROP_VIEW":           12,
	"SHOW_CREATEDATABASE": 13,
	"SHOW_CREATETABLE":    14,
	"SHOW_DATABASES":      15,
	"SHOW_TABLES":         16,
	"SHOW_COLUMNS":        17,
	"SHOW_INDEX":          18,
	"SHOW_VARIABLES":      19,
	"SHOW_WARNINGS":       20,
	"SHOW_ERRORS":         21,
	"SHOW_STATUS":         22,
	"SHOW_PROCESSLIST":    23,
	"SHOW_TABLE_STATUS":   24,
	"SHOW_TARGET":         25,
	"SHOW_COLLATION":      26,
	"LOCK_TABLES":         27,
	"UNLOCK_TABLES":       28,
	"CREATE_SEQUENCE":     29,
	"ALTER_SEQUENCE":      30,
	"DROP_SEQUENCE":       31,
	"SHOW_SEQUENCES":      32,
	"SHOW_CONNECTORS":     33,
	"SHOW_UPGRADE":        34,
}

func (x DataDefinition_DdlType) String() string {
	return proto.EnumName(DataDefinition_DdlType_name, int32(x))
}

func (DataDefinition_DdlType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{76, 0}
}

type AlterTableDrop_Typ int32

const (
	AlterTableDrop_COLUMN      AlterTableDrop_Typ = 0
	AlterTableDrop_INDEX       AlterTableDrop_Typ = 1
	AlterTableDrop_KEY         AlterTableDrop_Typ = 2
	AlterTableDrop_PRIMARY_KEY AlterTableDrop_Typ = 3
	AlterTableDrop_FOREIGN_KEY AlterTableDrop_Typ = 4
)

var AlterTableDrop_Typ_name = map[int32]string{
	0: "COLUMN",
	1: "INDEX",
	2: "KEY",
	3: "PRIMARY_KEY",
	4: "FOREIGN_KEY",
}

var AlterTableDrop_Typ_value = map[string]int32{
	"COLUMN":      0,
	"INDEX":       1,
	"KEY":         2,
	"PRIMARY_KEY": 3,
	"FOREIGN_KEY": 4,
}

func (x AlterTableDrop_Typ) String() string {
	return proto.EnumName(AlterTableDrop_Typ_name, int32(x))
}

func (AlterTableDrop_Typ) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{84, 0}
}

type AlterTable_AlgorithmType int32

const (
	AlterTable_DEFAULT AlterTable_AlgorithmType = 0
	AlterTable_COPY    AlterTable_AlgorithmType = 1
	AlterTable_INSTANT AlterTable_AlgorithmType = 2
	AlterTable_INPLACE AlterTable_AlgorithmType = 3
)

var AlterTable_AlgorithmType_name = map[int32]string{
	0: "DEFAULT",
	1: "COPY",
	2: "INSTANT",
	3: "INPLACE",
}

var AlterTable_AlgorithmType_value = map[string]int32{
	"DEFAULT": 0,
	"COPY":    1,
	"INSTANT": 2,
	"INPLACE": 3,
}

func (x AlterTable_AlgorithmType) String() string {
	return proto.EnumName(AlterTable_AlgorithmType_name, int32(x))
}

func (AlterTable_AlgorithmType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{95, 0}
}

type MetadataScanInfo_MetadataScanInfoType int32

const (
	MetadataScanInfo_COL_NAME      MetadataScanInfo_MetadataScanInfoType = 0
	MetadataScanInfo_OBJECT_NAME   MetadataScanInfo_MetadataScanInfoType = 1
	MetadataScanInfo_IS_HIDDEN     MetadataScanInfo_MetadataScanInfoType = 2
	MetadataScanInfo_OBJ_LOC       MetadataScanInfo_MetadataScanInfoType = 3
	MetadataScanInfo_CREATE_TS     MetadataScanInfo_MetadataScanInfoType = 4
	MetadataScanInfo_DELETE_TS     MetadataScanInfo_MetadataScanInfoType = 5
	MetadataScanInfo_ROWS_CNT      MetadataScanInfo_MetadataScanInfoType = 6
	MetadataScanInfo_NULL_CNT      MetadataScanInfo_MetadataScanInfoType = 7
	MetadataScanInfo_COMPRESS_SIZE MetadataScanInfo_MetadataScanInfoType = 8
	MetadataScanInfo_ORIGIN_SIZE   MetadataScanInfo_MetadataScanInfoType = 9
	MetadataScanInfo_MIN           MetadataScanInfo_MetadataScanInfoType = 10
	MetadataScanInfo_MAX           MetadataScanInfo_MetadataScanInfoType = 11
	MetadataScanInfo_SUM           MetadataScanInfo_MetadataScanInfoType = 12
)

var MetadataScanInfo_MetadataScanInfoType_name = map[int32]string{
	0:  "COL_NAME",
	1:  "OBJECT_NAME",
	2:  "IS_HIDDEN",
	3:  "OBJ_LOC",
	4:  "CREATE_TS",
	5:  "DELETE_TS",
	6:  "ROWS_CNT",
	7:  "NULL_CNT",
	8:  "COMPRESS_SIZE",
	9:  "ORIGIN_SIZE",
	10: "MIN",
	11: "MAX",
	12: "SUM",
}

var MetadataScanInfo_MetadataScanInfoType_value = map[string]int32{
	"COL_NAME":      0,
	"OBJECT_NAME":   1,
	"IS_HIDDEN":     2,
	"OBJ_LOC":       3,
	"CREATE_TS":     4,
	"DELETE_TS":     5,
	"ROWS_CNT":      6,
	"NULL_CNT":      7,
	"COMPRESS_SIZE": 8,
	"ORIGIN_SIZE":   9,
	"MIN":           10,
	"MAX":           11,
	"SUM":           12,
}

func (x MetadataScanInfo_MetadataScanInfoType) String() string {
	return proto.EnumName(MetadataScanInfo_MetadataScanInfoType_name, int32(x))
}

func (MetadataScanInfo_MetadataScanInfoType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{116, 0}
}

type Type struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	NotNullable          bool     `protobuf:"varint,2,opt,name=notNullable,proto3" json:"notNullable,omitempty"`
	AutoIncr             bool     `protobuf:"varint,3,opt,name=auto_incr,json=autoIncr,proto3" json:"auto_incr,omitempty"`
	Width                int32    `protobuf:"varint,4,opt,name=width,proto3" json:"width,omitempty"`
	Scale                int32    `protobuf:"varint,5,opt,name=scale,proto3" json:"scale,omitempty"`
	Table                string   `protobuf:"bytes,6,opt,name=table,proto3" json:"table,omitempty"`
	Enumvalues           string   `protobuf:"bytes,7,opt,name=enumvalues,proto3" json:"enumvalues,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Type) Reset()         { *m = Type{} }
func (m *Type) String() string { return proto.CompactTextString(m) }
func (*Type) ProtoMessage()    {}
func (*Type) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{0}
}
func (m *Type) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Type) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Type.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Type) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Type.Merge(m, src)
}
func (m *Type) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Type) XXX_DiscardUnknown() {
	xxx_messageInfo_Type.DiscardUnknown(m)
}

var xxx_messageInfo_Type proto.InternalMessageInfo

func (m *Type) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Type) GetNotNullable() bool {
	if m != nil {
		return m.NotNullable
	}
	return false
}

func (m *Type) GetAutoIncr() bool {
	if m != nil {
		return m.AutoIncr
	}
	return false
}

func (m *Type) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Type) GetScale() int32 {
	if m != nil {
		return m.Scale
	}
	return 0
}

func (m *Type) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *Type) GetEnumvalues() string {
	if m != nil {
		return m.Enumvalues
	}
	return ""
}

type MsgHeader struct {
	MsgTag               int32    `protobuf:"varint,1,opt,name=msg_tag,json=msgTag,proto3" json:"msg_tag,omitempty"`
	MsgType              int32    `protobuf:"varint,2,opt,name=msg_type,json=msgType,proto3" json:"msg_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MsgHeader) Reset()         { *m = MsgHeader{} }
func (m *MsgHeader) String() string { return proto.CompactTextString(m) }
func (*MsgHeader) ProtoMessage()    {}
func (*MsgHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{1}
}
func (m *MsgHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgHeader.Merge(m, src)
}
func (m *MsgHeader) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MsgHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgHeader.DiscardUnknown(m)
}

var xxx_messageInfo_MsgHeader proto.InternalMessageInfo

func (m *MsgHeader) GetMsgTag() int32 {
	if m != nil {
		return m.MsgTag
	}
	return 0
}

func (m *MsgHeader) GetMsgType() int32 {
	if m != nil {
		return m.MsgType
	}
	return 0
}

// Literal: if a literal value can be reprensented by int64 or
// double, use that, otherwise store a string representation.
type Literal struct {
	Isnull bool `protobuf:"varint,1,opt,name=isnull,proto3" json:"isnull,omitempty"`
	// Types that are valid to be assigned to Value:
	//	*Literal_I8Val
	//	*Literal_I16Val
	//	*Literal_I32Val
	//	*Literal_I64Val
	//	*Literal_U8Val
	//	*Literal_U16Val
	//	*Literal_U32Val
	//	*Literal_U64Val
	//	*Literal_Dval
	//	*Literal_Sval
	//	*Literal_Bval
	//	*Literal_Fval
	//	*Literal_Dateval
	//	*Literal_Timeval
	//	*Literal_Datetimeval
	//	*Literal_Decimal64Val
	//	*Literal_Decimal128Val
	//	*Literal_Timestampval
	//	*Literal_Jsonval
	//	*Literal_Defaultval
	//	*Literal_UpdateVal
	//	*Literal_EnumVal
	Value                isLiteral_Value `protobuf_oneof:"value"`
	IsBin                bool            `protobuf:"varint,24,opt,name=isBin,proto3" json:"isBin,omitempty"`
	Src                  *Expr           `protobuf:"bytes,25,opt,name=src,proto3" json:"src,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Literal) Reset()         { *m = Literal{} }
func (m *Literal) String() string { return proto.CompactTextString(m) }
func (*Literal) ProtoMessage()    {}
func (*Literal) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{2}
}
func (m *Literal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Literal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Literal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Literal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Literal.Merge(m, src)
}
func (m *Literal) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Literal) XXX_DiscardUnknown() {
	xxx_messageInfo_Literal.DiscardUnknown(m)
}

var xxx_messageInfo_Literal proto.InternalMessageInfo

type isLiteral_Value interface {
	isLiteral_Value()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type Literal_I8Val struct {
	I8Val int32 `protobuf:"varint,2,opt,name=i8val,proto3,oneof" json:"i8val,omitempty"`
}
type Literal_I16Val struct {
	I16Val int32 `protobuf:"varint,3,opt,name=i16val,proto3,oneof" json:"i16val,omitempty"`
}
type Literal_I32Val struct {
	I32Val int32 `protobuf:"varint,4,opt,name=i32val,proto3,oneof" json:"i32val,omitempty"`
}
type Literal_I64Val struct {
	I64Val int64 `protobuf:"varint,5,opt,name=i64val,proto3,oneof" json:"i64val,omitempty"`
}
type Literal_U8Val struct {
	U8Val uint32 `protobuf:"varint,6,opt,name=u8val,proto3,oneof" json:"u8val,omitempty"`
}
type Literal_U16Val struct {
	U16Val uint32 `protobuf:"varint,7,opt,name=u16val,proto3,oneof" json:"u16val,omitempty"`
}
type Literal_U32Val struct {
	U32Val uint32 `protobuf:"varint,8,opt,name=u32val,proto3,oneof" json:"u32val,omitempty"`
}
type Literal_U64Val struct {
	U64Val uint64 `protobuf:"varint,9,opt,name=u64val,proto3,oneof" json:"u64val,omitempty"`
}
type Literal_Dval struct {
	Dval float64 `protobuf:"fixed64,10,opt,name=dval,proto3,oneof" json:"dval,omitempty"`
}
type Literal_Sval struct {
	Sval string `protobuf:"bytes,11,opt,name=sval,proto3,oneof" json:"sval,omitempty"`
}
type Literal_Bval struct {
	Bval bool `protobuf:"varint,12,opt,name=bval,proto3,oneof" json:"bval,omitempty"`
}
type Literal_Fval struct {
	Fval float32 `protobuf:"fixed32,13,opt,name=fval,proto3,oneof" json:"fval,omitempty"`
}
type Literal_Dateval struct {
	Dateval int32 `protobuf:"varint,14,opt,name=dateval,proto3,oneof" json:"dateval,omitempty"`
}
type Literal_Timeval struct {
	Timeval int64 `protobuf:"varint,15,opt,name=timeval,proto3,oneof" json:"timeval,omitempty"`
}
type Literal_Datetimeval struct {
	Datetimeval int64 `protobuf:"varint,16,opt,name=datetimeval,proto3,oneof" json:"datetimeval,omitempty"`
}
type Literal_Decimal64Val struct {
	Decimal64Val *Decimal64 `protobuf:"bytes,17,opt,name=decimal64val,proto3,oneof" json:"decimal64val,omitempty"`
}
type Literal_Decimal128Val struct {
	Decimal128Val *Decimal128 `protobuf:"bytes,18,opt,name=decimal128val,proto3,oneof" json:"decimal128val,omitempty"`
}
type Literal_Timestampval struct {
	Timestampval int64 `protobuf:"varint,19,opt,name=timestampval,proto3,oneof" json:"timestampval,omitempty"`
}
type Literal_Jsonval struct {
	Jsonval string `protobuf:"bytes,20,opt,name=jsonval,proto3,oneof" json:"jsonval,omitempty"`
}
type Literal_Defaultval struct {
	Defaultval bool `protobuf:"varint,21,opt,name=defaultval,proto3,oneof" json:"defaultval,omitempty"`
}
type Literal_UpdateVal struct {
	UpdateVal bool `protobuf:"varint,22,opt,name=updateVal,proto3,oneof" json:"updateVal,omitempty"`
}
type Literal_EnumVal struct {
	EnumVal uint32 `protobuf:"varint,23,opt,name=enumVal,proto3,oneof" json:"enumVal,omitempty"`
}

func (*Literal_I8Val) isLiteral_Value()         {}
func (*Literal_I16Val) isLiteral_Value()        {}
func (*Literal_I32Val) isLiteral_Value()        {}
func (*Literal_I64Val) isLiteral_Value()        {}
func (*Literal_U8Val) isLiteral_Value()         {}
func (*Literal_U16Val) isLiteral_Value()        {}
func (*Literal_U32Val) isLiteral_Value()        {}
func (*Literal_U64Val) isLiteral_Value()        {}
func (*Literal_Dval) isLiteral_Value()          {}
func (*Literal_Sval) isLiteral_Value()          {}
func (*Literal_Bval) isLiteral_Value()          {}
func (*Literal_Fval) isLiteral_Value()          {}
func (*Literal_Dateval) isLiteral_Value()       {}
func (*Literal_Timeval) isLiteral_Value()       {}
func (*Literal_Datetimeval) isLiteral_Value()   {}
func (*Literal_Decimal64Val) isLiteral_Value()  {}
func (*Literal_Decimal128Val) isLiteral_Value() {}
func (*Literal_Timestampval) isLiteral_Value()  {}
func (*Literal_Jsonval) isLiteral_Value()       {}
func (*Literal_Defaultval) isLiteral_Value()    {}
func (*Literal_UpdateVal) isLiteral_Value()     {}
func (*Literal_EnumVal) isLiteral_Value()       {}

func (m *Literal) GetValue() isLiteral_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Literal) GetIsnull() bool {
	if m != nil {
		return m.Isnull
	}
	return false
}

func (m *Literal) GetI8Val() int32 {
	if x, ok := m.GetValue().(*Literal_I8Val); ok {
		return x.I8Val
	}
	return 0
}

func (m *Literal) GetI16Val() int32 {
	if x, ok := m.GetValue().(*Literal_I16Val); ok {
		return x.I16Val
	}
	return 0
}

func (m *Literal) GetI32Val() int32 {
	if x, ok := m.GetValue().(*Literal_I32Val); ok {
		return x.I32Val
	}
	return 0
}

func (m *Literal) GetI64Val() int64 {
	if x, ok := m.GetValue().(*Literal_I64Val); ok {
		return x.I64Val
	}
	return 0
}

func (m *Literal) GetU8Val() uint32 {
	if x, ok := m.GetValue().(*Literal_U8Val); ok {
		return x.U8Val
	}
	return 0
}

func (m *Literal) GetU16Val() uint32 {
	if x, ok := m.GetValue().(*Literal_U16Val); ok {
		return x.U16Val
	}
	return 0
}

func (m *Literal) GetU32Val() uint32 {
	if x, ok := m.GetValue().(*Literal_U32Val); ok {
		return x.U32Val
	}
	return 0
}

func (m *Literal) GetU64Val() uint64 {
	if x, ok := m.GetValue().(*Literal_U64Val); ok {
		return x.U64Val
	}
	return 0
}

func (m *Literal) GetDval() float64 {
	if x, ok := m.GetValue().(*Literal_Dval); ok {
		return x.Dval
	}
	return 0
}

func (m *Literal) GetSval() string {
	if x, ok := m.GetValue().(*Literal_Sval); ok {
		return x.Sval
	}
	return ""
}

func (m *Literal) GetBval() bool {
	if x, ok := m.GetValue().(*Literal_Bval); ok {
		return x.Bval
	}
	return false
}

func (m *Literal) GetFval() float32 {
	if x, ok := m.GetValue().(*Literal_Fval); ok {
		return x.Fval
	}
	return 0
}

func (m *Literal) GetDateval() int32 {
	if x, ok := m.GetValue().(*Literal_Dateval); ok {
		return x.Dateval
	}
	return 0
}

func (m *Literal) GetTimeval() int64 {
	if x, ok := m.GetValue().(*Literal_Timeval); ok {
		return x.Timeval
	}
	return 0
}

func (m *Literal) GetDatetimeval() int64 {
	if x, ok := m.GetValue().(*Literal_Datetimeval); ok {
		return x.Datetimeval
	}
	return 0
}

func (m *Literal) GetDecimal64Val() *Decimal64 {
	if x, ok := m.GetValue().(*Literal_Decimal64Val); ok {
		return x.Decimal64Val
	}
	return nil
}

func (m *Literal) GetDecimal128Val() *Decimal128 {
	if x, ok := m.GetValue().(*Literal_Decimal128Val); ok {
		return x.Decimal128Val
	}
	return nil
}

func (m *Literal) GetTimestampval() int64 {
	if x, ok := m.GetValue().(*Literal_Timestampval); ok {
		return x.Timestampval
	}
	return 0
}

func (m *Literal) GetJsonval() string {
	if x, ok := m.GetValue().(*Literal_Jsonval); ok {
		return x.Jsonval
	}
	return ""
}

func (m *Literal) GetDefaultval() bool {
	if x, ok := m.GetValue().(*Literal_Defaultval); ok {
		return x.Defaultval
	}
	return false
}

func (m *Literal) GetUpdateVal() bool {
	if x, ok := m.GetValue().(*Literal_UpdateVal); ok {
		return x.UpdateVal
	}
	return false
}

func (m *Literal) GetEnumVal() uint32 {
	if x, ok := m.GetValue().(*Literal_EnumVal); ok {
		return x.EnumVal
	}
	return 0
}

func (m *Literal) GetIsBin() bool {
	if m != nil {
		return m.IsBin
	}
	return false
}

func (m *Literal) GetSrc() *Expr {
	if m != nil {
		return m.Src
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Literal) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Literal_I8Val)(nil),
		(*Literal_I16Val)(nil),
		(*Literal_I32Val)(nil),
		(*Literal_I64Val)(nil),
		(*Literal_U8Val)(nil),
		(*Literal_U16Val)(nil),
		(*Literal_U32Val)(nil),
		(*Literal_U64Val)(nil),
		(*Literal_Dval)(nil),
		(*Literal_Sval)(nil),
		(*Literal_Bval)(nil),
		(*Literal_Fval)(nil),
		(*Literal_Dateval)(nil),
		(*Literal_Timeval)(nil),
		(*Literal_Datetimeval)(nil),
		(*Literal_Decimal64Val)(nil),
		(*Literal_Decimal128Val)(nil),
		(*Literal_Timestampval)(nil),
		(*Literal_Jsonval)(nil),
		(*Literal_Defaultval)(nil),
		(*Literal_UpdateVal)(nil),
		(*Literal_EnumVal)(nil),
	}
}

// Bounded param for prepared statement.  User fill on execution.
type ParamRef struct {
	Pos                  int32    `protobuf:"varint,1,opt,name=pos,proto3" json:"pos,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ParamRef) Reset()         { *m = ParamRef{} }
func (m *ParamRef) String() string { return proto.CompactTextString(m) }
func (*ParamRef) ProtoMessage()    {}
func (*ParamRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{3}
}
func (m *ParamRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParamRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParamRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParamRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParamRef.Merge(m, src)
}
func (m *ParamRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ParamRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ParamRef.DiscardUnknown(m)
}

var xxx_messageInfo_ParamRef proto.InternalMessageInfo

func (m *ParamRef) GetPos() int32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

// Session variable ref, compiler should fold.
type VarRef struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	System               bool     `protobuf:"varint,2,opt,name=system,proto3" json:"system,omitempty"`
	Global               bool     `protobuf:"varint,3,opt,name=global,proto3" json:"global,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VarRef) Reset()         { *m = VarRef{} }
func (m *VarRef) String() string { return proto.CompactTextString(m) }
func (*VarRef) ProtoMessage()    {}
func (*VarRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{4}
}
func (m *VarRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VarRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VarRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VarRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VarRef.Merge(m, src)
}
func (m *VarRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *VarRef) XXX_DiscardUnknown() {
	xxx_messageInfo_VarRef.DiscardUnknown(m)
}

var xxx_messageInfo_VarRef proto.InternalMessageInfo

func (m *VarRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VarRef) GetSystem() bool {
	if m != nil {
		return m.System
	}
	return false
}

func (m *VarRef) GetGlobal() bool {
	if m != nil {
		return m.Global
	}
	return false
}

// Reference a column in the proj list of a node.
type ColRef struct {
	RelPos               int32    `protobuf:"varint,1,opt,name=rel_pos,json=relPos,proto3" json:"rel_pos,omitempty"`
	ColPos               int32    `protobuf:"varint,2,opt,name=col_pos,json=colPos,proto3" json:"col_pos,omitempty"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	TblName              string   `protobuf:"bytes,4,opt,name=tbl_name,json=tblName,proto3" json:"tbl_name,omitempty"`
	DbName               string   `protobuf:"bytes,5,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ColRef) Reset()         { *m = ColRef{} }
func (m *ColRef) String() string { return proto.CompactTextString(m) }
func (*ColRef) ProtoMessage()    {}
func (*ColRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{5}
}
func (m *ColRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColRef.Merge(m, src)
}
func (m *ColRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ColRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ColRef.DiscardUnknown(m)
}

var xxx_messageInfo_ColRef proto.InternalMessageInfo

func (m *ColRef) GetRelPos() int32 {
	if m != nil {
		return m.RelPos
	}
	return 0
}

func (m *ColRef) GetColPos() int32 {
	if m != nil {
		return m.ColPos
	}
	return 0
}

func (m *ColRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ColRef) GetTblName() string {
	if m != nil {
		return m.TblName
	}
	return ""
}

func (m *ColRef) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

// Reference a column by its internal table id and column id
type RawColRef struct {
	TblId                uint64   `protobuf:"varint,1,opt,name=tbl_id,json=tblId,proto3" json:"tbl_id,omitempty"`
	ColId                uint64   `protobuf:"varint,2,opt,name=col_id,json=colId,proto3" json:"col_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RawColRef) Reset()         { *m = RawColRef{} }
func (m *RawColRef) String() string { return proto.CompactTextString(m) }
func (*RawColRef) ProtoMessage()    {}
func (*RawColRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{6}
}
func (m *RawColRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawColRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawColRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawColRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawColRef.Merge(m, src)
}
func (m *RawColRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RawColRef) XXX_DiscardUnknown() {
	xxx_messageInfo_RawColRef.DiscardUnknown(m)
}

var xxx_messageInfo_RawColRef proto.InternalMessageInfo

func (m *RawColRef) GetTblId() uint64 {
	if m != nil {
		return m.TblId
	}
	return 0
}

func (m *RawColRef) GetColId() uint64 {
	if m != nil {
		return m.ColId
	}
	return 0
}

// Reference a correlated column in the proj list of a node.
type CorrColRef struct {
	RelPos               int32    `protobuf:"varint,1,opt,name=rel_pos,json=relPos,proto3" json:"rel_pos,omitempty"`
	ColPos               int32    `protobuf:"varint,2,opt,name=col_pos,json=colPos,proto3" json:"col_pos,omitempty"`
	Depth                int32    `protobuf:"varint,3,opt,name=depth,proto3" json:"depth,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CorrColRef) Reset()         { *m = CorrColRef{} }
func (m *CorrColRef) String() string { return proto.CompactTextString(m) }
func (*CorrColRef) ProtoMessage()    {}
func (*CorrColRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{7}
}
func (m *CorrColRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CorrColRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CorrColRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CorrColRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CorrColRef.Merge(m, src)
}
func (m *CorrColRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CorrColRef) XXX_DiscardUnknown() {
	xxx_messageInfo_CorrColRef.DiscardUnknown(m)
}

var xxx_messageInfo_CorrColRef proto.InternalMessageInfo

func (m *CorrColRef) GetRelPos() int32 {
	if m != nil {
		return m.RelPos
	}
	return 0
}

func (m *CorrColRef) GetColPos() int32 {
	if m != nil {
		return m.ColPos
	}
	return 0
}

func (m *CorrColRef) GetDepth() int32 {
	if m != nil {
		return m.Depth
	}
	return 0
}

// ExprList is a type of Expr
type ExprList struct {
	List                 []*Expr  `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExprList) Reset()         { *m = ExprList{} }
func (m *ExprList) String() string { return proto.CompactTextString(m) }
func (*ExprList) ProtoMessage()    {}
func (*ExprList) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{8}
}
func (m *ExprList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExprList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExprList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExprList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExprList.Merge(m, src)
}
func (m *ExprList) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExprList) XXX_DiscardUnknown() {
	xxx_messageInfo_ExprList.DiscardUnknown(m)
}

var xxx_messageInfo_ExprList proto.InternalMessageInfo

func (m *ExprList) GetList() []*Expr {
	if m != nil {
		return m.List
	}
	return nil
}

type MaxValue struct {
	Value                string   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MaxValue) Reset()         { *m = MaxValue{} }
func (m *MaxValue) String() string { return proto.CompactTextString(m) }
func (*MaxValue) ProtoMessage()    {}
func (*MaxValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{9}
}
func (m *MaxValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaxValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaxValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaxValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaxValue.Merge(m, src)
}
func (m *MaxValue) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MaxValue) XXX_DiscardUnknown() {
	xxx_messageInfo_MaxValue.DiscardUnknown(m)
}

var xxx_messageInfo_MaxValue proto.InternalMessageInfo

func (m *MaxValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// TargetType used in cast function as target type
type TargetType struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TargetType) Reset()         { *m = TargetType{} }
func (m *TargetType) String() string { return proto.CompactTextString(m) }
func (*TargetType) ProtoMessage()    {}
func (*TargetType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{10}
}
func (m *TargetType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TargetType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TargetType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TargetType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TargetType.Merge(m, src)
}
func (m *TargetType) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TargetType) XXX_DiscardUnknown() {
	xxx_messageInfo_TargetType.DiscardUnknown(m)
}

var xxx_messageInfo_TargetType proto.InternalMessageInfo

// Reference a subquery
type SubqueryRef struct {
	Typ                  SubqueryRef_Type `protobuf:"varint,1,opt,name=typ,proto3,enum=plan.SubqueryRef_Type" json:"typ,omitempty"`
	NodeId               int32            `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Op                   string           `protobuf:"bytes,3,opt,name=op,proto3" json:"op,omitempty"`
	Child                *Expr            `protobuf:"bytes,4,opt,name=child,proto3" json:"child,omitempty"`
	RowSize              int32            `protobuf:"varint,5,opt,name=row_size,json=rowSize,proto3" json:"row_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SubqueryRef) Reset()         { *m = SubqueryRef{} }
func (m *SubqueryRef) String() string { return proto.CompactTextString(m) }
func (*SubqueryRef) ProtoMessage()    {}
func (*SubqueryRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{11}
}
func (m *SubqueryRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubqueryRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubqueryRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubqueryRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubqueryRef.Merge(m, src)
}
func (m *SubqueryRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SubqueryRef) XXX_DiscardUnknown() {
	xxx_messageInfo_SubqueryRef.DiscardUnknown(m)
}

var xxx_messageInfo_SubqueryRef proto.InternalMessageInfo

func (m *SubqueryRef) GetTyp() SubqueryRef_Type {
	if m != nil {
		return m.Typ
	}
	return SubqueryRef_SCALAR
}

func (m *SubqueryRef) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *SubqueryRef) GetOp() string {
	if m != nil {
		return m.Op
	}
	return ""
}

func (m *SubqueryRef) GetChild() *Expr {
	if m != nil {
		return m.Child
	}
	return nil
}

func (m *SubqueryRef) GetRowSize() int32 {
	if m != nil {
		return m.RowSize
	}
	return 0
}

// Object ref, reference a object in database, 4 part name.
type ObjectRef struct {
	Server               int64    `protobuf:"varint,1,opt,name=server,proto3" json:"server,omitempty"`
	Db                   int64    `protobuf:"varint,2,opt,name=db,proto3" json:"db,omitempty"`
	Schema               int64    `protobuf:"varint,3,opt,name=schema,proto3" json:"schema,omitempty"`
	Obj                  int64    `protobuf:"varint,4,opt,name=obj,proto3" json:"obj,omitempty"`
	ServerName           string   `protobuf:"bytes,5,opt,name=server_name,json=serverName,proto3" json:"server_name,omitempty"`
	DbName               string   `protobuf:"bytes,6,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	SchemaName           string   `protobuf:"bytes,7,opt,name=schema_name,json=schemaName,proto3" json:"schema_name,omitempty"`
	ObjName              string   `protobuf:"bytes,8,opt,name=obj_name,json=objName,proto3" json:"obj_name,omitempty"`
	SubscriptionName     string   `protobuf:"bytes,9,opt,name=subscription_name,json=subscriptionName,proto3" json:"subscription_name,omitempty"`
	PubInfo              *PubInfo `protobuf:"bytes,10,opt,name=pub_info,json=pubInfo,proto3" json:"pub_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectRef) Reset()         { *m = ObjectRef{} }
func (m *ObjectRef) String() string { return proto.CompactTextString(m) }
func (*ObjectRef) ProtoMessage()    {}
func (*ObjectRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{12}
}
func (m *ObjectRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectRef.Merge(m, src)
}
func (m *ObjectRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ObjectRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectRef.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectRef proto.InternalMessageInfo

func (m *ObjectRef) GetServer() int64 {
	if m != nil {
		return m.Server
	}
	return 0
}

func (m *ObjectRef) GetDb() int64 {
	if m != nil {
		return m.Db
	}
	return 0
}

func (m *ObjectRef) GetSchema() int64 {
	if m != nil {
		return m.Schema
	}
	return 0
}

func (m *ObjectRef) GetObj() int64 {
	if m != nil {
		return m.Obj
	}
	return 0
}

func (m *ObjectRef) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

func (m *ObjectRef) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *ObjectRef) GetSchemaName() string {
	if m != nil {
		return m.SchemaName
	}
	return ""
}

func (m *ObjectRef) GetObjName() string {
	if m != nil {
		return m.ObjName
	}
	return ""
}

func (m *ObjectRef) GetSubscriptionName() string {
	if m != nil {
		return m.SubscriptionName
	}
	return ""
}

func (m *ObjectRef) GetPubInfo() *PubInfo {
	if m != nil {
		return m.PubInfo
	}
	return nil
}

type PubInfo struct {
	TenantId             int32    `protobuf:"varint,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PubInfo) Reset()         { *m = PubInfo{} }
func (m *PubInfo) String() string { return proto.CompactTextString(m) }
func (*PubInfo) ProtoMessage()    {}
func (*PubInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{13}
}
func (m *PubInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PubInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PubInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PubInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PubInfo.Merge(m, src)
}
func (m *PubInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PubInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PubInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PubInfo proto.InternalMessageInfo

func (m *PubInfo) GetTenantId() int32 {
	if m != nil {
		return m.TenantId
	}
	return 0
}

type SubscriptionMeta struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	AccountId            int32    `protobuf:"varint,2,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
	DbName               string   `protobuf:"bytes,3,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	AccountName          string   `protobuf:"bytes,4,opt,name=account_name,json=accountName,proto3" json:"account_name,omitempty"`
	SubName              string   `protobuf:"bytes,5,opt,name=sub_name,json=subName,proto3" json:"sub_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscriptionMeta) Reset()         { *m = SubscriptionMeta{} }
func (m *SubscriptionMeta) String() string { return proto.CompactTextString(m) }
func (*SubscriptionMeta) ProtoMessage()    {}
func (*SubscriptionMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{14}
}
func (m *SubscriptionMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscriptionMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscriptionMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscriptionMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriptionMeta.Merge(m, src)
}
func (m *SubscriptionMeta) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SubscriptionMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriptionMeta.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriptionMeta proto.InternalMessageInfo

func (m *SubscriptionMeta) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SubscriptionMeta) GetAccountId() int32 {
	if m != nil {
		return m.AccountId
	}
	return 0
}

func (m *SubscriptionMeta) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *SubscriptionMeta) GetAccountName() string {
	if m != nil {
		return m.AccountName
	}
	return ""
}

func (m *SubscriptionMeta) GetSubName() string {
	if m != nil {
		return m.SubName
	}
	return ""
}

type Function struct {
	Func                 *ObjectRef `protobuf:"bytes,1,opt,name=func,proto3" json:"func,omitempty"`
	Args                 []*Expr    `protobuf:"bytes,2,rep,name=args,proto3" json:"args,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Function) Reset()         { *m = Function{} }
func (m *Function) String() string { return proto.CompactTextString(m) }
func (*Function) ProtoMessage()    {}
func (*Function) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{15}
}
func (m *Function) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Function) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Function.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Function) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Function.Merge(m, src)
}
func (m *Function) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Function) XXX_DiscardUnknown() {
	xxx_messageInfo_Function.DiscardUnknown(m)
}

var xxx_messageInfo_Function proto.InternalMessageInfo

func (m *Function) GetFunc() *ObjectRef {
	if m != nil {
		return m.Func
	}
	return nil
}

func (m *Function) GetArgs() []*Expr {
	if m != nil {
		return m.Args
	}
	return nil
}

type Expr struct {
	Typ Type `protobuf:"bytes,1,opt,name=typ,proto3" json:"typ"`
	// Types that are valid to be assigned to Expr:
	//
	//	*Expr_Lit
	//	*Expr_P
	//	*Expr_V
	//	*Expr_Col
	//	*Expr_Raw
	//	*Expr_F
	//	*Expr_W
	//	*Expr_Sub
	//	*Expr_Corr
	//	*Expr_T
	//	*Expr_List
	//	*Expr_Max
	//	*Expr_Vec
	Expr                 isExpr_Expr `protobuf_oneof:"expr"`
	AuxId                int32       `protobuf:"varint,15,opt,name=aux_id,json=auxId,proto3" json:"aux_id,omitempty"`
	Ndv                  float64     `protobuf:"fixed64,16,opt,name=ndv,proto3" json:"ndv,omitempty"`
	Selectivity          float64     `protobuf:"fixed64,17,opt,name=selectivity,proto3" json:"selectivity,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Expr) Reset()         { *m = Expr{} }
func (m *Expr) String() string { return proto.CompactTextString(m) }
func (*Expr) ProtoMessage()    {}
func (*Expr) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{16}
}
func (m *Expr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Expr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Expr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Expr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Expr.Merge(m, src)
}
func (m *Expr) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Expr) XXX_DiscardUnknown() {
	xxx_messageInfo_Expr.DiscardUnknown(m)
}

var xxx_messageInfo_Expr proto.InternalMessageInfo

type isExpr_Expr interface {
	isExpr_Expr()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type Expr_Lit struct {
	Lit *Literal `protobuf:"bytes,2,opt,name=lit,proto3,oneof" json:"lit,omitempty"`
}
type Expr_P struct {
	P *ParamRef `protobuf:"bytes,3,opt,name=p,proto3,oneof" json:"p,omitempty"`
}
type Expr_V struct {
	V *VarRef `protobuf:"bytes,4,opt,name=v,proto3,oneof" json:"v,omitempty"`
}
type Expr_Col struct {
	Col *ColRef `protobuf:"bytes,5,opt,name=col,proto3,oneof" json:"col,omitempty"`
}
type Expr_Raw struct {
	Raw *RawColRef `protobuf:"bytes,6,opt,name=raw,proto3,oneof" json:"raw,omitempty"`
}
type Expr_F struct {
	F *Function `protobuf:"bytes,7,opt,name=f,proto3,oneof" json:"f,omitempty"`
}
type Expr_W struct {
	W *WindowSpec `protobuf:"bytes,8,opt,name=w,proto3,oneof" json:"w,omitempty"`
}
type Expr_Sub struct {
	Sub *SubqueryRef `protobuf:"bytes,9,opt,name=sub,proto3,oneof" json:"sub,omitempty"`
}
type Expr_Corr struct {
	Corr *CorrColRef `protobuf:"bytes,10,opt,name=corr,proto3,oneof" json:"corr,omitempty"`
}
type Expr_T struct {
	T *TargetType `protobuf:"bytes,11,opt,name=t,proto3,oneof" json:"t,omitempty"`
}
type Expr_List struct {
	List *ExprList `protobuf:"bytes,12,opt,name=list,proto3,oneof" json:"list,omitempty"`
}
type Expr_Max struct {
	Max *MaxValue `protobuf:"bytes,13,opt,name=max,proto3,oneof" json:"max,omitempty"`
}
type Expr_Vec struct {
	Vec *LiteralVec `protobuf:"bytes,14,opt,name=vec,proto3,oneof" json:"vec,omitempty"`
}

func (*Expr_Lit) isExpr_Expr()  {}
func (*Expr_P) isExpr_Expr()    {}
func (*Expr_V) isExpr_Expr()    {}
func (*Expr_Col) isExpr_Expr()  {}
func (*Expr_Raw) isExpr_Expr()  {}
func (*Expr_F) isExpr_Expr()    {}
func (*Expr_W) isExpr_Expr()    {}
func (*Expr_Sub) isExpr_Expr()  {}
func (*Expr_Corr) isExpr_Expr() {}
func (*Expr_T) isExpr_Expr()    {}
func (*Expr_List) isExpr_Expr() {}
func (*Expr_Max) isExpr_Expr()  {}
func (*Expr_Vec) isExpr_Expr()  {}

func (m *Expr) GetExpr() isExpr_Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Expr) GetTyp() Type {
	if m != nil {
		return m.Typ
	}
	return Type{}
}

func (m *Expr) GetLit() *Literal {
	if x, ok := m.GetExpr().(*Expr_Lit); ok {
		return x.Lit
	}
	return nil
}

func (m *Expr) GetP() *ParamRef {
	if x, ok := m.GetExpr().(*Expr_P); ok {
		return x.P
	}
	return nil
}

func (m *Expr) GetV() *VarRef {
	if x, ok := m.GetExpr().(*Expr_V); ok {
		return x.V
	}
	return nil
}

func (m *Expr) GetCol() *ColRef {
	if x, ok := m.GetExpr().(*Expr_Col); ok {
		return x.Col
	}
	return nil
}

func (m *Expr) GetRaw() *RawColRef {
	if x, ok := m.GetExpr().(*Expr_Raw); ok {
		return x.Raw
	}
	return nil
}

func (m *Expr) GetF() *Function {
	if x, ok := m.GetExpr().(*Expr_F); ok {
		return x.F
	}
	return nil
}

func (m *Expr) GetW() *WindowSpec {
	if x, ok := m.GetExpr().(*Expr_W); ok {
		return x.W
	}
	return nil
}

func (m *Expr) GetSub() *SubqueryRef {
	if x, ok := m.GetExpr().(*Expr_Sub); ok {
		return x.Sub
	}
	return nil
}

func (m *Expr) GetCorr() *CorrColRef {
	if x, ok := m.GetExpr().(*Expr_Corr); ok {
		return x.Corr
	}
	return nil
}

func (m *Expr) GetT() *TargetType {
	if x, ok := m.GetExpr().(*Expr_T); ok {
		return x.T
	}
	return nil
}

func (m *Expr) GetList() *ExprList {
	if x, ok := m.GetExpr().(*Expr_List); ok {
		return x.List
	}
	return nil
}

func (m *Expr) GetMax() *MaxValue {
	if x, ok := m.GetExpr().(*Expr_Max); ok {
		return x.Max
	}
	return nil
}

func (m *Expr) GetVec() *LiteralVec {
	if x, ok := m.GetExpr().(*Expr_Vec); ok {
		return x.Vec
	}
	return nil
}

func (m *Expr) GetAuxId() int32 {
	if m != nil {
		return m.AuxId
	}
	return 0
}

func (m *Expr) GetNdv() float64 {
	if m != nil {
		return m.Ndv
	}
	return 0
}

func (m *Expr) GetSelectivity() float64 {
	if m != nil {
		return m.Selectivity
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Expr) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Expr_Lit)(nil),
		(*Expr_P)(nil),
		(*Expr_V)(nil),
		(*Expr_Col)(nil),
		(*Expr_Raw)(nil),
		(*Expr_F)(nil),
		(*Expr_W)(nil),
		(*Expr_Sub)(nil),
		(*Expr_Corr)(nil),
		(*Expr_T)(nil),
		(*Expr_List)(nil),
		(*Expr_Max)(nil),
		(*Expr_Vec)(nil),
	}
}

type LiteralVec struct {
	Len                  int32    `protobuf:"varint,1,opt,name=len,proto3" json:"len,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LiteralVec) Reset()         { *m = LiteralVec{} }
func (m *LiteralVec) String() string { return proto.CompactTextString(m) }
func (*LiteralVec) ProtoMessage()    {}
func (*LiteralVec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{17}
}
func (m *LiteralVec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiteralVec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiteralVec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiteralVec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiteralVec.Merge(m, src)
}
func (m *LiteralVec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LiteralVec) XXX_DiscardUnknown() {
	xxx_messageInfo_LiteralVec.DiscardUnknown(m)
}

var xxx_messageInfo_LiteralVec proto.InternalMessageInfo

func (m *LiteralVec) GetLen() int32 {
	if m != nil {
		return m.Len
	}
	return 0
}

func (m *LiteralVec) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type Decimal64 struct {
	A                    int64    `protobuf:"varint,1,opt,name=a,proto3" json:"a,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Decimal64) Reset()         { *m = Decimal64{} }
func (m *Decimal64) String() string { return proto.CompactTextString(m) }
func (*Decimal64) ProtoMessage()    {}
func (*Decimal64) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{18}
}
func (m *Decimal64) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Decimal64) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Decimal64.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Decimal64) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Decimal64.Merge(m, src)
}
func (m *Decimal64) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Decimal64) XXX_DiscardUnknown() {
	xxx_messageInfo_Decimal64.DiscardUnknown(m)
}

var xxx_messageInfo_Decimal64 proto.InternalMessageInfo

func (m *Decimal64) GetA() int64 {
	if m != nil {
		return m.A
	}
	return 0
}

type Decimal128 struct {
	A                    int64    `protobuf:"varint,1,opt,name=a,proto3" json:"a,omitempty"`
	B                    int64    `protobuf:"varint,2,opt,name=b,proto3" json:"b,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Decimal128) Reset()         { *m = Decimal128{} }
func (m *Decimal128) String() string { return proto.CompactTextString(m) }
func (*Decimal128) ProtoMessage()    {}
func (*Decimal128) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{19}
}
func (m *Decimal128) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Decimal128) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Decimal128.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Decimal128) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Decimal128.Merge(m, src)
}
func (m *Decimal128) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Decimal128) XXX_DiscardUnknown() {
	xxx_messageInfo_Decimal128.DiscardUnknown(m)
}

var xxx_messageInfo_Decimal128 proto.InternalMessageInfo

func (m *Decimal128) GetA() int64 {
	if m != nil {
		return m.A
	}
	return 0
}

func (m *Decimal128) GetB() int64 {
	if m != nil {
		return m.B
	}
	return 0
}

type ResultColDef struct {
	ResultCols           []*ColDef `protobuf:"bytes,1,rep,name=ResultCols,proto3" json:"ResultCols,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ResultColDef) Reset()         { *m = ResultColDef{} }
func (m *ResultColDef) String() string { return proto.CompactTextString(m) }
func (*ResultColDef) ProtoMessage()    {}
func (*ResultColDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{20}
}
func (m *ResultColDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultColDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultColDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultColDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultColDef.Merge(m, src)
}
func (m *ResultColDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ResultColDef) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultColDef.DiscardUnknown(m)
}

var xxx_messageInfo_ResultColDef proto.InternalMessageInfo

func (m *ResultColDef) GetResultCols() []*ColDef {
	if m != nil {
		return m.ResultCols
	}
	return nil
}

type ColDef struct {
	ColId    uint64       `protobuf:"varint,1,opt,name=col_id,json=colId,proto3" json:"col_id,omitempty"`
	Name     string       `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Hidden   bool         `protobuf:"varint,3,opt,name=hidden,proto3" json:"hidden,omitempty"`
	Alg      CompressType `protobuf:"varint,4,opt,name=alg,proto3,enum=plan.CompressType" json:"alg,omitempty"`
	Typ      Type         `protobuf:"bytes,5,opt,name=typ,proto3" json:"typ"`
	NotNull  bool         `protobuf:"varint,6,opt,name=not_null,json=notNull,proto3" json:"not_null,omitempty"`
	Default  *Default     `protobuf:"bytes,7,opt,name=default,proto3" json:"default,omitempty"`
	Comment  string       `protobuf:"bytes,8,opt,name=comment,proto3" json:"comment,omitempty"`
	OnUpdate *OnUpdate    `protobuf:"bytes,9,opt,name=on_update,json=onUpdate,proto3" json:"on_update,omitempty"`
	LowCard  bool         `protobuf:"varint,10,opt,name=low_card,json=lowCard,proto3" json:"low_card,omitempty"`
	Seqnum   uint32       `protobuf:"varint,11,opt,name=seqnum,proto3" json:"seqnum,omitempty"`
	// XXX: Deprecated and to be removed soon.
	ClusterBy            bool     `protobuf:"varint,12,opt,name=clusterBy,proto3" json:"clusterBy,omitempty"`
	Primary              bool     `protobuf:"varint,13,opt,name=primary,proto3" json:"primary,omitempty"`
	Pkidx                int32    `protobuf:"varint,14,opt,name=pkidx,proto3" json:"pkidx,omitempty"`
	Headers              bool     `protobuf:"varint,15,opt,name=headers,proto3" json:"headers,omitempty"`
	Header               string   `protobuf:"bytes,16,opt,name=header,proto3" json:"header,omitempty"`
	TblName              string   `protobuf:"bytes,17,opt,name=tbl_name,json=tblName,proto3" json:"tbl_name,omitempty"`
	DbName               string   `protobuf:"bytes,18,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ColDef) Reset()         { *m = ColDef{} }
func (m *ColDef) String() string { return proto.CompactTextString(m) }
func (*ColDef) ProtoMessage()    {}
func (*ColDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{21}
}
func (m *ColDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColDef.Merge(m, src)
}
func (m *ColDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ColDef) XXX_DiscardUnknown() {
	xxx_messageInfo_ColDef.DiscardUnknown(m)
}

var xxx_messageInfo_ColDef proto.InternalMessageInfo

func (m *ColDef) GetColId() uint64 {
	if m != nil {
		return m.ColId
	}
	return 0
}

func (m *ColDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ColDef) GetHidden() bool {
	if m != nil {
		return m.Hidden
	}
	return false
}

func (m *ColDef) GetAlg() CompressType {
	if m != nil {
		return m.Alg
	}
	return CompressType_None
}

func (m *ColDef) GetTyp() Type {
	if m != nil {
		return m.Typ
	}
	return Type{}
}

func (m *ColDef) GetNotNull() bool {
	if m != nil {
		return m.NotNull
	}
	return false
}

func (m *ColDef) GetDefault() *Default {
	if m != nil {
		return m.Default
	}
	return nil
}

func (m *ColDef) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *ColDef) GetOnUpdate() *OnUpdate {
	if m != nil {
		return m.OnUpdate
	}
	return nil
}

func (m *ColDef) GetLowCard() bool {
	if m != nil {
		return m.LowCard
	}
	return false
}

func (m *ColDef) GetSeqnum() uint32 {
	if m != nil {
		return m.Seqnum
	}
	return 0
}

func (m *ColDef) GetClusterBy() bool {
	if m != nil {
		return m.ClusterBy
	}
	return false
}

func (m *ColDef) GetPrimary() bool {
	if m != nil {
		return m.Primary
	}
	return false
}

func (m *ColDef) GetPkidx() int32 {
	if m != nil {
		return m.Pkidx
	}
	return 0
}

func (m *ColDef) GetHeaders() bool {
	if m != nil {
		return m.Headers
	}
	return false
}

func (m *ColDef) GetHeader() string {
	if m != nil {
		return m.Header
	}
	return ""
}

func (m *ColDef) GetTblName() string {
	if m != nil {
		return m.TblName
	}
	return ""
}

func (m *ColDef) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

type Default struct {
	Expr         *Expr  `protobuf:"bytes,1,opt,name=expr,proto3" json:"expr,omitempty"`
	OriginString string `protobuf:"bytes,2,opt,name=origin_string,json=originString,proto3" json:"origin_string,omitempty"`
	// XXX: Deprecated and to be removed soon.
	NullAbility          bool     `protobuf:"varint,3,opt,name=null_ability,json=nullAbility,proto3" json:"null_ability,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Default) Reset()         { *m = Default{} }
func (m *Default) String() string { return proto.CompactTextString(m) }
func (*Default) ProtoMessage()    {}
func (*Default) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{22}
}
func (m *Default) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Default) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Default.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Default) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Default.Merge(m, src)
}
func (m *Default) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Default) XXX_DiscardUnknown() {
	xxx_messageInfo_Default.DiscardUnknown(m)
}

var xxx_messageInfo_Default proto.InternalMessageInfo

func (m *Default) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Default) GetOriginString() string {
	if m != nil {
		return m.OriginString
	}
	return ""
}

func (m *Default) GetNullAbility() bool {
	if m != nil {
		return m.NullAbility
	}
	return false
}

type OnUpdate struct {
	Expr                 *Expr    `protobuf:"bytes,1,opt,name=expr,proto3" json:"expr,omitempty"`
	OriginString         string   `protobuf:"bytes,2,opt,name=origin_string,json=originString,proto3" json:"origin_string,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OnUpdate) Reset()         { *m = OnUpdate{} }
func (m *OnUpdate) String() string { return proto.CompactTextString(m) }
func (*OnUpdate) ProtoMessage()    {}
func (*OnUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{23}
}
func (m *OnUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OnUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OnUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OnUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnUpdate.Merge(m, src)
}
func (m *OnUpdate) XXX_Size() int {
	return m.ProtoSize()
}
func (m *OnUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_OnUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_OnUpdate proto.InternalMessageInfo

func (m *OnUpdate) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *OnUpdate) GetOriginString() string {
	if m != nil {
		return m.OriginString
	}
	return ""
}

type IndexOption struct {
	CreateExtraTable     bool     `protobuf:"varint,1,opt,name=create_extra_table,json=createExtraTable,proto3" json:"create_extra_table,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IndexOption) Reset()         { *m = IndexOption{} }
func (m *IndexOption) String() string { return proto.CompactTextString(m) }
func (*IndexOption) ProtoMessage()    {}
func (*IndexOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{24}
}
func (m *IndexOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexOption.Merge(m, src)
}
func (m *IndexOption) XXX_Size() int {
	return m.ProtoSize()
}
func (m *IndexOption) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexOption.DiscardUnknown(m)
}

var xxx_messageInfo_IndexOption proto.InternalMessageInfo

func (m *IndexOption) GetCreateExtraTable() bool {
	if m != nil {
		return m.CreateExtraTable
	}
	return false
}

type PrimaryKeyDef struct {
	// currently not used
	Cols []uint64 `protobuf:"varint,1,rep,packed,name=cols,proto3" json:"cols,omitempty"`
	// currently not used
	PkeyColId uint64 `protobuf:"varint,2,opt,name=pkey_col_id,json=pkeyColId,proto3" json:"pkey_col_id,omitempty"`
	// currently not used
	Option *IndexOption `protobuf:"bytes,3,opt,name=option,proto3" json:"option,omitempty"`
	// Composed primary key column name: __mo_cpkey
	PkeyColName string `protobuf:"bytes,4,opt,name=pkey_col_name,json=pkeyColName,proto3" json:"pkey_col_name,omitempty"`
	// XXX: Deprecated and to be removed soon.
	Names []string `protobuf:"bytes,5,rep,name=names,proto3" json:"names,omitempty"`
	// Composite primary key column definition
	CompPkeyCol          *ColDef  `protobuf:"bytes,6,opt,name=comp_pkey_col,json=compPkeyCol,proto3" json:"comp_pkey_col,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PrimaryKeyDef) Reset()         { *m = PrimaryKeyDef{} }
func (m *PrimaryKeyDef) String() string { return proto.CompactTextString(m) }
func (*PrimaryKeyDef) ProtoMessage()    {}
func (*PrimaryKeyDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{25}
}
func (m *PrimaryKeyDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrimaryKeyDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrimaryKeyDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrimaryKeyDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrimaryKeyDef.Merge(m, src)
}
func (m *PrimaryKeyDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PrimaryKeyDef) XXX_DiscardUnknown() {
	xxx_messageInfo_PrimaryKeyDef.DiscardUnknown(m)
}

var xxx_messageInfo_PrimaryKeyDef proto.InternalMessageInfo

func (m *PrimaryKeyDef) GetCols() []uint64 {
	if m != nil {
		return m.Cols
	}
	return nil
}

func (m *PrimaryKeyDef) GetPkeyColId() uint64 {
	if m != nil {
		return m.PkeyColId
	}
	return 0
}

func (m *PrimaryKeyDef) GetOption() *IndexOption {
	if m != nil {
		return m.Option
	}
	return nil
}

func (m *PrimaryKeyDef) GetPkeyColName() string {
	if m != nil {
		return m.PkeyColName
	}
	return ""
}

func (m *PrimaryKeyDef) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

func (m *PrimaryKeyDef) GetCompPkeyCol() *ColDef {
	if m != nil {
		return m.CompPkeyCol
	}
	return nil
}

type IndexDef struct {
	// Generate UUID for each index, currently not used
	IdxId     string `protobuf:"bytes,1,opt,name=idx_id,json=idxId,proto3" json:"idx_id,omitempty"`
	IndexName string `protobuf:"bytes,2,opt,name=index_name,json=indexName,proto3" json:"index_name,omitempty"`
	// The constituent columns of the index
	Parts          []string `protobuf:"bytes,3,rep,name=parts,proto3" json:"parts,omitempty"`
	Unique         bool     `protobuf:"varint,4,opt,name=unique,proto3" json:"unique,omitempty"`
	IndexTableName string   `protobuf:"bytes,5,opt,name=index_table_name,json=indexTableName,proto3" json:"index_table_name,omitempty"`
	TableExist     bool     `protobuf:"varint,6,opt,name=table_exist,json=tableExist,proto3" json:"table_exist,omitempty"`
	Comment        string   `protobuf:"bytes,7,opt,name=comment,proto3" json:"comment,omitempty"`
	Visible        bool     `protobuf:"varint,8,opt,name=visible,proto3" json:"visible,omitempty"`
	// currently not used
	Option               *IndexOption `protobuf:"bytes,9,opt,name=option,proto3" json:"option,omitempty"`
	IndexAlgo            string       `protobuf:"bytes,10,opt,name=index_algo,json=indexAlgo,proto3" json:"index_algo,omitempty"`
	IndexAlgoTableType   string       `protobuf:"bytes,11,opt,name=index_algo_table_type,json=indexAlgoTableType,proto3" json:"index_algo_table_type,omitempty"`
	IndexAlgoParams      string       `protobuf:"bytes,12,opt,name=index_algo_params,json=indexAlgoParams,proto3" json:"index_algo_params,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *IndexDef) Reset()         { *m = IndexDef{} }
func (m *IndexDef) String() string { return proto.CompactTextString(m) }
func (*IndexDef) ProtoMessage()    {}
func (*IndexDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{26}
}
func (m *IndexDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexDef.Merge(m, src)
}
func (m *IndexDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *IndexDef) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexDef.DiscardUnknown(m)
}

var xxx_messageInfo_IndexDef proto.InternalMessageInfo

func (m *IndexDef) GetIdxId() string {
	if m != nil {
		return m.IdxId
	}
	return ""
}

func (m *IndexDef) GetIndexName() string {
	if m != nil {
		return m.IndexName
	}
	return ""
}

func (m *IndexDef) GetParts() []string {
	if m != nil {
		return m.Parts
	}
	return nil
}

func (m *IndexDef) GetUnique() bool {
	if m != nil {
		return m.Unique
	}
	return false
}

func (m *IndexDef) GetIndexTableName() string {
	if m != nil {
		return m.IndexTableName
	}
	return ""
}

func (m *IndexDef) GetTableExist() bool {
	if m != nil {
		return m.TableExist
	}
	return false
}

func (m *IndexDef) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *IndexDef) GetVisible() bool {
	if m != nil {
		return m.Visible
	}
	return false
}

func (m *IndexDef) GetOption() *IndexOption {
	if m != nil {
		return m.Option
	}
	return nil
}

func (m *IndexDef) GetIndexAlgo() string {
	if m != nil {
		return m.IndexAlgo
	}
	return ""
}

func (m *IndexDef) GetIndexAlgoTableType() string {
	if m != nil {
		return m.IndexAlgoTableType
	}
	return ""
}

func (m *IndexDef) GetIndexAlgoParams() string {
	if m != nil {
		return m.IndexAlgoParams
	}
	return ""
}

type ForeignKeyDef struct {
	Name string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Cols []uint64 `protobuf:"varint,2,rep,packed,name=cols,proto3" json:"cols,omitempty"`
	// Foreign key parent table Id
	ForeignTbl uint64 `protobuf:"varint,3,opt,name=foreign_tbl,json=foreignTbl,proto3" json:"foreign_tbl,omitempty"`
	// Foreign key parent table dependent column colids
	ForeignCols          []uint64                `protobuf:"varint,4,rep,packed,name=foreign_cols,json=foreignCols,proto3" json:"foreign_cols,omitempty"`
	OnDelete             ForeignKeyDef_RefAction `protobuf:"varint,5,opt,name=on_delete,json=onDelete,proto3,enum=plan.ForeignKeyDef_RefAction" json:"on_delete,omitempty"`
	OnUpdate             ForeignKeyDef_RefAction `protobuf:"varint,6,opt,name=on_update,json=onUpdate,proto3,enum=plan.ForeignKeyDef_RefAction" json:"on_update,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *ForeignKeyDef) Reset()         { *m = ForeignKeyDef{} }
func (m *ForeignKeyDef) String() string { return proto.CompactTextString(m) }
func (*ForeignKeyDef) ProtoMessage()    {}
func (*ForeignKeyDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{27}
}
func (m *ForeignKeyDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForeignKeyDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ForeignKeyDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ForeignKeyDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForeignKeyDef.Merge(m, src)
}
func (m *ForeignKeyDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ForeignKeyDef) XXX_DiscardUnknown() {
	xxx_messageInfo_ForeignKeyDef.DiscardUnknown(m)
}

var xxx_messageInfo_ForeignKeyDef proto.InternalMessageInfo

func (m *ForeignKeyDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ForeignKeyDef) GetCols() []uint64 {
	if m != nil {
		return m.Cols
	}
	return nil
}

func (m *ForeignKeyDef) GetForeignTbl() uint64 {
	if m != nil {
		return m.ForeignTbl
	}
	return 0
}

func (m *ForeignKeyDef) GetForeignCols() []uint64 {
	if m != nil {
		return m.ForeignCols
	}
	return nil
}

func (m *ForeignKeyDef) GetOnDelete() ForeignKeyDef_RefAction {
	if m != nil {
		return m.OnDelete
	}
	return ForeignKeyDef_RESTRICT
}

func (m *ForeignKeyDef) GetOnUpdate() ForeignKeyDef_RefAction {
	if m != nil {
		return m.OnUpdate
	}
	return ForeignKeyDef_RESTRICT
}

type CheckDef struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Name for anonymous constraints, __mo_chk_[INDEX_ID]
	Check                *Expr    `protobuf:"bytes,2,opt,name=check,proto3" json:"check,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckDef) Reset()         { *m = CheckDef{} }
func (m *CheckDef) String() string { return proto.CompactTextString(m) }
func (*CheckDef) ProtoMessage()    {}
func (*CheckDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{28}
}
func (m *CheckDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckDef.Merge(m, src)
}
func (m *CheckDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CheckDef) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckDef.DiscardUnknown(m)
}

var xxx_messageInfo_CheckDef proto.InternalMessageInfo

func (m *CheckDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CheckDef) GetCheck() *Expr {
	if m != nil {
		return m.Check
	}
	return nil
}

type ClusterByDef struct {
	// XXX: Deprecated and to be removed soon.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Composite cluster by column definition
	CompCbkeyCol         *ColDef  `protobuf:"bytes,2,opt,name=comp_cbkey_col,json=compCbkeyCol,proto3" json:"comp_cbkey_col,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterByDef) Reset()         { *m = ClusterByDef{} }
func (m *ClusterByDef) String() string { return proto.CompactTextString(m) }
func (*ClusterByDef) ProtoMessage()    {}
func (*ClusterByDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{29}
}
func (m *ClusterByDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterByDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterByDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterByDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterByDef.Merge(m, src)
}
func (m *ClusterByDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ClusterByDef) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterByDef.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterByDef proto.InternalMessageInfo

func (m *ClusterByDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ClusterByDef) GetCompCbkeyCol() *ColDef {
	if m != nil {
		return m.CompCbkeyCol
	}
	return nil
}

type PropertyDef struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PropertyDef) Reset()         { *m = PropertyDef{} }
func (m *PropertyDef) String() string { return proto.CompactTextString(m) }
func (*PropertyDef) ProtoMessage()    {}
func (*PropertyDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{30}
}
func (m *PropertyDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropertyDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropertyDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropertyDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropertyDef.Merge(m, src)
}
func (m *PropertyDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PropertyDef) XXX_DiscardUnknown() {
	xxx_messageInfo_PropertyDef.DiscardUnknown(m)
}

var xxx_messageInfo_PropertyDef proto.InternalMessageInfo

func (m *PropertyDef) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *PropertyDef) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type Property struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Property) Reset()         { *m = Property{} }
func (m *Property) String() string { return proto.CompactTextString(m) }
func (*Property) ProtoMessage()    {}
func (*Property) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{31}
}
func (m *Property) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Property) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Property.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Property) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Property.Merge(m, src)
}
func (m *Property) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Property) XXX_DiscardUnknown() {
	xxx_messageInfo_Property.DiscardUnknown(m)
}

var xxx_messageInfo_Property proto.InternalMessageInfo

func (m *Property) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Property) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type PropertiesDef struct {
	Properties           []*Property `protobuf:"bytes,1,rep,name=properties,proto3" json:"properties,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *PropertiesDef) Reset()         { *m = PropertiesDef{} }
func (m *PropertiesDef) String() string { return proto.CompactTextString(m) }
func (*PropertiesDef) ProtoMessage()    {}
func (*PropertiesDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{32}
}
func (m *PropertiesDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropertiesDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropertiesDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropertiesDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropertiesDef.Merge(m, src)
}
func (m *PropertiesDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PropertiesDef) XXX_DiscardUnknown() {
	xxx_messageInfo_PropertiesDef.DiscardUnknown(m)
}

var xxx_messageInfo_PropertiesDef proto.InternalMessageInfo

func (m *PropertiesDef) GetProperties() []*Property {
	if m != nil {
		return m.Properties
	}
	return nil
}

type PartitionByDef struct {
	Type                 PartitionType     `protobuf:"varint,1,opt,name=type,proto3,enum=plan.PartitionType" json:"type,omitempty"`
	PartitionExpr        *PartitionExpr    `protobuf:"bytes,2,opt,name=partition_expr,json=partitionExpr,proto3" json:"partition_expr,omitempty"`
	PartitionExpression  *Expr             `protobuf:"bytes,3,opt,name=partition_expression,json=partitionExpression,proto3" json:"partition_expression,omitempty"`
	PartitionColumns     *PartitionColumns `protobuf:"bytes,4,opt,name=partition_columns,json=partitionColumns,proto3" json:"partition_columns,omitempty"`
	PartitionNum         uint64            `protobuf:"varint,5,opt,name=partitionNum,proto3" json:"partitionNum,omitempty"`
	Partitions           []*PartitionItem  `protobuf:"bytes,6,rep,name=partitions,proto3" json:"partitions,omitempty"`
	Algorithm            int64             `protobuf:"varint,7,opt,name=algorithm,proto3" json:"algorithm,omitempty"`
	IsSubPartition       bool              `protobuf:"varint,8,opt,name=is_sub_partition,json=isSubPartition,proto3" json:"is_sub_partition,omitempty"`
	PartitionMsg         string            `protobuf:"bytes,9,opt,name=partition_msg,json=partitionMsg,proto3" json:"partition_msg,omitempty"`
	PartitionTableNames  []string          `protobuf:"bytes,10,rep,name=partition_table_names,json=partitionTableNames,proto3" json:"partition_table_names,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *PartitionByDef) Reset()         { *m = PartitionByDef{} }
func (m *PartitionByDef) String() string { return proto.CompactTextString(m) }
func (*PartitionByDef) ProtoMessage()    {}
func (*PartitionByDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{33}
}
func (m *PartitionByDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionByDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionByDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionByDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionByDef.Merge(m, src)
}
func (m *PartitionByDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PartitionByDef) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionByDef.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionByDef proto.InternalMessageInfo

func (m *PartitionByDef) GetType() PartitionType {
	if m != nil {
		return m.Type
	}
	return PartitionType_KEY
}

func (m *PartitionByDef) GetPartitionExpr() *PartitionExpr {
	if m != nil {
		return m.PartitionExpr
	}
	return nil
}

func (m *PartitionByDef) GetPartitionExpression() *Expr {
	if m != nil {
		return m.PartitionExpression
	}
	return nil
}

func (m *PartitionByDef) GetPartitionColumns() *PartitionColumns {
	if m != nil {
		return m.PartitionColumns
	}
	return nil
}

func (m *PartitionByDef) GetPartitionNum() uint64 {
	if m != nil {
		return m.PartitionNum
	}
	return 0
}

func (m *PartitionByDef) GetPartitions() []*PartitionItem {
	if m != nil {
		return m.Partitions
	}
	return nil
}

func (m *PartitionByDef) GetAlgorithm() int64 {
	if m != nil {
		return m.Algorithm
	}
	return 0
}

func (m *PartitionByDef) GetIsSubPartition() bool {
	if m != nil {
		return m.IsSubPartition
	}
	return false
}

func (m *PartitionByDef) GetPartitionMsg() string {
	if m != nil {
		return m.PartitionMsg
	}
	return ""
}

func (m *PartitionByDef) GetPartitionTableNames() []string {
	if m != nil {
		return m.PartitionTableNames
	}
	return nil
}

type PartitionExpr struct {
	Expr                 *Expr    `protobuf:"bytes,1,opt,name=expr,proto3" json:"expr,omitempty"`
	ExprStr              string   `protobuf:"bytes,2,opt,name=expr_str,json=exprStr,proto3" json:"expr_str,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartitionExpr) Reset()         { *m = PartitionExpr{} }
func (m *PartitionExpr) String() string { return proto.CompactTextString(m) }
func (*PartitionExpr) ProtoMessage()    {}
func (*PartitionExpr) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{34}
}
func (m *PartitionExpr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionExpr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionExpr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionExpr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionExpr.Merge(m, src)
}
func (m *PartitionExpr) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PartitionExpr) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionExpr.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionExpr proto.InternalMessageInfo

func (m *PartitionExpr) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *PartitionExpr) GetExprStr() string {
	if m != nil {
		return m.ExprStr
	}
	return ""
}

type PartitionColumns struct {
	Columns              []*Expr  `protobuf:"bytes,1,rep,name=columns,proto3" json:"columns,omitempty"`
	PartitionColumns     []string `protobuf:"bytes,2,rep,name=partition_columns,json=partitionColumns,proto3" json:"partition_columns,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartitionColumns) Reset()         { *m = PartitionColumns{} }
func (m *PartitionColumns) String() string { return proto.CompactTextString(m) }
func (*PartitionColumns) ProtoMessage()    {}
func (*PartitionColumns) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{35}
}
func (m *PartitionColumns) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionColumns) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionColumns.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionColumns) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionColumns.Merge(m, src)
}
func (m *PartitionColumns) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PartitionColumns) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionColumns.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionColumns proto.InternalMessageInfo

func (m *PartitionColumns) GetColumns() []*Expr {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *PartitionColumns) GetPartitionColumns() []string {
	if m != nil {
		return m.PartitionColumns
	}
	return nil
}

type PartitionItem struct {
	PartitionName        string   `protobuf:"bytes,1,opt,name=partition_name,json=partitionName,proto3" json:"partition_name,omitempty"`
	OrdinalPosition      uint32   `protobuf:"varint,2,opt,name=ordinal_position,json=ordinalPosition,proto3" json:"ordinal_position,omitempty"`
	Description          string   `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Comment              string   `protobuf:"bytes,4,opt,name=comment,proto3" json:"comment,omitempty"`
	LessThan             []*Expr  `protobuf:"bytes,5,rep,name=less_than,json=lessThan,proto3" json:"less_than,omitempty"`
	InValues             []*Expr  `protobuf:"bytes,6,rep,name=in_values,json=inValues,proto3" json:"in_values,omitempty"`
	PartitionTableName   string   `protobuf:"bytes,7,opt,name=partition_table_name,json=partitionTableName,proto3" json:"partition_table_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartitionItem) Reset()         { *m = PartitionItem{} }
func (m *PartitionItem) String() string { return proto.CompactTextString(m) }
func (*PartitionItem) ProtoMessage()    {}
func (*PartitionItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{36}
}
func (m *PartitionItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionItem.Merge(m, src)
}
func (m *PartitionItem) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PartitionItem) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionItem.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionItem proto.InternalMessageInfo

func (m *PartitionItem) GetPartitionName() string {
	if m != nil {
		return m.PartitionName
	}
	return ""
}

func (m *PartitionItem) GetOrdinalPosition() uint32 {
	if m != nil {
		return m.OrdinalPosition
	}
	return 0
}

func (m *PartitionItem) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *PartitionItem) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *PartitionItem) GetLessThan() []*Expr {
	if m != nil {
		return m.LessThan
	}
	return nil
}

func (m *PartitionItem) GetInValues() []*Expr {
	if m != nil {
		return m.InValues
	}
	return nil
}

func (m *PartitionItem) GetPartitionTableName() string {
	if m != nil {
		return m.PartitionTableName
	}
	return ""
}

type ViewDef struct {
	View                 string   `protobuf:"bytes,1,opt,name=view,proto3" json:"view,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ViewDef) Reset()         { *m = ViewDef{} }
func (m *ViewDef) String() string { return proto.CompactTextString(m) }
func (*ViewDef) ProtoMessage()    {}
func (*ViewDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{37}
}
func (m *ViewDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewDef.Merge(m, src)
}
func (m *ViewDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ViewDef) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewDef.DiscardUnknown(m)
}

var xxx_messageInfo_ViewDef proto.InternalMessageInfo

func (m *ViewDef) GetView() string {
	if m != nil {
		return m.View
	}
	return ""
}

type TableDef struct {
	TblId        uint64           `protobuf:"varint,1,opt,name=tbl_id,json=tblId,proto3" json:"tbl_id,omitempty"`
	Name         string           `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Hidden       bool             `protobuf:"varint,3,opt,name=hidden,proto3" json:"hidden,omitempty"`
	Cols         []*ColDef        `protobuf:"bytes,4,rep,name=cols,proto3" json:"cols,omitempty"`
	TableType    string           `protobuf:"bytes,5,opt,name=table_type,json=tableType,proto3" json:"table_type,omitempty"`
	Createsql    string           `protobuf:"bytes,6,opt,name=createsql,proto3" json:"createsql,omitempty"`
	TblFunc      *TableFunction   `protobuf:"bytes,7,opt,name=tbl_func,json=tblFunc,proto3" json:"tbl_func,omitempty"`
	Version      uint32           `protobuf:"varint,8,opt,name=version,proto3" json:"version,omitempty"`
	Pkey         *PrimaryKeyDef   `protobuf:"bytes,11,opt,name=pkey,proto3" json:"pkey,omitempty"`
	Indexes      []*IndexDef      `protobuf:"bytes,12,rep,name=indexes,proto3" json:"indexes,omitempty"`
	Fkeys        []*ForeignKeyDef `protobuf:"bytes,13,rep,name=fkeys,proto3" json:"fkeys,omitempty"`
	RefChildTbls []uint64         `protobuf:"varint,14,rep,packed,name=ref_child_tbls,json=refChildTbls,proto3" json:"ref_child_tbls,omitempty"`
	Checks       []*CheckDef      `protobuf:"bytes,15,rep,name=checks,proto3" json:"checks,omitempty"`
	Partition    *PartitionByDef  `protobuf:"bytes,21,opt,name=partition,proto3" json:"partition,omitempty"`
	ClusterBy    *ClusterByDef    `protobuf:"bytes,22,opt,name=cluster_by,json=clusterBy,proto3" json:"cluster_by,omitempty"`
	Props        []*PropertyDef   `protobuf:"bytes,23,rep,name=props,proto3" json:"props,omitempty"`
	ViewSql      *ViewDef         `protobuf:"bytes,24,opt,name=view_sql,json=viewSql,proto3" json:"view_sql,omitempty"`
	// XXX: Deprecated and to be removed soon.
	Defs                 []*TableDef_DefType `protobuf:"bytes,25,rep,name=defs,proto3" json:"defs,omitempty"`
	Name2ColIndex        map[string]int32    `protobuf:"bytes,26,rep,name=name2col_index,json=name2colIndex,proto3" json:"name2col_index,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	IsLocked             bool                `protobuf:"varint,27,opt,name=isLocked,proto3" json:"isLocked,omitempty"`
	TableLockType        TableLockType       `protobuf:"varint,28,opt,name=tableLockType,proto3,enum=plan.TableLockType" json:"tableLockType,omitempty"`
	IsTemporary          bool                `protobuf:"varint,29,opt,name=is_temporary,json=isTemporary,proto3" json:"is_temporary,omitempty"`
	AutoIncrOffset       uint64              `protobuf:"varint,30,opt,name=auto_incr_offset,json=autoIncrOffset,proto3" json:"auto_incr_offset,omitempty"`
	IsDynamic            bool                `protobuf:"varint,31,opt,name=is_dynamic,json=isDynamic,proto3" json:"is_dynamic,omitempty"`
	DbName               string              `protobuf:"bytes,32,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TableDef) Reset()         { *m = TableDef{} }
func (m *TableDef) String() string { return proto.CompactTextString(m) }
func (*TableDef) ProtoMessage()    {}
func (*TableDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{38}
}
func (m *TableDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDef.Merge(m, src)
}
func (m *TableDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableDef) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDef.DiscardUnknown(m)
}

var xxx_messageInfo_TableDef proto.InternalMessageInfo

func (m *TableDef) GetTblId() uint64 {
	if m != nil {
		return m.TblId
	}
	return 0
}

func (m *TableDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TableDef) GetHidden() bool {
	if m != nil {
		return m.Hidden
	}
	return false
}

func (m *TableDef) GetCols() []*ColDef {
	if m != nil {
		return m.Cols
	}
	return nil
}

func (m *TableDef) GetTableType() string {
	if m != nil {
		return m.TableType
	}
	return ""
}

func (m *TableDef) GetCreatesql() string {
	if m != nil {
		return m.Createsql
	}
	return ""
}

func (m *TableDef) GetTblFunc() *TableFunction {
	if m != nil {
		return m.TblFunc
	}
	return nil
}

func (m *TableDef) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *TableDef) GetPkey() *PrimaryKeyDef {
	if m != nil {
		return m.Pkey
	}
	return nil
}

func (m *TableDef) GetIndexes() []*IndexDef {
	if m != nil {
		return m.Indexes
	}
	return nil
}

func (m *TableDef) GetFkeys() []*ForeignKeyDef {
	if m != nil {
		return m.Fkeys
	}
	return nil
}

func (m *TableDef) GetRefChildTbls() []uint64 {
	if m != nil {
		return m.RefChildTbls
	}
	return nil
}

func (m *TableDef) GetChecks() []*CheckDef {
	if m != nil {
		return m.Checks
	}
	return nil
}

func (m *TableDef) GetPartition() *PartitionByDef {
	if m != nil {
		return m.Partition
	}
	return nil
}

func (m *TableDef) GetClusterBy() *ClusterByDef {
	if m != nil {
		return m.ClusterBy
	}
	return nil
}

func (m *TableDef) GetProps() []*PropertyDef {
	if m != nil {
		return m.Props
	}
	return nil
}

func (m *TableDef) GetViewSql() *ViewDef {
	if m != nil {
		return m.ViewSql
	}
	return nil
}

func (m *TableDef) GetDefs() []*TableDef_DefType {
	if m != nil {
		return m.Defs
	}
	return nil
}

func (m *TableDef) GetName2ColIndex() map[string]int32 {
	if m != nil {
		return m.Name2ColIndex
	}
	return nil
}

func (m *TableDef) GetIsLocked() bool {
	if m != nil {
		return m.IsLocked
	}
	return false
}

func (m *TableDef) GetTableLockType() TableLockType {
	if m != nil {
		return m.TableLockType
	}
	return TableLockType_TableLockNone
}

func (m *TableDef) GetIsTemporary() bool {
	if m != nil {
		return m.IsTemporary
	}
	return false
}

func (m *TableDef) GetAutoIncrOffset() uint64 {
	if m != nil {
		return m.AutoIncrOffset
	}
	return 0
}

func (m *TableDef) GetIsDynamic() bool {
	if m != nil {
		return m.IsDynamic
	}
	return false
}

func (m *TableDef) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

// XXX: Deprecated and to be removed soon.
type TableDef_DefType struct {
	// Types that are valid to be assigned to Def:
	//
	//	*TableDef_DefType_Properties
	Def                  isTableDef_DefType_Def `protobuf_oneof:"def"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *TableDef_DefType) Reset()         { *m = TableDef_DefType{} }
func (m *TableDef_DefType) String() string { return proto.CompactTextString(m) }
func (*TableDef_DefType) ProtoMessage()    {}
func (*TableDef_DefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{38, 0}
}
func (m *TableDef_DefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDef_DefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableDef_DefType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableDef_DefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDef_DefType.Merge(m, src)
}
func (m *TableDef_DefType) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableDef_DefType) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDef_DefType.DiscardUnknown(m)
}

var xxx_messageInfo_TableDef_DefType proto.InternalMessageInfo

type isTableDef_DefType_Def interface {
	isTableDef_DefType_Def()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type TableDef_DefType_Properties struct {
	Properties *PropertiesDef `protobuf:"bytes,1,opt,name=properties,proto3,oneof" json:"properties,omitempty"`
}

func (*TableDef_DefType_Properties) isTableDef_DefType_Def() {}

func (m *TableDef_DefType) GetDef() isTableDef_DefType_Def {
	if m != nil {
		return m.Def
	}
	return nil
}

func (m *TableDef_DefType) GetProperties() *PropertiesDef {
	if x, ok := m.GetDef().(*TableDef_DefType_Properties); ok {
		return x.Properties
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TableDef_DefType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TableDef_DefType_Properties)(nil),
	}
}

type TableFunction struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Param                []byte   `protobuf:"bytes,2,opt,name=param,proto3" json:"param,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TableFunction) Reset()         { *m = TableFunction{} }
func (m *TableFunction) String() string { return proto.CompactTextString(m) }
func (*TableFunction) ProtoMessage()    {}
func (*TableFunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{39}
}
func (m *TableFunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableFunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableFunction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableFunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableFunction.Merge(m, src)
}
func (m *TableFunction) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableFunction) XXX_DiscardUnknown() {
	xxx_messageInfo_TableFunction.DiscardUnknown(m)
}

var xxx_messageInfo_TableFunction proto.InternalMessageInfo

func (m *TableFunction) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TableFunction) GetParam() []byte {
	if m != nil {
		return m.Param
	}
	return nil
}

type HashMapStats struct {
	// hashmap size for nodes which build a hashmap
	HashmapSize float64 `protobuf:"fixed64,1,opt,name=hashmap_size,json=hashmapSize,proto3" json:"hashmap_size,omitempty"`
	HashOnPK    bool    `protobuf:"varint,2,opt,name=hashOnPK,proto3" json:"hashOnPK,omitempty"`
	// for group by and join node with big hashmap, use shuffle
	// shuffle on which column. choose a column with max ndv
	Shuffle       bool  `protobuf:"varint,3,opt,name=shuffle,proto3" json:"shuffle,omitempty"`
	ShuffleColIdx int32 `protobuf:"varint,4,opt,name=shuffleColIdx,proto3" json:"shuffleColIdx,omitempty"`
	// shuffle type
	ShuffleType           ShuffleType           `protobuf:"varint,5,opt,name=shuffleType,proto3,enum=plan.ShuffleType" json:"shuffleType,omitempty"`
	ShuffleTypeForMultiCN ShuffleTypeForMultiCN `protobuf:"varint,6,opt,name=shuffleTypeForMultiCN,proto3,enum=plan.ShuffleTypeForMultiCN" json:"shuffleTypeForMultiCN,omitempty"`
	// for range shuffle on integer column, need to know its min and max value
	ShuffleColMin        int64         `protobuf:"varint,7,opt,name=shuffleColMin,proto3" json:"shuffleColMin,omitempty"`
	ShuffleColMax        int64         `protobuf:"varint,8,opt,name=shuffleColMax,proto3" json:"shuffleColMax,omitempty"`
	ShuffleMethod        ShuffleMethod `protobuf:"varint,9,opt,name=shuffleMethod,proto3,enum=plan.ShuffleMethod" json:"shuffleMethod,omitempty"`
	Nullcnt              int64         `protobuf:"varint,10,opt,name=nullcnt,proto3" json:"nullcnt,omitempty"`
	Ranges               []float64     `protobuf:"fixed64,11,rep,packed,name=ranges,proto3" json:"ranges,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *HashMapStats) Reset()         { *m = HashMapStats{} }
func (m *HashMapStats) String() string { return proto.CompactTextString(m) }
func (*HashMapStats) ProtoMessage()    {}
func (*HashMapStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{40}
}
func (m *HashMapStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HashMapStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HashMapStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HashMapStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HashMapStats.Merge(m, src)
}
func (m *HashMapStats) XXX_Size() int {
	return m.ProtoSize()
}
func (m *HashMapStats) XXX_DiscardUnknown() {
	xxx_messageInfo_HashMapStats.DiscardUnknown(m)
}

var xxx_messageInfo_HashMapStats proto.InternalMessageInfo

func (m *HashMapStats) GetHashmapSize() float64 {
	if m != nil {
		return m.HashmapSize
	}
	return 0
}

func (m *HashMapStats) GetHashOnPK() bool {
	if m != nil {
		return m.HashOnPK
	}
	return false
}

func (m *HashMapStats) GetShuffle() bool {
	if m != nil {
		return m.Shuffle
	}
	return false
}

func (m *HashMapStats) GetShuffleColIdx() int32 {
	if m != nil {
		return m.ShuffleColIdx
	}
	return 0
}

func (m *HashMapStats) GetShuffleType() ShuffleType {
	if m != nil {
		return m.ShuffleType
	}
	return ShuffleType_Hash
}

func (m *HashMapStats) GetShuffleTypeForMultiCN() ShuffleTypeForMultiCN {
	if m != nil {
		return m.ShuffleTypeForMultiCN
	}
	return ShuffleTypeForMultiCN_Simple
}

func (m *HashMapStats) GetShuffleColMin() int64 {
	if m != nil {
		return m.ShuffleColMin
	}
	return 0
}

func (m *HashMapStats) GetShuffleColMax() int64 {
	if m != nil {
		return m.ShuffleColMax
	}
	return 0
}

func (m *HashMapStats) GetShuffleMethod() ShuffleMethod {
	if m != nil {
		return m.ShuffleMethod
	}
	return ShuffleMethod_Normal
}

func (m *HashMapStats) GetNullcnt() int64 {
	if m != nil {
		return m.Nullcnt
	}
	return 0
}

func (m *HashMapStats) GetRanges() []float64 {
	if m != nil {
		return m.Ranges
	}
	return nil
}

type Stats struct {
	// for scan, number of blocks to read from S3
	BlockNum int32 `protobuf:"varint,1,opt,name=block_num,json=blockNum,proto3" json:"block_num,omitempty"`
	// for scan, cost of reading from S3, basically the read lines
	// for other nodes, it means the estimated cost of current node
	Cost float64 `protobuf:"fixed64,2,opt,name=cost,proto3" json:"cost,omitempty"`
	// number of output lines
	Outcnt float64 `protobuf:"fixed64,3,opt,name=outcnt,proto3" json:"outcnt,omitempty"`
	// average size of one row, currently not used
	Rowsize float64 `protobuf:"fixed64,4,opt,name=rowsize,proto3" json:"rowsize,omitempty"`
	// for scan, this means total count of all table, before filtering
	TableCnt float64 `protobuf:"fixed64,5,opt,name=table_cnt,json=tableCnt,proto3" json:"table_cnt,omitempty"`
	// for scan, selectivity means outcnt divide total count
	Selectivity          float64       `protobuf:"fixed64,6,opt,name=selectivity,proto3" json:"selectivity,omitempty"`
	ForceOneCN           bool          `protobuf:"varint,7,opt,name=forceOneCN,proto3" json:"forceOneCN,omitempty"`
	HashmapStats         *HashMapStats `protobuf:"bytes,8,opt,name=hashmapStats,proto3" json:"hashmapStats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Stats) Reset()         { *m = Stats{} }
func (m *Stats) String() string { return proto.CompactTextString(m) }
func (*Stats) ProtoMessage()    {}
func (*Stats) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{41}
}
func (m *Stats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Stats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Stats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Stats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Stats.Merge(m, src)
}
func (m *Stats) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Stats) XXX_DiscardUnknown() {
	xxx_messageInfo_Stats.DiscardUnknown(m)
}

var xxx_messageInfo_Stats proto.InternalMessageInfo

func (m *Stats) GetBlockNum() int32 {
	if m != nil {
		return m.BlockNum
	}
	return 0
}

func (m *Stats) GetCost() float64 {
	if m != nil {
		return m.Cost
	}
	return 0
}

func (m *Stats) GetOutcnt() float64 {
	if m != nil {
		return m.Outcnt
	}
	return 0
}

func (m *Stats) GetRowsize() float64 {
	if m != nil {
		return m.Rowsize
	}
	return 0
}

func (m *Stats) GetTableCnt() float64 {
	if m != nil {
		return m.TableCnt
	}
	return 0
}

func (m *Stats) GetSelectivity() float64 {
	if m != nil {
		return m.Selectivity
	}
	return 0
}

func (m *Stats) GetForceOneCN() bool {
	if m != nil {
		return m.ForceOneCN
	}
	return false
}

func (m *Stats) GetHashmapStats() *HashMapStats {
	if m != nil {
		return m.HashmapStats
	}
	return nil
}

type RowsetExpr struct {
	RowPos               int32    `protobuf:"varint,1,opt,name=row_pos,json=rowPos,proto3" json:"row_pos,omitempty"`
	Pos                  int32    `protobuf:"varint,2,opt,name=pos,proto3" json:"pos,omitempty"`
	Expr                 *Expr    `protobuf:"bytes,3,opt,name=expr,proto3" json:"expr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RowsetExpr) Reset()         { *m = RowsetExpr{} }
func (m *RowsetExpr) String() string { return proto.CompactTextString(m) }
func (*RowsetExpr) ProtoMessage()    {}
func (*RowsetExpr) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{42}
}
func (m *RowsetExpr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowsetExpr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RowsetExpr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RowsetExpr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowsetExpr.Merge(m, src)
}
func (m *RowsetExpr) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RowsetExpr) XXX_DiscardUnknown() {
	xxx_messageInfo_RowsetExpr.DiscardUnknown(m)
}

var xxx_messageInfo_RowsetExpr proto.InternalMessageInfo

func (m *RowsetExpr) GetRowPos() int32 {
	if m != nil {
		return m.RowPos
	}
	return 0
}

func (m *RowsetExpr) GetPos() int32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

func (m *RowsetExpr) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

type ColData struct {
	Data                 []*RowsetExpr `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ColData) Reset()         { *m = ColData{} }
func (m *ColData) String() string { return proto.CompactTextString(m) }
func (*ColData) ProtoMessage()    {}
func (*ColData) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{43}
}
func (m *ColData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColData.Merge(m, src)
}
func (m *ColData) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ColData) XXX_DiscardUnknown() {
	xxx_messageInfo_ColData.DiscardUnknown(m)
}

var xxx_messageInfo_ColData proto.InternalMessageInfo

func (m *ColData) GetData() []*RowsetExpr {
	if m != nil {
		return m.Data
	}
	return nil
}

type RowsetData struct {
	Cols                 []*ColData `protobuf:"bytes,1,rep,name=cols,proto3" json:"cols,omitempty"`
	RowCount             int32      `protobuf:"varint,2,opt,name=row_count,json=rowCount,proto3" json:"row_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RowsetData) Reset()         { *m = RowsetData{} }
func (m *RowsetData) String() string { return proto.CompactTextString(m) }
func (*RowsetData) ProtoMessage()    {}
func (*RowsetData) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{44}
}
func (m *RowsetData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowsetData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RowsetData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RowsetData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowsetData.Merge(m, src)
}
func (m *RowsetData) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RowsetData) XXX_DiscardUnknown() {
	xxx_messageInfo_RowsetData.DiscardUnknown(m)
}

var xxx_messageInfo_RowsetData proto.InternalMessageInfo

func (m *RowsetData) GetCols() []*ColData {
	if m != nil {
		return m.Cols
	}
	return nil
}

func (m *RowsetData) GetRowCount() int32 {
	if m != nil {
		return m.RowCount
	}
	return 0
}

type OrderBySpec struct {
	Expr                 *Expr                   `protobuf:"bytes,1,opt,name=expr,proto3" json:"expr,omitempty"`
	Collation            string                  `protobuf:"bytes,2,opt,name=collation,proto3" json:"collation,omitempty"`
	Flag                 OrderBySpec_OrderByFlag `protobuf:"varint,3,opt,name=flag,proto3,enum=plan.OrderBySpec_OrderByFlag" json:"flag,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *OrderBySpec) Reset()         { *m = OrderBySpec{} }
func (m *OrderBySpec) String() string { return proto.CompactTextString(m) }
func (*OrderBySpec) ProtoMessage()    {}
func (*OrderBySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{45}
}
func (m *OrderBySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderBySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderBySpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderBySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderBySpec.Merge(m, src)
}
func (m *OrderBySpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *OrderBySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderBySpec.DiscardUnknown(m)
}

var xxx_messageInfo_OrderBySpec proto.InternalMessageInfo

func (m *OrderBySpec) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *OrderBySpec) GetCollation() string {
	if m != nil {
		return m.Collation
	}
	return ""
}

func (m *OrderBySpec) GetFlag() OrderBySpec_OrderByFlag {
	if m != nil {
		return m.Flag
	}
	return OrderBySpec_INTERNAL
}

type WindowSpec struct {
	WindowFunc           *Expr          `protobuf:"bytes,1,opt,name=window_func,json=windowFunc,proto3" json:"window_func,omitempty"`
	PartitionBy          []*Expr        `protobuf:"bytes,2,rep,name=partition_by,json=partitionBy,proto3" json:"partition_by,omitempty"`
	OrderBy              []*OrderBySpec `protobuf:"bytes,3,rep,name=order_by,json=orderBy,proto3" json:"order_by,omitempty"`
	Frame                *FrameClause   `protobuf:"bytes,4,opt,name=frame,proto3" json:"frame,omitempty"`
	Name                 string         `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *WindowSpec) Reset()         { *m = WindowSpec{} }
func (m *WindowSpec) String() string { return proto.CompactTextString(m) }
func (*WindowSpec) ProtoMessage()    {}
func (*WindowSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{46}
}
func (m *WindowSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WindowSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WindowSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowSpec.Merge(m, src)
}
func (m *WindowSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *WindowSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowSpec.DiscardUnknown(m)
}

var xxx_messageInfo_WindowSpec proto.InternalMessageInfo

func (m *WindowSpec) GetWindowFunc() *Expr {
	if m != nil {
		return m.WindowFunc
	}
	return nil
}

func (m *WindowSpec) GetPartitionBy() []*Expr {
	if m != nil {
		return m.PartitionBy
	}
	return nil
}

func (m *WindowSpec) GetOrderBy() []*OrderBySpec {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *WindowSpec) GetFrame() *FrameClause {
	if m != nil {
		return m.Frame
	}
	return nil
}

func (m *WindowSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type SampleFuncSpec struct {
	Rows                 int32    `protobuf:"varint,1,opt,name=Rows,proto3" json:"Rows,omitempty"`
	Percent              float64  `protobuf:"fixed64,2,opt,name=Percent,proto3" json:"Percent,omitempty"`
	UsingRow             bool     `protobuf:"varint,3,opt,name=UsingRow,proto3" json:"UsingRow,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SampleFuncSpec) Reset()         { *m = SampleFuncSpec{} }
func (m *SampleFuncSpec) String() string { return proto.CompactTextString(m) }
func (*SampleFuncSpec) ProtoMessage()    {}
func (*SampleFuncSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{47}
}
func (m *SampleFuncSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SampleFuncSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SampleFuncSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SampleFuncSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SampleFuncSpec.Merge(m, src)
}
func (m *SampleFuncSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SampleFuncSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SampleFuncSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SampleFuncSpec proto.InternalMessageInfo

func (m *SampleFuncSpec) GetRows() int32 {
	if m != nil {
		return m.Rows
	}
	return 0
}

func (m *SampleFuncSpec) GetPercent() float64 {
	if m != nil {
		return m.Percent
	}
	return 0
}

func (m *SampleFuncSpec) GetUsingRow() bool {
	if m != nil {
		return m.UsingRow
	}
	return false
}

type FrameClause struct {
	Type                 FrameClause_FrameType `protobuf:"varint,1,opt,name=type,proto3,enum=plan.FrameClause_FrameType" json:"type,omitempty"`
	Start                *FrameBound           `protobuf:"bytes,2,opt,name=start,proto3" json:"start,omitempty"`
	End                  *FrameBound           `protobuf:"bytes,3,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *FrameClause) Reset()         { *m = FrameClause{} }
func (m *FrameClause) String() string { return proto.CompactTextString(m) }
func (*FrameClause) ProtoMessage()    {}
func (*FrameClause) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{48}
}
func (m *FrameClause) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FrameClause) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FrameClause.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FrameClause) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FrameClause.Merge(m, src)
}
func (m *FrameClause) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FrameClause) XXX_DiscardUnknown() {
	xxx_messageInfo_FrameClause.DiscardUnknown(m)
}

var xxx_messageInfo_FrameClause proto.InternalMessageInfo

func (m *FrameClause) GetType() FrameClause_FrameType {
	if m != nil {
		return m.Type
	}
	return FrameClause_ROWS
}

func (m *FrameClause) GetStart() *FrameBound {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *FrameClause) GetEnd() *FrameBound {
	if m != nil {
		return m.End
	}
	return nil
}

type FrameBound struct {
	Type                 FrameBound_BoundType `protobuf:"varint,1,opt,name=type,proto3,enum=plan.FrameBound_BoundType" json:"type,omitempty"`
	UnBounded            bool                 `protobuf:"varint,2,opt,name=unBounded,proto3" json:"unBounded,omitempty"`
	Val                  *Expr                `protobuf:"bytes,3,opt,name=val,proto3" json:"val,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *FrameBound) Reset()         { *m = FrameBound{} }
func (m *FrameBound) String() string { return proto.CompactTextString(m) }
func (*FrameBound) ProtoMessage()    {}
func (*FrameBound) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{49}
}
func (m *FrameBound) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FrameBound) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FrameBound.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FrameBound) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FrameBound.Merge(m, src)
}
func (m *FrameBound) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FrameBound) XXX_DiscardUnknown() {
	xxx_messageInfo_FrameBound.DiscardUnknown(m)
}

var xxx_messageInfo_FrameBound proto.InternalMessageInfo

func (m *FrameBound) GetType() FrameBound_BoundType {
	if m != nil {
		return m.Type
	}
	return FrameBound_FOLLOWING
}

func (m *FrameBound) GetUnBounded() bool {
	if m != nil {
		return m.UnBounded
	}
	return false
}

func (m *FrameBound) GetVal() *Expr {
	if m != nil {
		return m.Val
	}
	return nil
}

type OnDuplicateKeyCtx struct {
	Attrs                []string         `protobuf:"bytes,1,rep,name=attrs,proto3" json:"attrs,omitempty"`
	InsertColCount       int32            `protobuf:"varint,2,opt,name=insert_col_count,json=insertColCount,proto3" json:"insert_col_count,omitempty"`
	UniqueColCheckExpr   []*Expr          `protobuf:"bytes,3,rep,name=unique_col_check_expr,json=uniqueColCheckExpr,proto3" json:"unique_col_check_expr,omitempty"`
	UniqueCols           []string         `protobuf:"bytes,4,rep,name=unique_cols,json=uniqueCols,proto3" json:"unique_cols,omitempty"`
	OnDuplicateIdx       []int32          `protobuf:"varint,5,rep,packed,name=on_duplicate_idx,json=onDuplicateIdx,proto3" json:"on_duplicate_idx,omitempty"`
	OnDuplicateExpr      map[string]*Expr `protobuf:"bytes,6,rep,name=on_duplicate_expr,json=onDuplicateExpr,proto3" json:"on_duplicate_expr,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	IsIgnore             bool             `protobuf:"varint,7,opt,name=is_ignore,json=isIgnore,proto3" json:"is_ignore,omitempty"`
	TableName            string           `protobuf:"bytes,8,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	TableId              uint64           `protobuf:"varint,9,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	TableVersion         uint32           `protobuf:"varint,10,opt,name=table_version,json=tableVersion,proto3" json:"table_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *OnDuplicateKeyCtx) Reset()         { *m = OnDuplicateKeyCtx{} }
func (m *OnDuplicateKeyCtx) String() string { return proto.CompactTextString(m) }
func (*OnDuplicateKeyCtx) ProtoMessage()    {}
func (*OnDuplicateKeyCtx) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{50}
}
func (m *OnDuplicateKeyCtx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OnDuplicateKeyCtx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OnDuplicateKeyCtx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OnDuplicateKeyCtx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnDuplicateKeyCtx.Merge(m, src)
}
func (m *OnDuplicateKeyCtx) XXX_Size() int {
	return m.ProtoSize()
}
func (m *OnDuplicateKeyCtx) XXX_DiscardUnknown() {
	xxx_messageInfo_OnDuplicateKeyCtx.DiscardUnknown(m)
}

var xxx_messageInfo_OnDuplicateKeyCtx proto.InternalMessageInfo

func (m *OnDuplicateKeyCtx) GetAttrs() []string {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *OnDuplicateKeyCtx) GetInsertColCount() int32 {
	if m != nil {
		return m.InsertColCount
	}
	return 0
}

func (m *OnDuplicateKeyCtx) GetUniqueColCheckExpr() []*Expr {
	if m != nil {
		return m.UniqueColCheckExpr
	}
	return nil
}

func (m *OnDuplicateKeyCtx) GetUniqueCols() []string {
	if m != nil {
		return m.UniqueCols
	}
	return nil
}

func (m *OnDuplicateKeyCtx) GetOnDuplicateIdx() []int32 {
	if m != nil {
		return m.OnDuplicateIdx
	}
	return nil
}

func (m *OnDuplicateKeyCtx) GetOnDuplicateExpr() map[string]*Expr {
	if m != nil {
		return m.OnDuplicateExpr
	}
	return nil
}

func (m *OnDuplicateKeyCtx) GetIsIgnore() bool {
	if m != nil {
		return m.IsIgnore
	}
	return false
}

func (m *OnDuplicateKeyCtx) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *OnDuplicateKeyCtx) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *OnDuplicateKeyCtx) GetTableVersion() uint32 {
	if m != nil {
		return m.TableVersion
	}
	return 0
}

type InsertCtx struct {
	Ref             *ObjectRef `protobuf:"bytes,1,opt,name=ref,proto3" json:"ref,omitempty"`
	AddAffectedRows bool       `protobuf:"varint,2,opt,name=add_affected_rows,json=addAffectedRows,proto3" json:"add_affected_rows,omitempty"`
	IsClusterTable  bool       `protobuf:"varint,3,opt,name=is_cluster_table,json=isClusterTable,proto3" json:"is_cluster_table,omitempty"`
	TableDef        *TableDef  `protobuf:"bytes,4,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	// Align array index with the partition number
	PartitionTableIds    []uint64 `protobuf:"varint,5,rep,packed,name=partition_table_ids,json=partitionTableIds,proto3" json:"partition_table_ids,omitempty"`
	PartitionTableNames  []string `protobuf:"bytes,6,rep,name=partition_table_names,json=partitionTableNames,proto3" json:"partition_table_names,omitempty"`
	PartitionIdx         int32    `protobuf:"varint,7,opt,name=partition_idx,json=partitionIdx,proto3" json:"partition_idx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InsertCtx) Reset()         { *m = InsertCtx{} }
func (m *InsertCtx) String() string { return proto.CompactTextString(m) }
func (*InsertCtx) ProtoMessage()    {}
func (*InsertCtx) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{51}
}
func (m *InsertCtx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InsertCtx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InsertCtx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InsertCtx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InsertCtx.Merge(m, src)
}
func (m *InsertCtx) XXX_Size() int {
	return m.ProtoSize()
}
func (m *InsertCtx) XXX_DiscardUnknown() {
	xxx_messageInfo_InsertCtx.DiscardUnknown(m)
}

var xxx_messageInfo_InsertCtx proto.InternalMessageInfo

func (m *InsertCtx) GetRef() *ObjectRef {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *InsertCtx) GetAddAffectedRows() bool {
	if m != nil {
		return m.AddAffectedRows
	}
	return false
}

func (m *InsertCtx) GetIsClusterTable() bool {
	if m != nil {
		return m.IsClusterTable
	}
	return false
}

func (m *InsertCtx) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *InsertCtx) GetPartitionTableIds() []uint64 {
	if m != nil {
		return m.PartitionTableIds
	}
	return nil
}

func (m *InsertCtx) GetPartitionTableNames() []string {
	if m != nil {
		return m.PartitionTableNames
	}
	return nil
}

func (m *InsertCtx) GetPartitionIdx() int32 {
	if m != nil {
		return m.PartitionIdx
	}
	return 0
}

type ReplaceCtx struct {
	Ref             *ObjectRef `protobuf:"bytes,1,opt,name=ref,proto3" json:"ref,omitempty"`
	AddAffectedRows bool       `protobuf:"varint,2,opt,name=add_affected_rows,json=addAffectedRows,proto3" json:"add_affected_rows,omitempty"`
	IsClusterTable  bool       `protobuf:"varint,3,opt,name=is_cluster_table,json=isClusterTable,proto3" json:"is_cluster_table,omitempty"`
	TableDef        *TableDef  `protobuf:"bytes,4,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	DeleteCond      string     `protobuf:"bytes,5,opt,name=delete_cond,json=deleteCond,proto3" json:"delete_cond,omitempty"`
	// Align array index with the partition number
	PartitionTableIds    []uint64 `protobuf:"varint,6,rep,packed,name=partition_table_ids,json=partitionTableIds,proto3" json:"partition_table_ids,omitempty"`
	PartitionTableNames  []string `protobuf:"bytes,7,rep,name=partition_table_names,json=partitionTableNames,proto3" json:"partition_table_names,omitempty"`
	PartitionIdx         int32    `protobuf:"varint,8,opt,name=partition_idx,json=partitionIdx,proto3" json:"partition_idx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReplaceCtx) Reset()         { *m = ReplaceCtx{} }
func (m *ReplaceCtx) String() string { return proto.CompactTextString(m) }
func (*ReplaceCtx) ProtoMessage()    {}
func (*ReplaceCtx) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{52}
}
func (m *ReplaceCtx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceCtx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplaceCtx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplaceCtx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceCtx.Merge(m, src)
}
func (m *ReplaceCtx) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ReplaceCtx) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceCtx.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceCtx proto.InternalMessageInfo

func (m *ReplaceCtx) GetRef() *ObjectRef {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *ReplaceCtx) GetAddAffectedRows() bool {
	if m != nil {
		return m.AddAffectedRows
	}
	return false
}

func (m *ReplaceCtx) GetIsClusterTable() bool {
	if m != nil {
		return m.IsClusterTable
	}
	return false
}

func (m *ReplaceCtx) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *ReplaceCtx) GetDeleteCond() string {
	if m != nil {
		return m.DeleteCond
	}
	return ""
}

func (m *ReplaceCtx) GetPartitionTableIds() []uint64 {
	if m != nil {
		return m.PartitionTableIds
	}
	return nil
}

func (m *ReplaceCtx) GetPartitionTableNames() []string {
	if m != nil {
		return m.PartitionTableNames
	}
	return nil
}

func (m *ReplaceCtx) GetPartitionIdx() int32 {
	if m != nil {
		return m.PartitionIdx
	}
	return 0
}

type AnalyzeInfo struct {
	InputRows              int64    `protobuf:"varint,1,opt,name=input_rows,json=inputRows,proto3" json:"input_rows,omitempty"`
	OutputRows             int64    `protobuf:"varint,2,opt,name=output_rows,json=outputRows,proto3" json:"output_rows,omitempty"`
	InputSize              int64    `protobuf:"varint,3,opt,name=input_size,json=inputSize,proto3" json:"input_size,omitempty"`
	OutputSize             int64    `protobuf:"varint,4,opt,name=output_size,json=outputSize,proto3" json:"output_size,omitempty"`
	TimeConsumed           int64    `protobuf:"varint,5,opt,name=time_consumed,json=timeConsumed,proto3" json:"time_consumed,omitempty"`
	MemorySize             int64    `protobuf:"varint,6,opt,name=memory_size,json=memorySize,proto3" json:"memory_size,omitempty"`
	WaitTimeConsumed       int64    `protobuf:"varint,7,opt,name=wait_time_consumed,json=waitTimeConsumed,proto3" json:"wait_time_consumed,omitempty"`
	DiskIO                 int64    `protobuf:"varint,8,opt,name=diskIO,proto3" json:"diskIO,omitempty"`
	S3IOByte               int64    `protobuf:"varint,9,opt,name=s3IO_byte,json=s3IOByte,proto3" json:"s3IO_byte,omitempty"`
	S3IOInputCount         int64    `protobuf:"varint,10,opt,name=s3IO_input_count,json=s3IOInputCount,proto3" json:"s3IO_input_count,omitempty"`
	S3IOOutputCount        int64    `protobuf:"varint,11,opt,name=s3IO_output_count,json=s3IOOutputCount,proto3" json:"s3IO_output_count,omitempty"`
	NetworkIO              int64    `protobuf:"varint,12,opt,name=networkIO,proto3" json:"networkIO,omitempty"`
	ScanTime               int64    `protobuf:"varint,13,opt,name=scanTime,proto3" json:"scanTime,omitempty"`
	InsertTime             int64    `protobuf:"varint,14,opt,name=insertTime,proto3" json:"insertTime,omitempty"`
	TimeConsumedArrayMajor []int64  `protobuf:"varint,15,rep,packed,name=time_consumed_array_major,json=timeConsumedArrayMajor,proto3" json:"time_consumed_array_major,omitempty"`
	TimeConsumedArrayMinor []int64  `protobuf:"varint,16,rep,packed,name=time_consumed_array_minor,json=timeConsumedArrayMinor,proto3" json:"time_consumed_array_minor,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *AnalyzeInfo) Reset()         { *m = AnalyzeInfo{} }
func (m *AnalyzeInfo) String() string { return proto.CompactTextString(m) }
func (*AnalyzeInfo) ProtoMessage()    {}
func (*AnalyzeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{53}
}
func (m *AnalyzeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnalyzeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnalyzeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AnalyzeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnalyzeInfo.Merge(m, src)
}
func (m *AnalyzeInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AnalyzeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AnalyzeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AnalyzeInfo proto.InternalMessageInfo

func (m *AnalyzeInfo) GetInputRows() int64 {
	if m != nil {
		return m.InputRows
	}
	return 0
}

func (m *AnalyzeInfo) GetOutputRows() int64 {
	if m != nil {
		return m.OutputRows
	}
	return 0
}

func (m *AnalyzeInfo) GetInputSize() int64 {
	if m != nil {
		return m.InputSize
	}
	return 0
}

func (m *AnalyzeInfo) GetOutputSize() int64 {
	if m != nil {
		return m.OutputSize
	}
	return 0
}

func (m *AnalyzeInfo) GetTimeConsumed() int64 {
	if m != nil {
		return m.TimeConsumed
	}
	return 0
}

func (m *AnalyzeInfo) GetMemorySize() int64 {
	if m != nil {
		return m.MemorySize
	}
	return 0
}

func (m *AnalyzeInfo) GetWaitTimeConsumed() int64 {
	if m != nil {
		return m.WaitTimeConsumed
	}
	return 0
}

func (m *AnalyzeInfo) GetDiskIO() int64 {
	if m != nil {
		return m.DiskIO
	}
	return 0
}

func (m *AnalyzeInfo) GetS3IOByte() int64 {
	if m != nil {
		return m.S3IOByte
	}
	return 0
}

func (m *AnalyzeInfo) GetS3IOInputCount() int64 {
	if m != nil {
		return m.S3IOInputCount
	}
	return 0
}

func (m *AnalyzeInfo) GetS3IOOutputCount() int64 {
	if m != nil {
		return m.S3IOOutputCount
	}
	return 0
}

func (m *AnalyzeInfo) GetNetworkIO() int64 {
	if m != nil {
		return m.NetworkIO
	}
	return 0
}

func (m *AnalyzeInfo) GetScanTime() int64 {
	if m != nil {
		return m.ScanTime
	}
	return 0
}

func (m *AnalyzeInfo) GetInsertTime() int64 {
	if m != nil {
		return m.InsertTime
	}
	return 0
}

func (m *AnalyzeInfo) GetTimeConsumedArrayMajor() []int64 {
	if m != nil {
		return m.TimeConsumedArrayMajor
	}
	return nil
}

func (m *AnalyzeInfo) GetTimeConsumedArrayMinor() []int64 {
	if m != nil {
		return m.TimeConsumedArrayMinor
	}
	return nil
}

type PartitionPrune struct {
	IsPruned             bool             `protobuf:"varint,1,opt,name=isPruned,proto3" json:"isPruned,omitempty"`
	SelectedPartitions   []*PartitionItem `protobuf:"bytes,2,rep,name=selected_partitions,json=selectedPartitions,proto3" json:"selected_partitions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *PartitionPrune) Reset()         { *m = PartitionPrune{} }
func (m *PartitionPrune) String() string { return proto.CompactTextString(m) }
func (*PartitionPrune) ProtoMessage()    {}
func (*PartitionPrune) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{54}
}
func (m *PartitionPrune) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionPrune) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionPrune.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionPrune) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionPrune.Merge(m, src)
}
func (m *PartitionPrune) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PartitionPrune) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionPrune.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionPrune proto.InternalMessageInfo

func (m *PartitionPrune) GetIsPruned() bool {
	if m != nil {
		return m.IsPruned
	}
	return false
}

func (m *PartitionPrune) GetSelectedPartitions() []*PartitionItem {
	if m != nil {
		return m.SelectedPartitions
	}
	return nil
}

type OriginTableMessageForFuzzy struct {
	ParentTableName      string    `protobuf:"bytes,1,opt,name=ParentTableName,proto3" json:"ParentTableName,omitempty"`
	ParentUniqueCols     []*ColDef `protobuf:"bytes,2,rep,name=ParentUniqueCols,proto3" json:"ParentUniqueCols,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *OriginTableMessageForFuzzy) Reset()         { *m = OriginTableMessageForFuzzy{} }
func (m *OriginTableMessageForFuzzy) String() string { return proto.CompactTextString(m) }
func (*OriginTableMessageForFuzzy) ProtoMessage()    {}
func (*OriginTableMessageForFuzzy) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{55}
}
func (m *OriginTableMessageForFuzzy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OriginTableMessageForFuzzy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OriginTableMessageForFuzzy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OriginTableMessageForFuzzy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OriginTableMessageForFuzzy.Merge(m, src)
}
func (m *OriginTableMessageForFuzzy) XXX_Size() int {
	return m.ProtoSize()
}
func (m *OriginTableMessageForFuzzy) XXX_DiscardUnknown() {
	xxx_messageInfo_OriginTableMessageForFuzzy.DiscardUnknown(m)
}

var xxx_messageInfo_OriginTableMessageForFuzzy proto.InternalMessageInfo

func (m *OriginTableMessageForFuzzy) GetParentTableName() string {
	if m != nil {
		return m.ParentTableName
	}
	return ""
}

func (m *OriginTableMessageForFuzzy) GetParentUniqueCols() []*ColDef {
	if m != nil {
		return m.ParentUniqueCols
	}
	return nil
}

type Node struct {
	NodeType Node_NodeType `protobuf:"varint,1,opt,name=node_type,json=nodeType,proto3,enum=plan.Node_NodeType" json:"node_type,omitempty"`
	NodeId   int32         `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Stats    *Stats        `protobuf:"bytes,3,opt,name=stats,proto3" json:"stats,omitempty"`
	Children []int32       `protobuf:"varint,4,rep,packed,name=children,proto3" json:"children,omitempty"`
	// PROJECT
	ProjectList []*Expr `protobuf:"bytes,5,rep,name=project_list,json=projectList,proto3" json:"project_list,omitempty"`
	// JOIN
	JoinType    Node_JoinType `protobuf:"varint,6,opt,name=join_type,json=joinType,proto3,enum=plan.Node_JoinType" json:"join_type,omitempty"`
	OnList      []*Expr       `protobuf:"bytes,7,rep,name=on_list,json=onList,proto3" json:"on_list,omitempty"`
	BuildOnLeft bool          `protobuf:"varint,8,opt,name=build_on_left,json=buildOnLeft,proto3" json:"build_on_left,omitempty"`
	// FILTER
	FilterList []*Expr `protobuf:"bytes,9,rep,name=filter_list,json=filterList,proto3" json:"filter_list,omitempty"`
	// AGG
	GroupBy     []*Expr `protobuf:"bytes,10,rep,name=group_by,json=groupBy,proto3" json:"group_by,omitempty"`
	GroupingSet []*Expr `protobuf:"bytes,11,rep,name=grouping_set,json=groupingSet,proto3" json:"grouping_set,omitempty"`
	AggList     []*Expr `protobuf:"bytes,12,rep,name=agg_list,json=aggList,proto3" json:"agg_list,omitempty"`
	// WINDOW
	WinSpecList []*Expr `protobuf:"bytes,13,rep,name=win_spec_list,json=winSpecList,proto3" json:"win_spec_list,omitempty"`
	// SORT
	OrderBy []*OrderBySpec `protobuf:"bytes,14,rep,name=order_by,json=orderBy,proto3" json:"order_by,omitempty"`
	// LIMIT
	Limit           *Expr         `protobuf:"bytes,15,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset          *Expr         `protobuf:"bytes,16,opt,name=offset,proto3" json:"offset,omitempty"`
	TableDef        *TableDef     `protobuf:"bytes,17,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	ObjRef          *ObjectRef    `protobuf:"bytes,18,opt,name=obj_ref,json=objRef,proto3" json:"obj_ref,omitempty"`
	ParentObjRef    *ObjectRef    `protobuf:"bytes,19,opt,name=parent_obj_ref,json=parentObjRef,proto3" json:"parent_obj_ref,omitempty"`
	RowsetData      *RowsetData   `protobuf:"bytes,20,opt,name=rowset_data,json=rowsetData,proto3" json:"rowset_data,omitempty"`
	ExtraOptions    string        `protobuf:"bytes,22,opt,name=extra_options,json=extraOptions,proto3" json:"extra_options,omitempty"`
	DeleteCtx       *DeleteCtx    `protobuf:"bytes,23,opt,name=delete_ctx,json=deleteCtx,proto3" json:"delete_ctx,omitempty"`
	BindingTags     []int32       `protobuf:"varint,24,rep,packed,name=binding_tags,json=bindingTags,proto3" json:"binding_tags,omitempty"`
	AnalyzeInfo     *AnalyzeInfo  `protobuf:"bytes,25,opt,name=analyze_info,json=analyzeInfo,proto3" json:"analyze_info,omitempty"`
	TblFuncExprList []*Expr       `protobuf:"bytes,26,rep,name=tbl_func_expr_list,json=tblFuncExprList,proto3" json:"tbl_func_expr_list,omitempty"`
	ClusterTable    *ClusterTable `protobuf:"bytes,28,opt,name=cluster_table,json=clusterTable,proto3" json:"cluster_table,omitempty"`
	NotCacheable    bool          `protobuf:"varint,29,opt,name=not_cacheable,json=notCacheable,proto3" json:"not_cacheable,omitempty"`
	InsertCtx       *InsertCtx    `protobuf:"bytes,30,opt,name=insert_ctx,json=insertCtx,proto3" json:"insert_ctx,omitempty"`
	ReplaceCtx      *ReplaceCtx   `protobuf:"bytes,31,opt,name=replace_ctx,json=replaceCtx,proto3" json:"replace_ctx,omitempty"`
	// used to connect two plans[steps]
	SourceStep   []int32       `protobuf:"varint,32,rep,packed,name=source_step,json=sourceStep,proto3" json:"source_step,omitempty"`
	PreDeleteCtx *PreDeleteCtx `protobuf:"bytes,33,opt,name=pre_delete_ctx,json=preDeleteCtx,proto3" json:"pre_delete_ctx,omitempty"`
	PreInsertCtx *PreInsertCtx `protobuf:"bytes,34,opt,name=pre_insert_ctx,json=preInsertCtx,proto3" json:"pre_insert_ctx,omitempty"`
	// build unique key batch before insert into hidden table which keep the unique key
	PreInsertUkCtx  *PreInsertUkCtx    `protobuf:"bytes,35,opt,name=pre_insert_uk_ctx,json=preInsertUkCtx,proto3" json:"pre_insert_uk_ctx,omitempty"`
	OnDuplicateKey  *OnDuplicateKeyCtx `protobuf:"bytes,36,opt,name=on_duplicate_key,json=onDuplicateKey,proto3" json:"on_duplicate_key,omitempty"`
	IsEnd           bool               `protobuf:"varint,37,opt,name=IsEnd,proto3" json:"IsEnd,omitempty"`
	LockTargets     []*LockTarget      `protobuf:"bytes,38,rep,name=lock_targets,json=lockTargets,proto3" json:"lock_targets,omitempty"`
	BlockFilterList []*Expr            `protobuf:"bytes,39,rep,name=block_filter_list,json=blockFilterList,proto3" json:"block_filter_list,omitempty"`
	// Runtime filters
	RuntimeFilterProbeList []*RuntimeFilterSpec `protobuf:"bytes,40,rep,name=runtime_filter_probe_list,json=runtimeFilterProbeList,proto3" json:"runtime_filter_probe_list,omitempty"`
	RuntimeFilterBuildList []*RuntimeFilterSpec `protobuf:"bytes,41,rep,name=runtime_filter_build_list,json=runtimeFilterBuildList,proto3" json:"runtime_filter_build_list,omitempty"`
	Uuid                   []byte               `protobuf:"bytes,42,opt,name=uuid,proto3" json:"uuid,omitempty"`
	RecursiveSink          bool                 `protobuf:"varint,43,opt,name=recursive_sink,json=recursiveSink,proto3" json:"recursive_sink,omitempty"`
	ExternScan             *ExternScan          `protobuf:"bytes,44,opt,name=extern_scan,json=externScan,proto3" json:"extern_scan,omitempty"`
	PartitionPrune         *PartitionPrune      `protobuf:"bytes,45,opt,name=partition_prune,json=partitionPrune,proto3" json:"partition_prune,omitempty"`
	PreInsertSkCtx         *PreInsertUkCtx      `protobuf:"bytes,46,opt,name=pre_insert_sk_ctx,json=preInsertSkCtx,proto3" json:"pre_insert_sk_ctx,omitempty"`
	Interval               *Expr                `protobuf:"bytes,47,opt,name=interval,proto3" json:"interval,omitempty"`
	Sliding                *Expr                `protobuf:"bytes,48,opt,name=sliding,proto3" json:"sliding,omitempty"`
	FillType               Node_FillType        `protobuf:"varint,49,opt,name=fill_type,json=fillType,proto3,enum=plan.Node_FillType" json:"fill_type,omitempty"`
	FillVal                []*Expr              `protobuf:"bytes,50,rep,name=fill_val,json=fillVal,proto3" json:"fill_val,omitempty"`
	// sample function related.
	SampleFunc    *SampleFuncSpec             `protobuf:"bytes,51,opt,name=sample_func,json=sampleFunc,proto3" json:"sample_func,omitempty"`
	WindowIdx     int32                       `protobuf:"varint,52,opt,name=window_idx,json=windowIdx,proto3" json:"window_idx,omitempty"`
	OnUpdateExprs []*Expr                     `protobuf:"bytes,53,rep,name=onUpdateExprs,proto3" json:"onUpdateExprs,omitempty"`
	Fuzzymessage  *OriginTableMessageForFuzzy `protobuf:"bytes,54,opt,name=fuzzymessage,proto3" json:"fuzzymessage,omitempty"`
	// for message
	SendMsgList          []*MsgHeader `protobuf:"bytes,55,rep,name=send_msg_list,json=sendMsgList,proto3" json:"send_msg_list,omitempty"`
	RecvMsgList          []*MsgHeader `protobuf:"bytes,56,rep,name=recv_msg_list,json=recvMsgList,proto3" json:"recv_msg_list,omitempty"`
	ScanSnapshot         *Snapshot    `protobuf:"bytes,57,opt,name=scan_snapshot,json=scanSnapshot,proto3" json:"scan_snapshot,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{56}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetNodeType() Node_NodeType {
	if m != nil {
		return m.NodeType
	}
	return Node_UNKNOWN
}

func (m *Node) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *Node) GetStats() *Stats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *Node) GetChildren() []int32 {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *Node) GetProjectList() []*Expr {
	if m != nil {
		return m.ProjectList
	}
	return nil
}

func (m *Node) GetJoinType() Node_JoinType {
	if m != nil {
		return m.JoinType
	}
	return Node_INNER
}

func (m *Node) GetOnList() []*Expr {
	if m != nil {
		return m.OnList
	}
	return nil
}

func (m *Node) GetBuildOnLeft() bool {
	if m != nil {
		return m.BuildOnLeft
	}
	return false
}

func (m *Node) GetFilterList() []*Expr {
	if m != nil {
		return m.FilterList
	}
	return nil
}

func (m *Node) GetGroupBy() []*Expr {
	if m != nil {
		return m.GroupBy
	}
	return nil
}

func (m *Node) GetGroupingSet() []*Expr {
	if m != nil {
		return m.GroupingSet
	}
	return nil
}

func (m *Node) GetAggList() []*Expr {
	if m != nil {
		return m.AggList
	}
	return nil
}

func (m *Node) GetWinSpecList() []*Expr {
	if m != nil {
		return m.WinSpecList
	}
	return nil
}

func (m *Node) GetOrderBy() []*OrderBySpec {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *Node) GetLimit() *Expr {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *Node) GetOffset() *Expr {
	if m != nil {
		return m.Offset
	}
	return nil
}

func (m *Node) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *Node) GetObjRef() *ObjectRef {
	if m != nil {
		return m.ObjRef
	}
	return nil
}

func (m *Node) GetParentObjRef() *ObjectRef {
	if m != nil {
		return m.ParentObjRef
	}
	return nil
}

func (m *Node) GetRowsetData() *RowsetData {
	if m != nil {
		return m.RowsetData
	}
	return nil
}

func (m *Node) GetExtraOptions() string {
	if m != nil {
		return m.ExtraOptions
	}
	return ""
}

func (m *Node) GetDeleteCtx() *DeleteCtx {
	if m != nil {
		return m.DeleteCtx
	}
	return nil
}

func (m *Node) GetBindingTags() []int32 {
	if m != nil {
		return m.BindingTags
	}
	return nil
}

func (m *Node) GetAnalyzeInfo() *AnalyzeInfo {
	if m != nil {
		return m.AnalyzeInfo
	}
	return nil
}

func (m *Node) GetTblFuncExprList() []*Expr {
	if m != nil {
		return m.TblFuncExprList
	}
	return nil
}

func (m *Node) GetClusterTable() *ClusterTable {
	if m != nil {
		return m.ClusterTable
	}
	return nil
}

func (m *Node) GetNotCacheable() bool {
	if m != nil {
		return m.NotCacheable
	}
	return false
}

func (m *Node) GetInsertCtx() *InsertCtx {
	if m != nil {
		return m.InsertCtx
	}
	return nil
}

func (m *Node) GetReplaceCtx() *ReplaceCtx {
	if m != nil {
		return m.ReplaceCtx
	}
	return nil
}

func (m *Node) GetSourceStep() []int32 {
	if m != nil {
		return m.SourceStep
	}
	return nil
}

func (m *Node) GetPreDeleteCtx() *PreDeleteCtx {
	if m != nil {
		return m.PreDeleteCtx
	}
	return nil
}

func (m *Node) GetPreInsertCtx() *PreInsertCtx {
	if m != nil {
		return m.PreInsertCtx
	}
	return nil
}

func (m *Node) GetPreInsertUkCtx() *PreInsertUkCtx {
	if m != nil {
		return m.PreInsertUkCtx
	}
	return nil
}

func (m *Node) GetOnDuplicateKey() *OnDuplicateKeyCtx {
	if m != nil {
		return m.OnDuplicateKey
	}
	return nil
}

func (m *Node) GetIsEnd() bool {
	if m != nil {
		return m.IsEnd
	}
	return false
}

func (m *Node) GetLockTargets() []*LockTarget {
	if m != nil {
		return m.LockTargets
	}
	return nil
}

func (m *Node) GetBlockFilterList() []*Expr {
	if m != nil {
		return m.BlockFilterList
	}
	return nil
}

func (m *Node) GetRuntimeFilterProbeList() []*RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterProbeList
	}
	return nil
}

func (m *Node) GetRuntimeFilterBuildList() []*RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterBuildList
	}
	return nil
}

func (m *Node) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *Node) GetRecursiveSink() bool {
	if m != nil {
		return m.RecursiveSink
	}
	return false
}

func (m *Node) GetExternScan() *ExternScan {
	if m != nil {
		return m.ExternScan
	}
	return nil
}

func (m *Node) GetPartitionPrune() *PartitionPrune {
	if m != nil {
		return m.PartitionPrune
	}
	return nil
}

func (m *Node) GetPreInsertSkCtx() *PreInsertUkCtx {
	if m != nil {
		return m.PreInsertSkCtx
	}
	return nil
}

func (m *Node) GetInterval() *Expr {
	if m != nil {
		return m.Interval
	}
	return nil
}

func (m *Node) GetSliding() *Expr {
	if m != nil {
		return m.Sliding
	}
	return nil
}

func (m *Node) GetFillType() Node_FillType {
	if m != nil {
		return m.FillType
	}
	return Node_NONE
}

func (m *Node) GetFillVal() []*Expr {
	if m != nil {
		return m.FillVal
	}
	return nil
}

func (m *Node) GetSampleFunc() *SampleFuncSpec {
	if m != nil {
		return m.SampleFunc
	}
	return nil
}

func (m *Node) GetWindowIdx() int32 {
	if m != nil {
		return m.WindowIdx
	}
	return 0
}

func (m *Node) GetOnUpdateExprs() []*Expr {
	if m != nil {
		return m.OnUpdateExprs
	}
	return nil
}

func (m *Node) GetFuzzymessage() *OriginTableMessageForFuzzy {
	if m != nil {
		return m.Fuzzymessage
	}
	return nil
}

func (m *Node) GetSendMsgList() []*MsgHeader {
	if m != nil {
		return m.SendMsgList
	}
	return nil
}

func (m *Node) GetRecvMsgList() []*MsgHeader {
	if m != nil {
		return m.RecvMsgList
	}
	return nil
}

func (m *Node) GetScanSnapshot() *Snapshot {
	if m != nil {
		return m.ScanSnapshot
	}
	return nil
}

// Snapshot Represents a snapshot of the database
type Snapshot struct {
	// The timestamp of the snapshot
	TS *timestamp.Timestamp `protobuf:"bytes,1,opt,name=TS,proto3" json:"TS,omitempty"`
	// Tenant information for creating snapshots
	CreatedByTenant      *SnapshotTenant `protobuf:"bytes,2,opt,name=createdByTenant,proto3" json:"createdByTenant,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Snapshot) Reset()         { *m = Snapshot{} }
func (m *Snapshot) String() string { return proto.CompactTextString(m) }
func (*Snapshot) ProtoMessage()    {}
func (*Snapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{57}
}
func (m *Snapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Snapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Snapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Snapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot.Merge(m, src)
}
func (m *Snapshot) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Snapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot proto.InternalMessageInfo

func (m *Snapshot) GetTS() *timestamp.Timestamp {
	if m != nil {
		return m.TS
	}
	return nil
}

func (m *Snapshot) GetCreatedByTenant() *SnapshotTenant {
	if m != nil {
		return m.CreatedByTenant
	}
	return nil
}

// Tenant information for creating snapshots
type SnapshotTenant struct {
	TenantName           string   `protobuf:"bytes,1,opt,name=tenantName,proto3" json:"tenantName,omitempty"`
	TenantID             uint32   `protobuf:"varint,2,opt,name=tenantID,proto3" json:"tenantID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SnapshotTenant) Reset()         { *m = SnapshotTenant{} }
func (m *SnapshotTenant) String() string { return proto.CompactTextString(m) }
func (*SnapshotTenant) ProtoMessage()    {}
func (*SnapshotTenant) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{58}
}
func (m *SnapshotTenant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotTenant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotTenant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotTenant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotTenant.Merge(m, src)
}
func (m *SnapshotTenant) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SnapshotTenant) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotTenant.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotTenant proto.InternalMessageInfo

func (m *SnapshotTenant) GetTenantName() string {
	if m != nil {
		return m.TenantName
	}
	return ""
}

func (m *SnapshotTenant) GetTenantID() uint32 {
	if m != nil {
		return m.TenantID
	}
	return 0
}

type ExternScan struct {
	Type                 int32    `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Data                 string   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	Format               string   `protobuf:"bytes,3,opt,name=format,proto3" json:"format,omitempty"`
	IgnoredLines         uint64   `protobuf:"varint,4,opt,name=ignored_lines,json=ignoredLines,proto3" json:"ignored_lines,omitempty"`
	EnclosedBy           []byte   `protobuf:"bytes,5,opt,name=enclosed_by,json=enclosedBy,proto3" json:"enclosed_by,omitempty"`
	Terminated           string   `protobuf:"bytes,6,opt,name=terminated,proto3" json:"terminated,omitempty"`
	JsonType             string   `protobuf:"bytes,7,opt,name=json_type,json=jsonType,proto3" json:"json_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExternScan) Reset()         { *m = ExternScan{} }
func (m *ExternScan) String() string { return proto.CompactTextString(m) }
func (*ExternScan) ProtoMessage()    {}
func (*ExternScan) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{59}
}
func (m *ExternScan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternScan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExternScan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExternScan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternScan.Merge(m, src)
}
func (m *ExternScan) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExternScan) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternScan.DiscardUnknown(m)
}

var xxx_messageInfo_ExternScan proto.InternalMessageInfo

func (m *ExternScan) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ExternScan) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *ExternScan) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *ExternScan) GetIgnoredLines() uint64 {
	if m != nil {
		return m.IgnoredLines
	}
	return 0
}

func (m *ExternScan) GetEnclosedBy() []byte {
	if m != nil {
		return m.EnclosedBy
	}
	return nil
}

func (m *ExternScan) GetTerminated() string {
	if m != nil {
		return m.Terminated
	}
	return ""
}

func (m *ExternScan) GetJsonType() string {
	if m != nil {
		return m.JsonType
	}
	return ""
}

type LockTarget struct {
	TableId              uint64        `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	PrimaryColIdxInBat   int32         `protobuf:"varint,2,opt,name=primary_col_idx_in_bat,json=primaryColIdxInBat,proto3" json:"primary_col_idx_in_bat,omitempty"`
	PrimaryColTyp        Type          `protobuf:"bytes,3,opt,name=primary_col_typ,json=primaryColTyp,proto3" json:"primary_col_typ"`
	RefreshTsIdxInBat    int32         `protobuf:"varint,4,opt,name=refresh_ts_idx_in_bat,json=refreshTsIdxInBat,proto3" json:"refresh_ts_idx_in_bat,omitempty"`
	FilterColIdxInBat    int32         `protobuf:"varint,5,opt,name=filter_col_idx_in_bat,json=filterColIdxInBat,proto3" json:"filter_col_idx_in_bat,omitempty"`
	LockTable            bool          `protobuf:"varint,6,opt,name=lock_table,json=lockTable,proto3" json:"lock_table,omitempty"`
	IsPartitionTable     bool          `protobuf:"varint,7,opt,name=is_partition_table,json=isPartitionTable,proto3" json:"is_partition_table,omitempty"`
	PartitionTableIds    []uint64      `protobuf:"varint,8,rep,packed,name=partition_table_ids,json=partitionTableIds,proto3" json:"partition_table_ids,omitempty"`
	Block                bool          `protobuf:"varint,9,opt,name=block,proto3" json:"block,omitempty"`
	Mode                 lock.LockMode `protobuf:"varint,10,opt,name=Mode,proto3,enum=lock.LockMode" json:"Mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LockTarget) Reset()         { *m = LockTarget{} }
func (m *LockTarget) String() string { return proto.CompactTextString(m) }
func (*LockTarget) ProtoMessage()    {}
func (*LockTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{60}
}
func (m *LockTarget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockTarget.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LockTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockTarget.Merge(m, src)
}
func (m *LockTarget) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LockTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_LockTarget.DiscardUnknown(m)
}

var xxx_messageInfo_LockTarget proto.InternalMessageInfo

func (m *LockTarget) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *LockTarget) GetPrimaryColIdxInBat() int32 {
	if m != nil {
		return m.PrimaryColIdxInBat
	}
	return 0
}

func (m *LockTarget) GetPrimaryColTyp() Type {
	if m != nil {
		return m.PrimaryColTyp
	}
	return Type{}
}

func (m *LockTarget) GetRefreshTsIdxInBat() int32 {
	if m != nil {
		return m.RefreshTsIdxInBat
	}
	return 0
}

func (m *LockTarget) GetFilterColIdxInBat() int32 {
	if m != nil {
		return m.FilterColIdxInBat
	}
	return 0
}

func (m *LockTarget) GetLockTable() bool {
	if m != nil {
		return m.LockTable
	}
	return false
}

func (m *LockTarget) GetIsPartitionTable() bool {
	if m != nil {
		return m.IsPartitionTable
	}
	return false
}

func (m *LockTarget) GetPartitionTableIds() []uint64 {
	if m != nil {
		return m.PartitionTableIds
	}
	return nil
}

func (m *LockTarget) GetBlock() bool {
	if m != nil {
		return m.Block
	}
	return false
}

func (m *LockTarget) GetMode() lock.LockMode {
	if m != nil {
		return m.Mode
	}
	return lock.LockMode_Exclusive
}

type PreInsertUkCtx struct {
	// index of columns(parts of unique key) in pre batch
	Columns              []int32  `protobuf:"varint,1,rep,packed,name=columns,proto3" json:"columns,omitempty"`
	PkColumn             int32    `protobuf:"varint,2,opt,name=pk_column,json=pkColumn,proto3" json:"pk_column,omitempty"`
	PkType               Type     `protobuf:"bytes,3,opt,name=pk_type,json=pkType,proto3" json:"pk_type"`
	UkType               Type     `protobuf:"bytes,4,opt,name=uk_type,json=ukType,proto3" json:"uk_type"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PreInsertUkCtx) Reset()         { *m = PreInsertUkCtx{} }
func (m *PreInsertUkCtx) String() string { return proto.CompactTextString(m) }
func (*PreInsertUkCtx) ProtoMessage()    {}
func (*PreInsertUkCtx) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{61}
}
func (m *PreInsertUkCtx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreInsertUkCtx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PreInsertUkCtx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PreInsertUkCtx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreInsertUkCtx.Merge(m, src)
}
func (m *PreInsertUkCtx) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PreInsertUkCtx) XXX_DiscardUnknown() {
	xxx_messageInfo_PreInsertUkCtx.DiscardUnknown(m)
}

var xxx_messageInfo_PreInsertUkCtx proto.InternalMessageInfo

func (m *PreInsertUkCtx) GetColumns() []int32 {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *PreInsertUkCtx) GetPkColumn() int32 {
	if m != nil {
		return m.PkColumn
	}
	return 0
}

func (m *PreInsertUkCtx) GetPkType() Type {
	if m != nil {
		return m.PkType
	}
	return Type{}
}

func (m *PreInsertUkCtx) GetUkType() Type {
	if m != nil {
		return m.UkType
	}
	return Type{}
}

type PreDeleteCtx struct {
	// the indexes of row_id&pk column in the batch
	Idx                  []int32  `protobuf:"varint,1,rep,packed,name=idx,proto3" json:"idx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PreDeleteCtx) Reset()         { *m = PreDeleteCtx{} }
func (m *PreDeleteCtx) String() string { return proto.CompactTextString(m) }
func (*PreDeleteCtx) ProtoMessage()    {}
func (*PreDeleteCtx) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{62}
}
func (m *PreDeleteCtx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreDeleteCtx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PreDeleteCtx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PreDeleteCtx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreDeleteCtx.Merge(m, src)
}
func (m *PreDeleteCtx) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PreDeleteCtx) XXX_DiscardUnknown() {
	xxx_messageInfo_PreDeleteCtx.DiscardUnknown(m)
}

var xxx_messageInfo_PreDeleteCtx proto.InternalMessageInfo

func (m *PreDeleteCtx) GetIdx() []int32 {
	if m != nil {
		return m.Idx
	}
	return nil
}

type PreInsertCtx struct {
	Ref                  *ObjectRef `protobuf:"bytes,1,opt,name=ref,proto3" json:"ref,omitempty"`
	TableDef             *TableDef  `protobuf:"bytes,2,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	HasAutoCol           bool       `protobuf:"varint,3,opt,name=has_auto_col,json=hasAutoCol,proto3" json:"has_auto_col,omitempty"`
	IsUpdate             bool       `protobuf:"varint,4,opt,name=is_update,json=isUpdate,proto3" json:"is_update,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *PreInsertCtx) Reset()         { *m = PreInsertCtx{} }
func (m *PreInsertCtx) String() string { return proto.CompactTextString(m) }
func (*PreInsertCtx) ProtoMessage()    {}
func (*PreInsertCtx) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{63}
}
func (m *PreInsertCtx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreInsertCtx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PreInsertCtx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PreInsertCtx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreInsertCtx.Merge(m, src)
}
func (m *PreInsertCtx) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PreInsertCtx) XXX_DiscardUnknown() {
	xxx_messageInfo_PreInsertCtx.DiscardUnknown(m)
}

var xxx_messageInfo_PreInsertCtx proto.InternalMessageInfo

func (m *PreInsertCtx) GetRef() *ObjectRef {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *PreInsertCtx) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *PreInsertCtx) GetHasAutoCol() bool {
	if m != nil {
		return m.HasAutoCol
	}
	return false
}

func (m *PreInsertCtx) GetIsUpdate() bool {
	if m != nil {
		return m.IsUpdate
	}
	return false
}

type RuntimeFilterSpec struct {
	Tag                  int32    `protobuf:"varint,1,opt,name=tag,proto3" json:"tag,omitempty"`
	MatchPrefix          bool     `protobuf:"varint,2,opt,name=match_prefix,json=matchPrefix,proto3" json:"match_prefix,omitempty"`
	UpperLimit           int32    `protobuf:"varint,3,opt,name=upper_limit,json=upperLimit,proto3" json:"upper_limit,omitempty"`
	Expr                 *Expr    `protobuf:"bytes,4,opt,name=expr,proto3" json:"expr,omitempty"`
	Handled              bool     `protobuf:"varint,5,opt,name=handled,proto3" json:"handled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RuntimeFilterSpec) Reset()         { *m = RuntimeFilterSpec{} }
func (m *RuntimeFilterSpec) String() string { return proto.CompactTextString(m) }
func (*RuntimeFilterSpec) ProtoMessage()    {}
func (*RuntimeFilterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{64}
}
func (m *RuntimeFilterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuntimeFilterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RuntimeFilterSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RuntimeFilterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuntimeFilterSpec.Merge(m, src)
}
func (m *RuntimeFilterSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RuntimeFilterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RuntimeFilterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RuntimeFilterSpec proto.InternalMessageInfo

func (m *RuntimeFilterSpec) GetTag() int32 {
	if m != nil {
		return m.Tag
	}
	return 0
}

func (m *RuntimeFilterSpec) GetMatchPrefix() bool {
	if m != nil {
		return m.MatchPrefix
	}
	return false
}

func (m *RuntimeFilterSpec) GetUpperLimit() int32 {
	if m != nil {
		return m.UpperLimit
	}
	return 0
}

func (m *RuntimeFilterSpec) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *RuntimeFilterSpec) GetHandled() bool {
	if m != nil {
		return m.Handled
	}
	return false
}

type IdList struct {
	List                 []int64  `protobuf:"varint,1,rep,packed,name=list,proto3" json:"list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IdList) Reset()         { *m = IdList{} }
func (m *IdList) String() string { return proto.CompactTextString(m) }
func (*IdList) ProtoMessage()    {}
func (*IdList) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{65}
}
func (m *IdList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IdList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IdList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IdList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IdList.Merge(m, src)
}
func (m *IdList) XXX_Size() int {
	return m.ProtoSize()
}
func (m *IdList) XXX_DiscardUnknown() {
	xxx_messageInfo_IdList.DiscardUnknown(m)
}

var xxx_messageInfo_IdList proto.InternalMessageInfo

func (m *IdList) GetList() []int64 {
	if m != nil {
		return m.List
	}
	return nil
}

type ColPosMap struct {
	Map                  map[string]int32 `protobuf:"bytes,1,rep,name=map,proto3" json:"map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ColPosMap) Reset()         { *m = ColPosMap{} }
func (m *ColPosMap) String() string { return proto.CompactTextString(m) }
func (*ColPosMap) ProtoMessage()    {}
func (*ColPosMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{66}
}
func (m *ColPosMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColPosMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColPosMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColPosMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColPosMap.Merge(m, src)
}
func (m *ColPosMap) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ColPosMap) XXX_DiscardUnknown() {
	xxx_messageInfo_ColPosMap.DiscardUnknown(m)
}

var xxx_messageInfo_ColPosMap proto.InternalMessageInfo

func (m *ColPosMap) GetMap() map[string]int32 {
	if m != nil {
		return m.Map
	}
	return nil
}

type DeleteCtx struct {
	CanTruncate     bool       `protobuf:"varint,1,opt,name=can_truncate,json=canTruncate,proto3" json:"can_truncate,omitempty"`
	Ref             *ObjectRef `protobuf:"bytes,2,opt,name=ref,proto3" json:"ref,omitempty"`
	RowIdIdx        int32      `protobuf:"varint,3,opt,name=row_id_idx,json=rowIdIdx,proto3" json:"row_id_idx,omitempty"`
	AddAffectedRows bool       `protobuf:"varint,4,opt,name=add_affected_rows,json=addAffectedRows,proto3" json:"add_affected_rows,omitempty"`
	IsClusterTable  bool       `protobuf:"varint,5,opt,name=is_cluster_table,json=isClusterTable,proto3" json:"is_cluster_table,omitempty"`
	// Align array index with the partition number
	PartitionTableIds    []uint64       `protobuf:"varint,6,rep,packed,name=partition_table_ids,json=partitionTableIds,proto3" json:"partition_table_ids,omitempty"`
	PartitionTableNames  []string       `protobuf:"bytes,7,rep,name=partition_table_names,json=partitionTableNames,proto3" json:"partition_table_names,omitempty"`
	PartitionIdx         int32          `protobuf:"varint,8,opt,name=partition_idx,json=partitionIdx,proto3" json:"partition_idx,omitempty"`
	PrimaryKeyIdx        int32          `protobuf:"varint,9,opt,name=primary_key_idx,json=primaryKeyIdx,proto3" json:"primary_key_idx,omitempty"`
	TruncateTable        *TruncateTable `protobuf:"bytes,10,opt,name=truncate_table,json=truncateTable,proto3" json:"truncate_table,omitempty"`
	TableDef             *TableDef      `protobuf:"bytes,11,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *DeleteCtx) Reset()         { *m = DeleteCtx{} }
func (m *DeleteCtx) String() string { return proto.CompactTextString(m) }
func (*DeleteCtx) ProtoMessage()    {}
func (*DeleteCtx) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{67}
}
func (m *DeleteCtx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteCtx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteCtx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteCtx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteCtx.Merge(m, src)
}
func (m *DeleteCtx) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeleteCtx) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteCtx.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteCtx proto.InternalMessageInfo

func (m *DeleteCtx) GetCanTruncate() bool {
	if m != nil {
		return m.CanTruncate
	}
	return false
}

func (m *DeleteCtx) GetRef() *ObjectRef {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *DeleteCtx) GetRowIdIdx() int32 {
	if m != nil {
		return m.RowIdIdx
	}
	return 0
}

func (m *DeleteCtx) GetAddAffectedRows() bool {
	if m != nil {
		return m.AddAffectedRows
	}
	return false
}

func (m *DeleteCtx) GetIsClusterTable() bool {
	if m != nil {
		return m.IsClusterTable
	}
	return false
}

func (m *DeleteCtx) GetPartitionTableIds() []uint64 {
	if m != nil {
		return m.PartitionTableIds
	}
	return nil
}

func (m *DeleteCtx) GetPartitionTableNames() []string {
	if m != nil {
		return m.PartitionTableNames
	}
	return nil
}

func (m *DeleteCtx) GetPartitionIdx() int32 {
	if m != nil {
		return m.PartitionIdx
	}
	return 0
}

func (m *DeleteCtx) GetPrimaryKeyIdx() int32 {
	if m != nil {
		return m.PrimaryKeyIdx
	}
	return 0
}

func (m *DeleteCtx) GetTruncateTable() *TruncateTable {
	if m != nil {
		return m.TruncateTable
	}
	return nil
}

func (m *DeleteCtx) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

type Query struct {
	StmtType Query_StatementType `protobuf:"varint,1,opt,name=stmt_type,json=stmtType,proto3,enum=plan.Query_StatementType" json:"stmt_type,omitempty"`
	// Each step is simply a root node.  Root node refers to other
	// node as children and the whole step is a DAG.
	Steps []int32 `protobuf:"varint,2,rep,packed,name=steps,proto3" json:"steps,omitempty"`
	// All the nodes.  It is OK to have dangle nodes, we only excute nodes
	// reachable from step roots.
	Nodes []*Node `protobuf:"bytes,3,rep,name=nodes,proto3" json:"nodes,omitempty"`
	// Bound Parameter for the query.
	Params []*Expr `protobuf:"bytes,4,rep,name=params,proto3" json:"params,omitempty"`
	// return head
	Headings []string `protobuf:"bytes,5,rep,name=headings,proto3" json:"headings,omitempty"`
	// load Tag
	LoadTag bool `protobuf:"varint,6,opt,name=loadTag,proto3" json:"loadTag,omitempty"`
	// detectSqls are sqls detect fk self refer constraint
	DetectSqls           []string `protobuf:"bytes,7,rep,name=detectSqls,proto3" json:"detectSqls,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Query) Reset()         { *m = Query{} }
func (m *Query) String() string { return proto.CompactTextString(m) }
func (*Query) ProtoMessage()    {}
func (*Query) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{68}
}
func (m *Query) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Query) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Query.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Query) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Query.Merge(m, src)
}
func (m *Query) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Query) XXX_DiscardUnknown() {
	xxx_messageInfo_Query.DiscardUnknown(m)
}

var xxx_messageInfo_Query proto.InternalMessageInfo

func (m *Query) GetStmtType() Query_StatementType {
	if m != nil {
		return m.StmtType
	}
	return Query_UNKNOWN
}

func (m *Query) GetSteps() []int32 {
	if m != nil {
		return m.Steps
	}
	return nil
}

func (m *Query) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *Query) GetParams() []*Expr {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *Query) GetHeadings() []string {
	if m != nil {
		return m.Headings
	}
	return nil
}

func (m *Query) GetLoadTag() bool {
	if m != nil {
		return m.LoadTag
	}
	return false
}

func (m *Query) GetDetectSqls() []string {
	if m != nil {
		return m.DetectSqls
	}
	return nil
}

type TransationControl struct {
	// TransationControl type
	TclType TransationControl_TclType `protobuf:"varint,1,opt,name=tcl_type,json=tclType,proto3,enum=plan.TransationControl_TclType" json:"tcl_type,omitempty"`
	// Types that are valid to be assigned to Action:
	//
	//	*TransationControl_Begin
	//	*TransationControl_Commit
	//	*TransationControl_Rollback
	Action               isTransationControl_Action `protobuf_oneof:"action"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *TransationControl) Reset()         { *m = TransationControl{} }
func (m *TransationControl) String() string { return proto.CompactTextString(m) }
func (*TransationControl) ProtoMessage()    {}
func (*TransationControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{69}
}
func (m *TransationControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransationControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransationControl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransationControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransationControl.Merge(m, src)
}
func (m *TransationControl) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransationControl) XXX_DiscardUnknown() {
	xxx_messageInfo_TransationControl.DiscardUnknown(m)
}

var xxx_messageInfo_TransationControl proto.InternalMessageInfo

type isTransationControl_Action interface {
	isTransationControl_Action()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type TransationControl_Begin struct {
	Begin *TransationBegin `protobuf:"bytes,2,opt,name=begin,proto3,oneof" json:"begin,omitempty"`
}
type TransationControl_Commit struct {
	Commit *TransationCommit `protobuf:"bytes,3,opt,name=commit,proto3,oneof" json:"commit,omitempty"`
}
type TransationControl_Rollback struct {
	Rollback *TransationRollback `protobuf:"bytes,4,opt,name=rollback,proto3,oneof" json:"rollback,omitempty"`
}

func (*TransationControl_Begin) isTransationControl_Action()    {}
func (*TransationControl_Commit) isTransationControl_Action()   {}
func (*TransationControl_Rollback) isTransationControl_Action() {}

func (m *TransationControl) GetAction() isTransationControl_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *TransationControl) GetTclType() TransationControl_TclType {
	if m != nil {
		return m.TclType
	}
	return TransationControl_BEGIN
}

func (m *TransationControl) GetBegin() *TransationBegin {
	if x, ok := m.GetAction().(*TransationControl_Begin); ok {
		return x.Begin
	}
	return nil
}

func (m *TransationControl) GetCommit() *TransationCommit {
	if x, ok := m.GetAction().(*TransationControl_Commit); ok {
		return x.Commit
	}
	return nil
}

func (m *TransationControl) GetRollback() *TransationRollback {
	if x, ok := m.GetAction().(*TransationControl_Rollback); ok {
		return x.Rollback
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TransationControl) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TransationControl_Begin)(nil),
		(*TransationControl_Commit)(nil),
		(*TransationControl_Rollback)(nil),
	}
}

type TransationBegin struct {
	Mode                 TransationBegin_TransationMode `protobuf:"varint,1,opt,name=mode,proto3,enum=plan.TransationBegin_TransationMode" json:"mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *TransationBegin) Reset()         { *m = TransationBegin{} }
func (m *TransationBegin) String() string { return proto.CompactTextString(m) }
func (*TransationBegin) ProtoMessage()    {}
func (*TransationBegin) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{70}
}
func (m *TransationBegin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransationBegin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransationBegin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransationBegin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransationBegin.Merge(m, src)
}
func (m *TransationBegin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransationBegin) XXX_DiscardUnknown() {
	xxx_messageInfo_TransationBegin.DiscardUnknown(m)
}

var xxx_messageInfo_TransationBegin proto.InternalMessageInfo

func (m *TransationBegin) GetMode() TransationBegin_TransationMode {
	if m != nil {
		return m.Mode
	}
	return TransationBegin_NONE
}

type TransationCommit struct {
	CompletionType       TransationCompletionType `protobuf:"varint,1,opt,name=completion_type,json=completionType,proto3,enum=plan.TransationCompletionType" json:"completion_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *TransationCommit) Reset()         { *m = TransationCommit{} }
func (m *TransationCommit) String() string { return proto.CompactTextString(m) }
func (*TransationCommit) ProtoMessage()    {}
func (*TransationCommit) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{71}
}
func (m *TransationCommit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransationCommit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransationCommit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransationCommit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransationCommit.Merge(m, src)
}
func (m *TransationCommit) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransationCommit) XXX_DiscardUnknown() {
	xxx_messageInfo_TransationCommit.DiscardUnknown(m)
}

var xxx_messageInfo_TransationCommit proto.InternalMessageInfo

func (m *TransationCommit) GetCompletionType() TransationCompletionType {
	if m != nil {
		return m.CompletionType
	}
	return TransationCompletionType_CHAIN
}

type TransationRollback struct {
	CompletionType       TransationCompletionType `protobuf:"varint,1,opt,name=completion_type,json=completionType,proto3,enum=plan.TransationCompletionType" json:"completion_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *TransationRollback) Reset()         { *m = TransationRollback{} }
func (m *TransationRollback) String() string { return proto.CompactTextString(m) }
func (*TransationRollback) ProtoMessage()    {}
func (*TransationRollback) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{72}
}
func (m *TransationRollback) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransationRollback) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransationRollback.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransationRollback) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransationRollback.Merge(m, src)
}
func (m *TransationRollback) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransationRollback) XXX_DiscardUnknown() {
	xxx_messageInfo_TransationRollback.DiscardUnknown(m)
}

var xxx_messageInfo_TransationRollback proto.InternalMessageInfo

func (m *TransationRollback) GetCompletionType() TransationCompletionType {
	if m != nil {
		return m.CompletionType
	}
	return TransationCompletionType_CHAIN
}

type Plan struct {
	// Types that are valid to be assigned to Plan:
	//
	//	*Plan_Query
	//	*Plan_Tcl
	//	*Plan_Ddl
	//	*Plan_Dcl
	Plan                 isPlan_Plan `protobuf_oneof:"plan"`
	TryRunTimes          int32       `protobuf:"varint,5,opt,name=try_run_times,json=tryRunTimes,proto3" json:"try_run_times,omitempty"`
	IsPrepare            bool        `protobuf:"varint,6,opt,name=is_prepare,json=isPrepare,proto3" json:"is_prepare,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Plan) Reset()         { *m = Plan{} }
func (m *Plan) String() string { return proto.CompactTextString(m) }
func (*Plan) ProtoMessage()    {}
func (*Plan) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{73}
}
func (m *Plan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Plan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Plan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Plan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Plan.Merge(m, src)
}
func (m *Plan) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Plan) XXX_DiscardUnknown() {
	xxx_messageInfo_Plan.DiscardUnknown(m)
}

var xxx_messageInfo_Plan proto.InternalMessageInfo

type isPlan_Plan interface {
	isPlan_Plan()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type Plan_Query struct {
	Query *Query `protobuf:"bytes,1,opt,name=query,proto3,oneof" json:"query,omitempty"`
}
type Plan_Tcl struct {
	Tcl *TransationControl `protobuf:"bytes,2,opt,name=tcl,proto3,oneof" json:"tcl,omitempty"`
}
type Plan_Ddl struct {
	Ddl *DataDefinition `protobuf:"bytes,3,opt,name=ddl,proto3,oneof" json:"ddl,omitempty"`
}
type Plan_Dcl struct {
	Dcl *DataControl `protobuf:"bytes,4,opt,name=dcl,proto3,oneof" json:"dcl,omitempty"`
}

func (*Plan_Query) isPlan_Plan() {}
func (*Plan_Tcl) isPlan_Plan()   {}
func (*Plan_Ddl) isPlan_Plan()   {}
func (*Plan_Dcl) isPlan_Plan()   {}

func (m *Plan) GetPlan() isPlan_Plan {
	if m != nil {
		return m.Plan
	}
	return nil
}

func (m *Plan) GetQuery() *Query {
	if x, ok := m.GetPlan().(*Plan_Query); ok {
		return x.Query
	}
	return nil
}

func (m *Plan) GetTcl() *TransationControl {
	if x, ok := m.GetPlan().(*Plan_Tcl); ok {
		return x.Tcl
	}
	return nil
}

func (m *Plan) GetDdl() *DataDefinition {
	if x, ok := m.GetPlan().(*Plan_Ddl); ok {
		return x.Ddl
	}
	return nil
}

func (m *Plan) GetDcl() *DataControl {
	if x, ok := m.GetPlan().(*Plan_Dcl); ok {
		return x.Dcl
	}
	return nil
}

func (m *Plan) GetTryRunTimes() int32 {
	if m != nil {
		return m.TryRunTimes
	}
	return 0
}

func (m *Plan) GetIsPrepare() bool {
	if m != nil {
		return m.IsPrepare
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Plan) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Plan_Query)(nil),
		(*Plan_Tcl)(nil),
		(*Plan_Ddl)(nil),
		(*Plan_Dcl)(nil),
	}
}

type Column struct {
	Column               []*Expr  `protobuf:"bytes,1,rep,name=column,proto3" json:"column,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Column) Reset()         { *m = Column{} }
func (m *Column) String() string { return proto.CompactTextString(m) }
func (*Column) ProtoMessage()    {}
func (*Column) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{74}
}
func (m *Column) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Column) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Column.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Column) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Column.Merge(m, src)
}
func (m *Column) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Column) XXX_DiscardUnknown() {
	xxx_messageInfo_Column.DiscardUnknown(m)
}

var xxx_messageInfo_Column proto.InternalMessageInfo

func (m *Column) GetColumn() []*Expr {
	if m != nil {
		return m.Column
	}
	return nil
}

type DataControl struct {
	// DataDefinition type
	DclType DataControl_DclType `protobuf:"varint,1,opt,name=dcl_type,json=dclType,proto3,enum=plan.DataControl_DclType" json:"dcl_type,omitempty"`
	// Types that are valid to be assigned to Control:
	//
	//	*DataControl_SetVariables
	//	*DataControl_Prepare
	//	*DataControl_Execute
	//	*DataControl_Deallocate
	//	*DataControl_Other
	Control              isDataControl_Control `protobuf_oneof:"control"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *DataControl) Reset()         { *m = DataControl{} }
func (m *DataControl) String() string { return proto.CompactTextString(m) }
func (*DataControl) ProtoMessage()    {}
func (*DataControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{75}
}
func (m *DataControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataControl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataControl.Merge(m, src)
}
func (m *DataControl) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DataControl) XXX_DiscardUnknown() {
	xxx_messageInfo_DataControl.DiscardUnknown(m)
}

var xxx_messageInfo_DataControl proto.InternalMessageInfo

type isDataControl_Control interface {
	isDataControl_Control()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type DataControl_SetVariables struct {
	SetVariables *SetVariables `protobuf:"bytes,2,opt,name=set_variables,json=setVariables,proto3,oneof" json:"set_variables,omitempty"`
}
type DataControl_Prepare struct {
	Prepare *Prepare `protobuf:"bytes,3,opt,name=prepare,proto3,oneof" json:"prepare,omitempty"`
}
type DataControl_Execute struct {
	Execute *Execute `protobuf:"bytes,4,opt,name=execute,proto3,oneof" json:"execute,omitempty"`
}
type DataControl_Deallocate struct {
	Deallocate *Deallocate `protobuf:"bytes,5,opt,name=deallocate,proto3,oneof" json:"deallocate,omitempty"`
}
type DataControl_Other struct {
	Other *OtherDCL `protobuf:"bytes,6,opt,name=other,proto3,oneof" json:"other,omitempty"`
}

func (*DataControl_SetVariables) isDataControl_Control() {}
func (*DataControl_Prepare) isDataControl_Control()      {}
func (*DataControl_Execute) isDataControl_Control()      {}
func (*DataControl_Deallocate) isDataControl_Control()   {}
func (*DataControl_Other) isDataControl_Control()        {}

func (m *DataControl) GetControl() isDataControl_Control {
	if m != nil {
		return m.Control
	}
	return nil
}

func (m *DataControl) GetDclType() DataControl_DclType {
	if m != nil {
		return m.DclType
	}
	return DataControl_SET_VARIABLES
}

func (m *DataControl) GetSetVariables() *SetVariables {
	if x, ok := m.GetControl().(*DataControl_SetVariables); ok {
		return x.SetVariables
	}
	return nil
}

func (m *DataControl) GetPrepare() *Prepare {
	if x, ok := m.GetControl().(*DataControl_Prepare); ok {
		return x.Prepare
	}
	return nil
}

func (m *DataControl) GetExecute() *Execute {
	if x, ok := m.GetControl().(*DataControl_Execute); ok {
		return x.Execute
	}
	return nil
}

func (m *DataControl) GetDeallocate() *Deallocate {
	if x, ok := m.GetControl().(*DataControl_Deallocate); ok {
		return x.Deallocate
	}
	return nil
}

func (m *DataControl) GetOther() *OtherDCL {
	if x, ok := m.GetControl().(*DataControl_Other); ok {
		return x.Other
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DataControl) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DataControl_SetVariables)(nil),
		(*DataControl_Prepare)(nil),
		(*DataControl_Execute)(nil),
		(*DataControl_Deallocate)(nil),
		(*DataControl_Other)(nil),
	}
}

type DataDefinition struct {
	// DataDefinition type
	DdlType DataDefinition_DdlType `protobuf:"varint,1,opt,name=ddl_type,json=ddlType,proto3,enum=plan.DataDefinition_DdlType" json:"ddl_type,omitempty"`
	// other show statement we will rewrite to a select statement
	// then we will get a Query
	// eg: 'show databases' will rewrite to 'select md.datname as `Database` from mo_database md'
	Query *Query `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// Types that are valid to be assigned to Definition:
	//
	//	*DataDefinition_CreateDatabase
	//	*DataDefinition_AlterDatabase
	//	*DataDefinition_DropDatabase
	//	*DataDefinition_CreateTable
	//	*DataDefinition_AlterTable
	//	*DataDefinition_DropTable
	//	*DataDefinition_CreateIndex
	//	*DataDefinition_AlterIndex
	//	*DataDefinition_DropIndex
	//	*DataDefinition_TruncateTable
	//	*DataDefinition_ShowVariables
	//	*DataDefinition_AlterView
	//	*DataDefinition_LockTables
	//	*DataDefinition_UnlockTables
	//	*DataDefinition_CreateSequence
	//	*DataDefinition_DropSequence
	//	*DataDefinition_AlterSequence
	Definition           isDataDefinition_Definition `protobuf_oneof:"definition"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *DataDefinition) Reset()         { *m = DataDefinition{} }
func (m *DataDefinition) String() string { return proto.CompactTextString(m) }
func (*DataDefinition) ProtoMessage()    {}
func (*DataDefinition) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{76}
}
func (m *DataDefinition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataDefinition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataDefinition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataDefinition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataDefinition.Merge(m, src)
}
func (m *DataDefinition) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DataDefinition) XXX_DiscardUnknown() {
	xxx_messageInfo_DataDefinition.DiscardUnknown(m)
}

var xxx_messageInfo_DataDefinition proto.InternalMessageInfo

type isDataDefinition_Definition interface {
	isDataDefinition_Definition()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type DataDefinition_CreateDatabase struct {
	CreateDatabase *CreateDatabase `protobuf:"bytes,3,opt,name=create_database,json=createDatabase,proto3,oneof" json:"create_database,omitempty"`
}
type DataDefinition_AlterDatabase struct {
	AlterDatabase *AlterDatabase `protobuf:"bytes,4,opt,name=alter_database,json=alterDatabase,proto3,oneof" json:"alter_database,omitempty"`
}
type DataDefinition_DropDatabase struct {
	DropDatabase *DropDatabase `protobuf:"bytes,5,opt,name=drop_database,json=dropDatabase,proto3,oneof" json:"drop_database,omitempty"`
}
type DataDefinition_CreateTable struct {
	CreateTable *CreateTable `protobuf:"bytes,6,opt,name=create_table,json=createTable,proto3,oneof" json:"create_table,omitempty"`
}
type DataDefinition_AlterTable struct {
	AlterTable *AlterTable `protobuf:"bytes,7,opt,name=alter_table,json=alterTable,proto3,oneof" json:"alter_table,omitempty"`
}
type DataDefinition_DropTable struct {
	DropTable *DropTable `protobuf:"bytes,8,opt,name=drop_table,json=dropTable,proto3,oneof" json:"drop_table,omitempty"`
}
type DataDefinition_CreateIndex struct {
	CreateIndex *CreateIndex `protobuf:"bytes,9,opt,name=create_index,json=createIndex,proto3,oneof" json:"create_index,omitempty"`
}
type DataDefinition_AlterIndex struct {
	AlterIndex *AlterIndex `protobuf:"bytes,10,opt,name=alter_index,json=alterIndex,proto3,oneof" json:"alter_index,omitempty"`
}
type DataDefinition_DropIndex struct {
	DropIndex *DropIndex `protobuf:"bytes,11,opt,name=drop_index,json=dropIndex,proto3,oneof" json:"drop_index,omitempty"`
}
type DataDefinition_TruncateTable struct {
	TruncateTable *TruncateTable `protobuf:"bytes,12,opt,name=truncate_table,json=truncateTable,proto3,oneof" json:"truncate_table,omitempty"`
}
type DataDefinition_ShowVariables struct {
	ShowVariables *ShowVariables `protobuf:"bytes,13,opt,name=show_variables,json=showVariables,proto3,oneof" json:"show_variables,omitempty"`
}
type DataDefinition_AlterView struct {
	AlterView *AlterView `protobuf:"bytes,14,opt,name=alter_view,json=alterView,proto3,oneof" json:"alter_view,omitempty"`
}
type DataDefinition_LockTables struct {
	LockTables *LockTables `protobuf:"bytes,15,opt,name=lock_tables,json=lockTables,proto3,oneof" json:"lock_tables,omitempty"`
}
type DataDefinition_UnlockTables struct {
	UnlockTables *UnLockTables `protobuf:"bytes,16,opt,name=unlock_tables,json=unlockTables,proto3,oneof" json:"unlock_tables,omitempty"`
}
type DataDefinition_CreateSequence struct {
	CreateSequence *CreateSequence `protobuf:"bytes,17,opt,name=create_sequence,json=createSequence,proto3,oneof" json:"create_sequence,omitempty"`
}
type DataDefinition_DropSequence struct {
	DropSequence *DropSequence `protobuf:"bytes,18,opt,name=drop_sequence,json=dropSequence,proto3,oneof" json:"drop_sequence,omitempty"`
}
type DataDefinition_AlterSequence struct {
	AlterSequence *AlterSequence `protobuf:"bytes,19,opt,name=alter_sequence,json=alterSequence,proto3,oneof" json:"alter_sequence,omitempty"`
}

func (*DataDefinition_CreateDatabase) isDataDefinition_Definition() {}
func (*DataDefinition_AlterDatabase) isDataDefinition_Definition()  {}
func (*DataDefinition_DropDatabase) isDataDefinition_Definition()   {}
func (*DataDefinition_CreateTable) isDataDefinition_Definition()    {}
func (*DataDefinition_AlterTable) isDataDefinition_Definition()     {}
func (*DataDefinition_DropTable) isDataDefinition_Definition()      {}
func (*DataDefinition_CreateIndex) isDataDefinition_Definition()    {}
func (*DataDefinition_AlterIndex) isDataDefinition_Definition()     {}
func (*DataDefinition_DropIndex) isDataDefinition_Definition()      {}
func (*DataDefinition_TruncateTable) isDataDefinition_Definition()  {}
func (*DataDefinition_ShowVariables) isDataDefinition_Definition()  {}
func (*DataDefinition_AlterView) isDataDefinition_Definition()      {}
func (*DataDefinition_LockTables) isDataDefinition_Definition()     {}
func (*DataDefinition_UnlockTables) isDataDefinition_Definition()   {}
func (*DataDefinition_CreateSequence) isDataDefinition_Definition() {}
func (*DataDefinition_DropSequence) isDataDefinition_Definition()   {}
func (*DataDefinition_AlterSequence) isDataDefinition_Definition()  {}

func (m *DataDefinition) GetDefinition() isDataDefinition_Definition {
	if m != nil {
		return m.Definition
	}
	return nil
}

func (m *DataDefinition) GetDdlType() DataDefinition_DdlType {
	if m != nil {
		return m.DdlType
	}
	return DataDefinition_CREATE_DATABASE
}

func (m *DataDefinition) GetQuery() *Query {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *DataDefinition) GetCreateDatabase() *CreateDatabase {
	if x, ok := m.GetDefinition().(*DataDefinition_CreateDatabase); ok {
		return x.CreateDatabase
	}
	return nil
}

func (m *DataDefinition) GetAlterDatabase() *AlterDatabase {
	if x, ok := m.GetDefinition().(*DataDefinition_AlterDatabase); ok {
		return x.AlterDatabase
	}
	return nil
}

func (m *DataDefinition) GetDropDatabase() *DropDatabase {
	if x, ok := m.GetDefinition().(*DataDefinition_DropDatabase); ok {
		return x.DropDatabase
	}
	return nil
}

func (m *DataDefinition) GetCreateTable() *CreateTable {
	if x, ok := m.GetDefinition().(*DataDefinition_CreateTable); ok {
		return x.CreateTable
	}
	return nil
}

func (m *DataDefinition) GetAlterTable() *AlterTable {
	if x, ok := m.GetDefinition().(*DataDefinition_AlterTable); ok {
		return x.AlterTable
	}
	return nil
}

func (m *DataDefinition) GetDropTable() *DropTable {
	if x, ok := m.GetDefinition().(*DataDefinition_DropTable); ok {
		return x.DropTable
	}
	return nil
}

func (m *DataDefinition) GetCreateIndex() *CreateIndex {
	if x, ok := m.GetDefinition().(*DataDefinition_CreateIndex); ok {
		return x.CreateIndex
	}
	return nil
}

func (m *DataDefinition) GetAlterIndex() *AlterIndex {
	if x, ok := m.GetDefinition().(*DataDefinition_AlterIndex); ok {
		return x.AlterIndex
	}
	return nil
}

func (m *DataDefinition) GetDropIndex() *DropIndex {
	if x, ok := m.GetDefinition().(*DataDefinition_DropIndex); ok {
		return x.DropIndex
	}
	return nil
}

func (m *DataDefinition) GetTruncateTable() *TruncateTable {
	if x, ok := m.GetDefinition().(*DataDefinition_TruncateTable); ok {
		return x.TruncateTable
	}
	return nil
}

func (m *DataDefinition) GetShowVariables() *ShowVariables {
	if x, ok := m.GetDefinition().(*DataDefinition_ShowVariables); ok {
		return x.ShowVariables
	}
	return nil
}

func (m *DataDefinition) GetAlterView() *AlterView {
	if x, ok := m.GetDefinition().(*DataDefinition_AlterView); ok {
		return x.AlterView
	}
	return nil
}

func (m *DataDefinition) GetLockTables() *LockTables {
	if x, ok := m.GetDefinition().(*DataDefinition_LockTables); ok {
		return x.LockTables
	}
	return nil
}

func (m *DataDefinition) GetUnlockTables() *UnLockTables {
	if x, ok := m.GetDefinition().(*DataDefinition_UnlockTables); ok {
		return x.UnlockTables
	}
	return nil
}

func (m *DataDefinition) GetCreateSequence() *CreateSequence {
	if x, ok := m.GetDefinition().(*DataDefinition_CreateSequence); ok {
		return x.CreateSequence
	}
	return nil
}

func (m *DataDefinition) GetDropSequence() *DropSequence {
	if x, ok := m.GetDefinition().(*DataDefinition_DropSequence); ok {
		return x.DropSequence
	}
	return nil
}

func (m *DataDefinition) GetAlterSequence() *AlterSequence {
	if x, ok := m.GetDefinition().(*DataDefinition_AlterSequence); ok {
		return x.AlterSequence
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DataDefinition) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DataDefinition_CreateDatabase)(nil),
		(*DataDefinition_AlterDatabase)(nil),
		(*DataDefinition_DropDatabase)(nil),
		(*DataDefinition_CreateTable)(nil),
		(*DataDefinition_AlterTable)(nil),
		(*DataDefinition_DropTable)(nil),
		(*DataDefinition_CreateIndex)(nil),
		(*DataDefinition_AlterIndex)(nil),
		(*DataDefinition_DropIndex)(nil),
		(*DataDefinition_TruncateTable)(nil),
		(*DataDefinition_ShowVariables)(nil),
		(*DataDefinition_AlterView)(nil),
		(*DataDefinition_LockTables)(nil),
		(*DataDefinition_UnlockTables)(nil),
		(*DataDefinition_CreateSequence)(nil),
		(*DataDefinition_DropSequence)(nil),
		(*DataDefinition_AlterSequence)(nil),
	}
}

type SubscriptionOption struct {
	From                 string   `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	Publication          string   `protobuf:"bytes,2,opt,name=publication,proto3" json:"publication,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscriptionOption) Reset()         { *m = SubscriptionOption{} }
func (m *SubscriptionOption) String() string { return proto.CompactTextString(m) }
func (*SubscriptionOption) ProtoMessage()    {}
func (*SubscriptionOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{77}
}
func (m *SubscriptionOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscriptionOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscriptionOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscriptionOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriptionOption.Merge(m, src)
}
func (m *SubscriptionOption) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SubscriptionOption) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriptionOption.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriptionOption proto.InternalMessageInfo

func (m *SubscriptionOption) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *SubscriptionOption) GetPublication() string {
	if m != nil {
		return m.Publication
	}
	return ""
}

type CreateDatabase struct {
	IfNotExists          bool                `protobuf:"varint,1,opt,name=if_not_exists,json=ifNotExists,proto3" json:"if_not_exists,omitempty"`
	Database             string              `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	SubscriptionOption   *SubscriptionOption `protobuf:"bytes,3,opt,name=subscription_option,json=subscriptionOption,proto3" json:"subscription_option,omitempty"`
	Sql                  string              `protobuf:"bytes,4,opt,name=sql,proto3" json:"sql,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *CreateDatabase) Reset()         { *m = CreateDatabase{} }
func (m *CreateDatabase) String() string { return proto.CompactTextString(m) }
func (*CreateDatabase) ProtoMessage()    {}
func (*CreateDatabase) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{78}
}
func (m *CreateDatabase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateDatabase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateDatabase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateDatabase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateDatabase.Merge(m, src)
}
func (m *CreateDatabase) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CreateDatabase) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateDatabase.DiscardUnknown(m)
}

var xxx_messageInfo_CreateDatabase proto.InternalMessageInfo

func (m *CreateDatabase) GetIfNotExists() bool {
	if m != nil {
		return m.IfNotExists
	}
	return false
}

func (m *CreateDatabase) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *CreateDatabase) GetSubscriptionOption() *SubscriptionOption {
	if m != nil {
		return m.SubscriptionOption
	}
	return nil
}

func (m *CreateDatabase) GetSql() string {
	if m != nil {
		return m.Sql
	}
	return ""
}

type AlterDatabase struct {
	IfExists             bool     `protobuf:"varint,1,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	Database             string   `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterDatabase) Reset()         { *m = AlterDatabase{} }
func (m *AlterDatabase) String() string { return proto.CompactTextString(m) }
func (*AlterDatabase) ProtoMessage()    {}
func (*AlterDatabase) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{79}
}
func (m *AlterDatabase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterDatabase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterDatabase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterDatabase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterDatabase.Merge(m, src)
}
func (m *AlterDatabase) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterDatabase) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterDatabase.DiscardUnknown(m)
}

var xxx_messageInfo_AlterDatabase proto.InternalMessageInfo

func (m *AlterDatabase) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

func (m *AlterDatabase) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

type DropDatabase struct {
	IfExists   bool   `protobuf:"varint,1,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	Database   string `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	DatabaseId uint64 `protobuf:"varint,3,opt,name=database_id,json=databaseId,proto3" json:"database_id,omitempty"`
	// drop database should delete fk records related to this database
	// from mo_foreign_keys
	UpdateFkSql string `protobuf:"bytes,4,opt,name=updateFkSql,proto3" json:"updateFkSql,omitempty"`
	// drop database should check mo_foreign_keys to find fk records
	// that refer to this database before dropping the database
	CheckFKSql           string   `protobuf:"bytes,5,opt,name=checkFKSql,proto3" json:"checkFKSql,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DropDatabase) Reset()         { *m = DropDatabase{} }
func (m *DropDatabase) String() string { return proto.CompactTextString(m) }
func (*DropDatabase) ProtoMessage()    {}
func (*DropDatabase) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{80}
}
func (m *DropDatabase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropDatabase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropDatabase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropDatabase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropDatabase.Merge(m, src)
}
func (m *DropDatabase) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DropDatabase) XXX_DiscardUnknown() {
	xxx_messageInfo_DropDatabase.DiscardUnknown(m)
}

var xxx_messageInfo_DropDatabase proto.InternalMessageInfo

func (m *DropDatabase) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

func (m *DropDatabase) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *DropDatabase) GetDatabaseId() uint64 {
	if m != nil {
		return m.DatabaseId
	}
	return 0
}

func (m *DropDatabase) GetUpdateFkSql() string {
	if m != nil {
		return m.UpdateFkSql
	}
	return ""
}

func (m *DropDatabase) GetCheckFKSql() string {
	if m != nil {
		return m.CheckFKSql
	}
	return ""
}

type FkColName struct {
	Cols                 []string `protobuf:"bytes,1,rep,name=cols,proto3" json:"cols,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FkColName) Reset()         { *m = FkColName{} }
func (m *FkColName) String() string { return proto.CompactTextString(m) }
func (*FkColName) ProtoMessage()    {}
func (*FkColName) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{81}
}
func (m *FkColName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FkColName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FkColName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FkColName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FkColName.Merge(m, src)
}
func (m *FkColName) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FkColName) XXX_DiscardUnknown() {
	xxx_messageInfo_FkColName.DiscardUnknown(m)
}

var xxx_messageInfo_FkColName proto.InternalMessageInfo

func (m *FkColName) GetCols() []string {
	if m != nil {
		return m.Cols
	}
	return nil
}

// ForeignKeyInfo holds the fk forward reference.
//
// Example: t2(b) --fk--> t1(a) but t1 defined after t2
//
// set foreign_key_checks=0;
//
// create table t2(b int, constraint c1 foreign key (b) references t1(a));
//
// create table t1(a int primary key);
//
// The reason we need ForeignKeyInfo instead of using ForeignKeyDef is that:
//
// ForeignKeyDef only has table id, column id that does not exist in handling fk forward reference.
// ForeignKeyDef does not have database name, table name and column names,
// ForeignKeyInfo also has the ForeignKeyDef internally that holds the child table fk definition.
type ForeignKeyInfo struct {
	Db                   string         `protobuf:"bytes,1,opt,name=db,proto3" json:"db,omitempty"`
	Table                string         `protobuf:"bytes,2,opt,name=table,proto3" json:"table,omitempty"`
	Cols                 *FkColName     `protobuf:"bytes,3,opt,name=cols,proto3" json:"cols,omitempty"`
	ColsReferred         *FkColName     `protobuf:"bytes,4,opt,name=colsReferred,proto3" json:"colsReferred,omitempty"`
	Def                  *ForeignKeyDef `protobuf:"bytes,5,opt,name=def,proto3" json:"def,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ForeignKeyInfo) Reset()         { *m = ForeignKeyInfo{} }
func (m *ForeignKeyInfo) String() string { return proto.CompactTextString(m) }
func (*ForeignKeyInfo) ProtoMessage()    {}
func (*ForeignKeyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{82}
}
func (m *ForeignKeyInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForeignKeyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ForeignKeyInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ForeignKeyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForeignKeyInfo.Merge(m, src)
}
func (m *ForeignKeyInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ForeignKeyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ForeignKeyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ForeignKeyInfo proto.InternalMessageInfo

func (m *ForeignKeyInfo) GetDb() string {
	if m != nil {
		return m.Db
	}
	return ""
}

func (m *ForeignKeyInfo) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *ForeignKeyInfo) GetCols() *FkColName {
	if m != nil {
		return m.Cols
	}
	return nil
}

func (m *ForeignKeyInfo) GetColsReferred() *FkColName {
	if m != nil {
		return m.ColsReferred
	}
	return nil
}

func (m *ForeignKeyInfo) GetDef() *ForeignKeyDef {
	if m != nil {
		return m.Def
	}
	return nil
}

type CreateTable struct {
	IfNotExists bool        `protobuf:"varint,1,opt,name=if_not_exists,json=ifNotExists,proto3" json:"if_not_exists,omitempty"`
	Temporary   bool        `protobuf:"varint,2,opt,name=temporary,proto3" json:"temporary,omitempty"`
	Database    string      `protobuf:"bytes,3,opt,name=database,proto3" json:"database,omitempty"`
	Replace     bool        `protobuf:"varint,4,opt,name=replace,proto3" json:"replace,omitempty"`
	TableDef    *TableDef   `protobuf:"bytes,5,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	IndexTables []*TableDef `protobuf:"bytes,6,rep,name=index_tables,json=indexTables,proto3" json:"index_tables,omitempty"`
	// we need the db/table name of foreign key when create table. but we don't need it in ForeignKeyDef
	FkDbs    []string `protobuf:"bytes,7,rep,name=fk_dbs,json=fkDbs,proto3" json:"fk_dbs,omitempty"`
	FkTables []string `protobuf:"bytes,8,rep,name=fk_tables,json=fkTables,proto3" json:"fk_tables,omitempty"`
	// we need column name when create table, but not in ForeignKeyDef
	FkCols            []*FkColName `protobuf:"bytes,9,rep,name=fk_cols,json=fkCols,proto3" json:"fk_cols,omitempty"`
	PartitionTables   []*TableDef  `protobuf:"bytes,10,rep,name=partition_tables,json=partitionTables,proto3" json:"partition_tables,omitempty"`
	CreateAsSelectSql string       `protobuf:"bytes,11,opt,name=create_as_select_sql,json=createAsSelectSql,proto3" json:"create_as_select_sql,omitempty"`
	// create table may insert fk records related to this table
	// into mo_foreign_keys
	UpdateFkSqls []string `protobuf:"bytes,12,rep,name=updateFkSqls,proto3" json:"updateFkSqls,omitempty"`
	// fks forward reference to me
	FksReferToMe         []*ForeignKeyInfo `protobuf:"bytes,13,rep,name=fksReferToMe,proto3" json:"fksReferToMe,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *CreateTable) Reset()         { *m = CreateTable{} }
func (m *CreateTable) String() string { return proto.CompactTextString(m) }
func (*CreateTable) ProtoMessage()    {}
func (*CreateTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{83}
}
func (m *CreateTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateTable.Merge(m, src)
}
func (m *CreateTable) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CreateTable) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateTable.DiscardUnknown(m)
}

var xxx_messageInfo_CreateTable proto.InternalMessageInfo

func (m *CreateTable) GetIfNotExists() bool {
	if m != nil {
		return m.IfNotExists
	}
	return false
}

func (m *CreateTable) GetTemporary() bool {
	if m != nil {
		return m.Temporary
	}
	return false
}

func (m *CreateTable) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *CreateTable) GetReplace() bool {
	if m != nil {
		return m.Replace
	}
	return false
}

func (m *CreateTable) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *CreateTable) GetIndexTables() []*TableDef {
	if m != nil {
		return m.IndexTables
	}
	return nil
}

func (m *CreateTable) GetFkDbs() []string {
	if m != nil {
		return m.FkDbs
	}
	return nil
}

func (m *CreateTable) GetFkTables() []string {
	if m != nil {
		return m.FkTables
	}
	return nil
}

func (m *CreateTable) GetFkCols() []*FkColName {
	if m != nil {
		return m.FkCols
	}
	return nil
}

func (m *CreateTable) GetPartitionTables() []*TableDef {
	if m != nil {
		return m.PartitionTables
	}
	return nil
}

func (m *CreateTable) GetCreateAsSelectSql() string {
	if m != nil {
		return m.CreateAsSelectSql
	}
	return ""
}

func (m *CreateTable) GetUpdateFkSqls() []string {
	if m != nil {
		return m.UpdateFkSqls
	}
	return nil
}

func (m *CreateTable) GetFksReferToMe() []*ForeignKeyInfo {
	if m != nil {
		return m.FksReferToMe
	}
	return nil
}

type AlterTableDrop struct {
	Typ                  AlterTableDrop_Typ `protobuf:"varint,1,opt,name=typ,proto3,enum=plan.AlterTableDrop_Typ" json:"typ,omitempty"`
	Name                 string             `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	IndexTableName       string             `protobuf:"bytes,3,opt,name=index_table_name,json=indexTableName,proto3" json:"index_table_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *AlterTableDrop) Reset()         { *m = AlterTableDrop{} }
func (m *AlterTableDrop) String() string { return proto.CompactTextString(m) }
func (*AlterTableDrop) ProtoMessage()    {}
func (*AlterTableDrop) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{84}
}
func (m *AlterTableDrop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTableDrop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTableDrop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTableDrop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTableDrop.Merge(m, src)
}
func (m *AlterTableDrop) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTableDrop) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTableDrop.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTableDrop proto.InternalMessageInfo

func (m *AlterTableDrop) GetTyp() AlterTableDrop_Typ {
	if m != nil {
		return m.Typ
	}
	return AlterTableDrop_COLUMN
}

func (m *AlterTableDrop) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AlterTableDrop) GetIndexTableName() string {
	if m != nil {
		return m.IndexTableName
	}
	return ""
}

type AlterTableAddFk struct {
	DbName               string         `protobuf:"bytes,1,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	TableName            string         `protobuf:"bytes,2,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	Cols                 []string       `protobuf:"bytes,3,rep,name=cols,proto3" json:"cols,omitempty"`
	Fkey                 *ForeignKeyDef `protobuf:"bytes,4,opt,name=fkey,proto3" json:"fkey,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *AlterTableAddFk) Reset()         { *m = AlterTableAddFk{} }
func (m *AlterTableAddFk) String() string { return proto.CompactTextString(m) }
func (*AlterTableAddFk) ProtoMessage()    {}
func (*AlterTableAddFk) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{85}
}
func (m *AlterTableAddFk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTableAddFk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTableAddFk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTableAddFk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTableAddFk.Merge(m, src)
}
func (m *AlterTableAddFk) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTableAddFk) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTableAddFk.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTableAddFk proto.InternalMessageInfo

func (m *AlterTableAddFk) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *AlterTableAddFk) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *AlterTableAddFk) GetCols() []string {
	if m != nil {
		return m.Cols
	}
	return nil
}

func (m *AlterTableAddFk) GetFkey() *ForeignKeyDef {
	if m != nil {
		return m.Fkey
	}
	return nil
}

type AlterTableAddIndex struct {
	DbName                string       `protobuf:"bytes,1,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	TableName             string       `protobuf:"bytes,2,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	OriginTablePrimaryKey string       `protobuf:"bytes,3,opt,name=origin_table_primary_key,json=originTablePrimaryKey,proto3" json:"origin_table_primary_key,omitempty"`
	IndexInfo             *CreateTable `protobuf:"bytes,4,opt,name=indexInfo,proto3" json:"indexInfo,omitempty"`
	IndexTableExist       bool         `protobuf:"varint,5,opt,name=index_table_exist,json=indexTableExist,proto3" json:"index_table_exist,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}     `json:"-"`
	XXX_unrecognized      []byte       `json:"-"`
	XXX_sizecache         int32        `json:"-"`
}

func (m *AlterTableAddIndex) Reset()         { *m = AlterTableAddIndex{} }
func (m *AlterTableAddIndex) String() string { return proto.CompactTextString(m) }
func (*AlterTableAddIndex) ProtoMessage()    {}
func (*AlterTableAddIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{86}
}
func (m *AlterTableAddIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTableAddIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTableAddIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTableAddIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTableAddIndex.Merge(m, src)
}
func (m *AlterTableAddIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTableAddIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTableAddIndex.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTableAddIndex proto.InternalMessageInfo

func (m *AlterTableAddIndex) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *AlterTableAddIndex) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *AlterTableAddIndex) GetOriginTablePrimaryKey() string {
	if m != nil {
		return m.OriginTablePrimaryKey
	}
	return ""
}

func (m *AlterTableAddIndex) GetIndexInfo() *CreateTable {
	if m != nil {
		return m.IndexInfo
	}
	return nil
}

func (m *AlterTableAddIndex) GetIndexTableExist() bool {
	if m != nil {
		return m.IndexTableExist
	}
	return false
}

type AlterTableDropIndex struct {
	DbName               string   `protobuf:"bytes,1,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	TableName            string   `protobuf:"bytes,2,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	IndexName            string   `protobuf:"bytes,3,opt,name=index_name,json=indexName,proto3" json:"index_name,omitempty"`
	IndexTableName       string   `protobuf:"bytes,4,opt,name=index_table_name,json=indexTableName,proto3" json:"index_table_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterTableDropIndex) Reset()         { *m = AlterTableDropIndex{} }
func (m *AlterTableDropIndex) String() string { return proto.CompactTextString(m) }
func (*AlterTableDropIndex) ProtoMessage()    {}
func (*AlterTableDropIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{87}
}
func (m *AlterTableDropIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTableDropIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTableDropIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTableDropIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTableDropIndex.Merge(m, src)
}
func (m *AlterTableDropIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTableDropIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTableDropIndex.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTableDropIndex proto.InternalMessageInfo

func (m *AlterTableDropIndex) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *AlterTableDropIndex) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *AlterTableDropIndex) GetIndexName() string {
	if m != nil {
		return m.IndexName
	}
	return ""
}

func (m *AlterTableDropIndex) GetIndexTableName() string {
	if m != nil {
		return m.IndexTableName
	}
	return ""
}

type AlterTableAlterIndex struct {
	DbName               string   `protobuf:"bytes,1,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	TableName            string   `protobuf:"bytes,2,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	IndexName            string   `protobuf:"bytes,3,opt,name=index_name,json=indexName,proto3" json:"index_name,omitempty"`
	Visible              bool     `protobuf:"varint,4,opt,name=visible,proto3" json:"visible,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterTableAlterIndex) Reset()         { *m = AlterTableAlterIndex{} }
func (m *AlterTableAlterIndex) String() string { return proto.CompactTextString(m) }
func (*AlterTableAlterIndex) ProtoMessage()    {}
func (*AlterTableAlterIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{88}
}
func (m *AlterTableAlterIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTableAlterIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTableAlterIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTableAlterIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTableAlterIndex.Merge(m, src)
}
func (m *AlterTableAlterIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTableAlterIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTableAlterIndex.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTableAlterIndex proto.InternalMessageInfo

func (m *AlterTableAlterIndex) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *AlterTableAlterIndex) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *AlterTableAlterIndex) GetIndexName() string {
	if m != nil {
		return m.IndexName
	}
	return ""
}

func (m *AlterTableAlterIndex) GetVisible() bool {
	if m != nil {
		return m.Visible
	}
	return false
}

type AlterTableAlterReIndex struct {
	DbName               string   `protobuf:"bytes,1,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	TableName            string   `protobuf:"bytes,2,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	IndexName            string   `protobuf:"bytes,3,opt,name=index_name,json=indexName,proto3" json:"index_name,omitempty"`
	IndexAlgoParamList   int64    `protobuf:"varint,4,opt,name=index_algo_param_list,json=indexAlgoParamList,proto3" json:"index_algo_param_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterTableAlterReIndex) Reset()         { *m = AlterTableAlterReIndex{} }
func (m *AlterTableAlterReIndex) String() string { return proto.CompactTextString(m) }
func (*AlterTableAlterReIndex) ProtoMessage()    {}
func (*AlterTableAlterReIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{89}
}
func (m *AlterTableAlterReIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTableAlterReIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTableAlterReIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTableAlterReIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTableAlterReIndex.Merge(m, src)
}
func (m *AlterTableAlterReIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTableAlterReIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTableAlterReIndex.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTableAlterReIndex proto.InternalMessageInfo

func (m *AlterTableAlterReIndex) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *AlterTableAlterReIndex) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *AlterTableAlterReIndex) GetIndexName() string {
	if m != nil {
		return m.IndexName
	}
	return ""
}

func (m *AlterTableAlterReIndex) GetIndexAlgoParamList() int64 {
	if m != nil {
		return m.IndexAlgoParamList
	}
	return 0
}

type AlterTableAddPartition struct {
	Definitions          []*PartitionItem `protobuf:"bytes,1,rep,name=definitions,proto3" json:"definitions,omitempty"`
	PartitionTables      []*TableDef      `protobuf:"bytes,2,rep,name=partition_tables,json=partitionTables,proto3" json:"partition_tables,omitempty"`
	PartitionDef         *PartitionByDef  `protobuf:"bytes,3,opt,name=PartitionDef,proto3" json:"PartitionDef,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *AlterTableAddPartition) Reset()         { *m = AlterTableAddPartition{} }
func (m *AlterTableAddPartition) String() string { return proto.CompactTextString(m) }
func (*AlterTableAddPartition) ProtoMessage()    {}
func (*AlterTableAddPartition) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{90}
}
func (m *AlterTableAddPartition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTableAddPartition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTableAddPartition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTableAddPartition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTableAddPartition.Merge(m, src)
}
func (m *AlterTableAddPartition) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTableAddPartition) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTableAddPartition.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTableAddPartition proto.InternalMessageInfo

func (m *AlterTableAddPartition) GetDefinitions() []*PartitionItem {
	if m != nil {
		return m.Definitions
	}
	return nil
}

func (m *AlterTableAddPartition) GetPartitionTables() []*TableDef {
	if m != nil {
		return m.PartitionTables
	}
	return nil
}

func (m *AlterTableAddPartition) GetPartitionDef() *PartitionByDef {
	if m != nil {
		return m.PartitionDef
	}
	return nil
}

type AlterTableComment struct {
	NewComment           string   `protobuf:"bytes,1,opt,name=new_comment,json=newComment,proto3" json:"new_comment,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterTableComment) Reset()         { *m = AlterTableComment{} }
func (m *AlterTableComment) String() string { return proto.CompactTextString(m) }
func (*AlterTableComment) ProtoMessage()    {}
func (*AlterTableComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{91}
}
func (m *AlterTableComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTableComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTableComment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTableComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTableComment.Merge(m, src)
}
func (m *AlterTableComment) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTableComment) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTableComment.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTableComment proto.InternalMessageInfo

func (m *AlterTableComment) GetNewComment() string {
	if m != nil {
		return m.NewComment
	}
	return ""
}

type AlterTableName struct {
	OldName              string   `protobuf:"bytes,1,opt,name=old_name,json=oldName,proto3" json:"old_name,omitempty"`
	NewName              string   `protobuf:"bytes,2,opt,name=new_name,json=newName,proto3" json:"new_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterTableName) Reset()         { *m = AlterTableName{} }
func (m *AlterTableName) String() string { return proto.CompactTextString(m) }
func (*AlterTableName) ProtoMessage()    {}
func (*AlterTableName) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{92}
}
func (m *AlterTableName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTableName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTableName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTableName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTableName.Merge(m, src)
}
func (m *AlterTableName) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTableName) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTableName.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTableName proto.InternalMessageInfo

func (m *AlterTableName) GetOldName() string {
	if m != nil {
		return m.OldName
	}
	return ""
}

func (m *AlterTableName) GetNewName() string {
	if m != nil {
		return m.NewName
	}
	return ""
}

type AlterAddColumn struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	PreName              string   `protobuf:"bytes,2,opt,name=pre_name,json=preName,proto3" json:"pre_name,omitempty"`
	Type                 Type     `protobuf:"bytes,3,opt,name=type,proto3" json:"type"`
	Pos                  int32    `protobuf:"varint,4,opt,name=pos,proto3" json:"pos,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterAddColumn) Reset()         { *m = AlterAddColumn{} }
func (m *AlterAddColumn) String() string { return proto.CompactTextString(m) }
func (*AlterAddColumn) ProtoMessage()    {}
func (*AlterAddColumn) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{93}
}
func (m *AlterAddColumn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterAddColumn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterAddColumn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterAddColumn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterAddColumn.Merge(m, src)
}
func (m *AlterAddColumn) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterAddColumn) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterAddColumn.DiscardUnknown(m)
}

var xxx_messageInfo_AlterAddColumn proto.InternalMessageInfo

func (m *AlterAddColumn) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AlterAddColumn) GetPreName() string {
	if m != nil {
		return m.PreName
	}
	return ""
}

func (m *AlterAddColumn) GetType() Type {
	if m != nil {
		return m.Type
	}
	return Type{}
}

func (m *AlterAddColumn) GetPos() int32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

type AlterDropColumn struct {
	Idx                  uint32   `protobuf:"varint,1,opt,name=idx,proto3" json:"idx,omitempty"`
	Seq                  uint32   `protobuf:"varint,2,opt,name=seq,proto3" json:"seq,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterDropColumn) Reset()         { *m = AlterDropColumn{} }
func (m *AlterDropColumn) String() string { return proto.CompactTextString(m) }
func (*AlterDropColumn) ProtoMessage()    {}
func (*AlterDropColumn) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{94}
}
func (m *AlterDropColumn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterDropColumn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterDropColumn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterDropColumn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterDropColumn.Merge(m, src)
}
func (m *AlterDropColumn) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterDropColumn) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterDropColumn.DiscardUnknown(m)
}

var xxx_messageInfo_AlterDropColumn proto.InternalMessageInfo

func (m *AlterDropColumn) GetIdx() uint32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *AlterDropColumn) GetSeq() uint32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

type AlterTable struct {
	Database          string                   `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	TableDef          *TableDef                `protobuf:"bytes,2,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	CopyTableDef      *TableDef                `protobuf:"bytes,3,opt,name=copy_table_def,json=copyTableDef,proto3" json:"copy_table_def,omitempty"`
	IsClusterTable    bool                     `protobuf:"varint,4,opt,name=is_cluster_table,json=isClusterTable,proto3" json:"is_cluster_table,omitempty"`
	Actions           []*AlterTable_Action     `protobuf:"bytes,5,rep,name=actions,proto3" json:"actions,omitempty"`
	AlgorithmType     AlterTable_AlgorithmType `protobuf:"varint,6,opt,name=algorithm_type,json=algorithmType,proto3,enum=plan.AlterTable_AlgorithmType" json:"algorithm_type,omitempty"`
	CreateTmpTableSql string                   `protobuf:"bytes,7,opt,name=create_tmp_table_sql,json=createTmpTableSql,proto3" json:"create_tmp_table_sql,omitempty"`
	InsertTmpDataSql  string                   `protobuf:"bytes,8,opt,name=insert_tmp_data_sql,json=insertTmpDataSql,proto3" json:"insert_tmp_data_sql,omitempty"`
	CreateTableSql    string                   `protobuf:"bytes,9,opt,name=create_table_sql,json=createTableSql,proto3" json:"create_table_sql,omitempty"`
	InsertDataSql     string                   `protobuf:"bytes,10,opt,name=insert_data_sql,json=insertDataSql,proto3" json:"insert_data_sql,omitempty"`
	ChangeTblColIdMap map[uint64]*ColDef       `protobuf:"bytes,11,rep,name=change_tbl_colId_map,json=changeTblColIdMap,proto3" json:"change_tbl_colId_map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// detect fk self refer constraint
	DetectSqls []string `protobuf:"bytes,12,rep,name=detectSqls,proto3" json:"detectSqls,omitempty"`
	// alter table may insert fk records related to this table
	// into mo_foreign_keys
	UpdateFkSqls         []string `protobuf:"bytes,13,rep,name=updateFkSqls,proto3" json:"updateFkSqls,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterTable) Reset()         { *m = AlterTable{} }
func (m *AlterTable) String() string { return proto.CompactTextString(m) }
func (*AlterTable) ProtoMessage()    {}
func (*AlterTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{95}
}
func (m *AlterTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTable.Merge(m, src)
}
func (m *AlterTable) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTable) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTable.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTable proto.InternalMessageInfo

func (m *AlterTable) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *AlterTable) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *AlterTable) GetCopyTableDef() *TableDef {
	if m != nil {
		return m.CopyTableDef
	}
	return nil
}

func (m *AlterTable) GetIsClusterTable() bool {
	if m != nil {
		return m.IsClusterTable
	}
	return false
}

func (m *AlterTable) GetActions() []*AlterTable_Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *AlterTable) GetAlgorithmType() AlterTable_AlgorithmType {
	if m != nil {
		return m.AlgorithmType
	}
	return AlterTable_DEFAULT
}

func (m *AlterTable) GetCreateTmpTableSql() string {
	if m != nil {
		return m.CreateTmpTableSql
	}
	return ""
}

func (m *AlterTable) GetInsertTmpDataSql() string {
	if m != nil {
		return m.InsertTmpDataSql
	}
	return ""
}

func (m *AlterTable) GetCreateTableSql() string {
	if m != nil {
		return m.CreateTableSql
	}
	return ""
}

func (m *AlterTable) GetInsertDataSql() string {
	if m != nil {
		return m.InsertDataSql
	}
	return ""
}

func (m *AlterTable) GetChangeTblColIdMap() map[uint64]*ColDef {
	if m != nil {
		return m.ChangeTblColIdMap
	}
	return nil
}

func (m *AlterTable) GetDetectSqls() []string {
	if m != nil {
		return m.DetectSqls
	}
	return nil
}

func (m *AlterTable) GetUpdateFkSqls() []string {
	if m != nil {
		return m.UpdateFkSqls
	}
	return nil
}

type AlterTable_Action struct {
	// Types that are valid to be assigned to Action:
	//
	//	*AlterTable_Action_Drop
	//	*AlterTable_Action_AddFk
	//	*AlterTable_Action_AddIndex
	//	*AlterTable_Action_AlterIndex
	//	*AlterTable_Action_AlterComment
	//	*AlterTable_Action_AlterName
	//	*AlterTable_Action_AddColumn
	//	*AlterTable_Action_DropColumn
	//	*AlterTable_Action_AlterReindex
	//	*AlterTable_Action_AddPartition
	Action               isAlterTable_Action_Action `protobuf_oneof:"action"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *AlterTable_Action) Reset()         { *m = AlterTable_Action{} }
func (m *AlterTable_Action) String() string { return proto.CompactTextString(m) }
func (*AlterTable_Action) ProtoMessage()    {}
func (*AlterTable_Action) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{95, 0}
}
func (m *AlterTable_Action) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTable_Action) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTable_Action.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTable_Action) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTable_Action.Merge(m, src)
}
func (m *AlterTable_Action) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTable_Action) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTable_Action.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTable_Action proto.InternalMessageInfo

type isAlterTable_Action_Action interface {
	isAlterTable_Action_Action()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type AlterTable_Action_Drop struct {
	Drop *AlterTableDrop `protobuf:"bytes,1,opt,name=drop,proto3,oneof" json:"drop,omitempty"`
}
type AlterTable_Action_AddFk struct {
	AddFk *AlterTableAddFk `protobuf:"bytes,2,opt,name=add_fk,json=addFk,proto3,oneof" json:"add_fk,omitempty"`
}
type AlterTable_Action_AddIndex struct {
	AddIndex *AlterTableAddIndex `protobuf:"bytes,3,opt,name=add_index,json=addIndex,proto3,oneof" json:"add_index,omitempty"`
}
type AlterTable_Action_AlterIndex struct {
	AlterIndex *AlterTableAlterIndex `protobuf:"bytes,4,opt,name=alter_index,json=alterIndex,proto3,oneof" json:"alter_index,omitempty"`
}
type AlterTable_Action_AlterComment struct {
	AlterComment *AlterTableComment `protobuf:"bytes,5,opt,name=alter_comment,json=alterComment,proto3,oneof" json:"alter_comment,omitempty"`
}
type AlterTable_Action_AlterName struct {
	AlterName *AlterTableName `protobuf:"bytes,6,opt,name=alter_name,json=alterName,proto3,oneof" json:"alter_name,omitempty"`
}
type AlterTable_Action_AddColumn struct {
	AddColumn *AlterAddColumn `protobuf:"bytes,7,opt,name=add_column,json=addColumn,proto3,oneof" json:"add_column,omitempty"`
}
type AlterTable_Action_DropColumn struct {
	DropColumn *AlterDropColumn `protobuf:"bytes,8,opt,name=drop_column,json=dropColumn,proto3,oneof" json:"drop_column,omitempty"`
}
type AlterTable_Action_AlterReindex struct {
	AlterReindex *AlterTableAlterReIndex `protobuf:"bytes,9,opt,name=alter_reindex,json=alterReindex,proto3,oneof" json:"alter_reindex,omitempty"`
}
type AlterTable_Action_AddPartition struct {
	AddPartition *AlterTableAddPartition `protobuf:"bytes,10,opt,name=addPartition,proto3,oneof" json:"addPartition,omitempty"`
}

func (*AlterTable_Action_Drop) isAlterTable_Action_Action()         {}
func (*AlterTable_Action_AddFk) isAlterTable_Action_Action()        {}
func (*AlterTable_Action_AddIndex) isAlterTable_Action_Action()     {}
func (*AlterTable_Action_AlterIndex) isAlterTable_Action_Action()   {}
func (*AlterTable_Action_AlterComment) isAlterTable_Action_Action() {}
func (*AlterTable_Action_AlterName) isAlterTable_Action_Action()    {}
func (*AlterTable_Action_AddColumn) isAlterTable_Action_Action()    {}
func (*AlterTable_Action_DropColumn) isAlterTable_Action_Action()   {}
func (*AlterTable_Action_AlterReindex) isAlterTable_Action_Action() {}
func (*AlterTable_Action_AddPartition) isAlterTable_Action_Action() {}

func (m *AlterTable_Action) GetAction() isAlterTable_Action_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *AlterTable_Action) GetDrop() *AlterTableDrop {
	if x, ok := m.GetAction().(*AlterTable_Action_Drop); ok {
		return x.Drop
	}
	return nil
}

func (m *AlterTable_Action) GetAddFk() *AlterTableAddFk {
	if x, ok := m.GetAction().(*AlterTable_Action_AddFk); ok {
		return x.AddFk
	}
	return nil
}

func (m *AlterTable_Action) GetAddIndex() *AlterTableAddIndex {
	if x, ok := m.GetAction().(*AlterTable_Action_AddIndex); ok {
		return x.AddIndex
	}
	return nil
}

func (m *AlterTable_Action) GetAlterIndex() *AlterTableAlterIndex {
	if x, ok := m.GetAction().(*AlterTable_Action_AlterIndex); ok {
		return x.AlterIndex
	}
	return nil
}

func (m *AlterTable_Action) GetAlterComment() *AlterTableComment {
	if x, ok := m.GetAction().(*AlterTable_Action_AlterComment); ok {
		return x.AlterComment
	}
	return nil
}

func (m *AlterTable_Action) GetAlterName() *AlterTableName {
	if x, ok := m.GetAction().(*AlterTable_Action_AlterName); ok {
		return x.AlterName
	}
	return nil
}

func (m *AlterTable_Action) GetAddColumn() *AlterAddColumn {
	if x, ok := m.GetAction().(*AlterTable_Action_AddColumn); ok {
		return x.AddColumn
	}
	return nil
}

func (m *AlterTable_Action) GetDropColumn() *AlterDropColumn {
	if x, ok := m.GetAction().(*AlterTable_Action_DropColumn); ok {
		return x.DropColumn
	}
	return nil
}

func (m *AlterTable_Action) GetAlterReindex() *AlterTableAlterReIndex {
	if x, ok := m.GetAction().(*AlterTable_Action_AlterReindex); ok {
		return x.AlterReindex
	}
	return nil
}

func (m *AlterTable_Action) GetAddPartition() *AlterTableAddPartition {
	if x, ok := m.GetAction().(*AlterTable_Action_AddPartition); ok {
		return x.AddPartition
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AlterTable_Action) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AlterTable_Action_Drop)(nil),
		(*AlterTable_Action_AddFk)(nil),
		(*AlterTable_Action_AddIndex)(nil),
		(*AlterTable_Action_AlterIndex)(nil),
		(*AlterTable_Action_AlterComment)(nil),
		(*AlterTable_Action_AlterName)(nil),
		(*AlterTable_Action_AddColumn)(nil),
		(*AlterTable_Action_DropColumn)(nil),
		(*AlterTable_Action_AlterReindex)(nil),
		(*AlterTable_Action_AddPartition)(nil),
	}
}

type DropTable struct {
	IfExists            bool          `protobuf:"varint,1,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	Database            string        `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	Table               string        `protobuf:"bytes,3,opt,name=table,proto3" json:"table,omitempty"`
	IndexTableNames     []string      `protobuf:"bytes,4,rep,name=index_table_names,json=indexTableNames,proto3" json:"index_table_names,omitempty"`
	ClusterTable        *ClusterTable `protobuf:"bytes,5,opt,name=cluster_table,json=clusterTable,proto3" json:"cluster_table,omitempty"`
	TableId             uint64        `protobuf:"varint,6,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	ForeignTbl          []uint64      `protobuf:"varint,7,rep,packed,name=foreign_tbl,json=foreignTbl,proto3" json:"foreign_tbl,omitempty"`
	PartitionTableNames []string      `protobuf:"bytes,8,rep,name=partition_table_names,json=partitionTableNames,proto3" json:"partition_table_names,omitempty"`
	IsView              bool          `protobuf:"varint,9,opt,name=isView,proto3" json:"isView,omitempty"`
	TableDef            *TableDef     `protobuf:"bytes,10,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	// drop table may delete fk records related to this table
	// into mo_foreign_keys
	UpdateFkSqls []string `protobuf:"bytes,11,rep,name=updateFkSqls,proto3" json:"updateFkSqls,omitempty"`
	// fk child table id that refers to me
	FkChildTblsReferToMe []uint64 `protobuf:"varint,12,rep,packed,name=fkChildTblsReferToMe,proto3" json:"fkChildTblsReferToMe,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DropTable) Reset()         { *m = DropTable{} }
func (m *DropTable) String() string { return proto.CompactTextString(m) }
func (*DropTable) ProtoMessage()    {}
func (*DropTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{96}
}
func (m *DropTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropTable.Merge(m, src)
}
func (m *DropTable) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DropTable) XXX_DiscardUnknown() {
	xxx_messageInfo_DropTable.DiscardUnknown(m)
}

var xxx_messageInfo_DropTable proto.InternalMessageInfo

func (m *DropTable) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

func (m *DropTable) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *DropTable) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *DropTable) GetIndexTableNames() []string {
	if m != nil {
		return m.IndexTableNames
	}
	return nil
}

func (m *DropTable) GetClusterTable() *ClusterTable {
	if m != nil {
		return m.ClusterTable
	}
	return nil
}

func (m *DropTable) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *DropTable) GetForeignTbl() []uint64 {
	if m != nil {
		return m.ForeignTbl
	}
	return nil
}

func (m *DropTable) GetPartitionTableNames() []string {
	if m != nil {
		return m.PartitionTableNames
	}
	return nil
}

func (m *DropTable) GetIsView() bool {
	if m != nil {
		return m.IsView
	}
	return false
}

func (m *DropTable) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *DropTable) GetUpdateFkSqls() []string {
	if m != nil {
		return m.UpdateFkSqls
	}
	return nil
}

func (m *DropTable) GetFkChildTblsReferToMe() []uint64 {
	if m != nil {
		return m.FkChildTblsReferToMe
	}
	return nil
}

type AlterView struct {
	IfExists             bool      `protobuf:"varint,1,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	Database             string    `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	TableDef             *TableDef `protobuf:"bytes,4,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *AlterView) Reset()         { *m = AlterView{} }
func (m *AlterView) String() string { return proto.CompactTextString(m) }
func (*AlterView) ProtoMessage()    {}
func (*AlterView) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{97}
}
func (m *AlterView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterView.Merge(m, src)
}
func (m *AlterView) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterView) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterView.DiscardUnknown(m)
}

var xxx_messageInfo_AlterView proto.InternalMessageInfo

func (m *AlterView) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

func (m *AlterView) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *AlterView) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

type CreateSequence struct {
	IfNotExists          bool      `protobuf:"varint,1,opt,name=if_not_exists,json=ifNotExists,proto3" json:"if_not_exists,omitempty"`
	Database             string    `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	TableDef             *TableDef `protobuf:"bytes,3,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *CreateSequence) Reset()         { *m = CreateSequence{} }
func (m *CreateSequence) String() string { return proto.CompactTextString(m) }
func (*CreateSequence) ProtoMessage()    {}
func (*CreateSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{98}
}
func (m *CreateSequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateSequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSequence.Merge(m, src)
}
func (m *CreateSequence) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CreateSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSequence.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSequence proto.InternalMessageInfo

func (m *CreateSequence) GetIfNotExists() bool {
	if m != nil {
		return m.IfNotExists
	}
	return false
}

func (m *CreateSequence) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *CreateSequence) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

type DropSequence struct {
	IfExists             bool     `protobuf:"varint,1,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	Database             string   `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	Table                string   `protobuf:"bytes,3,opt,name=table,proto3" json:"table,omitempty"`
	TableId              uint64   `protobuf:"varint,4,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DropSequence) Reset()         { *m = DropSequence{} }
func (m *DropSequence) String() string { return proto.CompactTextString(m) }
func (*DropSequence) ProtoMessage()    {}
func (*DropSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{99}
}
func (m *DropSequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropSequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropSequence.Merge(m, src)
}
func (m *DropSequence) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DropSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_DropSequence.DiscardUnknown(m)
}

var xxx_messageInfo_DropSequence proto.InternalMessageInfo

func (m *DropSequence) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

func (m *DropSequence) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *DropSequence) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *DropSequence) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

type AlterSequence struct {
	IfExists             bool      `protobuf:"varint,1,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	Database             string    `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	TableDef             *TableDef `protobuf:"bytes,3,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *AlterSequence) Reset()         { *m = AlterSequence{} }
func (m *AlterSequence) String() string { return proto.CompactTextString(m) }
func (*AlterSequence) ProtoMessage()    {}
func (*AlterSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{100}
}
func (m *AlterSequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterSequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterSequence.Merge(m, src)
}
func (m *AlterSequence) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterSequence.DiscardUnknown(m)
}

var xxx_messageInfo_AlterSequence proto.InternalMessageInfo

func (m *AlterSequence) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

func (m *AlterSequence) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *AlterSequence) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

type CreateIndex struct {
	Database              string       `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	Table                 string       `protobuf:"bytes,2,opt,name=table,proto3" json:"table,omitempty"`
	TableDef              *TableDef    `protobuf:"bytes,3,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	OriginTablePrimaryKey string       `protobuf:"bytes,4,opt,name=origin_table_primary_key,json=originTablePrimaryKey,proto3" json:"origin_table_primary_key,omitempty"`
	Index                 *CreateTable `protobuf:"bytes,5,opt,name=index,proto3" json:"index,omitempty"`
	TableExist            bool         `protobuf:"varint,6,opt,name=table_exist,json=tableExist,proto3" json:"table_exist,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}     `json:"-"`
	XXX_unrecognized      []byte       `json:"-"`
	XXX_sizecache         int32        `json:"-"`
}

func (m *CreateIndex) Reset()         { *m = CreateIndex{} }
func (m *CreateIndex) String() string { return proto.CompactTextString(m) }
func (*CreateIndex) ProtoMessage()    {}
func (*CreateIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{101}
}
func (m *CreateIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateIndex.Merge(m, src)
}
func (m *CreateIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CreateIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateIndex.DiscardUnknown(m)
}

var xxx_messageInfo_CreateIndex proto.InternalMessageInfo

func (m *CreateIndex) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *CreateIndex) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *CreateIndex) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *CreateIndex) GetOriginTablePrimaryKey() string {
	if m != nil {
		return m.OriginTablePrimaryKey
	}
	return ""
}

func (m *CreateIndex) GetIndex() *CreateTable {
	if m != nil {
		return m.Index
	}
	return nil
}

func (m *CreateIndex) GetTableExist() bool {
	if m != nil {
		return m.TableExist
	}
	return false
}

type AlterIndex struct {
	Index                string   `protobuf:"bytes,1,opt,name=index,proto3" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterIndex) Reset()         { *m = AlterIndex{} }
func (m *AlterIndex) String() string { return proto.CompactTextString(m) }
func (*AlterIndex) ProtoMessage()    {}
func (*AlterIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{102}
}
func (m *AlterIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterIndex.Merge(m, src)
}
func (m *AlterIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterIndex.DiscardUnknown(m)
}

var xxx_messageInfo_AlterIndex proto.InternalMessageInfo

func (m *AlterIndex) GetIndex() string {
	if m != nil {
		return m.Index
	}
	return ""
}

type DropIndex struct {
	Database             string   `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	Table                string   `protobuf:"bytes,2,opt,name=table,proto3" json:"table,omitempty"`
	IndexName            string   `protobuf:"bytes,3,opt,name=index_name,json=indexName,proto3" json:"index_name,omitempty"`
	IndexTableName       string   `protobuf:"bytes,4,opt,name=index_table_name,json=indexTableName,proto3" json:"index_table_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DropIndex) Reset()         { *m = DropIndex{} }
func (m *DropIndex) String() string { return proto.CompactTextString(m) }
func (*DropIndex) ProtoMessage()    {}
func (*DropIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{103}
}
func (m *DropIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropIndex.Merge(m, src)
}
func (m *DropIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DropIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_DropIndex.DiscardUnknown(m)
}

var xxx_messageInfo_DropIndex proto.InternalMessageInfo

func (m *DropIndex) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *DropIndex) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *DropIndex) GetIndexName() string {
	if m != nil {
		return m.IndexName
	}
	return ""
}

func (m *DropIndex) GetIndexTableName() string {
	if m != nil {
		return m.IndexTableName
	}
	return ""
}

type TruncateTable struct {
	Database             string        `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	Table                string        `protobuf:"bytes,2,opt,name=table,proto3" json:"table,omitempty"`
	IndexTableNames      []string      `protobuf:"bytes,3,rep,name=index_table_names,json=indexTableNames,proto3" json:"index_table_names,omitempty"`
	PartitionTableNames  []string      `protobuf:"bytes,4,rep,name=partition_table_names,json=partitionTableNames,proto3" json:"partition_table_names,omitempty"`
	ClusterTable         *ClusterTable `protobuf:"bytes,5,opt,name=cluster_table,json=clusterTable,proto3" json:"cluster_table,omitempty"`
	TableId              uint64        `protobuf:"varint,6,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	ForeignTbl           []uint64      `protobuf:"varint,7,rep,packed,name=foreign_tbl,json=foreignTbl,proto3" json:"foreign_tbl,omitempty"`
	IsDelete             bool          `protobuf:"varint,8,opt,name=is_delete,json=isDelete,proto3" json:"is_delete,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TruncateTable) Reset()         { *m = TruncateTable{} }
func (m *TruncateTable) String() string { return proto.CompactTextString(m) }
func (*TruncateTable) ProtoMessage()    {}
func (*TruncateTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{104}
}
func (m *TruncateTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TruncateTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TruncateTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TruncateTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TruncateTable.Merge(m, src)
}
func (m *TruncateTable) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TruncateTable) XXX_DiscardUnknown() {
	xxx_messageInfo_TruncateTable.DiscardUnknown(m)
}

var xxx_messageInfo_TruncateTable proto.InternalMessageInfo

func (m *TruncateTable) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *TruncateTable) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *TruncateTable) GetIndexTableNames() []string {
	if m != nil {
		return m.IndexTableNames
	}
	return nil
}

func (m *TruncateTable) GetPartitionTableNames() []string {
	if m != nil {
		return m.PartitionTableNames
	}
	return nil
}

func (m *TruncateTable) GetClusterTable() *ClusterTable {
	if m != nil {
		return m.ClusterTable
	}
	return nil
}

func (m *TruncateTable) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *TruncateTable) GetForeignTbl() []uint64 {
	if m != nil {
		return m.ForeignTbl
	}
	return nil
}

func (m *TruncateTable) GetIsDelete() bool {
	if m != nil {
		return m.IsDelete
	}
	return false
}

type ClusterTable struct {
	IsClusterTable         bool     `protobuf:"varint,1,opt,name=is_cluster_table,json=isClusterTable,proto3" json:"is_cluster_table,omitempty"`
	AccountIDs             []uint32 `protobuf:"varint,2,rep,packed,name=accountIDs,proto3" json:"accountIDs,omitempty"`
	ColumnIndexOfAccountId int32    `protobuf:"varint,3,opt,name=column_index_of_accountId,json=columnIndexOfAccountId,proto3" json:"column_index_of_accountId,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *ClusterTable) Reset()         { *m = ClusterTable{} }
func (m *ClusterTable) String() string { return proto.CompactTextString(m) }
func (*ClusterTable) ProtoMessage()    {}
func (*ClusterTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{105}
}
func (m *ClusterTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterTable.Merge(m, src)
}
func (m *ClusterTable) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ClusterTable) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterTable.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterTable proto.InternalMessageInfo

func (m *ClusterTable) GetIsClusterTable() bool {
	if m != nil {
		return m.IsClusterTable
	}
	return false
}

func (m *ClusterTable) GetAccountIDs() []uint32 {
	if m != nil {
		return m.AccountIDs
	}
	return nil
}

func (m *ClusterTable) GetColumnIndexOfAccountId() int32 {
	if m != nil {
		return m.ColumnIndexOfAccountId
	}
	return 0
}

type ShowVariables struct {
	Global               bool     `protobuf:"varint,1,opt,name=global,proto3" json:"global,omitempty"`
	Where                []*Expr  `protobuf:"bytes,2,rep,name=where,proto3" json:"where,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShowVariables) Reset()         { *m = ShowVariables{} }
func (m *ShowVariables) String() string { return proto.CompactTextString(m) }
func (*ShowVariables) ProtoMessage()    {}
func (*ShowVariables) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{106}
}
func (m *ShowVariables) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowVariables) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowVariables.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowVariables) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowVariables.Merge(m, src)
}
func (m *ShowVariables) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ShowVariables) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowVariables.DiscardUnknown(m)
}

var xxx_messageInfo_ShowVariables proto.InternalMessageInfo

func (m *ShowVariables) GetGlobal() bool {
	if m != nil {
		return m.Global
	}
	return false
}

func (m *ShowVariables) GetWhere() []*Expr {
	if m != nil {
		return m.Where
	}
	return nil
}

type SetVariables struct {
	Items                []*SetVariablesItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *SetVariables) Reset()         { *m = SetVariables{} }
func (m *SetVariables) String() string { return proto.CompactTextString(m) }
func (*SetVariables) ProtoMessage()    {}
func (*SetVariables) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{107}
}
func (m *SetVariables) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetVariables) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetVariables.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetVariables) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetVariables.Merge(m, src)
}
func (m *SetVariables) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SetVariables) XXX_DiscardUnknown() {
	xxx_messageInfo_SetVariables.DiscardUnknown(m)
}

var xxx_messageInfo_SetVariables proto.InternalMessageInfo

func (m *SetVariables) GetItems() []*SetVariablesItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type SetVariablesItem struct {
	System               bool     `protobuf:"varint,1,opt,name=system,proto3" json:"system,omitempty"`
	Global               bool     `protobuf:"varint,2,opt,name=global,proto3" json:"global,omitempty"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Value                *Expr    `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`
	Reserved             *Expr    `protobuf:"bytes,5,opt,name=reserved,proto3" json:"reserved,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetVariablesItem) Reset()         { *m = SetVariablesItem{} }
func (m *SetVariablesItem) String() string { return proto.CompactTextString(m) }
func (*SetVariablesItem) ProtoMessage()    {}
func (*SetVariablesItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{108}
}
func (m *SetVariablesItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetVariablesItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetVariablesItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetVariablesItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetVariablesItem.Merge(m, src)
}
func (m *SetVariablesItem) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SetVariablesItem) XXX_DiscardUnknown() {
	xxx_messageInfo_SetVariablesItem.DiscardUnknown(m)
}

var xxx_messageInfo_SetVariablesItem proto.InternalMessageInfo

func (m *SetVariablesItem) GetSystem() bool {
	if m != nil {
		return m.System
	}
	return false
}

func (m *SetVariablesItem) GetGlobal() bool {
	if m != nil {
		return m.Global
	}
	return false
}

func (m *SetVariablesItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SetVariablesItem) GetValue() *Expr {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *SetVariablesItem) GetReserved() *Expr {
	if m != nil {
		return m.Reserved
	}
	return nil
}

type Prepare struct {
	Name                 string       `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Schemas              []*ObjectRef `protobuf:"bytes,2,rep,name=schemas,proto3" json:"schemas,omitempty"`
	Plan                 *Plan        `protobuf:"bytes,3,opt,name=plan,proto3" json:"plan,omitempty"`
	ParamTypes           []int32      `protobuf:"varint,4,rep,packed,name=param_types,json=paramTypes,proto3" json:"param_types,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Prepare) Reset()         { *m = Prepare{} }
func (m *Prepare) String() string { return proto.CompactTextString(m) }
func (*Prepare) ProtoMessage()    {}
func (*Prepare) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{109}
}
func (m *Prepare) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Prepare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Prepare.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Prepare) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Prepare.Merge(m, src)
}
func (m *Prepare) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Prepare) XXX_DiscardUnknown() {
	xxx_messageInfo_Prepare.DiscardUnknown(m)
}

var xxx_messageInfo_Prepare proto.InternalMessageInfo

func (m *Prepare) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Prepare) GetSchemas() []*ObjectRef {
	if m != nil {
		return m.Schemas
	}
	return nil
}

func (m *Prepare) GetPlan() *Plan {
	if m != nil {
		return m.Plan
	}
	return nil
}

func (m *Prepare) GetParamTypes() []int32 {
	if m != nil {
		return m.ParamTypes
	}
	return nil
}

type Execute struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Args                 []*Expr  `protobuf:"bytes,2,rep,name=args,proto3" json:"args,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Execute) Reset()         { *m = Execute{} }
func (m *Execute) String() string { return proto.CompactTextString(m) }
func (*Execute) ProtoMessage()    {}
func (*Execute) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{110}
}
func (m *Execute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Execute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Execute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Execute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Execute.Merge(m, src)
}
func (m *Execute) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Execute) XXX_DiscardUnknown() {
	xxx_messageInfo_Execute.DiscardUnknown(m)
}

var xxx_messageInfo_Execute proto.InternalMessageInfo

func (m *Execute) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Execute) GetArgs() []*Expr {
	if m != nil {
		return m.Args
	}
	return nil
}

type Deallocate struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Deallocate) Reset()         { *m = Deallocate{} }
func (m *Deallocate) String() string { return proto.CompactTextString(m) }
func (*Deallocate) ProtoMessage()    {}
func (*Deallocate) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{111}
}
func (m *Deallocate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deallocate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deallocate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deallocate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deallocate.Merge(m, src)
}
func (m *Deallocate) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Deallocate) XXX_DiscardUnknown() {
	xxx_messageInfo_Deallocate.DiscardUnknown(m)
}

var xxx_messageInfo_Deallocate proto.InternalMessageInfo

func (m *Deallocate) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type OtherDCL struct {
	ParamTypes           []int32  `protobuf:"varint,1,rep,packed,name=paramTypes,proto3" json:"paramTypes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OtherDCL) Reset()         { *m = OtherDCL{} }
func (m *OtherDCL) String() string { return proto.CompactTextString(m) }
func (*OtherDCL) ProtoMessage()    {}
func (*OtherDCL) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{112}
}
func (m *OtherDCL) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OtherDCL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OtherDCL.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OtherDCL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OtherDCL.Merge(m, src)
}
func (m *OtherDCL) XXX_Size() int {
	return m.ProtoSize()
}
func (m *OtherDCL) XXX_DiscardUnknown() {
	xxx_messageInfo_OtherDCL.DiscardUnknown(m)
}

var xxx_messageInfo_OtherDCL proto.InternalMessageInfo

func (m *OtherDCL) GetParamTypes() []int32 {
	if m != nil {
		return m.ParamTypes
	}
	return nil
}

type TableLockInfo struct {
	LockType             TableLockType `protobuf:"varint,1,opt,name=lockType,proto3,enum=plan.TableLockType" json:"lockType,omitempty"`
	TableDef             *TableDef     `protobuf:"bytes,2,opt,name=tableDef,proto3" json:"tableDef,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TableLockInfo) Reset()         { *m = TableLockInfo{} }
func (m *TableLockInfo) String() string { return proto.CompactTextString(m) }
func (*TableLockInfo) ProtoMessage()    {}
func (*TableLockInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{113}
}
func (m *TableLockInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableLockInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableLockInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableLockInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableLockInfo.Merge(m, src)
}
func (m *TableLockInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableLockInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TableLockInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TableLockInfo proto.InternalMessageInfo

func (m *TableLockInfo) GetLockType() TableLockType {
	if m != nil {
		return m.LockType
	}
	return TableLockType_TableLockNone
}

func (m *TableLockInfo) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

type LockTables struct {
	TableLocks           []*TableLockInfo `protobuf:"bytes,1,rep,name=tableLocks,proto3" json:"tableLocks,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *LockTables) Reset()         { *m = LockTables{} }
func (m *LockTables) String() string { return proto.CompactTextString(m) }
func (*LockTables) ProtoMessage()    {}
func (*LockTables) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{114}
}
func (m *LockTables) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockTables) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockTables.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LockTables) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockTables.Merge(m, src)
}
func (m *LockTables) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LockTables) XXX_DiscardUnknown() {
	xxx_messageInfo_LockTables.DiscardUnknown(m)
}

var xxx_messageInfo_LockTables proto.InternalMessageInfo

func (m *LockTables) GetTableLocks() []*TableLockInfo {
	if m != nil {
		return m.TableLocks
	}
	return nil
}

type UnLockTables struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnLockTables) Reset()         { *m = UnLockTables{} }
func (m *UnLockTables) String() string { return proto.CompactTextString(m) }
func (*UnLockTables) ProtoMessage()    {}
func (*UnLockTables) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{115}
}
func (m *UnLockTables) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnLockTables) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnLockTables.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnLockTables) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnLockTables.Merge(m, src)
}
func (m *UnLockTables) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnLockTables) XXX_DiscardUnknown() {
	xxx_messageInfo_UnLockTables.DiscardUnknown(m)
}

var xxx_messageInfo_UnLockTables proto.InternalMessageInfo

type MetadataScanInfo struct {
	ColName              string   `protobuf:"bytes,1,opt,name=col_name,json=colName,proto3" json:"col_name,omitempty"`
	ObjectName           string   `protobuf:"bytes,2,opt,name=object_name,json=objectName,proto3" json:"object_name,omitempty"`
	IsHidden             bool     `protobuf:"varint,3,opt,name=is_hidden,json=isHidden,proto3" json:"is_hidden,omitempty"`
	ObjLoc               []byte   `protobuf:"bytes,4,opt,name=obj_loc,json=objLoc,proto3" json:"obj_loc,omitempty"`
	CreateTs             []byte   `protobuf:"bytes,5,opt,name=create_ts,json=createTs,proto3" json:"create_ts,omitempty"`
	DeleteTs             []byte   `protobuf:"bytes,6,opt,name=delete_ts,json=deleteTs,proto3" json:"delete_ts,omitempty"`
	RowCnt               int64    `protobuf:"varint,7,opt,name=row_cnt,json=rowCnt,proto3" json:"row_cnt,omitempty"`
	NullCnt              int64    `protobuf:"varint,8,opt,name=null_cnt,json=nullCnt,proto3" json:"null_cnt,omitempty"`
	CompressSize         int64    `protobuf:"varint,9,opt,name=compress_size,json=compressSize,proto3" json:"compress_size,omitempty"`
	OriginSize           int64    `protobuf:"varint,10,opt,name=origin_size,json=originSize,proto3" json:"origin_size,omitempty"`
	ZoneMap              []byte   `protobuf:"bytes,11,opt,name=zone_map,json=zoneMap,proto3" json:"zone_map,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MetadataScanInfo) Reset()         { *m = MetadataScanInfo{} }
func (m *MetadataScanInfo) String() string { return proto.CompactTextString(m) }
func (*MetadataScanInfo) ProtoMessage()    {}
func (*MetadataScanInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{116}
}
func (m *MetadataScanInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetadataScanInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetadataScanInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetadataScanInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetadataScanInfo.Merge(m, src)
}
func (m *MetadataScanInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MetadataScanInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MetadataScanInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MetadataScanInfo proto.InternalMessageInfo

func (m *MetadataScanInfo) GetColName() string {
	if m != nil {
		return m.ColName
	}
	return ""
}

func (m *MetadataScanInfo) GetObjectName() string {
	if m != nil {
		return m.ObjectName
	}
	return ""
}

func (m *MetadataScanInfo) GetIsHidden() bool {
	if m != nil {
		return m.IsHidden
	}
	return false
}

func (m *MetadataScanInfo) GetObjLoc() []byte {
	if m != nil {
		return m.ObjLoc
	}
	return nil
}

func (m *MetadataScanInfo) GetCreateTs() []byte {
	if m != nil {
		return m.CreateTs
	}
	return nil
}

func (m *MetadataScanInfo) GetDeleteTs() []byte {
	if m != nil {
		return m.DeleteTs
	}
	return nil
}

func (m *MetadataScanInfo) GetRowCnt() int64 {
	if m != nil {
		return m.RowCnt
	}
	return 0
}

func (m *MetadataScanInfo) GetNullCnt() int64 {
	if m != nil {
		return m.NullCnt
	}
	return 0
}

func (m *MetadataScanInfo) GetCompressSize() int64 {
	if m != nil {
		return m.CompressSize
	}
	return 0
}

func (m *MetadataScanInfo) GetOriginSize() int64 {
	if m != nil {
		return m.OriginSize
	}
	return 0
}

func (m *MetadataScanInfo) GetZoneMap() []byte {
	if m != nil {
		return m.ZoneMap
	}
	return nil
}

func init() {
	proto.RegisterEnum("plan.CompressType", CompressType_name, CompressType_value)
	proto.RegisterEnum("plan.PartitionType", PartitionType_name, PartitionType_value)
	proto.RegisterEnum("plan.ShuffleType", ShuffleType_name, ShuffleType_value)
	proto.RegisterEnum("plan.ShuffleMethod", ShuffleMethod_name, ShuffleMethod_value)
	proto.RegisterEnum("plan.ShuffleTypeForMultiCN", ShuffleTypeForMultiCN_name, ShuffleTypeForMultiCN_value)
	proto.RegisterEnum("plan.TransationCompletionType", TransationCompletionType_name, TransationCompletionType_value)
	proto.RegisterEnum("plan.TableLockType", TableLockType_name, TableLockType_value)
	proto.RegisterEnum("plan.SubqueryRef_Type", SubqueryRef_Type_name, SubqueryRef_Type_value)
	proto.RegisterEnum("plan.Function_FuncFlag", Function_FuncFlag_name, Function_FuncFlag_value)
	proto.RegisterEnum("plan.ForeignKeyDef_RefAction", ForeignKeyDef_RefAction_name, ForeignKeyDef_RefAction_value)
	proto.RegisterEnum("plan.OrderBySpec_OrderByFlag", OrderBySpec_OrderByFlag_name, OrderBySpec_OrderByFlag_value)
	proto.RegisterEnum("plan.FrameClause_FrameType", FrameClause_FrameType_name, FrameClause_FrameType_value)
	proto.RegisterEnum("plan.FrameBound_BoundType", FrameBound_BoundType_name, FrameBound_BoundType_value)
	proto.RegisterEnum("plan.Node_NodeType", Node_NodeType_name, Node_NodeType_value)
	proto.RegisterEnum("plan.Node_JoinType", Node_JoinType_name, Node_JoinType_value)
	proto.RegisterEnum("plan.Node_AggMode", Node_AggMode_name, Node_AggMode_value)
	proto.RegisterEnum("plan.Node_FillType", Node_FillType_name, Node_FillType_value)
	proto.RegisterEnum("plan.Query_StatementType", Query_StatementType_name, Query_StatementType_value)
	proto.RegisterEnum("plan.TransationControl_TclType", TransationControl_TclType_name, TransationControl_TclType_value)
	proto.RegisterEnum("plan.TransationBegin_TransationMode", TransationBegin_TransationMode_name, TransationBegin_TransationMode_value)
	proto.RegisterEnum("plan.DataControl_DclType", DataControl_DclType_name, DataControl_DclType_value)
	proto.RegisterEnum("plan.DataDefinition_DdlType", DataDefinition_DdlType_name, DataDefinition_DdlType_value)
	proto.RegisterEnum("plan.AlterTableDrop_Typ", AlterTableDrop_Typ_name, AlterTableDrop_Typ_value)
	proto.RegisterEnum("plan.AlterTable_AlgorithmType", AlterTable_AlgorithmType_name, AlterTable_AlgorithmType_value)
	proto.RegisterEnum("plan.MetadataScanInfo_MetadataScanInfoType", MetadataScanInfo_MetadataScanInfoType_name, MetadataScanInfo_MetadataScanInfoType_value)
	proto.RegisterType((*Type)(nil), "plan.Type")
	proto.RegisterType((*MsgHeader)(nil), "plan.msgHeader")
	proto.RegisterType((*Literal)(nil), "plan.Literal")
	proto.RegisterType((*ParamRef)(nil), "plan.ParamRef")
	proto.RegisterType((*VarRef)(nil), "plan.VarRef")
	proto.RegisterType((*ColRef)(nil), "plan.ColRef")
	proto.RegisterType((*RawColRef)(nil), "plan.RawColRef")
	proto.RegisterType((*CorrColRef)(nil), "plan.CorrColRef")
	proto.RegisterType((*ExprList)(nil), "plan.ExprList")
	proto.RegisterType((*MaxValue)(nil), "plan.MaxValue")
	proto.RegisterType((*TargetType)(nil), "plan.TargetType")
	proto.RegisterType((*SubqueryRef)(nil), "plan.SubqueryRef")
	proto.RegisterType((*ObjectRef)(nil), "plan.ObjectRef")
	proto.RegisterType((*PubInfo)(nil), "plan.PubInfo")
	proto.RegisterType((*SubscriptionMeta)(nil), "plan.SubscriptionMeta")
	proto.RegisterType((*Function)(nil), "plan.Function")
	proto.RegisterType((*Expr)(nil), "plan.Expr")
	proto.RegisterType((*LiteralVec)(nil), "plan.LiteralVec")
	proto.RegisterType((*Decimal64)(nil), "plan.decimal64")
	proto.RegisterType((*Decimal128)(nil), "plan.decimal128")
	proto.RegisterType((*ResultColDef)(nil), "plan.ResultColDef")
	proto.RegisterType((*ColDef)(nil), "plan.ColDef")
	proto.RegisterType((*Default)(nil), "plan.Default")
	proto.RegisterType((*OnUpdate)(nil), "plan.OnUpdate")
	proto.RegisterType((*IndexOption)(nil), "plan.IndexOption")
	proto.RegisterType((*PrimaryKeyDef)(nil), "plan.PrimaryKeyDef")
	proto.RegisterType((*IndexDef)(nil), "plan.IndexDef")
	proto.RegisterType((*ForeignKeyDef)(nil), "plan.ForeignKeyDef")
	proto.RegisterType((*CheckDef)(nil), "plan.CheckDef")
	proto.RegisterType((*ClusterByDef)(nil), "plan.ClusterByDef")
	proto.RegisterType((*PropertyDef)(nil), "plan.PropertyDef")
	proto.RegisterType((*Property)(nil), "plan.Property")
	proto.RegisterType((*PropertiesDef)(nil), "plan.PropertiesDef")
	proto.RegisterType((*PartitionByDef)(nil), "plan.PartitionByDef")
	proto.RegisterType((*PartitionExpr)(nil), "plan.PartitionExpr")
	proto.RegisterType((*PartitionColumns)(nil), "plan.PartitionColumns")
	proto.RegisterType((*PartitionItem)(nil), "plan.PartitionItem")
	proto.RegisterType((*ViewDef)(nil), "plan.ViewDef")
	proto.RegisterType((*TableDef)(nil), "plan.TableDef")
	proto.RegisterMapType((map[string]int32)(nil), "plan.TableDef.Name2colIndexEntry")
	proto.RegisterType((*TableDef_DefType)(nil), "plan.TableDef.DefType")
	proto.RegisterType((*TableFunction)(nil), "plan.TableFunction")
	proto.RegisterType((*HashMapStats)(nil), "plan.HashMapStats")
	proto.RegisterType((*Stats)(nil), "plan.Stats")
	proto.RegisterType((*RowsetExpr)(nil), "plan.RowsetExpr")
	proto.RegisterType((*ColData)(nil), "plan.ColData")
	proto.RegisterType((*RowsetData)(nil), "plan.RowsetData")
	proto.RegisterType((*OrderBySpec)(nil), "plan.OrderBySpec")
	proto.RegisterType((*WindowSpec)(nil), "plan.WindowSpec")
	proto.RegisterType((*SampleFuncSpec)(nil), "plan.SampleFuncSpec")
	proto.RegisterType((*FrameClause)(nil), "plan.FrameClause")
	proto.RegisterType((*FrameBound)(nil), "plan.FrameBound")
	proto.RegisterType((*OnDuplicateKeyCtx)(nil), "plan.OnDuplicateKeyCtx")
	proto.RegisterMapType((map[string]*Expr)(nil), "plan.OnDuplicateKeyCtx.OnDuplicateExprEntry")
	proto.RegisterType((*InsertCtx)(nil), "plan.InsertCtx")
	proto.RegisterType((*ReplaceCtx)(nil), "plan.ReplaceCtx")
	proto.RegisterType((*AnalyzeInfo)(nil), "plan.AnalyzeInfo")
	proto.RegisterType((*PartitionPrune)(nil), "plan.PartitionPrune")
	proto.RegisterType((*OriginTableMessageForFuzzy)(nil), "plan.OriginTableMessageForFuzzy")
	proto.RegisterType((*Node)(nil), "plan.Node")
	proto.RegisterType((*Snapshot)(nil), "plan.Snapshot")
	proto.RegisterType((*SnapshotTenant)(nil), "plan.SnapshotTenant")
	proto.RegisterType((*ExternScan)(nil), "plan.ExternScan")
	proto.RegisterType((*LockTarget)(nil), "plan.LockTarget")
	proto.RegisterType((*PreInsertUkCtx)(nil), "plan.PreInsertUkCtx")
	proto.RegisterType((*PreDeleteCtx)(nil), "plan.PreDeleteCtx")
	proto.RegisterType((*PreInsertCtx)(nil), "plan.PreInsertCtx")
	proto.RegisterType((*RuntimeFilterSpec)(nil), "plan.RuntimeFilterSpec")
	proto.RegisterType((*IdList)(nil), "plan.IdList")
	proto.RegisterType((*ColPosMap)(nil), "plan.ColPosMap")
	proto.RegisterMapType((map[string]int32)(nil), "plan.ColPosMap.MapEntry")
	proto.RegisterType((*DeleteCtx)(nil), "plan.DeleteCtx")
	proto.RegisterType((*Query)(nil), "plan.Query")
	proto.RegisterType((*TransationControl)(nil), "plan.TransationControl")
	proto.RegisterType((*TransationBegin)(nil), "plan.TransationBegin")
	proto.RegisterType((*TransationCommit)(nil), "plan.TransationCommit")
	proto.RegisterType((*TransationRollback)(nil), "plan.TransationRollback")
	proto.RegisterType((*Plan)(nil), "plan.Plan")
	proto.RegisterType((*Column)(nil), "plan.column")
	proto.RegisterType((*DataControl)(nil), "plan.DataControl")
	proto.RegisterType((*DataDefinition)(nil), "plan.DataDefinition")
	proto.RegisterType((*SubscriptionOption)(nil), "plan.SubscriptionOption")
	proto.RegisterType((*CreateDatabase)(nil), "plan.CreateDatabase")
	proto.RegisterType((*AlterDatabase)(nil), "plan.AlterDatabase")
	proto.RegisterType((*DropDatabase)(nil), "plan.DropDatabase")
	proto.RegisterType((*FkColName)(nil), "plan.FkColName")
	proto.RegisterType((*ForeignKeyInfo)(nil), "plan.ForeignKeyInfo")
	proto.RegisterType((*CreateTable)(nil), "plan.CreateTable")
	proto.RegisterType((*AlterTableDrop)(nil), "plan.AlterTableDrop")
	proto.RegisterType((*AlterTableAddFk)(nil), "plan.AlterTableAddFk")
	proto.RegisterType((*AlterTableAddIndex)(nil), "plan.AlterTableAddIndex")
	proto.RegisterType((*AlterTableDropIndex)(nil), "plan.AlterTableDropIndex")
	proto.RegisterType((*AlterTableAlterIndex)(nil), "plan.AlterTableAlterIndex")
	proto.RegisterType((*AlterTableAlterReIndex)(nil), "plan.AlterTableAlterReIndex")
	proto.RegisterType((*AlterTableAddPartition)(nil), "plan.AlterTableAddPartition")
	proto.RegisterType((*AlterTableComment)(nil), "plan.AlterTableComment")
	proto.RegisterType((*AlterTableName)(nil), "plan.AlterTableName")
	proto.RegisterType((*AlterAddColumn)(nil), "plan.AlterAddColumn")
	proto.RegisterType((*AlterDropColumn)(nil), "plan.AlterDropColumn")
	proto.RegisterType((*AlterTable)(nil), "plan.AlterTable")
	proto.RegisterMapType((map[uint64]*ColDef)(nil), "plan.AlterTable.ChangeTblColIdMapEntry")
	proto.RegisterType((*AlterTable_Action)(nil), "plan.AlterTable.Action")
	proto.RegisterType((*DropTable)(nil), "plan.DropTable")
	proto.RegisterType((*AlterView)(nil), "plan.AlterView")
	proto.RegisterType((*CreateSequence)(nil), "plan.CreateSequence")
	proto.RegisterType((*DropSequence)(nil), "plan.DropSequence")
	proto.RegisterType((*AlterSequence)(nil), "plan.AlterSequence")
	proto.RegisterType((*CreateIndex)(nil), "plan.CreateIndex")
	proto.RegisterType((*AlterIndex)(nil), "plan.AlterIndex")
	proto.RegisterType((*DropIndex)(nil), "plan.DropIndex")
	proto.RegisterType((*TruncateTable)(nil), "plan.TruncateTable")
	proto.RegisterType((*ClusterTable)(nil), "plan.ClusterTable")
	proto.RegisterType((*ShowVariables)(nil), "plan.ShowVariables")
	proto.RegisterType((*SetVariables)(nil), "plan.SetVariables")
	proto.RegisterType((*SetVariablesItem)(nil), "plan.SetVariablesItem")
	proto.RegisterType((*Prepare)(nil), "plan.Prepare")
	proto.RegisterType((*Execute)(nil), "plan.Execute")
	proto.RegisterType((*Deallocate)(nil), "plan.Deallocate")
	proto.RegisterType((*OtherDCL)(nil), "plan.OtherDCL")
	proto.RegisterType((*TableLockInfo)(nil), "plan.TableLockInfo")
	proto.RegisterType((*LockTables)(nil), "plan.LockTables")
	proto.RegisterType((*UnLockTables)(nil), "plan.UnLockTables")
	proto.RegisterType((*MetadataScanInfo)(nil), "plan.MetadataScanInfo")
}

func init() { proto.RegisterFile("plan.proto", fileDescriptor_2d655ab2f7683c23) }

var fileDescriptor_2d655ab2f7683c23 = []byte{
	// 10629 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x7d, 0x5d, 0x8f, 0x1b, 0x57,
	0x96, 0x58, 0xf3, 0x9b, 0x3c, 0xfc, 0xe8, 0xea, 0xab, 0x96, 0x44, 0xc9, 0xb2, 0xd4, 0x2e, 0x6b,
	0x6c, 0x59, 0xe3, 0x91, 0x6d, 0xc9, 0x1f, 0xb2, 0x77, 0x66, 0x67, 0xd8, 0x6c, 0x4a, 0x4d, 0x8b,
	0x4d, 0xf6, 0x14, 0xd9, 0x92, 0x3d, 0x8b, 0xa0, 0x50, 0x64, 0x15, 0xbb, 0xcb, 0x5d, 0xac, 0xa2,
	0xab, 0x8a, 0xea, 0x6e, 0x03, 0x0b, 0x4c, 0x12, 0x20, 0x8b, 0x04, 0xc8, 0x53, 0x80, 0x7d, 0x49,
	0x02, 0x4c, 0x36, 0x6f, 0x8b, 0x04, 0x08, 0x90, 0x00, 0x1b, 0xe4, 0x35, 0x41, 0xb0, 0x09, 0x82,
	0x24, 0x40, 0x1e, 0x16, 0xf9, 0xc0, 0x26, 0x98, 0xbc, 0xe4, 0x6d, 0x1f, 0x36, 0x3f, 0x20, 0x38,
	0xe7, 0xde, 0xaa, 0xba, 0x45, 0xb2, 0x47, 0xf6, 0xec, 0x2c, 0x92, 0xbc, 0x74, 0xd7, 0x3d, 0xe7,
	0xdc, 0xef, 0x7b, 0xcf, 0xd7, 0x3d, 0xf7, 0x12, 0x60, 0xee, 0x18, 0xee, 0x83, 0xb9, 0xef, 0x85,
	0x1e, 0xcb, 0xe3, 0xf7, 0xcd, 0x1f, 0x1c, 0xdb, 0xe1, 0xc9, 0x62, 0xfc, 0x60, 0xe2, 0xcd, 0xde,
	0x3b, 0xf6, 0x8e, 0xbd, 0xf7, 0x08, 0x39, 0x5e, 0x4c, 0x29, 0x45, 0x09, 0xfa, 0xe2, 0x99, 0x6e,
	0x82, 0xe3, 0x4d, 0x4e, 0xc5, 0xf7, 0x66, 0x68, 0xcf, 0xac, 0x20, 0x34, 0x66, 0x73, 0x0e, 0x50,
	0xff, 0x28, 0x03, 0xf9, 0xd1, 0xc5, 0xdc, 0x62, 0x0d, 0xc8, 0xda, 0x66, 0x33, 0xb3, 0x93, 0xb9,
	0x57, 0xd0, 0xb2, 0xb6, 0xc9, 0x76, 0xa0, 0xea, 0x7a, 0x61, 0x7f, 0xe1, 0x38, 0xc6, 0xd8, 0xb1,
	0x9a, 0xd9, 0x9d, 0xcc, 0xbd, 0xb2, 0x26, 0x83, 0xd8, 0x6b, 0x50, 0x31, 0x16, 0xa1, 0xa7, 0xdb,
	0xee, 0xc4, 0x6f, 0xe6, 0x08, 0x5f, 0x46, 0x40, 0xd7, 0x9d, 0xf8, 0x6c, 0x1b, 0x0a, 0x67, 0xb6,
	0x19, 0x9e, 0x34, 0xf3, 0x54, 0x22, 0x4f, 0x20, 0x34, 0x98, 0x18, 0x8e, 0xd5, 0x2c, 0x70, 0x28,
	0x25, 0x10, 0x1a, 0x52, 0x25, 0xc5, 0x9d, 0xcc, 0xbd, 0x8a, 0xc6, 0x13, 0xec, 0x36, 0x80, 0xe5,
	0x2e, 0x66, 0x2f, 0x0d, 0x67, 0x61, 0x05, 0xcd, 0x12, 0xa1, 0x24, 0x88, 0xfa, 0x63, 0xa8, 0xcc,
	0x82, 0xe3, 0x7d, 0xcb, 0x30, 0x2d, 0x9f, 0x5d, 0x87, 0xd2, 0x2c, 0x38, 0xd6, 0x43, 0xe3, 0x58,
	0x74, 0xa1, 0x38, 0x0b, 0x8e, 0x47, 0xc6, 0x31, 0xbb, 0x01, 0x65, 0x42, 0x5c, 0xcc, 0x79, 0x1f,
	0x0a, 0x1a, 0x12, 0x62, 0x8f, 0xd5, 0x3f, 0x2b, 0x40, 0xa9, 0x67, 0x87, 0x96, 0x6f, 0x38, 0xec,
	0x1a, 0x14, 0xed, 0xc0, 0x5d, 0x38, 0x0e, 0x65, 0x2f, 0x6b, 0x22, 0xc5, 0xae, 0x41, 0xc1, 0x7e,
	0xfc, 0xd2, 0x70, 0x78, 0xde, 0xfd, 0x0d, 0x8d, 0x27, 0x59, 0x13, 0x8a, 0xf6, 0x07, 0x1f, 0x23,
	0x22, 0x27, 0x10, 0x22, 0x4d, 0x98, 0x47, 0x0f, 0x11, 0x93, 0x8f, 0x31, 0x94, 0x26, 0xcc, 0xc7,
	0x1f, 0x22, 0x06, 0x7b, 0x9f, 0x23, 0x0c, 0xa5, 0xb1, 0x96, 0x05, 0xd5, 0x82, 0x03, 0x50, 0xc7,
	0x5a, 0x16, 0x51, 0x2d, 0x0b, 0x5e, 0x4b, 0x49, 0x20, 0x44, 0x9a, 0x30, 0xbc, 0x96, 0x72, 0x8c,
	0x89, 0x6b, 0x59, 0xf0, 0x5a, 0x2a, 0x3b, 0x99, 0x7b, 0x79, 0xc2, 0xf0, 0x5a, 0xb6, 0x21, 0x6f,
	0x22, 0x1c, 0x76, 0x32, 0xf7, 0x32, 0xfb, 0x1b, 0x1a, 0xa5, 0x10, 0x1a, 0x20, 0xb4, 0x8a, 0x03,
	0x8c, 0xd0, 0x40, 0x40, 0xc7, 0x08, 0xad, 0xe1, 0x68, 0x20, 0x74, 0x2c, 0xa0, 0x53, 0x84, 0xd6,
	0x77, 0x32, 0xf7, 0xb2, 0x08, 0xc5, 0x14, 0xbb, 0x09, 0x25, 0xd3, 0x08, 0x2d, 0x44, 0x34, 0x44,
	0x97, 0x23, 0x00, 0xe2, 0x70, 0xc5, 0x21, 0x6e, 0x53, 0x74, 0x3a, 0x02, 0x30, 0x15, 0xaa, 0x48,
	0x16, 0xe1, 0x15, 0x81, 0x97, 0x81, 0xec, 0x23, 0xa8, 0x99, 0xd6, 0xc4, 0x9e, 0x19, 0x0e, 0xef,
	0xd3, 0xd6, 0x4e, 0xe6, 0x5e, 0xf5, 0xe1, 0xe6, 0x03, 0xda, 0x13, 0x31, 0x66, 0x7f, 0x43, 0x4b,
	0x91, 0xb1, 0xc7, 0x50, 0x17, 0xe9, 0x0f, 0x1e, 0xd2, 0xc0, 0x32, 0xca, 0xa7, 0xa4, 0xf2, 0x7d,
	0xf0, 0xf0, 0xf1, 0xfe, 0x86, 0x96, 0x26, 0x64, 0x77, 0xa1, 0x16, 0x6f, 0x11, 0xcc, 0x78, 0x45,
	0xb4, 0x2a, 0x05, 0xc5, 0x6e, 0x7d, 0x15, 0x78, 0x2e, 0x12, 0x6c, 0x8b, 0x71, 0x8b, 0x00, 0x6c,
	0x07, 0xc0, 0xb4, 0xa6, 0xc6, 0xc2, 0x09, 0x11, 0x7d, 0x55, 0x0c, 0xa0, 0x04, 0x63, 0xb7, 0xa1,
	0xb2, 0x98, 0x63, 0x2f, 0x9f, 0x1b, 0x4e, 0xf3, 0x9a, 0x20, 0x48, 0x40, 0x58, 0x3a, 0xae, 0x73,
	0xc4, 0x5e, 0x17, 0xb3, 0x1b, 0x01, 0x70, 0xaf, 0xd8, 0xc1, 0xae, 0xed, 0x36, 0x9b, 0xb4, 0x4e,
	0x79, 0x82, 0xdd, 0x82, 0x5c, 0xe0, 0x4f, 0x9a, 0x37, 0xa8, 0x97, 0xc0, 0x7b, 0xd9, 0x39, 0x9f,
	0xfb, 0x1a, 0x82, 0x77, 0x4b, 0x50, 0xa0, 0x3d, 0xa3, 0xde, 0x82, 0xf2, 0xa1, 0xe1, 0x1b, 0x33,
	0xcd, 0x9a, 0x32, 0x05, 0x72, 0x73, 0x2f, 0x10, 0xbb, 0x05, 0x3f, 0xd5, 0x1e, 0x14, 0x9f, 0x1b,
	0x3e, 0xe2, 0x18, 0xe4, 0x5d, 0x63, 0x66, 0x11, 0xb2, 0xa2, 0xd1, 0x37, 0xee, 0x90, 0xe0, 0x22,
	0x08, 0xad, 0x99, 0x60, 0x05, 0x22, 0x85, 0xf0, 0x63, 0xc7, 0x1b, 0x8b, 0x9d, 0x50, 0xd6, 0x44,
	0x4a, 0xfd, 0x6b, 0x19, 0x28, 0xb6, 0x3d, 0x07, 0x8b, 0xbb, 0x0e, 0x25, 0xdf, 0x72, 0xf4, 0xa4,
	0xba, 0xa2, 0x6f, 0x39, 0x87, 0x5e, 0x80, 0x88, 0x89, 0xc7, 0x11, 0x7c, 0x6f, 0x16, 0x27, 0x1e,
	0x21, 0xa2, 0x06, 0xe4, 0xa4, 0x06, 0xdc, 0x80, 0x72, 0x38, 0x76, 0x74, 0x82, 0xe7, 0x09, 0x5e,
	0x0a, 0xc7, 0x4e, 0x1f, 0x51, 0xd7, 0xa1, 0x64, 0x8e, 0x39, 0xa6, 0x40, 0x98, 0xa2, 0x39, 0x46,
	0x84, 0xfa, 0x29, 0x54, 0x34, 0xe3, 0x4c, 0x34, 0xe3, 0x2a, 0x14, 0xb1, 0x00, 0xc1, 0xe5, 0xf2,
	0x5a, 0x21, 0x1c, 0x3b, 0x5d, 0x13, 0xc1, 0xd8, 0x08, 0xdb, 0xa4, 0x36, 0xe4, 0xb5, 0xc2, 0xc4,
	0x73, 0xba, 0xa6, 0x3a, 0x02, 0x68, 0x7b, 0xbe, 0xff, 0x6b, 0x77, 0x61, 0x1b, 0x0a, 0xa6, 0x35,
	0x0f, 0x4f, 0x38, 0x83, 0xd0, 0x78, 0x42, 0xbd, 0x0f, 0x65, 0x9c, 0x97, 0x9e, 0x1d, 0x84, 0xec,
	0x36, 0xe4, 0x1d, 0x3b, 0x08, 0x9b, 0x99, 0x9d, 0xdc, 0xd2, 0xac, 0x11, 0x5c, 0xdd, 0x81, 0xf2,
	0x81, 0x71, 0xfe, 0x1c, 0x67, 0x0e, 0x4b, 0xa3, 0x29, 0x14, 0x53, 0x22, 0xe6, 0xb3, 0x06, 0x30,
	0x32, 0xfc, 0x63, 0x2b, 0x24, 0x7e, 0xf6, 0xe7, 0x19, 0xa8, 0x0e, 0x17, 0xe3, 0xaf, 0x17, 0x96,
	0x7f, 0x81, 0x6d, 0xbe, 0x07, 0xb9, 0xf0, 0x62, 0x4e, 0x39, 0x1a, 0x0f, 0xaf, 0xf1, 0xe2, 0x25,
	0xfc, 0x03, 0xcc, 0xa4, 0x21, 0x09, 0x76, 0xc2, 0xf5, 0x4c, 0x2b, 0x1a, 0x83, 0x82, 0x56, 0xc4,
	0x64, 0xd7, 0x44, 0xa1, 0xe0, 0xcd, 0xc5, 0x2c, 0x64, 0xbd, 0x39, 0xdb, 0x81, 0xc2, 0xe4, 0xc4,
	0x76, 0x4c, 0x9a, 0x80, 0x74, 0x9b, 0x39, 0x02, 0x67, 0xc9, 0xf7, 0xce, 0xf4, 0xc0, 0xfe, 0x26,
	0x62, 0xf2, 0x25, 0xdf, 0x3b, 0x1b, 0xda, 0xdf, 0x58, 0xea, 0x48, 0x48, 0x1a, 0x80, 0xe2, 0xb0,
	0xdd, 0xea, 0xb5, 0x34, 0x65, 0x03, 0xbf, 0x3b, 0x5f, 0x74, 0x87, 0xa3, 0xa1, 0x92, 0x61, 0x0d,
	0x80, 0xfe, 0x60, 0xa4, 0x8b, 0x74, 0x96, 0x15, 0x21, 0xdb, 0xed, 0x2b, 0x39, 0xa4, 0x41, 0x78,
	0xb7, 0xaf, 0xe4, 0x59, 0x09, 0x72, 0xad, 0xfe, 0x97, 0x4a, 0x81, 0x3e, 0x7a, 0x3d, 0xa5, 0xa8,
	0xfe, 0x61, 0x16, 0x2a, 0x83, 0xf1, 0x57, 0xd6, 0x24, 0xc4, 0x3e, 0xe3, 0x2a, 0xb5, 0xfc, 0x97,
	0x96, 0x4f, 0xdd, 0xce, 0x69, 0x22, 0x85, 0x1d, 0x31, 0xc7, 0xd4, 0xb9, 0x9c, 0x96, 0x35, 0xc7,
	0x44, 0x37, 0x39, 0xb1, 0x66, 0x06, 0x75, 0x0e, 0xe9, 0x28, 0x85, 0xbb, 0xc2, 0x1b, 0x7f, 0x45,
	0xdd, 0xcb, 0x69, 0xf8, 0xc9, 0xee, 0x40, 0x95, 0x97, 0x21, 0xaf, 0x2f, 0xe0, 0xa0, 0xe5, 0xc5,
	0x57, 0x94, 0x17, 0x1f, 0xe5, 0xa4, 0x52, 0x39, 0x52, 0x48, 0x30, 0x0e, 0xea, 0x8b, 0x15, 0xed,
	0x8d, 0xbf, 0xe2, 0xd8, 0x32, 0x5f, 0xd1, 0xde, 0xf8, 0x2b, 0x42, 0x7d, 0x1f, 0xb6, 0x82, 0xc5,
	0x38, 0x98, 0xf8, 0xf6, 0x3c, 0xb4, 0x3d, 0x97, 0xd3, 0x54, 0x88, 0x46, 0x91, 0x11, 0x44, 0x7c,
	0x0f, 0xca, 0xf3, 0xc5, 0x58, 0xb7, 0xdd, 0xa9, 0x47, 0xcc, 0xbd, 0xfa, 0xb0, 0xce, 0x27, 0xe6,
	0x70, 0x31, 0xee, 0xba, 0x53, 0x4f, 0x2b, 0xcd, 0xf9, 0x87, 0xfa, 0x16, 0x94, 0x04, 0x0c, 0xa5,
	0x77, 0x68, 0xb9, 0x86, 0x1b, 0xea, 0xb1, 0xd8, 0x2f, 0x73, 0x40, 0xd7, 0x54, 0xff, 0x5e, 0x06,
	0x94, 0xa1, 0x54, 0xcd, 0x81, 0x15, 0x1a, 0x6b, 0xb9, 0xc2, 0xeb, 0x00, 0xc6, 0x64, 0xe2, 0x2d,
	0x78, 0x31, 0x7c, 0xf1, 0x54, 0x04, 0xa4, 0x6b, 0xca, 0x63, 0x93, 0x4b, 0x8d, 0xcd, 0x1b, 0x50,
	0x8b, 0xf2, 0x49, 0x1b, 0xba, 0x2a, 0x60, 0xd1, 0xe8, 0x04, 0x8b, 0xd4, 0xae, 0x2e, 0x05, 0x0b,
	0xbe, 0xad, 0xff, 0x56, 0x16, 0xca, 0x4f, 0x16, 0xee, 0x04, 0x9b, 0xc6, 0xde, 0x84, 0xfc, 0x74,
	0xe1, 0x4e, 0xa8, 0x59, 0xb1, 0x68, 0x88, 0x57, 0x84, 0x46, 0x48, 0xdc, 0x6b, 0x86, 0x7f, 0x8c,
	0x7b, 0x74, 0x65, 0xaf, 0x21, 0x5c, 0xfd, 0xe7, 0x19, 0x5e, 0xe2, 0x13, 0xc7, 0x38, 0x66, 0x65,
	0xc8, 0xf7, 0x07, 0xfd, 0x8e, 0xb2, 0xc1, 0x6a, 0x50, 0xee, 0xf6, 0x47, 0x1d, 0xad, 0xdf, 0xea,
	0x29, 0x19, 0x5a, 0xb8, 0xa3, 0xd6, 0x6e, 0xaf, 0xa3, 0x64, 0x11, 0xf3, 0x7c, 0xd0, 0x6b, 0x8d,
	0xba, 0xbd, 0x8e, 0x92, 0xe7, 0x18, 0xad, 0xdb, 0x1e, 0x29, 0x65, 0xa6, 0x40, 0xed, 0x50, 0x1b,
	0xec, 0x1d, 0xb5, 0x3b, 0x7a, 0xff, 0xa8, 0xd7, 0x53, 0x14, 0x76, 0x05, 0x36, 0x63, 0xc8, 0x80,
	0x03, 0x77, 0x30, 0xcb, 0xf3, 0x96, 0xd6, 0xd2, 0x9e, 0x2a, 0x3f, 0x61, 0x65, 0xc8, 0xb5, 0x9e,
	0x3e, 0x55, 0x7e, 0x8e, 0x7b, 0xa0, 0xf2, 0xa2, 0xdb, 0xd7, 0x9f, 0xb7, 0x7a, 0x47, 0x1d, 0xe5,
	0xe7, 0xd9, 0x28, 0x3d, 0xd0, 0xf6, 0x3a, 0x9a, 0xf2, 0xf3, 0x3c, 0xdb, 0x82, 0xda, 0xcf, 0x06,
	0xfd, 0xce, 0x41, 0xeb, 0xf0, 0x90, 0x1a, 0xf2, 0xf3, 0xb2, 0xfa, 0xc7, 0x79, 0xc8, 0x63, 0x4f,
	0x98, 0x9a, 0xec, 0xf7, 0xb8, 0x8b, 0xb8, 0xe1, 0x76, 0xf3, 0x7f, 0xfc, 0xa7, 0x77, 0x36, 0xf8,
	0x4e, 0x7f, 0x03, 0x72, 0x8e, 0x1d, 0xd2, 0x44, 0xc5, 0xab, 0x44, 0xe8, 0x40, 0xfb, 0x1b, 0x1a,
	0xe2, 0xd8, 0x6d, 0xc8, 0xf0, 0x2d, 0x5f, 0x7d, 0xd8, 0x10, 0xcb, 0x48, 0xc8, 0x8c, 0xfd, 0x0d,
	0x2d, 0x33, 0x67, 0xb7, 0x20, 0xf3, 0x52, 0xec, 0xff, 0x1a, 0xc7, 0x73, 0xa9, 0x81, 0xd8, 0x97,
	0x6c, 0x07, 0x72, 0x13, 0x8f, 0x6b, 0x38, 0x31, 0x9e, 0xf3, 0x50, 0x2c, 0x7f, 0xe2, 0x39, 0xec,
	0x4d, 0xc8, 0xf9, 0xc6, 0x19, 0xed, 0x95, 0x78, 0xba, 0x62, 0x26, 0x8d, 0x44, 0xbe, 0x71, 0x86,
	0x8d, 0x98, 0xd2, 0x8e, 0x89, 0x1b, 0x11, 0xcd, 0x37, 0x56, 0x33, 0x65, 0x3b, 0x90, 0x39, 0xa3,
	0x3d, 0x13, 0x0b, 0xf5, 0x17, 0xb6, 0x6b, 0x7a, 0x67, 0xc3, 0xb9, 0x35, 0x41, 0x8a, 0x33, 0xf6,
	0x3d, 0xc8, 0x05, 0x8b, 0x31, 0xed, 0x99, 0xea, 0xc3, 0xad, 0x15, 0xee, 0x87, 0x15, 0x05, 0x8b,
	0x31, 0x7b, 0x0b, 0xf2, 0x13, 0xcf, 0xf7, 0xc5, 0xbe, 0x51, 0xa2, 0x06, 0x47, 0x8c, 0x1f, 0x95,
	0x1c, 0xc4, 0x63, 0x85, 0x21, 0xe9, 0x48, 0x31, 0x51, 0xc2, 0x79, 0xb1, 0xc2, 0x90, 0xdd, 0x15,
	0xec, 0xbc, 0x26, 0xb7, 0x3a, 0x62, 0xf6, 0x58, 0x0e, 0x62, 0x71, 0x92, 0x66, 0xc6, 0x39, 0x69,
	0x50, 0x31, 0x51, 0xc4, 0xe5, 0xb1, 0x4d, 0x33, 0xe3, 0x9c, 0xdd, 0x85, 0xdc, 0x4b, 0x6b, 0x42,
	0xca, 0x54, 0x5c, 0x9b, 0x98, 0xa4, 0xe7, 0xd4, 0x3d, 0x44, 0xa3, 0xdc, 0x32, 0x16, 0xe7, 0xb8,
	0xed, 0x36, 0xb9, 0x84, 0x31, 0x16, 0xe7, 0x5d, 0x13, 0x39, 0x98, 0x6b, 0xbe, 0x24, 0x6d, 0x2a,
	0xa3, 0xe1, 0x27, 0x6a, 0xf2, 0x81, 0xe5, 0x58, 0x93, 0xd0, 0x7e, 0x69, 0x87, 0x17, 0xa4, 0x42,
	0x65, 0x34, 0x19, 0xb4, 0x5b, 0x84, 0xbc, 0x75, 0x3e, 0xf7, 0xd5, 0x87, 0x00, 0x49, 0x3d, 0x58,
	0x92, 0x63, 0xb9, 0x91, 0x86, 0xe0, 0x58, 0x2e, 0x72, 0x00, 0xd3, 0x08, 0x0d, 0x5a, 0x3e, 0x35,
	0x8d, 0xbe, 0xd5, 0x1b, 0x50, 0x89, 0x55, 0x2f, 0x56, 0x83, 0x8c, 0x21, 0x38, 0x6f, 0xc6, 0x50,
	0xef, 0xa1, 0x26, 0x14, 0x29, 0x57, 0x69, 0x1c, 0xa6, 0x22, 0x7e, 0x9c, 0x19, 0xab, 0x3f, 0x84,
	0x9a, 0x66, 0x05, 0x0b, 0x27, 0x6c, 0x7b, 0xce, 0x9e, 0x35, 0x65, 0xef, 0x02, 0xc4, 0xe9, 0x40,
	0x08, 0xc8, 0x64, 0x31, 0xed, 0x59, 0x53, 0x4d, 0xc2, 0xab, 0xbf, 0x97, 0x27, 0x55, 0x63, 0x8f,
	0xcb, 0x78, 0x21, 0xcc, 0x33, 0x92, 0x30, 0x8f, 0x59, 0x57, 0x36, 0xad, 0xd0, 0x9c, 0xd8, 0xa6,
	0x69, 0xb9, 0x91, 0xe2, 0xc2, 0x53, 0x38, 0xfa, 0x86, 0x73, 0x4c, 0x2b, 0xbc, 0xf1, 0x90, 0x45,
	0x95, 0xce, 0xe6, 0xbe, 0x15, 0x04, 0x5c, 0x64, 0x1a, 0xce, 0x71, 0xb4, 0xd9, 0x0a, 0xbf, 0x6a,
	0xb3, 0xdd, 0x80, 0xb2, 0xeb, 0x85, 0x3a, 0x99, 0x15, 0x45, 0xaa, 0xa3, 0x24, 0xec, 0x27, 0xf6,
	0x36, 0x94, 0x84, 0x42, 0x28, 0x56, 0xb9, 0xd8, 0x8b, 0x7b, 0x1c, 0xa8, 0x45, 0x58, 0xd6, 0x44,
	0xfd, 0x62, 0x36, 0xb3, 0xdc, 0x30, 0x12, 0x11, 0x22, 0xc9, 0xbe, 0x0f, 0x15, 0xcf, 0xd5, 0xb9,
	0xd6, 0x28, 0x96, 0xb9, 0x58, 0x4f, 0x03, 0xf7, 0x88, 0xa0, 0x5a, 0xd9, 0x13, 0x5f, 0xd8, 0x14,
	0xc7, 0x3b, 0xd3, 0x27, 0x86, 0x6f, 0xd2, 0x52, 0x2f, 0x6b, 0x25, 0xc7, 0x3b, 0x6b, 0x1b, 0xbe,
	0xc9, 0x45, 0xe6, 0xd7, 0xee, 0x62, 0x46, 0xcb, 0xbb, 0xae, 0x89, 0x14, 0xbb, 0x05, 0x95, 0x89,
	0xb3, 0x08, 0x42, 0xcb, 0xdf, 0xbd, 0xe0, 0x76, 0x80, 0x96, 0x00, 0xb0, 0x5d, 0x73, 0xdf, 0x9e,
	0x19, 0xfe, 0x05, 0xad, 0xe5, 0xb2, 0x16, 0x25, 0x51, 0x55, 0x99, 0x9f, 0xda, 0xe6, 0x39, 0x37,
	0x06, 0x34, 0x9e, 0x40, 0xfa, 0x13, 0x32, 0xd5, 0x02, 0x5a, 0xae, 0x65, 0x2d, 0x4a, 0xd2, 0x3c,
	0xd0, 0x27, 0xad, 0xd9, 0x8a, 0x26, 0x52, 0x29, 0x7d, 0x6f, 0xeb, 0x52, 0x7d, 0x8f, 0xa5, 0xf4,
	0xbd, 0xaf, 0xa1, 0x24, 0x46, 0x10, 0x39, 0x3e, 0xae, 0xe9, 0x34, 0x3b, 0xe4, 0x1c, 0x1f, 0xe1,
	0xec, 0x4d, 0xa8, 0x7b, 0xbe, 0x7d, 0x6c, 0xbb, 0x7a, 0x10, 0xfa, 0xb6, 0x7b, 0x2c, 0xd6, 0x46,
	0x8d, 0x03, 0x87, 0x04, 0x43, 0x31, 0x85, 0xb3, 0xa7, 0x1b, 0x63, 0xdb, 0xc1, 0xbd, 0x93, 0x13,
	0x56, 0xf0, 0xc2, 0x71, 0x5a, 0x1c, 0xa4, 0x0e, 0xa0, 0x1c, 0x8d, 0xf7, 0x6f, 0xa4, 0x4e, 0xf5,
	0xb7, 0xa0, 0xda, 0x75, 0x4d, 0xeb, 0x7c, 0x40, 0x92, 0x97, 0xbd, 0x0b, 0x6c, 0xe2, 0x5b, 0x46,
	0x68, 0xe9, 0xd6, 0x79, 0xe8, 0x1b, 0x3a, 0xb7, 0x94, 0xb9, 0x95, 0xaa, 0x70, 0x4c, 0x07, 0x11,
	0x23, 0x84, 0xab, 0xff, 0x25, 0x03, 0xf5, 0x43, 0x3e, 0x11, 0xcf, 0xac, 0x8b, 0x3d, 0xae, 0xcb,
	0x4f, 0xa2, 0x4d, 0x94, 0xd7, 0xe8, 0x9b, 0xdd, 0x86, 0xea, 0xfc, 0xd4, 0xba, 0xd0, 0x53, 0x7a,
	0x6f, 0x05, 0x41, 0x6d, 0xda, 0x2e, 0xef, 0x40, 0xd1, 0xa3, 0xda, 0x85, 0x1c, 0x10, 0xec, 0x53,
	0x6a, 0x96, 0x26, 0x08, 0x98, 0x0a, 0xf5, 0xb8, 0x28, 0x59, 0x92, 0x8b, 0xc2, 0x68, 0xba, 0xb6,
	0xa1, 0x80, 0xa8, 0xa0, 0x59, 0xd8, 0xc9, 0xa1, 0xf2, 0x4a, 0x09, 0xf6, 0x3e, 0xd4, 0x27, 0xde,
	0x6c, 0xae, 0x47, 0xd9, 0x85, 0x44, 0x48, 0x6f, 0xf3, 0x2a, 0x92, 0x1c, 0xf2, 0xb2, 0xd4, 0xdf,
	0xcf, 0x41, 0x99, 0xda, 0x20, 0x76, 0xba, 0x6d, 0x9e, 0x47, 0x3b, 0xbd, 0xa2, 0x15, 0x6c, 0x13,
	0xd9, 0xdf, 0xeb, 0x00, 0x36, 0x92, 0xe8, 0xd2, 0x7e, 0xaf, 0x10, 0x24, 0x6a, 0xca, 0xdc, 0xf0,
	0xc3, 0xa0, 0x99, 0xe3, 0x4d, 0xa1, 0x04, 0x2e, 0xc1, 0x85, 0x6b, 0x7f, 0xbd, 0xe0, 0xad, 0x2f,
	0x6b, 0x22, 0xc5, 0xee, 0x81, 0xc2, 0x0b, 0xa3, 0x41, 0x97, 0x55, 0x91, 0x06, 0xc1, 0x69, 0xcc,
	0x23, 0x5d, 0x8f, 0xd3, 0x58, 0xe7, 0x28, 0x03, 0xf8, 0x6e, 0x07, 0x02, 0x75, 0x10, 0x22, 0xef,
	0xe3, 0x52, 0x7a, 0x1f, 0x37, 0xa1, 0xf4, 0xd2, 0x0e, 0x6c, 0x9c, 0xd5, 0x32, 0xdf, 0x19, 0x22,
	0x29, 0x4d, 0x43, 0xe5, 0x55, 0xd3, 0x10, 0x77, 0xdb, 0x70, 0x8e, 0xb9, 0x12, 0x18, 0x75, 0xbb,
	0xe5, 0x1c, 0x7b, 0xec, 0x03, 0xb8, 0x9a, 0xa0, 0x45, 0x6f, 0xc8, 0x25, 0x42, 0x56, 0xbf, 0xc6,
	0x62, 0x4a, 0xea, 0x11, 0x69, 0xe9, 0xf7, 0x61, 0x4b, 0xca, 0x32, 0x47, 0x15, 0x20, 0x20, 0x36,
	0x50, 0xd1, 0x36, 0x63, 0x72, 0xd2, 0x0c, 0x02, 0xf5, 0xdf, 0x64, 0xa1, 0xfe, 0xc4, 0xf3, 0x2d,
	0xfb, 0xd8, 0x4d, 0x56, 0xdd, 0x8a, 0xae, 0x18, 0xad, 0xc4, 0xac, 0xb4, 0x12, 0xef, 0x40, 0x75,
	0xca, 0x33, 0xea, 0xe1, 0x98, 0x9b, 0x90, 0x79, 0x0d, 0x04, 0x68, 0x34, 0x76, 0x70, 0x07, 0x46,
	0x04, 0x94, 0x39, 0x4f, 0x99, 0xa3, 0x4c, 0xc8, 0xfe, 0xd9, 0x67, 0xc4, 0x08, 0x4d, 0xcb, 0xb1,
	0x42, 0x3e, 0x3d, 0x8d, 0x87, 0xaf, 0x0b, 0x9d, 0x41, 0x6e, 0xd3, 0x03, 0xcd, 0x9a, 0xb6, 0x48,
	0x85, 0x40, 0xbe, 0xb8, 0x47, 0xe4, 0x22, 0xaf, 0x60, 0xa2, 0xc5, 0x6f, 0x99, 0x97, 0xef, 0x76,
	0x75, 0x04, 0x95, 0x18, 0x8c, 0xfa, 0xa0, 0xd6, 0x11, 0x3a, 0xe0, 0x06, 0xab, 0x42, 0xa9, 0xdd,
	0x1a, 0xb6, 0x5b, 0x7b, 0x1d, 0x25, 0x83, 0xa8, 0x61, 0x67, 0xc4, 0xf5, 0xbe, 0x2c, 0xdb, 0x84,
	0x2a, 0xa6, 0xf6, 0x3a, 0x4f, 0x5a, 0x47, 0xbd, 0x91, 0x92, 0x63, 0x75, 0xa8, 0xf4, 0x07, 0x7a,
	0xab, 0x3d, 0xea, 0x0e, 0xfa, 0x4a, 0x5e, 0xfd, 0x09, 0x94, 0xdb, 0x27, 0xd6, 0xe4, 0xf4, 0xb2,
	0x51, 0x24, 0x13, 0xcc, 0x9a, 0x9c, 0x0a, 0x1d, 0x6e, 0xc9, 0x04, 0xb3, 0x26, 0xa7, 0xea, 0x73,
	0xa8, 0xb5, 0x23, 0x3e, 0x7d, 0x59, 0x29, 0x0f, 0xa1, 0x41, 0x9b, 0x6f, 0x32, 0x8e, 0x76, 0x5f,
	0x76, 0xcd, 0xee, 0xab, 0x21, 0x4d, 0x7b, 0x2c, 0xb6, 0xdf, 0x47, 0x50, 0x3d, 0xf4, 0xbd, 0xb9,
	0xe5, 0x87, 0x54, 0xac, 0x02, 0xb9, 0x53, 0xeb, 0x42, 0x94, 0x8a, 0x9f, 0x89, 0x91, 0x9a, 0x95,
	0x8d, 0xd4, 0x87, 0x50, 0x8e, 0xb2, 0x7d, 0xeb, 0x3c, 0x3f, 0x46, 0x2e, 0x46, 0x79, 0x6c, 0x2b,
	0xc0, 0xca, 0x1e, 0x00, 0xcc, 0x63, 0x80, 0x50, 0x08, 0x22, 0xed, 0x54, 0x14, 0xae, 0x49, 0x14,
	0xea, 0x9f, 0xe7, 0xa0, 0x71, 0x68, 0xf8, 0xa1, 0x8d, 0x93, 0xc3, 0x87, 0xe1, 0x6d, 0xc8, 0xd3,
	0x92, 0xe7, 0xf6, 0xf0, 0x95, 0x58, 0xb5, 0xe5, 0x34, 0x24, 0xd9, 0x89, 0x80, 0x7d, 0x06, 0x8d,
	0x79, 0x04, 0xd6, 0x89, 0x9f, 0xf3, 0xb1, 0x59, 0xce, 0x42, 0x63, 0x5e, 0x9f, 0xcb, 0x49, 0xf6,
	0x23, 0xd8, 0x4e, 0xe7, 0xb5, 0x82, 0x20, 0xe1, 0xa3, 0xf2, 0x64, 0x5d, 0x49, 0x65, 0xe4, 0x64,
	0xac, 0x0d, 0x5b, 0x49, 0xf6, 0x89, 0xe7, 0x2c, 0x66, 0x6e, 0x20, 0x74, 0xed, 0x6b, 0x4b, 0xb5,
	0xb7, 0x39, 0x56, 0x53, 0xe6, 0x4b, 0x10, 0xa6, 0x42, 0x2d, 0x86, 0xf5, 0x17, 0x33, 0xda, 0x12,
	0x79, 0x2d, 0x05, 0x63, 0x8f, 0x00, 0xe2, 0x74, 0xd0, 0x2c, 0xd2, 0x78, 0x2e, 0xf7, 0xaf, 0x1b,
	0x5a, 0x33, 0x4d, 0x22, 0x43, 0x8d, 0x00, 0x99, 0x81, 0x6f, 0x87, 0x27, 0x33, 0xe2, 0x62, 0x39,
	0x2d, 0x01, 0x10, 0xb3, 0x0c, 0x74, 0x34, 0xd9, 0xe2, 0x2c, 0x82, 0xa1, 0x35, 0xec, 0x60, 0xb8,
	0x18, 0xc7, 0xe5, 0xa2, 0x18, 0x4c, 0x7a, 0x39, 0x0b, 0x8e, 0x85, 0x61, 0x9b, 0xb4, 0xf0, 0x20,
	0x38, 0x66, 0x0f, 0xe1, 0x6a, 0x42, 0x94, 0xf0, 0xdf, 0xa0, 0x09, 0xc4, 0xb9, 0x93, 0xe1, 0x8b,
	0x99, 0x70, 0xa0, 0x7e, 0x0e, 0xf5, 0xd4, 0xec, 0xbc, 0x52, 0x20, 0xdf, 0x80, 0x32, 0xfe, 0x47,
	0x71, 0x2c, 0x16, 0x60, 0x09, 0xd3, 0xc3, 0xd0, 0x57, 0x2d, 0x50, 0x96, 0xc7, 0x9a, 0xdd, 0x25,
	0x67, 0x0f, 0x4d, 0xca, 0xaa, 0xd3, 0x26, 0x42, 0xa1, 0xed, 0xbe, 0x3a, 0x89, 0x59, 0x6a, 0xf5,
	0xca, 0x64, 0xa9, 0xff, 0x20, 0x2b, 0xb5, 0x19, 0x47, 0x9c, 0x7d, 0x4f, 0x5e, 0x7e, 0xd2, 0xc6,
	0x4d, 0xc6, 0x8c, 0x24, 0xce, 0x3b, 0xa0, 0x78, 0xbe, 0x69, 0xbb, 0x06, 0x39, 0x9f, 0xf8, 0x70,
	0x67, 0x49, 0x81, 0xdb, 0x14, 0xf0, 0x43, 0x01, 0x46, 0x03, 0xc0, 0xb4, 0x62, 0x5b, 0x5e, 0x58,
	0xe2, 0x32, 0x48, 0x96, 0x4e, 0xf9, 0xb4, 0x74, 0x7a, 0x1b, 0x2a, 0x8e, 0x15, 0x04, 0x7a, 0x78,
	0x62, 0xb8, 0x24, 0xbf, 0xd3, 0x9d, 0x2e, 0x23, 0x72, 0x74, 0x62, 0xb8, 0x48, 0x68, 0xbb, 0xba,
	0xf0, 0xd6, 0x17, 0x57, 0x09, 0x6d, 0x97, 0x6c, 0x1c, 0x94, 0xfb, 0xdb, 0xeb, 0x26, 0x56, 0x88,
	0x45, 0xb6, 0x3a, 0xaf, 0xea, 0xeb, 0x50, 0x7a, 0x6e, 0x5b, 0x67, 0x82, 0x97, 0xbd, 0xb4, 0xad,
	0xb3, 0x88, 0x97, 0xe1, 0xb7, 0xfa, 0x9f, 0xcb, 0x50, 0x26, 0xe2, 0xbd, 0xcb, 0x9d, 0x7c, 0xdf,
	0xc5, 0x00, 0xd8, 0x11, 0x72, 0x2a, 0xbf, 0xc6, 0xec, 0xe0, 0x52, 0xeb, 0x75, 0x00, 0x49, 0x86,
	0x72, 0x8d, 0xa0, 0x12, 0xc6, 0xa2, 0x13, 0x35, 0x67, 0x52, 0xcc, 0x82, 0xaf, 0x1d, 0xe1, 0x13,
	0x4a, 0x00, 0xec, 0x01, 0xd7, 0x6b, 0xc9, 0x67, 0x51, 0x92, 0x19, 0x0b, 0xf5, 0x21, 0x32, 0x73,
	0x49, 0xd9, 0xc5, 0x04, 0xe9, 0x07, 0x96, 0x1f, 0x44, 0xdb, 0xa9, 0xae, 0x45, 0x49, 0xe4, 0x68,
	0xa8, 0x3c, 0x09, 0xb3, 0x34, 0xda, 0xbe, 0xb2, 0xf6, 0xa7, 0x11, 0x01, 0xbb, 0x07, 0x25, 0x12,
	0xd9, 0x16, 0x4a, 0x70, 0x89, 0x75, 0x46, 0xca, 0x94, 0x16, 0xa1, 0xd9, 0x3b, 0x50, 0x98, 0x9e,
	0x5a, 0x17, 0x41, 0xb3, 0x2e, 0xb3, 0x84, 0x94, 0x2c, 0xd4, 0x38, 0x05, 0xbb, 0x0b, 0x0d, 0xdf,
	0x9a, 0xea, 0xe4, 0xf6, 0x43, 0xe1, 0x1d, 0x34, 0x1b, 0x24, 0x9b, 0x6b, 0xbe, 0x35, 0x6d, 0x23,
	0x70, 0x34, 0x76, 0x02, 0xf6, 0x16, 0x14, 0x49, 0x2a, 0xa1, 0xda, 0x2f, 0xd5, 0x1c, 0x89, 0x38,
	0x4d, 0x60, 0xd9, 0x43, 0xa8, 0x24, 0x6c, 0xe3, 0x2a, 0x75, 0x68, 0x7b, 0x89, 0x1f, 0x11, 0x1b,
	0xd7, 0x12, 0x32, 0xf6, 0x01, 0x80, 0x30, 0x48, 0xf4, 0xf1, 0x05, 0x39, 0xd2, 0xab, 0xb1, 0xc1,
	0x26, 0x09, 0x40, 0xd9, 0x6c, 0x79, 0x1b, 0x0a, 0x28, 0x25, 0x82, 0xe6, 0x75, 0x6a, 0xcd, 0x56,
	0x5a, 0x84, 0x50, 0xef, 0x08, 0xcf, 0xee, 0x41, 0x19, 0x17, 0x97, 0x8e, 0x53, 0xd8, 0x94, 0x2d,
	0x34, 0xb1, 0x12, 0x51, 0x4b, 0xb3, 0xce, 0x86, 0x5f, 0x3b, 0xec, 0x3e, 0xe4, 0x4d, 0x6b, 0x1a,
	0x34, 0x6f, 0x50, 0x89, 0xd7, 0xa4, 0xb9, 0x44, 0xc5, 0x61, 0xcf, 0x9a, 0x72, 0xd1, 0x82, 0x34,
	0x6c, 0x1f, 0x1a, 0xb8, 0xf4, 0x1e, 0x92, 0xe2, 0x8d, 0x43, 0xde, 0xbc, 0x49, 0xb9, 0xde, 0x58,
	0xca, 0xd5, 0x17, 0x44, 0x34, 0x41, 0x1d, 0x37, 0xf4, 0x2f, 0xb4, 0xba, 0x2b, 0xc3, 0xd8, 0x4d,
	0x28, 0xdb, 0x41, 0xcf, 0x9b, 0x9c, 0x5a, 0x66, 0xf3, 0x35, 0x7e, 0xf6, 0x16, 0xa5, 0xd9, 0xa7,
	0x50, 0xa7, 0xc5, 0x88, 0x49, 0xac, 0xbc, 0x79, 0x4b, 0x16, 0x79, 0x23, 0x19, 0xa5, 0xa5, 0x29,
	0x51, 0xdd, 0xb2, 0x03, 0x3d, 0xb4, 0x66, 0x73, 0xcf, 0x47, 0xdb, 0xee, 0x75, 0x6e, 0xf0, 0xd8,
	0xc1, 0x28, 0x02, 0x21, 0x9f, 0x8f, 0x8f, 0xfd, 0x74, 0x6f, 0x3a, 0x0d, 0xac, 0xb0, 0x79, 0x9b,
	0xf6, 0x5a, 0x23, 0x3a, 0xfd, 0x1b, 0x10, 0x94, 0x94, 0xd2, 0x40, 0x37, 0x2f, 0x5c, 0x63, 0x66,
	0x4f, 0x9a, 0x77, 0xb8, 0x09, 0x69, 0x07, 0x7b, 0x1c, 0x20, 0x5b, 0x71, 0x3b, 0xb2, 0x15, 0x77,
	0xf3, 0x29, 0x59, 0x71, 0xd4, 0x9e, 0x8f, 0x96, 0xe4, 0x7e, 0x6a, 0xa1, 0x4b, 0x0a, 0xc2, 0xfe,
	0x86, 0x2c, 0xfe, 0x77, 0x0b, 0x90, 0x33, 0xad, 0xe9, 0xcd, 0x9f, 0x00, 0x5b, 0x1d, 0xc9, 0x57,
	0x29, 0x21, 0x05, 0xa1, 0x84, 0x7c, 0x96, 0x7d, 0x9c, 0x51, 0x3f, 0x85, 0x7a, 0x6a, 0x5b, 0xae,
	0x55, 0xa6, 0xb8, 0x51, 0x61, 0xcc, 0x84, 0x5f, 0x84, 0x27, 0xd4, 0x7f, 0x9f, 0x83, 0xda, 0xbe,
	0x11, 0x9c, 0x1c, 0x18, 0xf3, 0x61, 0x68, 0x84, 0x01, 0x8e, 0xed, 0x89, 0x11, 0x9c, 0xcc, 0x8c,
	0x39, 0x77, 0x8f, 0x67, 0xb8, 0x23, 0x46, 0xc0, 0x86, 0xf6, 0x37, 0x16, 0xce, 0x2a, 0x26, 0x07,
	0xee, 0xe1, 0x33, 0x71, 0xcc, 0x12, 0xa7, 0x91, 0x0f, 0x04, 0x27, 0x8b, 0xe9, 0xd4, 0xb1, 0x04,
	0xbf, 0x8a, 0x92, 0xec, 0x2e, 0xd4, 0xc5, 0x27, 0x99, 0x6f, 0xe7, 0xe2, 0xcc, 0x35, 0x0d, 0x64,
	0x8f, 0xa0, 0x2a, 0x00, 0xa3, 0x88, 0x6b, 0x35, 0x62, 0xc7, 0x58, 0x82, 0xd0, 0x64, 0x2a, 0xf6,
	0x53, 0xb8, 0x2a, 0x25, 0x9f, 0x78, 0xfe, 0xc1, 0xc2, 0x09, 0xed, 0x76, 0x5f, 0xe8, 0xca, 0xaf,
	0xad, 0x64, 0x4f, 0x48, 0xb4, 0xf5, 0x39, 0xd3, 0xad, 0x3d, 0xb0, 0x5d, 0xa1, 0x49, 0xa4, 0x81,
	0x4b, 0x54, 0xc6, 0x39, 0xf1, 0xbe, 0x34, 0x95, 0x71, 0x8e, 0x2b, 0x5d, 0x00, 0x0e, 0xac, 0xf0,
	0xc4, 0x33, 0x49, 0x93, 0x88, 0x57, 0xfa, 0x50, 0x46, 0x69, 0x69, 0x4a, 0x1c, 0x4e, 0x34, 0xe3,
	0x27, 0x6e, 0x48, 0xe6, 0x52, 0x4e, 0x8b, 0x92, 0x28, 0x17, 0x7c, 0xc3, 0x3d, 0xb6, 0x82, 0x66,
	0x75, 0x27, 0x77, 0x2f, 0xa3, 0x89, 0x94, 0xfa, 0x57, 0xb3, 0x50, 0xe0, 0x33, 0xf9, 0x1a, 0x54,
	0xc6, 0x8e, 0x37, 0x39, 0xd5, 0xdd, 0xc5, 0x2c, 0xf2, 0x9d, 0x13, 0x00, 0x55, 0x2b, 0x32, 0x73,
	0x02, 0xee, 0x63, 0xcd, 0x68, 0xf4, 0x8d, 0x45, 0x7a, 0x8b, 0x10, 0xeb, 0xca, 0x11, 0x54, 0xa4,
	0xb0, 0x11, 0xbe, 0x77, 0x46, 0xab, 0x21, 0x4f, 0x88, 0x28, 0x49, 0xee, 0x79, 0x12, 0x31, 0x98,
	0xa9, 0x40, 0xb8, 0x32, 0x01, 0xda, 0x6e, 0xb8, 0xec, 0xd1, 0x2b, 0xae, 0x78, 0xf4, 0xd8, 0x6d,
	0x40, 0x23, 0x6a, 0x62, 0x0d, 0x5c, 0xab, 0xdd, 0xa7, 0x11, 0x2e, 0x6b, 0x12, 0x84, 0x7d, 0x1c,
	0xaf, 0x45, 0xea, 0x91, 0x70, 0xa5, 0x0a, 0xe6, 0x29, 0xaf, 0x5a, 0x2d, 0x45, 0xa7, 0xbe, 0x00,
	0xd0, 0xbc, 0xb3, 0xc0, 0x0a, 0x49, 0xbd, 0xba, 0x4e, 0xcd, 0x4f, 0x9d, 0x8a, 0x79, 0x67, 0x87,
	0x5e, 0x10, 0x1d, 0x2e, 0x66, 0xe3, 0xc3, 0xc5, 0x58, 0x13, 0xcb, 0xad, 0xd7, 0xc4, 0xd4, 0xf7,
	0xa0, 0x84, 0x22, 0xd6, 0x08, 0x0d, 0x76, 0x57, 0x78, 0x19, 0xb9, 0x8a, 0x25, 0xfc, 0x9f, 0x49,
	0xad, 0xc2, 0xef, 0xd8, 0x8b, 0x5a, 0x42, 0x79, 0xde, 0x90, 0xbc, 0x1c, 0x31, 0xab, 0x16, 0x05,
	0x0a, 0xa1, 0xfd, 0x1a, 0x54, 0xb0, 0xb1, 0x74, 0xc0, 0x20, 0x5a, 0x56, 0xf6, 0xbd, 0xb3, 0x36,
	0xa6, 0xd5, 0xff, 0x9a, 0x81, 0xea, 0xc0, 0x37, 0x51, 0x46, 0x0c, 0xe7, 0xd6, 0xe4, 0x95, 0x8a,
	0x23, 0x8a, 0x78, 0xcf, 0x71, 0x8c, 0x58, 0xed, 0x42, 0x11, 0x1f, 0x01, 0xd8, 0x07, 0x90, 0x9f,
	0x3a, 0xc6, 0x31, 0x75, 0x36, 0x36, 0x28, 0xa5, 0xe2, 0xa3, 0xef, 0x27, 0x8e, 0x71, 0xac, 0x11,
	0xa9, 0xfa, 0x3b, 0x71, 0xfd, 0x74, 0x04, 0x21, 0x1f, 0x3c, 0x6c, 0xd0, 0x61, 0xd7, 0xb0, 0xad,
	0x64, 0x58, 0x19, 0xf2, 0x7b, 0x9d, 0x61, 0x9b, 0x9b, 0x91, 0x68, 0x50, 0x0e, 0xf5, 0x27, 0x5d,
	0x6d, 0x38, 0x52, 0xf2, 0x74, 0x7a, 0x46, 0x80, 0x5e, 0x6b, 0x38, 0x52, 0xca, 0x0c, 0xa0, 0x78,
	0xd4, 0xef, 0xfe, 0xf4, 0xa8, 0xa3, 0x28, 0xea, 0x7f, 0xca, 0x00, 0x24, 0xfe, 0x71, 0xf6, 0x7d,
	0xa8, 0x9e, 0x51, 0x4a, 0x97, 0x0e, 0x4e, 0xe4, 0x3e, 0x02, 0x47, 0x93, 0xfa, 0xf1, 0x03, 0xc9,
	0x9a, 0x40, 0x31, 0xbb, 0x7a, 0x82, 0x52, 0x9d, 0x27, 0x12, 0x9a, 0xbd, 0x0b, 0x65, 0x0f, 0xfb,
	0x81, 0xa4, 0x39, 0x59, 0xc6, 0x4a, 0xdd, 0xd7, 0x4a, 0x1e, 0x4f, 0xa0, 0x38, 0x9e, 0xfa, 0x91,
	0xd7, 0x28, 0x26, 0x7d, 0x82, 0xa0, 0xb6, 0x63, 0x2c, 0x02, 0x4b, 0xe3, 0xf8, 0x98, 0xed, 0x16,
	0x12, 0xb6, 0xab, 0xfe, 0x0c, 0x1a, 0x43, 0x63, 0x36, 0xe7, 0xcc, 0x99, 0x3a, 0xc6, 0x20, 0x8f,
	0x6b, 0x42, 0x2c, 0x46, 0xfa, 0xc6, 0x2d, 0x76, 0x68, 0xf9, 0x13, 0xcb, 0x8d, 0x76, 0x64, 0x94,
	0x44, 0x66, 0x7b, 0x14, 0xd8, 0xee, 0xb1, 0xe6, 0x9d, 0x45, 0xe1, 0x2b, 0x51, 0x5a, 0xfd, 0x47,
	0x19, 0xa8, 0x4a, 0xcd, 0x60, 0xef, 0xa5, 0x8c, 0xc7, 0xd7, 0x56, 0xda, 0xc9, 0xbf, 0x25, 0x23,
	0xf2, 0x2d, 0x28, 0x04, 0xa1, 0xe1, 0x47, 0x47, 0x2d, 0x8a, 0x94, 0x63, 0xd7, 0x5b, 0xb8, 0xa6,
	0xc6, 0xd1, 0x4c, 0x85, 0x9c, 0xe5, 0x9a, 0x62, 0x5b, 0xac, 0x52, 0x21, 0x52, 0xdd, 0x81, 0x4a,
	0x5c, 0x3c, 0x2e, 0x01, 0x6d, 0xf0, 0x62, 0xa8, 0x6c, 0xb0, 0x0a, 0x14, 0xb4, 0x56, 0xff, 0x69,
	0x47, 0xc9, 0xa8, 0xff, 0x2c, 0x03, 0x90, 0xe4, 0x62, 0x0f, 0x52, 0xad, 0xbd, 0xb9, 0x5c, 0xea,
	0x03, 0xfa, 0x2b, 0x35, 0xf6, 0x16, 0x54, 0x16, 0x2e, 0x01, 0x2d, 0x53, 0xc8, 0x9d, 0x04, 0xc0,
	0x6e, 0x41, 0x2e, 0x0a, 0x74, 0x59, 0x0a, 0x2e, 0x78, 0x69, 0x38, 0xea, 0x67, 0x50, 0x89, 0x8b,
	0x63, 0x75, 0xa8, 0x3c, 0x19, 0xf4, 0x7a, 0x83, 0x17, 0xdd, 0xfe, 0x53, 0x65, 0x03, 0x93, 0x87,
	0x5a, 0xa7, 0xdd, 0xd9, 0xc3, 0x64, 0x06, 0xd7, 0x6c, 0xfb, 0x48, 0xd3, 0x3a, 0xfd, 0x91, 0xae,
	0x0d, 0x5e, 0x28, 0x59, 0xf5, 0xaf, 0xe7, 0x61, 0x6b, 0xe0, 0xee, 0x2d, 0xe6, 0x8e, 0x3d, 0x31,
	0x42, 0xeb, 0x99, 0x75, 0xd1, 0x0e, 0xcf, 0x51, 0x9c, 0x1a, 0x61, 0xe8, 0xf3, 0xcd, 0x5c, 0xd1,
	0x78, 0x82, 0xfb, 0xe2, 0x02, 0xcb, 0x0f, 0xc9, 0xd5, 0x28, 0xef, 0xe2, 0x06, 0x87, 0xb7, 0x3d,
	0x87, 0xf6, 0x32, 0xfb, 0x11, 0x5c, 0xe5, 0xfe, 0x3b, 0x4e, 0x89, 0xfa, 0xa5, 0x2e, 0x78, 0xcf,
	0xf2, 0xd2, 0x65, 0x9c, 0x10, 0xb3, 0x22, 0x19, 0x31, 0xb5, 0x3b, 0x50, 0x4d, 0xb2, 0x73, 0x2b,
	0xa0, 0xa2, 0x41, 0x4c, 0x48, 0x2d, 0xf1, 0x5c, 0xdd, 0x8c, 0x5a, 0xad, 0xdb, 0xe6, 0x39, 0x59,
	0x46, 0x05, 0xad, 0xe1, 0x25, 0x9d, 0x41, 0x91, 0xfb, 0x05, 0x6c, 0xa5, 0x28, 0xa9, 0x15, 0xdc,
	0x36, 0x7a, 0x37, 0x72, 0xd5, 0x2f, 0xf5, 0x5e, 0x86, 0x60, 0x73, 0xb8, 0xf2, 0xb7, 0xe9, 0xa5,
	0xa1, 0xc8, 0xcc, 0xec, 0x40, 0xb7, 0x8f, 0x5d, 0xcf, 0xb7, 0x04, 0x7b, 0x2f, 0xdb, 0x41, 0x97,
	0xd2, 0x89, 0x79, 0x22, 0x9d, 0x2c, 0x73, 0x69, 0x12, 0x1d, 0xac, 0x72, 0xb4, 0xcd, 0xe5, 0x65,
	0x5e, 0x2b, 0x51, 0xba, 0x6b, 0xa2, 0x65, 0xce, 0x51, 0x91, 0xc5, 0x01, 0x64, 0x71, 0xd4, 0x08,
	0xf8, 0x9c, 0xc3, 0x6e, 0xf6, 0x61, 0x7b, 0x5d, 0x23, 0xd7, 0xe8, 0x55, 0x3b, 0xb2, 0x5e, 0xb5,
	0xe4, 0xab, 0x4a, 0x74, 0xac, 0x7f, 0x91, 0x85, 0x4a, 0x97, 0x4f, 0x61, 0x78, 0xce, 0xde, 0x80,
	0x9c, 0x6f, 0x4d, 0x2f, 0x3b, 0xcd, 0x45, 0x1c, 0xbb, 0x0f, 0x5b, 0x86, 0x69, 0xea, 0xc6, 0x74,
	0x6a, 0x4d, 0x42, 0xcb, 0xd4, 0x51, 0x66, 0x8a, 0x65, 0xbb, 0x69, 0x98, 0x66, 0x4b, 0xc0, 0x69,
	0xfb, 0x73, 0xaf, 0x44, 0x64, 0x26, 0x70, 0xe7, 0x79, 0x2e, 0xf2, 0x4a, 0x08, 0x2b, 0x81, 0x34,
	0x3c, 0xf6, 0xfd, 0x48, 0xe2, 0x9a, 0xd6, 0x54, 0xf0, 0xa3, 0x46, 0x5a, 0x2d, 0x17, 0x12, 0x98,
	0xfb, 0xa3, 0xae, 0x2c, 0x1b, 0xb1, 0xb6, 0xc9, 0x1d, 0xdc, 0x79, 0x6d, 0x2b, 0x6d, 0xc3, 0x76,
	0xcd, 0xe0, 0x72, 0x6f, 0x46, 0xf1, 0x52, 0x6f, 0x46, 0xda, 0x4d, 0x82, 0x8b, 0xac, 0x44, 0xcb,
	0x3d, 0x61, 0xc7, 0x5d, 0xf3, 0x5c, 0xfd, 0x6f, 0x59, 0x00, 0xcd, 0x9a, 0x3b, 0xc6, 0xc4, 0xfa,
	0xff, 0x67, 0xf4, 0xee, 0x40, 0x95, 0xbb, 0x6b, 0xf5, 0x89, 0xe7, 0x9a, 0x51, 0x4c, 0x05, 0x07,
	0xb5, 0x3d, 0x62, 0x60, 0x6b, 0x87, 0xb7, 0xf8, 0x9d, 0x87, 0xb7, 0xf4, 0x1d, 0x86, 0xb7, 0xbc,
	0x6e, 0x78, 0xf3, 0x50, 0x6d, 0xb9, 0x86, 0x73, 0xf1, 0x8d, 0x45, 0x51, 0x13, 0xe4, 0x67, 0x9f,
	0x2f, 0x42, 0x3e, 0x6a, 0xfc, 0x34, 0xb3, 0x42, 0x10, 0x1a, 0xaf, 0x3b, 0x50, 0xf5, 0x16, 0x61,
	0x8c, 0xe7, 0xe7, 0x9b, 0xc0, 0x41, 0x44, 0x10, 0xe7, 0x27, 0x9d, 0x2f, 0x27, 0xe5, 0x27, 0xfd,
	0x3f, 0xc9, 0x1f, 0xeb, 0x84, 0x71, 0x7e, 0x22, 0xc0, 0x0d, 0x6a, 0xcf, 0x68, 0xdc, 0x82, 0xc5,
	0xcc, 0xe2, 0x63, 0x97, 0xe3, 0xd1, 0x69, 0x6d, 0x01, 0xc3, 0x52, 0x66, 0xd6, 0xcc, 0xf3, 0x2f,
	0x78, 0x29, 0x45, 0x5e, 0x0a, 0x07, 0x51, 0x29, 0xef, 0x02, 0x3b, 0x33, 0xec, 0x50, 0x4f, 0x17,
	0xc5, 0xf5, 0x70, 0x05, 0x31, 0x23, 0xb9, 0xb8, 0x6b, 0x50, 0x34, 0xed, 0xe0, 0xb4, 0x3b, 0x10,
	0x3a, 0xb8, 0x48, 0x21, 0x0f, 0x0a, 0x1e, 0x75, 0x07, 0xfa, 0xf8, 0x42, 0x1c, 0x40, 0xe6, 0xb4,
	0x32, 0x02, 0x76, 0x2f, 0x42, 0x3a, 0x3a, 0x21, 0x24, 0xef, 0x2d, 0x67, 0xd7, 0x5c, 0xcf, 0x6e,
	0x20, 0xbc, 0x8b, 0x60, 0xce, 0xae, 0xef, 0xc3, 0x16, 0x51, 0x8a, 0x8e, 0x73, 0xd2, 0x2a, 0x91,
	0x6e, 0x22, 0x62, 0x40, 0x70, 0x4e, 0x7b, 0x0b, 0x2a, 0xae, 0x15, 0x9e, 0x79, 0x3e, 0xb6, 0xa6,
	0xc6, 0x47, 0x2f, 0x06, 0xa0, 0x40, 0x0f, 0x26, 0x86, 0x8b, 0x8d, 0xa7, 0x43, 0x49, 0x6c, 0x8f,
	0x48, 0xa3, 0x42, 0xcc, 0xc5, 0x04, 0x61, 0x1b, 0x7c, 0x48, 0x12, 0x08, 0xfb, 0x14, 0x6e, 0xa4,
	0x46, 0x43, 0x37, 0x7c, 0xdf, 0xb8, 0xd0, 0x67, 0xc6, 0x57, 0x9e, 0x4f, 0xae, 0x8b, 0x9c, 0x76,
	0x4d, 0x1e, 0xe4, 0x16, 0xa2, 0x0f, 0x10, 0x7b, 0x69, 0x56, 0xdb, 0xf5, 0xfc, 0xa6, 0x72, 0x59,
	0x56, 0xc4, 0xaa, 0xbe, 0xe4, 0xa5, 0x3e, 0xf4, 0x17, 0xae, 0xc5, 0xed, 0x7a, 0xfa, 0x34, 0xc5,
	0x21, 0x5f, 0x9c, 0x66, 0x7b, 0x70, 0x85, 0xeb, 0xf8, 0x96, 0xa9, 0x4b, 0xde, 0xdb, 0xec, 0xe5,
	0xde, 0x5b, 0x16, 0xd1, 0xc7, 0xe0, 0x40, 0xfd, 0x79, 0x06, 0x6e, 0x0e, 0xe8, 0xc0, 0x91, 0x36,
	0xc3, 0x81, 0x15, 0x04, 0xc6, 0x31, 0x1a, 0x68, 0x4f, 0x16, 0xdf, 0x7c, 0x83, 0xe6, 0xfd, 0xe6,
	0xa1, 0xe1, 0x5b, 0x6e, 0x18, 0x6f, 0x15, 0xc1, 0xd1, 0x97, 0xc1, 0xec, 0x31, 0x79, 0x48, 0x2d,
	0x37, 0x3c, 0x8a, 0x65, 0xa3, 0x68, 0x4b, 0xda, 0x67, 0xb6, 0x42, 0xa5, 0xfe, 0xeb, 0xd7, 0x20,
	0xdf, 0xf7, 0x4c, 0x8b, 0xbd, 0x0f, 0x15, 0x0a, 0x3c, 0x5b, 0x75, 0xcc, 0x23, 0x9a, 0xfe, 0x90,
	0x9a, 0x52, 0x76, 0xc5, 0xd7, 0xe5, 0xa1, 0x6a, 0x6f, 0x90, 0xc2, 0x45, 0x27, 0x7b, 0xc8, 0x7c,
	0xaa, 0xc2, 0x04, 0x24, 0x1b, 0x86, 0x63, 0x70, 0x6c, 0xc9, 0x5b, 0xe5, 0x5b, 0x2e, 0x89, 0xf5,
	0x82, 0x16, 0xa7, 0x49, 0xcd, 0xf5, 0x3d, 0x64, 0x94, 0x3a, 0x45, 0x71, 0x14, 0xd6, 0xa8, 0xb9,
	0x1c, 0x4f, 0xb1, 0x7b, 0xef, 0x43, 0xe5, 0x2b, 0xcf, 0x76, 0x79, 0xc3, 0x8b, 0x2b, 0x0d, 0xff,
	0xdc, 0xb3, 0xf9, 0x89, 0x42, 0xf9, 0x2b, 0xf1, 0xc5, 0xde, 0x84, 0x92, 0xe7, 0xf2, 0xb2, 0x4b,
	0x2b, 0x65, 0x17, 0x3d, 0xb7, 0xc7, 0xa3, 0x43, 0xea, 0xe3, 0x85, 0xed, 0x98, 0x3a, 0x92, 0x5a,
	0xd3, 0x50, 0x38, 0xd0, 0xab, 0x04, 0x1c, 0xb8, 0x3d, 0x6b, 0x1a, 0xa2, 0xf6, 0x3e, 0xb5, 0x1d,
	0xe4, 0xc7, 0x54, 0x58, 0x65, 0xa5, 0x30, 0xe0, 0x68, 0x2a, 0xf0, 0x7b, 0x50, 0x3e, 0xf6, 0xbd,
	0xc5, 0x1c, 0xd5, 0x71, 0x58, 0x75, 0x59, 0x13, 0x6e, 0xf7, 0x02, 0x7b, 0x4f, 0x9f, 0xb6, 0x7b,
	0xac, 0x07, 0x56, 0x48, 0x86, 0xef, 0x52, 0xef, 0x23, 0xfc, 0xd0, 0xa2, 0x52, 0x8d, 0xe3, 0x63,
	0x5d, 0x84, 0xbb, 0xac, 0x94, 0x6a, 0x1c, 0x1f, 0x53, 0xe5, 0x0f, 0xa0, 0x7e, 0x66, 0xbb, 0x7a,
	0x30, 0xb7, 0x26, 0x9c, 0xb6, 0xbe, 0x5a, 0xec, 0x99, 0xed, 0xa2, 0xea, 0x4e, 0xf4, 0xb2, 0xed,
	0xd0, 0x78, 0xa5, 0xed, 0xb0, 0x03, 0x05, 0xc7, 0x9e, 0xd9, 0x21, 0xc5, 0x13, 0x2c, 0x29, 0x17,
	0x84, 0x60, 0x2a, 0x14, 0x85, 0x7f, 0x4a, 0x59, 0x21, 0x11, 0x98, 0xb4, 0xdc, 0xda, 0x7a, 0x85,
	0xdc, 0xba, 0x07, 0x25, 0x6f, 0xfc, 0x95, 0x8e, 0x12, 0x96, 0xad, 0x97, 0xb0, 0x45, 0x6f, 0xfc,
	0x95, 0x66, 0x4d, 0xd9, 0x47, 0xe4, 0xc4, 0xb7, 0xdc, 0x50, 0x8f, 0x32, 0x5c, 0x59, 0x9f, 0xa1,
	0xc6, 0xc9, 0x06, 0x3c, 0xdb, 0x07, 0x50, 0xf5, 0xc9, 0xa8, 0xd5, 0xc9, 0x02, 0xde, 0x96, 0xad,
	0x82, 0xc4, 0xda, 0xd5, 0xc0, 0x4f, 0x2c, 0xdf, 0x37, 0xa1, 0xce, 0x03, 0x03, 0xf8, 0x49, 0x70,
	0x40, 0x7e, 0xd0, 0x8a, 0x56, 0x23, 0x20, 0x3f, 0x25, 0x0e, 0xd8, 0x03, 0x80, 0x48, 0xe0, 0x86,
	0xe7, 0x14, 0x54, 0x1c, 0x37, 0x85, 0x1f, 0x84, 0xb6, 0xc3, 0x73, 0xad, 0x62, 0x46, 0x9f, 0xec,
	0x0d, 0xa8, 0x8d, 0x6d, 0xd7, 0xc4, 0xe5, 0x10, 0x1a, 0xc7, 0x41, 0xb3, 0x49, 0xbb, 0xa5, 0x2a,
	0x60, 0x23, 0xe3, 0x38, 0x60, 0x1f, 0x42, 0xcd, 0xe0, 0x82, 0x91, 0x07, 0x1e, 0xde, 0x90, 0x2d,
	0x38, 0x49, 0x64, 0x6a, 0x55, 0x43, 0x92, 0x9f, 0x9f, 0x00, 0x8b, 0x9c, 0xdf, 0xa4, 0x0d, 0xf3,
	0x75, 0x71, 0x73, 0x65, 0x5d, 0x6c, 0x0a, 0xef, 0x77, 0x1c, 0x2c, 0xfb, 0x09, 0xd4, 0xd3, 0x6a,
	0xc8, 0xad, 0x35, 0xee, 0x5e, 0x9a, 0x32, 0xad, 0x36, 0x91, 0x15, 0x93, 0x37, 0xa1, 0xee, 0x7a,
	0xa1, 0x3e, 0x31, 0x26, 0x27, 0x16, 0x65, 0xe4, 0x2e, 0xcd, 0x9a, 0xeb, 0x85, 0xed, 0x08, 0x86,
	0xe3, 0x13, 0x19, 0x17, 0xe1, 0x39, 0x79, 0x33, 0xe3, 0xf1, 0x89, 0x35, 0x53, 0x94, 0xd3, 0x91,
	0x92, 0x8a, 0xf3, 0xc4, 0x95, 0x2e, 0xca, 0x70, 0x27, 0x35, 0x4f, 0xb1, 0x36, 0xa6, 0x81, 0x9f,
	0x68, 0x66, 0x77, 0xa0, 0x1a, 0x78, 0x0b, 0x7f, 0x62, 0xe9, 0x41, 0x68, 0xcd, 0x9b, 0x3b, 0x34,
	0xa2, 0xc0, 0x41, 0xc3, 0xd0, 0x9a, 0xb3, 0xc7, 0xd0, 0x98, 0xfb, 0x96, 0x2e, 0xcd, 0xd3, 0x1b,
	0x72, 0x17, 0x0f, 0x7d, 0x2b, 0x99, 0xaa, 0xda, 0x5c, 0x4a, 0x45, 0x39, 0xa5, 0x1e, 0xa8, 0x4b,
	0x39, 0x93, 0x4e, 0x60, 0xce, 0x44, 0xd9, 0xfe, 0x31, 0x6c, 0x49, 0x39, 0x17, 0xa7, 0x94, 0xf9,
	0xcd, 0x94, 0xf7, 0x3d, 0x22, 0x3f, 0x3a, 0xc5, 0xec, 0x8d, 0x79, 0x2a, 0xcd, 0x5a, 0x4b, 0xb6,
	0x10, 0x1a, 0x00, 0x77, 0x29, 0xff, 0xf5, 0x4b, 0x0c, 0x9c, 0x94, 0x91, 0xf4, 0x8c, 0x3b, 0x5f,
	0xbb, 0x41, 0xc7, 0x35, 0x9b, 0xdf, 0xe3, 0x11, 0xed, 0x94, 0x60, 0x8f, 0xa0, 0x46, 0x1e, 0xb6,
	0x90, 0xa2, 0xec, 0x82, 0xe6, 0x5b, 0xb2, 0x33, 0x88, 0xdc, 0xd5, 0x84, 0xd0, 0xaa, 0x4e, 0xfc,
	0x1d, 0xb0, 0x8f, 0x61, 0x8b, 0xfb, 0xe5, 0x64, 0x06, 0xf9, 0xf6, 0xea, 0xe2, 0x22, 0xa2, 0x27,
	0x09, 0x97, 0xd4, 0xe0, 0x86, 0xbf, 0x70, 0x49, 0x88, 0x8b, 0x9c, 0x73, 0xdf, 0x1b, 0x5b, 0x3c,
	0xff, 0x3d, 0xca, 0x2f, 0xba, 0xa3, 0x71, 0x32, 0x9e, 0x97, 0xf8, 0xd1, 0x35, 0x5f, 0x06, 0x1d,
	0x62, 0xbe, 0x4b, 0xca, 0xe4, 0x9c, 0x9d, 0xca, 0x7c, 0xe7, 0xbb, 0x94, 0xb9, 0x8b, 0xf9, 0xa8,
	0x4c, 0x06, 0xf9, 0xc5, 0xc2, 0x36, 0x9b, 0xf7, 0x79, 0xfc, 0x1d, 0x7e, 0xb3, 0xef, 0x41, 0xc3,
	0xb7, 0x26, 0x0b, 0x3f, 0xb0, 0x5f, 0x5a, 0x7a, 0x60, 0xbb, 0xa7, 0xcd, 0xef, 0xd3, 0x38, 0xd6,
	0x63, 0xe8, 0xd0, 0x76, 0x4f, 0x71, 0xc5, 0x5a, 0xe7, 0xa1, 0xe5, 0xbb, 0x3a, 0xaa, 0x44, 0xcd,
	0x77, 0xe5, 0x15, 0xdb, 0x21, 0xc4, 0x70, 0x62, 0xb8, 0x1a, 0x58, 0xf1, 0x37, 0xfb, 0x11, 0x6c,
	0x26, 0x0a, 0xf2, 0x1c, 0x55, 0x90, 0xe6, 0x0f, 0xd6, 0x1e, 0xcc, 0x90, 0x7a, 0xa2, 0x25, 0xa7,
	0x96, 0x5c, 0x93, 0x49, 0xaf, 0xad, 0x80, 0xaf, 0xad, 0x07, 0xdf, 0x6a, 0x6d, 0x0d, 0x69, 0x6d,
	0xbd, 0x05, 0x65, 0xdb, 0x0d, 0x2d, 0xff, 0xa5, 0xe1, 0x34, 0xdf, 0x5b, 0x61, 0xe0, 0x31, 0x8e,
	0xdd, 0x85, 0x52, 0xe0, 0xd8, 0xc8, 0x98, 0x9a, 0xef, 0xaf, 0x90, 0x45, 0x28, 0x94, 0xd8, 0x53,
	0xdb, 0x71, 0xb8, 0xc4, 0xfe, 0x60, 0x45, 0x62, 0x3f, 0xb1, 0x1d, 0x87, 0x4b, 0xec, 0xa9, 0xf8,
	0x42, 0x29, 0x47, 0x39, 0xb0, 0xfe, 0x87, 0xab, 0x52, 0x0e, 0x71, 0xcf, 0xe9, 0x8a, 0x4a, 0x35,
	0x20, 0x37, 0x14, 0xf7, 0xa6, 0x3d, 0x92, 0x7b, 0x98, 0xf6, 0x4f, 0x69, 0x10, 0xc4, 0x69, 0xb4,
	0x04, 0x84, 0x13, 0x0e, 0x6d, 0x8f, 0x0f, 0x79, 0xe4, 0x34, 0x87, 0x74, 0xcd, 0x73, 0xf6, 0x3e,
	0xd4, 0xa3, 0x40, 0x13, 0xac, 0x2e, 0x68, 0x7e, 0xb4, 0xd2, 0x82, 0x34, 0x01, 0xdb, 0x83, 0xda,
	0x14, 0x35, 0xb8, 0x19, 0x57, 0xe8, 0x9a, 0x1f, 0x53, 0x43, 0x76, 0x22, 0x09, 0x7a, 0x99, 0xc2,
	0xa7, 0xa5, 0x72, 0xb1, 0x47, 0x50, 0x0f, 0x2c, 0xd7, 0xd4, 0x67, 0x81, 0x90, 0xef, 0x9f, 0x50,
	0xbd, 0x82, 0x19, 0xc6, 0x17, 0xae, 0xb4, 0x2a, 0x52, 0x1d, 0x04, 0x5c, 0xd0, 0x3f, 0x02, 0x5c,
	0x6d, 0x2f, 0x93, 0x4c, 0x8f, 0x2f, 0xc9, 0x84, 0x54, 0x52, 0x26, 0x5c, 0x8a, 0x7a, 0xe0, 0x1a,
	0xf3, 0xe0, 0xc4, 0x0b, 0x9b, 0x9f, 0xca, 0xd2, 0x77, 0x28, 0xa0, 0x5a, 0x0d, 0x89, 0xa2, 0x94,
	0xfa, 0x8b, 0x02, 0x94, 0x23, 0xad, 0x90, 0x55, 0xa1, 0x74, 0xd4, 0x7f, 0xd6, 0x1f, 0xbc, 0xe8,
	0x2b, 0x1b, 0xac, 0x01, 0x40, 0x51, 0xd3, 0xfa, 0xb0, 0xdd, 0xea, 0xf3, 0xdb, 0x04, 0x14, 0xab,
	0xcd, 0xd3, 0x59, 0xb6, 0x05, 0xf5, 0x27, 0x47, 0x7d, 0x8a, 0xb2, 0xe1, 0xa0, 0x1c, 0x82, 0x3a,
	0x5f, 0x70, 0x27, 0x2b, 0x07, 0xe5, 0x11, 0x74, 0xd0, 0x1a, 0x75, 0xb4, 0x6e, 0x04, 0x2a, 0x50,
	0xc0, 0xce, 0xe0, 0x48, 0x6b, 0x8b, 0x92, 0x8a, 0x58, 0xed, 0xa1, 0x36, 0xf8, 0xbc, 0xd3, 0x1e,
	0x29, 0xc0, 0xae, 0xc2, 0x56, 0x5c, 0x46, 0x54, 0xbe, 0x52, 0x65, 0x35, 0x28, 0x47, 0xe5, 0x28,
	0xdb, 0x58, 0xaa, 0xd6, 0x69, 0x1f, 0x69, 0xc3, 0xee, 0xf3, 0x8e, 0xde, 0x1e, 0x75, 0x94, 0xab,
	0xac, 0x0c, 0xf9, 0x61, 0xb7, 0xff, 0x4c, 0xb9, 0xc6, 0xea, 0x50, 0xc1, 0x2f, 0x5e, 0xfa, 0x75,
	0xc6, 0xa0, 0x91, 0xd0, 0x12, 0xac, 0x49, 0xfe, 0xdf, 0xa7, 0x4f, 0x95, 0xdb, 0x58, 0xec, 0x5e,
	0x77, 0x38, 0xea, 0xf6, 0xdb, 0x23, 0xe5, 0x0e, 0x03, 0x28, 0x3e, 0xe9, 0xf6, 0x46, 0x1d, 0x4d,
	0xd9, 0xc1, 0xf2, 0x3e, 0x1f, 0x74, 0xfb, 0xca, 0x1b, 0x14, 0x8b, 0xde, 0x3a, 0x38, 0xec, 0x75,
	0x14, 0x95, 0x6a, 0x19, 0x68, 0x23, 0xe5, 0x4d, 0x56, 0x81, 0xc2, 0x51, 0x1f, 0xdb, 0x76, 0x17,
	0x2b, 0xa4, 0x4f, 0xbd, 0xd5, 0xeb, 0x29, 0xdf, 0x93, 0x1c, 0xc5, 0x6f, 0xe1, 0xf7, 0x8b, 0x6e,
	0x7f, 0x6f, 0xf0, 0x42, 0x79, 0x1b, 0xc9, 0x76, 0xb5, 0x41, 0x6b, 0xaf, 0xdd, 0x1a, 0x8e, 0x94,
	0x7b, 0x58, 0xc0, 0xf0, 0xb0, 0xd7, 0x1d, 0x29, 0xef, 0x20, 0xd5, 0xd3, 0xd6, 0x68, 0xbf, 0xa3,
	0x29, 0xf7, 0xf1, 0xbb, 0x35, 0x1c, 0x76, 0xb4, 0x91, 0xf2, 0x10, 0xbf, 0xbb, 0x7d, 0xfa, 0x7e,
	0x84, 0xdf, 0x7b, 0x9d, 0x5e, 0x67, 0xd4, 0x51, 0x3e, 0xc4, 0x01, 0xd3, 0x3a, 0x87, 0xbd, 0x56,
	0xbb, 0xa3, 0x7c, 0x84, 0x89, 0xde, 0xa0, 0xfd, 0x4c, 0x1f, 0x1c, 0x2a, 0x1f, 0x63, 0x1d, 0xe4,
	0xe6, 0x1e, 0xe2, 0x60, 0x7e, 0x82, 0xe3, 0x14, 0x27, 0xa9, 0x75, 0x8f, 0xb1, 0xda, 0x83, 0x6e,
	0xff, 0x68, 0xa8, 0x7c, 0x8a, 0xc4, 0xf4, 0x49, 0x98, 0xcf, 0xd8, 0x36, 0x28, 0x83, 0xbe, 0xbe,
	0x77, 0x74, 0xd8, 0xeb, 0xb6, 0x5b, 0xa3, 0x8e, 0xfe, 0xac, 0xf3, 0xa5, 0xf2, 0x5b, 0x38, 0xed,
	0x87, 0x5a, 0x47, 0x17, 0xed, 0xf8, 0x61, 0x94, 0x16, 0x6d, 0xf9, 0x11, 0x56, 0x91, 0xe0, 0xf5,
	0xa3, 0x67, 0xca, 0x6f, 0x2f, 0x81, 0x86, 0xcf, 0x94, 0x1f, 0xe3, 0x9c, 0x8f, 0xba, 0x07, 0x1d,
	0x5d, 0x0c, 0xc6, 0x4f, 0x70, 0x20, 0x9f, 0x74, 0x7b, 0x3d, 0xa5, 0x45, 0x3e, 0xcd, 0x96, 0x36,
	0xea, 0xd2, 0x44, 0xef, 0x32, 0x05, 0x6a, 0x4f, 0x8e, 0x7e, 0xf6, 0xb3, 0x2f, 0x75, 0x31, 0x13,
	0x6d, 0x75, 0x01, 0xe5, 0x48, 0xfd, 0xc7, 0xd6, 0x77, 0xfb, 0xfd, 0x8e, 0xa6, 0x6c, 0x60, 0x09,
	0xbd, 0xce, 0x93, 0x91, 0x92, 0x21, 0xbf, 0x6d, 0xf7, 0xe9, 0xfe, 0x48, 0xc9, 0xe2, 0xe7, 0xe0,
	0x08, 0xb3, 0xe5, 0x68, 0xaa, 0x3a, 0x07, 0x5d, 0x25, 0x8f, 0x5f, 0xad, 0xfe, 0xa8, 0xab, 0x14,
	0x68, 0x2a, 0xbb, 0xfd, 0xa7, 0xbd, 0x8e, 0x52, 0x44, 0xe8, 0x41, 0x4b, 0x7b, 0xa6, 0x94, 0x30,
	0x53, 0xeb, 0xf0, 0xb0, 0xf7, 0xa5, 0x52, 0xe6, 0xe5, 0xef, 0x75, 0xbe, 0x50, 0x2a, 0xea, 0x3d,
	0x28, 0xb5, 0x8e, 0x8f, 0x0f, 0xd0, 0xaa, 0xc2, 0xc6, 0x1e, 0xf5, 0x7a, 0xfc, 0x7a, 0xcd, 0xee,
	0x60, 0x34, 0x1a, 0x1c, 0x28, 0x19, 0x5c, 0x44, 0xa3, 0xc1, 0xa1, 0x92, 0x55, 0xbb, 0x50, 0x8e,
	0xb8, 0x9d, 0x74, 0xd5, 0xa1, 0x0c, 0xf9, 0x43, 0xad, 0xf3, 0x9c, 0x1f, 0x32, 0xf4, 0x3b, 0x5f,
	0x60, 0xf3, 0xf0, 0x0b, 0x0b, 0xca, 0x61, 0x45, 0xfc, 0x4e, 0x02, 0xdd, 0x75, 0xe8, 0x75, 0xfb,
	0x9d, 0x96, 0xa6, 0x14, 0xd4, 0x39, 0x94, 0xa3, 0xad, 0xc9, 0xee, 0x42, 0x76, 0x34, 0x14, 0x9e,
	0xa7, 0xed, 0x07, 0xc9, 0x3d, 0xd3, 0x51, 0xf4, 0xa5, 0x65, 0x47, 0x43, 0xf6, 0xdb, 0xb0, 0xc9,
	0x43, 0x21, 0xcc, 0xdd, 0x8b, 0x11, 0x5d, 0x37, 0x11, 0xce, 0xc1, 0xed, 0xf4, 0xbe, 0xe7, 0x38,
	0x6d, 0x99, 0x58, 0xed, 0x41, 0x23, 0x4d, 0x82, 0x96, 0x3d, 0xbf, 0xb7, 0x22, 0xd9, 0xaa, 0x12,
	0x04, 0xad, 0x3e, 0x71, 0xaf, 0x65, 0x4f, 0x04, 0xc8, 0xc4, 0x69, 0xf5, 0x3f, 0x64, 0x00, 0x12,
	0xe9, 0x87, 0xf2, 0x35, 0xb6, 0x44, 0x0b, 0xc2, 0x37, 0x2e, 0xc7, 0xbc, 0x57, 0xf8, 0xd9, 0x13,
	0xbb, 0x06, 0xc5, 0xa9, 0xe7, 0xcf, 0x8c, 0x30, 0xba, 0xd5, 0xc2, 0x53, 0xa8, 0x6b, 0x72, 0x97,
	0x2c, 0x8a, 0x79, 0xd7, 0xe2, 0xa1, 0x5b, 0x79, 0xad, 0x26, 0x80, 0x3d, 0x84, 0xa1, 0x22, 0x68,
	0xb9, 0x13, 0xc7, 0x0b, 0x2c, 0x13, 0x0d, 0x9d, 0x02, 0xc9, 0x72, 0x88, 0x40, 0xbb, 0x17, 0xbc,
	0x43, 0xfe, 0xcc, 0x76, 0xb1, 0xe3, 0x22, 0x7e, 0x44, 0x82, 0xb0, 0xd7, 0xa0, 0xf2, 0x55, 0xe0,
	0x09, 0xdb, 0x93, 0x47, 0xcd, 0x94, 0x11, 0x40, 0x97, 0xc0, 0xfe, 0x49, 0x0e, 0x20, 0x51, 0x8f,
	0x52, 0xbe, 0xde, 0x4c, 0xda, 0xd7, 0xfb, 0x10, 0xae, 0x89, 0x90, 0x6d, 0x11, 0x07, 0x7c, 0xae,
	0xdb, 0xae, 0x3e, 0x36, 0x22, 0xb7, 0x3a, 0x13, 0x58, 0x7e, 0x7c, 0xdc, 0x75, 0x77, 0x8d, 0x90,
	0x3d, 0x86, 0x4d, 0x39, 0x4f, 0x78, 0x31, 0x4f, 0x1f, 0x0b, 0x48, 0x11, 0xf0, 0xf5, 0x24, 0xfb,
	0xe8, 0x62, 0xce, 0xde, 0x87, 0xab, 0xbe, 0x35, 0xf5, 0xad, 0xe0, 0x44, 0x0f, 0x03, 0xb9, 0x32,
	0x7e, 0x56, 0xbd, 0x25, 0x90, 0xa3, 0x20, 0xae, 0xeb, 0x7d, 0xb8, 0x2a, 0x14, 0xa7, 0xa5, 0xe6,
	0xf1, 0x6b, 0x65, 0x5b, 0x1c, 0x29, 0xb7, 0xee, 0x75, 0x00, 0xa1, 0x33, 0x46, 0x97, 0x89, 0xcb,
	0x5a, 0x85, 0xeb, 0x87, 0xa8, 0xe4, 0xbf, 0x0b, 0xcc, 0x0e, 0xf4, 0x25, 0x3f, 0xa1, 0x70, 0x9e,
	0x2b, 0x76, 0x70, 0x98, 0xf2, 0x11, 0x5e, 0xe6, 0x82, 0x2c, 0x5f, 0xe6, 0x82, 0xdc, 0x86, 0x02,
	0xa9, 0x95, 0xe4, 0x09, 0x2b, 0x6b, 0x3c, 0xc1, 0x54, 0xc8, 0xe3, 0x96, 0x24, 0xd7, 0x57, 0xe3,
	0x61, 0xe3, 0x01, 0x5d, 0xc5, 0xc6, 0xf9, 0x41, 0xa8, 0x46, 0x38, 0xf5, 0xef, 0x67, 0xa0, 0x91,
	0x56, 0x85, 0x78, 0x3c, 0x56, 0x12, 0x68, 0x56, 0x48, 0x82, 0xcb, 0x5e, 0x83, 0xca, 0xfc, 0x54,
	0x44, 0x95, 0x45, 0xa7, 0x98, 0xf3, 0x53, 0x1e, 0x4d, 0xc6, 0xde, 0x81, 0xd2, 0xfc, 0x94, 0xaf,
	0x8b, 0xcb, 0xa6, 0xa5, 0x38, 0xe7, 0x81, 0x1e, 0xef, 0x40, 0x69, 0x21, 0x48, 0xf3, 0x97, 0x91,
	0x2e, 0x88, 0x54, 0xdd, 0x81, 0x9a, 0x6c, 0x7c, 0x30, 0x05, 0x72, 0xa8, 0xb2, 0xf0, 0x86, 0xe1,
	0x27, 0xf6, 0xa0, 0x26, 0x5b, 0x19, 0xdf, 0xc6, 0x0d, 0x9d, 0x32, 0xbc, 0xb3, 0xaf, 0x30, 0xbc,
	0x77, 0xe8, 0xb8, 0x5a, 0xa7, 0xb8, 0x93, 0x89, 0x17, 0x5d, 0x35, 0x85, 0x13, 0x23, 0x68, 0x2d,
	0x42, 0xaf, 0xed, 0x39, 0xe2, 0x40, 0x44, 0x04, 0xf2, 0xe6, 0x23, 0xc7, 0x99, 0x88, 0xd4, 0xfd,
	0x87, 0x19, 0xd8, 0x5a, 0xd1, 0xb2, 0xb1, 0x1f, 0xc9, 0x7d, 0x71, 0xfc, 0x44, 0xb3, 0x77, 0x66,
	0x84, 0x93, 0x13, 0x7d, 0xee, 0x5b, 0x53, 0xfb, 0x3c, 0xba, 0xf4, 0x4e, 0xb0, 0x43, 0x02, 0xd1,
	0xe9, 0xd0, 0x7c, 0x4e, 0xb6, 0xc5, 0xcc, 0x0e, 0xc5, 0xe5, 0x4e, 0x20, 0x50, 0x8f, 0x9c, 0x0e,
	0xd1, 0xc9, 0x71, 0xfe, 0x92, 0x93, 0xe3, 0x26, 0x94, 0x4e, 0x0c, 0xd7, 0x74, 0x84, 0xef, 0xb6,
	0xac, 0x45, 0x49, 0xf5, 0x16, 0x14, 0xbb, 0xb1, 0x9e, 0x1f, 0xdf, 0x0c, 0xcd, 0x89, 0xdb, 0xa0,
	0x1e, 0x54, 0xda, 0x74, 0xb3, 0xf4, 0xc0, 0x98, 0xb3, 0xfb, 0x90, 0x9b, 0x19, 0x73, 0x71, 0xda,
	0xdd, 0x8c, 0xbd, 0x6d, 0x1c, 0xfb, 0xe0, 0xc0, 0x98, 0xf3, 0x63, 0x23, 0x24, 0xba, 0xf9, 0x31,
	0x94, 0x23, 0xc0, 0x77, 0x0a, 0x7d, 0xf9, 0xef, 0x39, 0xa8, 0xec, 0xc9, 0x1e, 0x01, 0x54, 0xd6,
	0x42, 0x7f, 0xe1, 0xa2, 0xe1, 0x26, 0x7c, 0x93, 0xd5, 0x89, 0xe1, 0x8e, 0x04, 0x28, 0x9a, 0xf4,
	0xec, 0xaf, 0x98, 0xf4, 0x5b, 0x00, 0x3e, 0x69, 0xbc, 0xa4, 0xf4, 0xe6, 0xe2, 0x43, 0xf8, 0xae,
	0x89, 0x3a, 0xef, 0xda, 0x93, 0x89, 0xfc, 0xb7, 0x3f, 0x99, 0x28, 0xac, 0x3d, 0x99, 0xf8, 0x7f,
	0xe5, 0x2c, 0x81, 0xbd, 0x95, 0x30, 0xcf, 0x53, 0xeb, 0x82, 0xc8, 0x2a, 0x3c, 0x50, 0x67, 0x1e,
	0xc7, 0xec, 0x21, 0xdd, 0x67, 0xd0, 0x88, 0x86, 0x59, 0x74, 0x0c, 0x52, 0x61, 0x82, 0x02, 0xc7,
	0x9d, 0x1d, 0xf5, 0x50, 0x4e, 0xa6, 0x77, 0x55, 0xf5, 0x57, 0xef, 0x2a, 0xf5, 0x4f, 0xb2, 0x50,
	0xf8, 0xe9, 0xc2, 0xf2, 0x2f, 0xd8, 0xc7, 0x50, 0x09, 0xc2, 0x59, 0x28, 0xfb, 0x61, 0x6f, 0xf0,
	0x6c, 0x84, 0x27, 0x37, 0xaa, 0x35, 0xb3, 0xdc, 0x90, 0x9b, 0x48, 0x48, 0x4b, 0x5c, 0x64, 0x1b,
	0x0a, 0x41, 0x68, 0xcd, 0xb9, 0xdf, 0xb7, 0xa0, 0xf1, 0x04, 0xdb, 0x81, 0x82, 0xeb, 0x99, 0x56,
	0x90, 0x3e, 0x70, 0x45, 0xb5, 0x5d, 0xe3, 0x08, 0xa6, 0x42, 0x51, 0xdc, 0x28, 0xc8, 0xaf, 0xfa,
	0x42, 0x39, 0x86, 0x62, 0xa1, 0x2c, 0x03, 0x6d, 0xb7, 0xe8, 0xe2, 0x48, 0x9c, 0xc6, 0x4d, 0xe4,
	0x78, 0x86, 0x39, 0x32, 0x8e, 0xa3, 0x8b, 0x55, 0x22, 0x89, 0xc2, 0xd3, 0xb4, 0x42, 0x6b, 0x12,
	0x0e, 0xbf, 0x76, 0xa2, 0x29, 0x93, 0x20, 0xaa, 0x09, 0xf5, 0x54, 0x67, 0xd2, 0x46, 0x04, 0x2a,
	0x5c, 0x9d, 0x1e, 0x2a, 0xa3, 0x19, 0x49, 0x9b, 0xcd, 0xca, 0x1a, 0x6c, 0x4e, 0x52, 0x6d, 0x49,
	0x19, 0x3a, 0x3a, 0xdc, 0x6b, 0x8d, 0x3a, 0x4a, 0x81, 0x54, 0xd5, 0x8e, 0xf6, 0xb4, 0xa3, 0x14,
	0xd5, 0x3f, 0xc8, 0xc2, 0xd6, 0xc8, 0x37, 0xdc, 0xc0, 0xe0, 0xb1, 0xbe, 0x6e, 0xe8, 0x7b, 0x0e,
	0xfb, 0x0c, 0xca, 0xe1, 0xc4, 0x91, 0x07, 0xf9, 0x4e, 0x34, 0xa5, 0x4b, 0xa4, 0x0f, 0x46, 0x13,
	0x6e, 0x8d, 0x96, 0x42, 0xfe, 0xc1, 0x7e, 0x00, 0x85, 0xb1, 0x75, 0x6c, 0xbb, 0x62, 0x7b, 0x5d,
	0x5d, 0xce, 0xb8, 0x8b, 0xc8, 0xfd, 0x0d, 0x8d, 0x53, 0xb1, 0xf7, 0xa1, 0x38, 0xf1, 0x66, 0x11,
	0x87, 0x4a, 0xc2, 0x12, 0xa5, 0x8a, 0x10, 0xbb, 0xbf, 0xa1, 0x09, 0x3a, 0xf6, 0x31, 0x94, 0x7d,
	0xcf, 0x71, 0xc6, 0xc6, 0xe4, 0x54, 0xf0, 0xae, 0xe6, 0x72, 0x1e, 0x4d, 0xe0, 0xf7, 0x37, 0xb4,
	0x98, 0x56, 0x7d, 0x00, 0x25, 0xd1, 0x58, 0x1c, 0x80, 0xdd, 0xce, 0xd3, 0xae, 0x18, 0xc8, 0xf6,
	0xe0, 0xe0, 0xa0, 0x3b, 0xe2, 0xf7, 0x1f, 0xb4, 0x41, 0xaf, 0xb7, 0xdb, 0x6a, 0x3f, 0x53, 0xb2,
	0xbb, 0x65, 0x28, 0x1a, 0x14, 0x4a, 0xa7, 0xfe, 0x8d, 0x0c, 0x6c, 0x2e, 0x75, 0x80, 0x3d, 0x86,
	0xfc, 0x0c, 0xe5, 0x25, 0x1f, 0x9e, 0xbb, 0x6b, 0x7b, 0x29, 0xa5, 0xb9, 0x14, 0xc5, 0x1c, 0xea,
	0xa7, 0xd0, 0x48, 0xc3, 0x25, 0xdd, 0xb6, 0x0e, 0x15, 0xad, 0xd3, 0xda, 0xd3, 0x07, 0xfd, 0xde,
	0x97, 0xdc, 0x34, 0xa4, 0xe4, 0x0b, 0xad, 0x3b, 0xea, 0x28, 0x59, 0xf5, 0x77, 0x40, 0x59, 0x1e,
	0x18, 0xf6, 0x14, 0x36, 0x27, 0x1e, 0x1a, 0xeb, 0x9c, 0x0d, 0x24, 0x53, 0x76, 0x7b, 0xcd, 0x48,
	0x0a, 0x32, 0x9a, 0xb1, 0xc6, 0x24, 0x95, 0x56, 0xff, 0x0a, 0xb0, 0xd5, 0x11, 0xfc, 0xcd, 0x15,
	0xff, 0xbf, 0x33, 0x90, 0x3f, 0x74, 0x0c, 0x97, 0xbd, 0x09, 0x05, 0xba, 0xdb, 0x2a, 0x84, 0x6e,
	0x55, 0xda, 0xbe, 0xb8, 0x2c, 0x08, 0xc7, 0xbe, 0x0f, 0xb9, 0x70, 0x12, 0xdd, 0xf5, 0xb8, 0x7e,
	0xc9, 0xe2, 0xdb, 0xdf, 0xd0, 0x90, 0x8a, 0xdd, 0x83, 0x9c, 0x69, 0x46, 0x71, 0x1f, 0x42, 0x3d,
	0xdf, 0x33, 0x42, 0x63, 0xcf, 0x9a, 0xda, 0xae, 0x2d, 0xee, 0xe2, 0x22, 0x09, 0xfb, 0x1e, 0xe4,
	0xcc, 0x89, 0x93, 0x0e, 0xe2, 0x41, 0x4a, 0xa9, 0x40, 0x73, 0xe2, 0x30, 0x15, 0xea, 0xa1, 0x7f,
	0xa1, 0xfb, 0x0b, 0x97, 0x4e, 0x1e, 0x03, 0xa1, 0xc9, 0x55, 0x51, 0x54, 0x2d, 0xe8, 0x98, 0x2e,
	0x10, 0x31, 0xa3, 0x73, 0xdf, 0x9a, 0x1b, 0x7e, 0xac, 0xc3, 0xd9, 0xc1, 0x21, 0x07, 0xec, 0x16,
	0x81, 0x9e, 0xc0, 0x51, 0xdf, 0xa5, 0x7b, 0x9e, 0xa8, 0xf3, 0xa8, 0xd1, 0xd7, 0x9a, 0x90, 0x7c,
	0x81, 0x51, 0xff, 0x34, 0x07, 0x55, 0xa9, 0x3d, 0xec, 0x43, 0x28, 0x9b, 0xe9, 0x8d, 0x78, 0x63,
	0xa5, 0xd1, 0x0f, 0xf6, 0xa2, 0x2d, 0x68, 0x8a, 0xe5, 0xfd, 0x29, 0xd4, 0x03, 0x2b, 0xd4, 0x5f,
	0x1a, 0xbe, 0x8d, 0x1c, 0x34, 0x10, 0xc3, 0x28, 0xbc, 0xac, 0x43, 0x2b, 0x7c, 0x1e, 0x61, 0xf6,
	0x37, 0xb4, 0x5a, 0x20, 0xa5, 0x49, 0x31, 0x13, 0x5d, 0xca, 0xa5, 0x2e, 0xe8, 0x73, 0xe0, 0xfe,
	0x86, 0x16, 0xe1, 0x91, 0xd4, 0x3a, 0xb7, 0x26, 0x8b, 0x30, 0x52, 0xcc, 0xea, 0x51, 0x87, 0x08,
	0x48, 0x6f, 0x81, 0xf0, 0x4f, 0xf6, 0x10, 0x79, 0x9d, 0xe1, 0x38, 0x1e, 0x49, 0xe4, 0x82, 0xec,
	0xd2, 0xdb, 0x8b, 0xe1, 0xfc, 0xed, 0x91, 0x28, 0xc5, 0xde, 0x82, 0x82, 0x17, 0x9e, 0x58, 0xbe,
	0xb8, 0x6d, 0x17, 0xdd, 0x18, 0x45, 0xd0, 0x5e, 0xbb, 0x87, 0x2b, 0x85, 0xd0, 0xea, 0x2f, 0x32,
	0x50, 0x12, 0x23, 0x80, 0x06, 0xf2, 0xb0, 0x33, 0xd2, 0x9f, 0xb7, 0xb4, 0x6e, 0x6b, 0xb7, 0xd7,
	0x11, 0xb1, 0x47, 0x4f, 0xb5, 0x56, 0x5f, 0xf0, 0x49, 0xad, 0xf3, 0x7c, 0xf0, 0xac, 0xc3, 0x0d,
	0xc6, 0xbd, 0x4e, 0xff, 0x4b, 0x25, 0xc7, 0x9d, 0x24, 0x9d, 0xc3, 0x96, 0x86, 0x5c, 0xb2, 0x0a,
	0xa5, 0xce, 0x17, 0x9d, 0xf6, 0x11, 0xb1, 0xc9, 0x06, 0xc0, 0x5e, 0xa7, 0xd5, 0xeb, 0x0d, 0xd0,
	0x6a, 0x57, 0x8a, 0x8c, 0x41, 0xa3, 0xad, 0x75, 0xd0, 0x82, 0x6f, 0xb5, 0xdb, 0x83, 0xa3, 0xfe,
	0x48, 0x29, 0x61, 0x8d, 0x2d, 0x34, 0xa7, 0x63, 0x10, 0x5d, 0xab, 0xdf, 0xd3, 0x06, 0x87, 0x31,
	0xa4, 0xb2, 0x5b, 0x41, 0x25, 0x99, 0xe6, 0x4a, 0xfd, 0x5f, 0x75, 0x68, 0xa4, 0x97, 0x26, 0xfb,
	0x04, 0xca, 0xa6, 0x99, 0x9a, 0xe3, 0x5b, 0xeb, 0x96, 0xf0, 0x83, 0x3d, 0x33, 0x9a, 0x66, 0xfe,
	0xc1, 0xde, 0x88, 0x36, 0x52, 0x76, 0x65, 0x23, 0x45, 0xdb, 0xe8, 0xc7, 0x91, 0x11, 0x4b, 0xc7,
	0x34, 0x63, 0x23, 0xb0, 0xd2, 0xbb, 0xa4, 0x4d, 0xc8, 0x3d, 0x81, 0xdb, 0xdf, 0xd0, 0x1a, 0x93,
	0x14, 0x84, 0xfd, 0x10, 0x1a, 0x06, 0x99, 0x36, 0x71, 0xfe, 0xbc, 0x2c, 0xe2, 0x5b, 0x88, 0x93,
	0xb2, 0xd7, 0x0d, 0x19, 0x80, 0x0b, 0xd1, 0xf4, 0xbd, 0x79, 0x92, 0xb9, 0x20, 0x2f, 0xc4, 0x3d,
	0xdf, 0x9b, 0x4b, 0x79, 0x6b, 0xa6, 0x94, 0x66, 0x1f, 0x43, 0x4d, 0xb4, 0x3c, 0x31, 0x92, 0xe2,
	0x2d, 0xcb, 0x9b, 0x4d, 0x8a, 0xc2, 0xfe, 0x86, 0x56, 0x9d, 0x24, 0x49, 0xf6, 0x08, 0xaa, 0xbc,
	0xc1, 0x89, 0xd1, 0x14, 0xaf, 0x35, 0x6a, 0x6d, 0x94, 0x0b, 0x8c, 0x38, 0xc5, 0xde, 0x07, 0xa0,
	0x76, 0xf2, 0x3c, 0xe5, 0xd4, 0xa9, 0x93, 0xef, 0xcd, 0xa3, 0x2c, 0x15, 0x33, 0x4a, 0x48, 0xcd,
	0xe3, 0xd1, 0xf1, 0x95, 0xd5, 0xe6, 0x51, 0x20, 0x77, 0xd2, 0x3c, 0x1e, 0x0d, 0x1f, 0x37, 0x8f,
	0x67, 0x83, 0x95, 0xe6, 0x45, 0xb9, 0x78, 0xf3, 0x78, 0xa6, 0xa8, 0x79, 0x3c, 0x4f, 0x75, 0xb9,
	0x79, 0x51, 0x16, 0x6a, 0x1e, 0xcf, 0xf1, 0xc3, 0x15, 0xcd, 0xac, 0x76, 0xa9, 0x66, 0x86, 0xd3,
	0x96, 0xd6, 0xcd, 0x7e, 0x08, 0x8d, 0xe0, 0xc4, 0x3b, 0x93, 0x18, 0x48, 0x5d, 0xce, 0x3d, 0x3c,
	0xf1, 0xce, 0x64, 0x0e, 0x52, 0x0f, 0x64, 0x00, 0xb6, 0x96, 0x77, 0x91, 0xee, 0xbf, 0x34, 0xe4,
	0xd6, 0x52, 0x0f, 0x9f, 0xdb, 0xd6, 0x19, 0xb6, 0xd6, 0x88, 0x12, 0x38, 0x28, 0x89, 0x39, 0x1c,
	0x88, 0x63, 0xd2, 0xd4, 0x09, 0x8a, 0xa8, 0x09, 0x62, 0x1b, 0x39, 0xc0, 0xb5, 0xb5, 0x70, 0xe5,
	0x6c, 0x8a, 0xbc, 0xb6, 0x8e, 0xdc, 0x54, 0xc6, 0x1a, 0x27, 0x15, 0x59, 0x93, 0x5d, 0x11, 0x58,
	0x5f, 0x2f, 0x2c, 0x77, 0x62, 0x89, 0x03, 0xd5, 0xd4, 0xae, 0x18, 0x0a, 0x5c, 0xb2, 0x2b, 0x22,
	0x48, 0xbc, 0xae, 0xe3, 0xec, 0x6c, 0x79, 0x5d, 0x4b, 0x99, 0x69, 0x5d, 0xc7, 0x59, 0xe3, 0x0d,
	0x15, 0xe7, 0xbd, 0xb2, 0xb2, 0xa1, 0xa4, 0xcc, 0x7c, 0x43, 0x45, 0x00, 0xf5, 0xef, 0x16, 0xa0,
	0x24, 0xf8, 0x00, 0xbb, 0x02, 0x9b, 0x82, 0x1d, 0xed, 0xb5, 0x46, 0xad, 0xdd, 0xd6, 0x10, 0x15,
	0x08, 0x06, 0x0d, 0xce, 0x8f, 0x62, 0x58, 0x06, 0x79, 0x14, 0x31, 0xa4, 0x18, 0x94, 0x45, 0x1e,
	0x25, 0xf2, 0xf2, 0x67, 0x42, 0x72, 0x6c, 0x13, 0xaa, 0x3c, 0x23, 0x07, 0x50, 0x98, 0x2e, 0xe5,
	0xe2, 0xe9, 0x82, 0x94, 0x85, 0x3b, 0xf2, 0x8a, 0x49, 0x16, 0x0e, 0x28, 0xc5, 0x59, 0x78, 0xba,
	0x8c, 0x8d, 0x19, 0x69, 0x47, 0xfd, 0x76, 0x52, 0x4f, 0x85, 0x42, 0x2b, 0x79, 0x31, 0xcf, 0xbb,
	0x9d, 0x17, 0x0a, 0x60, 0x26, 0x5e, 0x0a, 0xa5, 0xab, 0xa8, 0x02, 0x51, 0x21, 0x94, 0xac, 0xb1,
	0xeb, 0x70, 0x65, 0xb8, 0x3f, 0x78, 0xa1, 0xf3, 0x4c, 0x71, 0x17, 0xea, 0x6c, 0x1b, 0x14, 0x09,
	0xc1, 0x8b, 0x6f, 0x60, 0x95, 0x04, 0x8d, 0x08, 0x87, 0xca, 0x26, 0xf9, 0xc5, 0x11, 0x36, 0xe2,
	0x32, 0x41, 0xc1, 0xae, 0xf0, 0xac, 0x83, 0xde, 0xd1, 0x41, 0x7f, 0xa8, 0x6c, 0x61, 0x23, 0x08,
	0xc2, 0x5b, 0xce, 0xe2, 0x62, 0x12, 0x49, 0x72, 0x85, 0x84, 0x0b, 0xc2, 0x5e, 0xb4, 0xb4, 0x7e,
	0xb7, 0xff, 0x74, 0xa8, 0x6c, 0xc7, 0x25, 0x77, 0x34, 0x6d, 0xa0, 0x0d, 0x95, 0xab, 0x31, 0x60,
	0x38, 0x6a, 0x8d, 0x8e, 0x86, 0xca, 0xb5, 0xb8, 0x95, 0x87, 0xda, 0xa0, 0xdd, 0x19, 0x0e, 0x7b,
	0xdd, 0xe1, 0x48, 0xb9, 0xce, 0xae, 0xc2, 0x56, 0xd2, 0xa2, 0x88, 0xb8, 0x29, 0x35, 0x54, 0x7b,
	0xda, 0x19, 0x29, 0x37, 0xe2, 0x66, 0xb4, 0x07, 0xbd, 0x5e, 0x8b, 0xfc, 0xb8, 0x37, 0x91, 0x88,
	0xdc, 0xd2, 0xa2, 0x37, 0xaf, 0x61, 0xbb, 0x8e, 0xfa, 0x32, 0xe8, 0x96, 0xb4, 0x34, 0x86, 0x9d,
	0x9f, 0x1e, 0x75, 0xfa, 0xed, 0x8e, 0xf2, 0x7a, 0xb2, 0x34, 0x62, 0xd8, 0xed, 0x78, 0x69, 0xc4,
	0xa0, 0x3b, 0x71, 0x9d, 0x11, 0x68, 0xa8, 0xec, 0x60, 0x79, 0xa2, 0x1d, 0xfd, 0x7e, 0xa7, 0x3d,
	0xc2, 0xbe, 0xbe, 0x11, 0x8f, 0xe2, 0xd1, 0xe1, 0x53, 0xad, 0xb5, 0xd7, 0x51, 0xd4, 0xdd, 0x1a,
	0x3d, 0x28, 0x26, 0xe4, 0x95, 0xfa, 0x39, 0x30, 0xf9, 0x65, 0x1e, 0xf1, 0x4a, 0x00, 0x83, 0xfc,
	0xd4, 0xf7, 0x66, 0xd1, 0xb5, 0x14, 0xfc, 0x66, 0x3b, 0x50, 0x9d, 0x2f, 0xc6, 0x74, 0xd0, 0x9a,
	0x44, 0xa9, 0xcb, 0x20, 0xf5, 0x1f, 0x67, 0xa0, 0x91, 0x96, 0x55, 0xa8, 0xa3, 0xd9, 0x53, 0xdd,
	0xf5, 0x42, 0x7e, 0x93, 0x3d, 0x88, 0x0c, 0x7d, 0x7b, 0xda, 0xf7, 0x42, 0xba, 0xca, 0x4e, 0x96,
	0x59, 0x2c, 0x7a, 0x78, 0xa9, 0x71, 0x9a, 0x75, 0xe1, 0x4a, 0xea, 0xe1, 0xa2, 0xd4, 0x3b, 0x02,
	0xcd, 0xf8, 0x19, 0x96, 0xa5, 0xf6, 0x6b, 0x2c, 0x58, 0xed, 0x93, 0x02, 0xb9, 0xe0, 0x6b, 0x47,
	0x5c, 0x48, 0xc4, 0x4f, 0x75, 0x1f, 0xea, 0x29, 0xd1, 0x48, 0x5e, 0x9f, 0x69, 0xba, 0xa5, 0x65,
	0x7b, 0xfa, 0xea, 0x66, 0xaa, 0x7f, 0x98, 0x81, 0x9a, 0x2c, 0x28, 0x7f, 0xed, 0x92, 0x28, 0x96,
	0x51, 0x7c, 0xeb, 0xb6, 0x19, 0xdd, 0x60, 0x8f, 0x40, 0x5d, 0x7a, 0x48, 0x91, 0xbb, 0xa5, 0x9e,
	0x9c, 0x0e, 0xe3, 0xee, 0xc8, 0x20, 0xb4, 0x59, 0x29, 0x4a, 0xf9, 0xc9, 0x33, 0x24, 0x10, 0xd1,
	0x90, 0x09, 0x44, 0xbd, 0x03, 0x95, 0x27, 0xa7, 0xd1, 0x63, 0x0a, 0xf2, 0x7b, 0x0e, 0x15, 0x7e,
	0xb5, 0x41, 0xfd, 0xa3, 0x0c, 0x34, 0x92, 0x3b, 0x7a, 0x14, 0x68, 0xc1, 0x1f, 0xbc, 0xe2, 0xcb,
	0x21, 0x6b, 0x8e, 0x93, 0x37, 0x16, 0xb3, 0xf2, 0x1b, 0x8b, 0x6f, 0x8a, 0xc2, 0x72, 0xb2, 0x38,
	0x89, 0xeb, 0x12, 0x17, 0x27, 0x1e, 0x41, 0x0d, 0xff, 0x6b, 0xd6, 0xd4, 0xf2, 0x7d, 0x2b, 0x7a,
	0xfb, 0x6b, 0x85, 0x38, 0x45, 0x44, 0x26, 0x81, 0x35, 0x15, 0x9a, 0xc9, 0xda, 0x6b, 0x84, 0x88,
	0x57, 0xff, 0x76, 0x1e, 0xaa, 0x92, 0xda, 0xf1, 0xad, 0x96, 0xdf, 0x2d, 0xa8, 0x24, 0x17, 0xd4,
	0x44, 0xb4, 0x7a, 0x0c, 0x48, 0xcd, 0x55, 0x6e, 0x69, 0xae, 0x9a, 0x50, 0x12, 0x11, 0x19, 0xc2,
	0xad, 0x14, 0x25, 0xd3, 0x7e, 0x93, 0xc2, 0x2b, 0xbc, 0x91, 0x1f, 0x40, 0x4d, 0x7a, 0x16, 0x22,
	0xba, 0xed, 0xba, 0x4c, 0x5f, 0x4d, 0x9e, 0x88, 0x08, 0xd8, 0x55, 0x28, 0x4e, 0x4f, 0x75, 0x73,
	0x1c, 0xb9, 0x24, 0x0a, 0xd3, 0xd3, 0xbd, 0x31, 0x79, 0x73, 0xa7, 0xb1, 0xa4, 0x2d, 0x73, 0x27,
	0xc7, 0x34, 0x92, 0xa7, 0xf7, 0xa0, 0x34, 0x3d, 0xe5, 0x41, 0xe8, 0x15, 0xf9, 0x3c, 0x35, 0x19,
	0xf2, 0xe2, 0xf4, 0x94, 0x22, 0xd2, 0x3f, 0x05, 0x65, 0xc9, 0x65, 0x15, 0x88, 0x68, 0xaf, 0xe5,
	0x46, 0x6d, 0xa6, 0xbd, 0x57, 0x01, 0x7b, 0x0f, 0xb6, 0x85, 0xd0, 0x36, 0x02, 0x9d, 0x47, 0x0b,
	0xd2, 0x9d, 0x47, 0xfe, 0x30, 0xc4, 0x16, 0xc7, 0xb5, 0x82, 0x21, 0x61, 0x70, 0xb1, 0xaa, 0x50,
	0x93, 0xd6, 0x2e, 0xbf, 0x50, 0x5a, 0xd1, 0x52, 0x30, 0xf6, 0x18, 0x6a, 0xd3, 0x53, 0xbe, 0x16,
	0x46, 0xde, 0x81, 0x25, 0xe2, 0xbe, 0xb6, 0x97, 0x57, 0x01, 0x85, 0x07, 0xa5, 0x28, 0xd5, 0x7f,
	0x99, 0x81, 0x46, 0xa2, 0x4f, 0xe2, 0x0e, 0x65, 0xf7, 0xe5, 0x67, 0xec, 0x9a, 0xcb, 0x2a, 0x27,
	0x92, 0x3c, 0x18, 0x5d, 0xcc, 0xf9, 0x8b, 0x3b, 0xeb, 0xae, 0xf9, 0xae, 0x7b, 0xc4, 0x23, 0xb7,
	0xee, 0x11, 0x0f, 0xf5, 0x29, 0xe4, 0x46, 0x17, 0x73, 0xee, 0xbb, 0x40, 0x11, 0xc6, 0xed, 0x1c,
	0x2e, 0xbc, 0xe8, 0xfc, 0xec, 0x59, 0xe7, 0x4b, 0x7e, 0xf5, 0xe6, 0x50, 0xeb, 0x1e, 0xb4, 0xb4,
	0x2f, 0xe9, 0xcc, 0x91, 0x84, 0xfc, 0x93, 0x81, 0xd6, 0xe9, 0x3e, 0xed, 0x13, 0x20, 0x4f, 0x9e,
	0x8d, 0xa4, 0x89, 0x2d, 0xd3, 0x7c, 0x72, 0x2a, 0xdf, 0x76, 0xcc, 0xa4, 0x9e, 0x42, 0x4b, 0x47,
	0xeb, 0x67, 0x97, 0xa3, 0xf5, 0x59, 0xbc, 0x45, 0xe3, 0xfd, 0xce, 0xde, 0x86, 0xfc, 0xf4, 0xd4,
	0xba, 0x48, 0x1b, 0x0d, 0xe9, 0xdd, 0x45, 0x04, 0xea, 0x2f, 0x33, 0xc0, 0x52, 0x0d, 0xe1, 0x7a,
	0xec, 0xaf, 0xdb, 0x96, 0x4f, 0xa0, 0x29, 0xde, 0xaf, 0xe1, 0x54, 0x92, 0x3b, 0x53, 0x0c, 0xe9,
	0x55, 0x2f, 0x09, 0x34, 0x48, 0x6e, 0x22, 0xb3, 0xf7, 0x80, 0x3f, 0x46, 0x82, 0x33, 0x9e, 0x76,
	0x13, 0x48, 0x9b, 0x5f, 0x4b, 0x68, 0x92, 0xd7, 0x47, 0xe4, 0x57, 0x55, 0xb8, 0x7f, 0x77, 0x33,
	0x99, 0x35, 0x62, 0x08, 0xea, 0xef, 0x67, 0xe0, 0x4a, 0x7a, 0x41, 0xfc, 0xc5, 0x7a, 0x99, 0x7e,
	0x42, 0x26, 0xb7, 0xfc, 0x84, 0xcc, 0xba, 0xf5, 0x94, 0x5f, 0xbb, 0x9e, 0x7e, 0x2f, 0x03, 0xdb,
	0xd2, 0xe8, 0x27, 0x96, 0xc7, 0x5f, 0x52, 0xcb, 0xa4, 0x97, 0x64, 0xf2, 0xa9, 0x97, 0x64, 0xd4,
	0x3f, 0xc8, 0xc0, 0xb5, 0xa5, 0x96, 0x68, 0xd6, 0x5f, 0x6a, 0x5b, 0xd2, 0x2f, 0xce, 0x90, 0x4b,
	0x97, 0x87, 0x86, 0xf0, 0x98, 0x76, 0x96, 0x7e, 0x42, 0xa6, 0x87, 0xf3, 0xf8, 0xaf, 0xd2, 0x8d,
	0x34, 0x93, 0xa0, 0x65, 0xf6, 0x11, 0x54, 0x13, 0x15, 0x28, 0xba, 0xe5, 0xb7, 0x36, 0xe2, 0x59,
	0xa6, 0x5b, 0xcb, 0x17, 0xb3, 0xdf, 0x8e, 0x2f, 0x3e, 0x86, 0x5a, 0x5c, 0xf0, 0x9e, 0x35, 0x4d,
	0xdb, 0xf7, 0x4b, 0x57, 0xd2, 0x53, 0x94, 0xea, 0x87, 0xb0, 0x95, 0xf4, 0xa2, 0x2d, 0x9e, 0x51,
	0xb8, 0x03, 0x55, 0xd7, 0x3a, 0xd3, 0xa3, 0x47, 0x16, 0xc4, 0x29, 0xb5, 0x6b, 0x9d, 0x09, 0x02,
	0xf5, 0x89, 0xcc, 0xf7, 0xe2, 0xd7, 0x21, 0x1d, 0x53, 0x9e, 0x99, 0x92, 0xe7, 0x98, 0x11, 0x0a,
	0x4b, 0x93, 0x26, 0xa6, 0xe4, 0x5a, 0x67, 0xb4, 0xe6, 0xce, 0x44, 0x39, 0x2d, 0xd3, 0x14, 0x87,
	0x82, 0xeb, 0x6e, 0x2c, 0xdf, 0x80, 0xf2, 0xdc, 0x4f, 0xcd, 0x6c, 0x69, 0xee, 0xf3, 0x6a, 0xef,
	0x8a, 0x33, 0xf0, 0xcb, 0x0e, 0x10, 0xf9, 0xa9, 0xb8, 0xb8, 0xe0, 0x99, 0x4f, 0x5e, 0x8f, 0xfd,
	0x48, 0xb0, 0x3c, 0xdc, 0x7f, 0xa2, 0xe6, 0xf8, 0xa0, 0x30, 0x73, 0xaf, 0x4e, 0x07, 0x85, 0xa4,
	0xd2, 0x59, 0x5f, 0x8b, 0x63, 0x78, 0xfc, 0x54, 0xff, 0x0c, 0x00, 0x92, 0x8e, 0xa7, 0xa4, 0x77,
	0x66, 0x49, 0x7a, 0x7f, 0xa7, 0x13, 0xc3, 0x0f, 0xa1, 0x31, 0xf1, 0xe6, 0x17, 0x7a, 0x92, 0x23,
	0xb7, 0x36, 0x47, 0x0d, 0xa9, 0x46, 0x49, 0x80, 0xef, 0xea, 0xa9, 0x52, 0x7e, 0xed, 0xa9, 0xd2,
	0x07, 0x50, 0xe2, 0x6e, 0xec, 0x40, 0x84, 0x8a, 0x5f, 0x5f, 0x96, 0x4c, 0x0f, 0xc4, 0x83, 0x41,
	0x11, 0x1d, 0xeb, 0xa0, 0x8d, 0x2a, 0x5e, 0x4b, 0x91, 0x03, 0xc7, 0x6f, 0xaf, 0xe6, 0x8c, 0xc8,
	0xf8, 0x15, 0x7d, 0x43, 0x4e, 0x4a, 0x12, 0x3b, 0x9c, 0x09, 0xdf, 0x0a, 0x49, 0xec, 0x92, 0x2c,
	0xb1, 0x47, 0x33, 0xee, 0x51, 0x41, 0x89, 0xfd, 0x03, 0xb8, 0x22, 0x82, 0xf0, 0x30, 0x03, 0x0e,
	0x27, 0xd1, 0xf3, 0x7b, 0x61, 0xe2, 0x52, 0xdd, 0x68, 0x46, 0xaa, 0x30, 0x92, 0xdf, 0x03, 0x45,
	0x76, 0x11, 0x11, 0x2d, 0x7f, 0xa0, 0xa5, 0x21, 0x79, 0x84, 0x90, 0xf2, 0x2d, 0xd8, 0x14, 0x05,
	0xc7, 0x85, 0xf2, 0x97, 0xa7, 0xea, 0x1c, 0x1c, 0x95, 0xf8, 0x05, 0x6c, 0x4f, 0x4e, 0x0c, 0xf7,
	0xd8, 0xd2, 0xc3, 0xb1, 0xa3, 0xd3, 0x8b, 0x7c, 0xfa, 0xcc, 0x98, 0x8b, 0x28, 0xf3, 0xb7, 0x57,
	0xba, 0xdf, 0x26, 0xe2, 0xd1, 0xd8, 0xa1, 0xc3, 0xfd, 0xf8, 0x34, 0x73, 0x6b, 0xb2, 0x0c, 0x5f,
	0x3a, 0xed, 0xa9, 0x2d, 0x9f, 0xf6, 0xac, 0x28, 0x2b, 0xf5, 0x55, 0x65, 0xe5, 0xe6, 0x9f, 0xe4,
	0xa1, 0x28, 0x1e, 0x71, 0xba, 0x0f, 0x79, 0xd3, 0xf7, 0xe6, 0x71, 0x10, 0xcb, 0x1a, 0x5d, 0x83,
	0xde, 0xcd, 0x46, 0xb5, 0xe4, 0x01, 0x14, 0x0d, 0xd3, 0xd4, 0xa7, 0xa7, 0xe9, 0x13, 0x99, 0x25,
	0xb1, 0xbf, 0xbf, 0xa1, 0x15, 0x0c, 0x92, 0xff, 0x9f, 0x40, 0x05, 0xe9, 0xb9, 0xb3, 0x29, 0x65,
	0x0e, 0xad, 0x0a, 0xe8, 0xfd, 0x0d, 0xad, 0x6c, 0x44, 0xc2, 0xfa, 0x47, 0x69, 0xdf, 0x16, 0x97,
	0x9e, 0x37, 0x57, 0xb2, 0x5e, 0xe6, 0xe5, 0xfa, 0x6d, 0xe0, 0xce, 0x8e, 0x98, 0xf7, 0x14, 0x64,
	0xe7, 0xff, 0x0a, 0xa7, 0xda, 0xdf, 0xd0, 0x6a, 0x06, 0x0f, 0xac, 0xe0, 0x9c, 0xeb, 0xa3, 0xc8,
	0xef, 0x14, 0xbf, 0x70, 0xbb, 0x66, 0x64, 0x90, 0x73, 0xc4, 0xce, 0x27, 0x62, 0x23, 0x98, 0xcd,
	0x34, 0xa3, 0x40, 0x85, 0xd2, 0x4a, 0xb6, 0x98, 0x3f, 0x51, 0xb6, 0x98, 0x59, 0x3d, 0x86, 0x2a,
	0xb9, 0x80, 0x44, 0xbe, 0xf2, 0xca, 0xd0, 0x26, 0xec, 0x85, 0x1c, 0xdb, 0x09, 0xb3, 0x69, 0x47,
	0xfd, 0xf4, 0x2d, 0xd9, 0x77, 0x78, 0x6b, 0xed, 0x40, 0x69, 0xb1, 0x1b, 0x91, 0x77, 0x56, 0xe3,
	0x79, 0xd8, 0x2e, 0xd4, 0x0c, 0x49, 0xee, 0x08, 0x47, 0xe2, 0xad, 0x35, 0xf3, 0x14, 0xd3, 0x50,
	0x19, 0x52, 0x3a, 0x39, 0xe0, 0xba, 0xa9, 0xc1, 0xb5, 0xf5, 0x4b, 0x59, 0x3e, 0x87, 0xcf, 0xf3,
	0x73, 0x78, 0x35, 0x7d, 0x55, 0x32, 0x7d, 0x83, 0x46, 0x3a, 0x95, 0xff, 0x09, 0x9a, 0xc0, 0x32,
	0x3b, 0xa8, 0x42, 0x29, 0x7a, 0x4b, 0x8c, 0x82, 0xb8, 0xda, 0x83, 0xc3, 0x2f, 0x95, 0x0c, 0x82,
	0xbb, 0xfd, 0xe1, 0xa8, 0xd5, 0x17, 0xc7, 0x97, 0xdd, 0xbe, 0x38, 0xbe, 0x54, 0xff, 0x5d, 0x0e,
	0x2a, 0xb1, 0xfb, 0xf5, 0xd7, 0xb7, 0x7b, 0x63, 0x83, 0x32, 0x27, 0x1b, 0x94, 0x4b, 0x7a, 0x1b,
	0x3f, 0x38, 0xe7, 0x57, 0x68, 0x37, 0xd3, 0xda, 0x51, 0xb0, 0x1a, 0xd2, 0x5f, 0xf8, 0x96, 0x21,
	0xfd, 0x72, 0x50, 0x53, 0x31, 0x1d, 0xd4, 0xb4, 0xf4, 0x9e, 0x5c, 0x89, 0x0e, 0xf9, 0xe5, 0xf7,
	0xe4, 0x2e, 0x3d, 0xdd, 0x2f, 0x5f, 0x7e, 0xba, 0x4f, 0x3f, 0x0e, 0xf0, 0xdc, 0xb6, 0xce, 0x44,
	0x6c, 0x8f, 0x48, 0xa5, 0x05, 0x12, 0xbc, 0x42, 0x20, 0x2d, 0xb3, 0xa2, 0xea, 0x1a, 0xbb, 0xe9,
	0x21, 0x6c, 0x4f, 0x4f, 0xe3, 0xb7, 0x73, 0x12, 0xfb, 0xa9, 0x46, 0xdd, 0x58, 0x8b, 0x53, 0xbf,
	0x86, 0x4a, 0xec, 0xff, 0xfd, 0xf5, 0x67, 0xf3, 0xbb, 0x5c, 0xdf, 0x54, 0x7f, 0x37, 0xf2, 0x1a,
	0xc5, 0xee, 0xd7, 0xbf, 0xa8, 0xd7, 0x28, 0x55, 0x7d, 0xee, 0x15, 0xd5, 0x9f, 0x73, 0xd7, 0x4d,
	0x5c, 0xf9, 0x6f, 0x78, 0x09, 0xcb, 0xab, 0x2b, 0x9f, 0x5a, 0x5d, 0xea, 0x42, 0xf8, 0x9f, 0xfe,
	0xe2, 0x55, 0x7f, 0xa7, 0x0e, 0xff, 0x59, 0x26, 0x72, 0x92, 0xc4, 0x6f, 0xff, 0x5c, 0xaa, 0x24,
	0xad, 0xf7, 0xf3, 0x7c, 0x97, 0xea, 0x7e, 0xa5, 0x95, 0x97, 0xff, 0x55, 0x56, 0xde, 0xdb, 0x50,
	0xe0, 0xac, 0xb7, 0x70, 0x99, 0x85, 0xc7, 0xf1, 0xaf, 0x7c, 0x2d, 0x53, 0x55, 0x85, 0x52, 0xc8,
	0xfb, 0xbb, 0x1d, 0x95, 0x1b, 0xbd, 0xf4, 0x89, 0x09, 0x34, 0xb2, 0x2b, 0x89, 0xb1, 0xf7, 0xdd,
	0xc7, 0xe4, 0x37, 0x66, 0xe6, 0xfd, 0xd3, 0x2c, 0xd4, 0x53, 0x47, 0x3f, 0xbf, 0x46, 0x63, 0xd6,
	0xf2, 0xcd, 0xdc, 0x7a, 0xbe, 0x79, 0x29, 0x0b, 0xcb, 0x5f, 0xce, 0xc2, 0xfe, 0xaf, 0xf0, 0x5a,
	0x1e, 0x93, 0x27, 0x1e, 0xe6, 0x2c, 0x47, 0x31, 0x79, 0x3c, 0xa6, 0x4c, 0xfd, 0x3b, 0x99, 0xf8,
	0x99, 0x4a, 0x5e, 0xd3, 0x3a, 0xdd, 0x3b, 0xb3, 0x56, 0xf7, 0xbe, 0x1d, 0x3f, 0x3a, 0xdf, 0xdd,
	0xe3, 0x06, 0x5d, 0x5d, 0x93, 0x20, 0xec, 0x53, 0xb8, 0xc1, 0xf5, 0x07, 0xae, 0x32, 0xe9, 0xde,
	0x54, 0x8f, 0x9f, 0xa4, 0x17, 0x41, 0x67, 0xd7, 0x38, 0x01, 0x7f, 0x4a, 0x75, 0xda, 0x8a, 0xb0,
	0x6a, 0x17, 0xea, 0xa9, 0x73, 0x38, 0xe9, 0xe7, 0x2d, 0x32, 0xf2, 0xcf, 0x5b, 0xb0, 0x1d, 0x28,
	0x9c, 0x9d, 0x58, 0xbe, 0xb5, 0xe6, 0x3d, 0x14, 0x8e, 0x50, 0x7f, 0x08, 0x35, 0x39, 0x26, 0x80,
	0xbd, 0x0b, 0x05, 0x3b, 0xb4, 0x66, 0x91, 0xf5, 0x7a, 0x6d, 0x35, 0x6c, 0x80, 0x0c, 0x58, 0x4e,
	0xa4, 0xfe, 0x22, 0x03, 0xca, 0x32, 0x4e, 0xfa, 0x0d, 0x8e, 0xcc, 0x25, 0xbf, 0xc1, 0x91, 0x4d,
	0x35, 0x72, 0xdd, 0xcf, 0x68, 0xc4, 0x6f, 0x32, 0xe4, 0x2f, 0x79, 0x93, 0x81, 0xbd, 0x05, 0x65,
	0xdf, 0xa2, 0x1f, 0x38, 0x30, 0xd3, 0xef, 0x5b, 0xf3, 0x7b, 0x37, 0x11, 0x4e, 0xfd, 0x9b, 0x19,
	0x28, 0x89, 0x00, 0x86, 0xb5, 0x46, 0xe6, 0x3b, 0x50, 0xe2, 0x3f, 0x76, 0x10, 0x19, 0xdd, 0x2b,
	0x31, 0x81, 0x11, 0x9e, 0xdd, 0xe6, 0x61, 0x1d, 0x69, 0xa3, 0xf3, 0xd0, 0x31, 0x5c, 0x8d, 0xe0,
	0xb8, 0xd4, 0xb8, 0x0b, 0x01, 0xcd, 0xa6, 0x40, 0x5c, 0xde, 0x05, 0x02, 0xa1, 0x12, 0x14, 0xa8,
	0x3f, 0x82, 0x92, 0x08, 0x90, 0x58, 0xdb, 0x94, 0x57, 0x3d, 0xff, 0xbf, 0x03, 0x90, 0x44, 0x4c,
	0xac, 0x2b, 0x41, 0xbd, 0x0f, 0xe5, 0x28, 0x48, 0x02, 0xd7, 0x5f, 0x52, 0xb5, 0x88, 0x83, 0x95,
	0x1b, 0xe3, 0x88, 0x47, 0xc3, 0x7a, 0xde, 0xe4, 0x94, 0xbc, 0x59, 0xef, 0x41, 0xd9, 0x89, 0xde,
	0x62, 0xcb, 0x5c, 0xfe, 0x16, 0x5b, 0x4c, 0xc4, 0xee, 0x43, 0xcc, 0x8e, 0x5f, 0x65, 0xe9, 0xaa,
	0xad, 0x28, 0xe0, 0x9b, 0x56, 0xd9, 0x23, 0xe1, 0xb5, 0x41, 0xd0, 0x92, 0xa3, 0x24, 0xd5, 0x26,
	0x4d, 0x22, 0x53, 0x1b, 0x50, 0x93, 0x4f, 0x76, 0xd5, 0x5f, 0xe4, 0x41, 0x39, 0xb0, 0x42, 0x03,
	0x99, 0xd6, 0x70, 0x62, 0xb8, 0xd4, 0x89, 0x1b, 0x50, 0x8e, 0x1f, 0x79, 0xce, 0x44, 0x8f, 0x44,
	0x3a, 0xd1, 0xeb, 0xc7, 0x1e, 0x4d, 0xaa, 0xec, 0x51, 0x00, 0x0e, 0x22, 0x02, 0xce, 0x09, 0x52,
	0xaf, 0x2d, 0x96, 0xed, 0x60, 0x9f, 0xbf, 0xb7, 0x78, 0x9d, 0xdf, 0xaa, 0x75, 0xbc, 0x09, 0xad,
	0xc9, 0x1a, 0x5d, 0xa2, 0xed, 0x79, 0x13, 0xcc, 0x15, 0x59, 0xa2, 0x81, 0x88, 0x93, 0x2f, 0x0b,
	0x13, 0x94, 0x5c, 0xe7, 0xe2, 0xaa, 0x64, 0x18, 0x10, 0x67, 0xaa, 0x69, 0x65, 0x0e, 0x18, 0x05,
	0xd1, 0xc3, 0x54, 0x13, 0xf1, 0xda, 0x72, 0x8e, 0x1e, 0xa6, 0x6a, 0xbb, 0x14, 0x0f, 0x4f, 0x0f,
	0x7a, 0x4f, 0xc4, 0x7b, 0xea, 0xe2, 0xd9, 0x2f, 0x44, 0xbd, 0xc9, 0xdf, 0xa3, 0xf6, 0xad, 0x20,
	0xe0, 0xef, 0x26, 0xf0, 0x27, 0x0d, 0x6a, 0x11, 0x30, 0x7e, 0xa0, 0x41, 0xbc, 0xe0, 0x8d, 0x24,
	0x20, 0x1e, 0x68, 0xe0, 0xef, 0x77, 0x23, 0xc1, 0x0d, 0x28, 0x7f, 0xe3, 0xb9, 0x96, 0xb0, 0x6f,
	0xb1, 0x55, 0x25, 0x4c, 0x1f, 0x18, 0x73, 0xf5, 0xdf, 0x66, 0x60, 0x7b, 0x79, 0x54, 0x69, 0xb6,
	0x6b, 0x50, 0x6e, 0x0f, 0x7a, 0x7a, 0xbf, 0x75, 0xd0, 0x51, 0x36, 0xd8, 0x26, 0x54, 0x07, 0xbb,
	0x9f, 0x77, 0xda, 0x23, 0x0e, 0xc8, 0xd0, 0x25, 0x99, 0xa1, 0xbe, 0xdf, 0xdd, 0xdb, 0xeb, 0xf4,
	0xb9, 0x32, 0x3f, 0xd8, 0xfd, 0x5c, 0xef, 0x0d, 0xda, 0xfc, 0xf1, 0xe0, 0xe8, 0xc4, 0x79, 0xa8,
	0xe4, 0xe9, 0x94, 0x97, 0x42, 0x13, 0x31, 0x59, 0xe0, 0x91, 0x77, 0x2f, 0x86, 0x7a, 0xbb, 0x3f,
	0x52, 0x8a, 0x98, 0xea, 0x1f, 0xf5, 0x7a, 0x94, 0xa2, 0x10, 0x9b, 0xf6, 0xe0, 0xe0, 0x50, 0xeb,
	0x0c, 0x87, 0xfa, 0xb0, 0xfb, 0xb3, 0x8e, 0x52, 0xa6, 0x9a, 0xb5, 0xee, 0xd3, 0x6e, 0x9f, 0x03,
	0x2a, 0xac, 0x04, 0xb9, 0x83, 0x6e, 0x5f, 0x01, 0xfa, 0x68, 0x7d, 0xa1, 0x54, 0xf1, 0x63, 0x78,
	0x74, 0xa0, 0xd4, 0xee, 0xbf, 0x01, 0x35, 0xf9, 0x51, 0x7c, 0x0a, 0xb6, 0xf3, 0x5c, 0x8b, 0x3f,
	0x56, 0xd5, 0xfb, 0xe6, 0x43, 0x25, 0x73, 0xff, 0x77, 0xa5, 0x97, 0x4d, 0x89, 0x46, 0x78, 0xd0,
	0xe9, 0xae, 0x16, 0xbf, 0x42, 0x42, 0xfe, 0x72, 0xba, 0x71, 0xb2, 0xdf, 0x1a, 0xee, 0x73, 0xdf,
	0xba, 0xc0, 0x10, 0x20, 0x97, 0x3c, 0x72, 0x44, 0x77, 0xb3, 0xe8, 0x33, 0x3e, 0x60, 0x2e, 0xd0,
	0xa5, 0x9a, 0xee, 0x10, 0x3b, 0xa7, 0x40, 0x0d, 0xbf, 0x62, 0x5c, 0xe9, 0xbe, 0x0a, 0x55, 0xe9,
	0x5d, 0x3a, 0xaa, 0xc3, 0x08, 0x4e, 0xc4, 0xbb, 0x49, 0x68, 0x95, 0x29, 0x99, 0xfb, 0x1f, 0x21,
	0xbb, 0x97, 0x5f, 0x85, 0x03, 0x28, 0xf6, 0x3d, 0x7f, 0x66, 0x38, 0x82, 0xce, 0x5a, 0x04, 0x16,
	0x9f, 0x02, 0xcd, 0x12, 0xef, 0xc7, 0x29, 0xd9, 0xfb, 0xef, 0xc1, 0xd5, 0xb5, 0x4f, 0xde, 0x51,
	0xfc, 0xa8, 0x3d, 0x9b, 0x3b, 0x16, 0x0f, 0x81, 0xdc, 0xbf, 0x18, 0xfb, 0xb6, 0xa9, 0x64, 0xee,
	0xff, 0x04, 0x9a, 0x97, 0x45, 0xf4, 0x61, 0x35, 0xed, 0xfd, 0x16, 0x45, 0x4d, 0xe2, 0x0c, 0x0d,
	0x74, 0x9e, 0xca, 0xf0, 0xa0, 0xd3, 0x5e, 0x87, 0x42, 0x0b, 0xee, 0xff, 0x3c, 0x23, 0x31, 0x95,
	0x28, 0x2a, 0x2b, 0x06, 0x88, 0xa1, 0x97, 0x41, 0x9a, 0x65, 0x98, 0x4a, 0x86, 0x5d, 0x03, 0x96,
	0x02, 0xf5, 0xbc, 0x89, 0xe1, 0x28, 0x59, 0x0a, 0x22, 0x88, 0xe0, 0x2f, 0x7c, 0x3b, 0xb4, 0x94,
	0x1c, 0x7b, 0x1d, 0x6e, 0xc4, 0xb0, 0x9e, 0x77, 0x76, 0xe8, 0xdb, 0x68, 0x67, 0x5e, 0x70, 0x74,
	0x7e, 0xf7, 0xc7, 0x7f, 0xfc, 0xcb, 0xdb, 0x99, 0xff, 0xf8, 0xcb, 0xdb, 0x99, 0xff, 0xf1, 0xcb,
	0xdb, 0x1b, 0xbf, 0xf8, 0x9f, 0xb7, 0x33, 0x3f, 0x93, 0x7f, 0x88, 0x6e, 0x66, 0x84, 0xbe, 0x7d,
	0xce, 0x77, 0x42, 0x94, 0x70, 0xad, 0xf7, 0xe6, 0xa7, 0xc7, 0xef, 0xcd, 0xc7, 0xef, 0x21, 0x03,
	0x1a, 0x17, 0xe9, 0x27, 0xe7, 0x1e, 0xfd, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x78, 0xd8, 0x9d,
	0x44, 0xd2, 0x6e, 0x00, 0x00,
}

func (m *Type) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Type) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Type) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Enumvalues) > 0 {
		i -= len(m.Enumvalues)
		copy(dAtA[i:], m.Enumvalues)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Enumvalues)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x32
	}
	if m.Scale != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Scale))
		i--
		dAtA[i] = 0x28
	}
	if m.Width != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x20
	}
	if m.AutoIncr {
		i--
		if m.AutoIncr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.NotNullable {
		i--
		if m.NotNullable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgHeader) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MsgType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.MsgType))
		i--
		dAtA[i] = 0x10
	}
	if m.MsgTag != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.MsgTag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Literal) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Literal) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Literal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Src != nil {
		{
			size, err := m.Src.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.IsBin {
		i--
		if m.IsBin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.Value != nil {
		{
			size := m.Value.ProtoSize()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Isnull {
		i--
		if m.Isnull {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Literal_I8Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Literal_I8Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.I8Val))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *Literal_I16Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Literal_I16Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.I16Val))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *Literal_I32Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Literal_I32Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.I32Val))
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *Literal_I64Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Literal_I64Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.I64Val))
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *Literal_U8Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Literal_U8Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.U8Val))
	i--
	dAtA[i] = 0x30
	return len(dAtA) - i, nil
}
func (m *Literal_U16Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Literal_U16Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.U16Val))
	i--
	dAtA[i] = 0x38
	return len(dAtA) - i, nil
}
func (m *Literal_U32Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Literal_U32Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.U32Val))
	i--
	dAtA[i] = 0x40
	return len(dAtA) - i, nil
}
func (m *Literal_U64Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Literal_U64Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.U64Val))
	i--
	dAtA[i] = 0x48
	return len(dAtA) - i, nil
}
func (m *Literal_Dval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Literal_Dval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Dval))))
	i--
	dAtA[i] = 0x51
	return len(dAtA) - i, nil
}
func (m *Literal_Sval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Literal_Sval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Sval)
	copy(dAtA[i:], m.Sval)
	i = encodeVarintPlan(dAtA, i, uint64(len(m.Sval)))
	i--
	dAtA[i] = 0x5a
	return len(dAtA) - i, nil
}
func (m *Literal_Bval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Literal_Bval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Bval {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x60
	return len(dAtA) - i, nil
}
func (m *Literal_Fval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Literal_Fval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Fval))))
	i--
	dAtA[i] = 0x6d
	return len(dAtA) - i, nil
}
func (m *Literal_Dateval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Literal_Dateval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.Dateval))
	i--
	dAtA[i] = 0x70
	return len(dAtA) - i, nil
}
func (m *Literal_Timeval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Literal_Timeval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.Timeval))
	i--
	dAtA[i] = 0x78
	return len(dAtA) - i, nil
}
func (m *Literal_Datetimeval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Literal_Datetimeval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.Datetimeval))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	return len(dAtA) - i, nil
}
func (m *Literal_Decimal64Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Literal_Decimal64Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Decimal64Val != nil {
		{
			size, err := m.Decimal64Val.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *Literal_Decimal128Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Literal_Decimal128Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Decimal128Val != nil {
		{
			size, err := m.Decimal128Val.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *Literal_Timestampval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Literal_Timestampval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.Timestampval))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x98
	return len(dAtA) - i, nil
}
func (m *Literal_Jsonval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Literal_Jsonval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Jsonval)
	copy(dAtA[i:], m.Jsonval)
	i = encodeVarintPlan(dAtA, i, uint64(len(m.Jsonval)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa2
	return len(dAtA) - i, nil
}
func (m *Literal_Defaultval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Literal_Defaultval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Defaultval {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa8
	return len(dAtA) - i, nil
}
func (m *Literal_UpdateVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Literal_UpdateVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.UpdateVal {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb0
	return len(dAtA) - i, nil
}
func (m *Literal_EnumVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Literal_EnumVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.EnumVal))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb8
	return len(dAtA) - i, nil
}
func (m *ParamRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParamRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParamRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Pos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Pos))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VarRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VarRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VarRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Global {
		i--
		if m.Global {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.System {
		i--
		if m.System {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ColRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TblName) > 0 {
		i -= len(m.TblName)
		copy(dAtA[i:], m.TblName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TblName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ColPos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ColPos))
		i--
		dAtA[i] = 0x10
	}
	if m.RelPos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RelPos))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RawColRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawColRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawColRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ColId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ColId))
		i--
		dAtA[i] = 0x10
	}
	if m.TblId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TblId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CorrColRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CorrColRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CorrColRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Depth != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Depth))
		i--
		dAtA[i] = 0x18
	}
	if m.ColPos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ColPos))
		i--
		dAtA[i] = 0x10
	}
	if m.RelPos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RelPos))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExprList) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExprList) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExprList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MaxValue) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaxValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaxValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TargetType) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TargetType) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TargetType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SubqueryRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubqueryRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubqueryRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RowSize != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RowSize))
		i--
		dAtA[i] = 0x28
	}
	if m.Child != nil {
		{
			size, err := m.Child.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Op) > 0 {
		i -= len(m.Op)
		copy(dAtA[i:], m.Op)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Op)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NodeId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x10
	}
	if m.Typ != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Typ))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ObjectRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PubInfo != nil {
		{
			size, err := m.PubInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.SubscriptionName) > 0 {
		i -= len(m.SubscriptionName)
		copy(dAtA[i:], m.SubscriptionName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.SubscriptionName)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ObjName) > 0 {
		i -= len(m.ObjName)
		copy(dAtA[i:], m.ObjName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ObjName)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SchemaName) > 0 {
		i -= len(m.SchemaName)
		copy(dAtA[i:], m.SchemaName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.SchemaName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ServerName) > 0 {
		i -= len(m.ServerName)
		copy(dAtA[i:], m.ServerName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ServerName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Obj != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Obj))
		i--
		dAtA[i] = 0x20
	}
	if m.Schema != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Schema))
		i--
		dAtA[i] = 0x18
	}
	if m.Db != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Db))
		i--
		dAtA[i] = 0x10
	}
	if m.Server != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Server))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PubInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PubInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PubInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TenantId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TenantId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubscriptionMeta) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscriptionMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscriptionMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SubName) > 0 {
		i -= len(m.SubName)
		copy(dAtA[i:], m.SubName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.SubName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AccountName) > 0 {
		i -= len(m.AccountName)
		copy(dAtA[i:], m.AccountName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.AccountName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AccountId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.AccountId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Function) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Function) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Function) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Args[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Func != nil {
		{
			size, err := m.Func.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Expr) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Expr) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Selectivity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Selectivity))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x89
	}
	if m.Ndv != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Ndv))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x81
	}
	if m.AuxId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.AuxId))
		i--
		dAtA[i] = 0x78
	}
	if m.Expr != nil {
		{
			size := m.Expr.ProtoSize()
			i -= size
			if _, err := m.Expr.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	{
		size, err := m.Typ.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPlan(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Expr_Lit) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_Lit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Lit != nil {
		{
			size, err := m.Lit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Expr_P) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_P) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.P != nil {
		{
			size, err := m.P.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Expr_V) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_V) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.V != nil {
		{
			size, err := m.V.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Expr_Col) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_Col) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Col != nil {
		{
			size, err := m.Col.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Expr_Raw) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_Raw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Raw != nil {
		{
			size, err := m.Raw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Expr_F) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_F) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.F != nil {
		{
			size, err := m.F.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Expr_W) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_W) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.W != nil {
		{
			size, err := m.W.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Expr_Sub) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_Sub) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Sub != nil {
		{
			size, err := m.Sub.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Expr_Corr) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_Corr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Corr != nil {
		{
			size, err := m.Corr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *Expr_T) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_T) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.T != nil {
		{
			size, err := m.T.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *Expr_List) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_List) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.List != nil {
		{
			size, err := m.List.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *Expr_Max) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_Max) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Max != nil {
		{
			size, err := m.Max.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *Expr_Vec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_Vec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Vec != nil {
		{
			size, err := m.Vec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *LiteralVec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiteralVec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiteralVec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Len != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Len))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Decimal64) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Decimal64) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Decimal64) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.A != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.A))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Decimal128) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Decimal128) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Decimal128) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.B != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.B))
		i--
		dAtA[i] = 0x10
	}
	if m.A != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.A))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResultColDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultColDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultColDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ResultCols) > 0 {
		for iNdEx := len(m.ResultCols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResultCols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ColDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.TblName) > 0 {
		i -= len(m.TblName)
		copy(dAtA[i:], m.TblName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TblName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.Header) > 0 {
		i -= len(m.Header)
		copy(dAtA[i:], m.Header)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Header)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Headers {
		i--
		if m.Headers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.Pkidx != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Pkidx))
		i--
		dAtA[i] = 0x70
	}
	if m.Primary {
		i--
		if m.Primary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.ClusterBy {
		i--
		if m.ClusterBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.Seqnum != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Seqnum))
		i--
		dAtA[i] = 0x58
	}
	if m.LowCard {
		i--
		if m.LowCard {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.OnUpdate != nil {
		{
			size, err := m.OnUpdate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x42
	}
	if m.Default != nil {
		{
			size, err := m.Default.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.NotNull {
		i--
		if m.NotNull {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	{
		size, err := m.Typ.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPlan(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.Alg != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Alg))
		i--
		dAtA[i] = 0x20
	}
	if m.Hidden {
		i--
		if m.Hidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ColId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ColId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Default) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Default) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Default) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NullAbility {
		i--
		if m.NullAbility {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.OriginString) > 0 {
		i -= len(m.OriginString)
		copy(dAtA[i:], m.OriginString)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.OriginString)))
		i--
		dAtA[i] = 0x12
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OnUpdate) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OnUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OriginString) > 0 {
		i -= len(m.OriginString)
		copy(dAtA[i:], m.OriginString)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.OriginString)))
		i--
		dAtA[i] = 0x12
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IndexOption) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CreateExtraTable {
		i--
		if m.CreateExtraTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PrimaryKeyDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrimaryKeyDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrimaryKeyDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CompPkeyCol != nil {
		{
			size, err := m.CompPkeyCol.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Names) > 0 {
		for iNdEx := len(m.Names) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Names[iNdEx])
			copy(dAtA[i:], m.Names[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.Names[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.PkeyColName) > 0 {
		i -= len(m.PkeyColName)
		copy(dAtA[i:], m.PkeyColName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.PkeyColName)))
		i--
		dAtA[i] = 0x22
	}
	if m.Option != nil {
		{
			size, err := m.Option.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PkeyColId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.PkeyColId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Cols) > 0 {
		dAtA29 := make([]byte, len(m.Cols)*10)
		var j28 int
		for _, num := range m.Cols {
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		i -= j28
		copy(dAtA[i:], dAtA29[:j28])
		i = encodeVarintPlan(dAtA, i, uint64(j28))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IndexDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IndexAlgoParams) > 0 {
		i -= len(m.IndexAlgoParams)
		copy(dAtA[i:], m.IndexAlgoParams)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexAlgoParams)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.IndexAlgoTableType) > 0 {
		i -= len(m.IndexAlgoTableType)
		copy(dAtA[i:], m.IndexAlgoTableType)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexAlgoTableType)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.IndexAlgo) > 0 {
		i -= len(m.IndexAlgo)
		copy(dAtA[i:], m.IndexAlgo)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexAlgo)))
		i--
		dAtA[i] = 0x52
	}
	if m.Option != nil {
		{
			size, err := m.Option.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Visible {
		i--
		if m.Visible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x3a
	}
	if m.TableExist {
		i--
		if m.TableExist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.IndexTableName) > 0 {
		i -= len(m.IndexTableName)
		copy(dAtA[i:], m.IndexTableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexTableName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Unique {
		i--
		if m.Unique {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Parts) > 0 {
		for iNdEx := len(m.Parts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Parts[iNdEx])
			copy(dAtA[i:], m.Parts[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.Parts[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.IndexName) > 0 {
		i -= len(m.IndexName)
		copy(dAtA[i:], m.IndexName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.IdxId) > 0 {
		i -= len(m.IdxId)
		copy(dAtA[i:], m.IdxId)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IdxId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ForeignKeyDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForeignKeyDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForeignKeyDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OnUpdate != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.OnUpdate))
		i--
		dAtA[i] = 0x30
	}
	if m.OnDelete != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.OnDelete))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ForeignCols) > 0 {
		dAtA32 := make([]byte, len(m.ForeignCols)*10)
		var j31 int
		for _, num := range m.ForeignCols {
			for num >= 1<<7 {
				dAtA32[j31] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j31++
			}
			dAtA32[j31] = uint8(num)
			j31++
		}
		i -= j31
		copy(dAtA[i:], dAtA32[:j31])
		i = encodeVarintPlan(dAtA, i, uint64(j31))
		i--
		dAtA[i] = 0x22
	}
	if m.ForeignTbl != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ForeignTbl))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Cols) > 0 {
		dAtA34 := make([]byte, len(m.Cols)*10)
		var j33 int
		for _, num := range m.Cols {
			for num >= 1<<7 {
				dAtA34[j33] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j33++
			}
			dAtA34[j33] = uint8(num)
			j33++
		}
		i -= j33
		copy(dAtA[i:], dAtA34[:j33])
		i = encodeVarintPlan(dAtA, i, uint64(j33))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Check != nil {
		{
			size, err := m.Check.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterByDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterByDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterByDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CompCbkeyCol != nil {
		{
			size, err := m.CompCbkeyCol.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PropertyDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropertyDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PropertyDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Property) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Property) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Property) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PropertiesDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropertiesDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PropertiesDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Properties) > 0 {
		for iNdEx := len(m.Properties) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Properties[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PartitionByDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionByDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionByDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PartitionTableNames) > 0 {
		for iNdEx := len(m.PartitionTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionTableNames[iNdEx])
			copy(dAtA[i:], m.PartitionTableNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionTableNames[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.PartitionMsg) > 0 {
		i -= len(m.PartitionMsg)
		copy(dAtA[i:], m.PartitionMsg)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionMsg)))
		i--
		dAtA[i] = 0x4a
	}
	if m.IsSubPartition {
		i--
		if m.IsSubPartition {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Algorithm != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Algorithm))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Partitions) > 0 {
		for iNdEx := len(m.Partitions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Partitions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.PartitionNum != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.PartitionNum))
		i--
		dAtA[i] = 0x28
	}
	if m.PartitionColumns != nil {
		{
			size, err := m.PartitionColumns.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PartitionExpression != nil {
		{
			size, err := m.PartitionExpression.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PartitionExpr != nil {
		{
			size, err := m.PartitionExpr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PartitionExpr) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionExpr) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionExpr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExprStr) > 0 {
		i -= len(m.ExprStr)
		copy(dAtA[i:], m.ExprStr)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ExprStr)))
		i--
		dAtA[i] = 0x12
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PartitionColumns) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionColumns) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionColumns) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PartitionColumns) > 0 {
		for iNdEx := len(m.PartitionColumns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionColumns[iNdEx])
			copy(dAtA[i:], m.PartitionColumns[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionColumns[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PartitionItem) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PartitionTableName) > 0 {
		i -= len(m.PartitionTableName)
		copy(dAtA[i:], m.PartitionTableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionTableName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.InValues) > 0 {
		for iNdEx := len(m.InValues) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InValues[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.LessThan) > 0 {
		for iNdEx := len(m.LessThan) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LessThan[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OrdinalPosition != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.OrdinalPosition))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PartitionName) > 0 {
		i -= len(m.PartitionName)
		copy(dAtA[i:], m.PartitionName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ViewDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ViewDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.View) > 0 {
		i -= len(m.View)
		copy(dAtA[i:], m.View)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.View)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if m.IsDynamic {
		i--
		if m.IsDynamic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.AutoIncrOffset != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.AutoIncrOffset))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.IsTemporary {
		i--
		if m.IsTemporary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.TableLockType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TableLockType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.IsLocked {
		i--
		if m.IsLocked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if len(m.Name2ColIndex) > 0 {
		for k := range m.Name2ColIndex {
			v := m.Name2ColIndex[k]
			baseI := i
			i = encodeVarintPlan(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPlan(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPlan(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.Defs) > 0 {
		for iNdEx := len(m.Defs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Defs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	if m.ViewSql != nil {
		{
			size, err := m.ViewSql.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.Props) > 0 {
		for iNdEx := len(m.Props) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Props[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if m.ClusterBy != nil {
		{
			size, err := m.ClusterBy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.Partition != nil {
		{
			size, err := m.Partition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.Checks) > 0 {
		for iNdEx := len(m.Checks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Checks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.RefChildTbls) > 0 {
		dAtA45 := make([]byte, len(m.RefChildTbls)*10)
		var j44 int
		for _, num := range m.RefChildTbls {
			for num >= 1<<7 {
				dAtA45[j44] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j44++
			}
			dAtA45[j44] = uint8(num)
			j44++
		}
		i -= j44
		copy(dAtA[i:], dAtA45[:j44])
		i = encodeVarintPlan(dAtA, i, uint64(j44))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Fkeys) > 0 {
		for iNdEx := len(m.Fkeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fkeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.Indexes) > 0 {
		for iNdEx := len(m.Indexes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Indexes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.Pkey != nil {
		{
			size, err := m.Pkey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Version != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x40
	}
	if m.TblFunc != nil {
		{
			size, err := m.TblFunc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Createsql) > 0 {
		i -= len(m.Createsql)
		copy(dAtA[i:], m.Createsql)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Createsql)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.TableType) > 0 {
		i -= len(m.TableType)
		copy(dAtA[i:], m.TableType)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TableType)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Cols) > 0 {
		for iNdEx := len(m.Cols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Hidden {
		i--
		if m.Hidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.TblId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TblId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableDef_DefType) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDef_DefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDef_DefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Def != nil {
		{
			size := m.Def.ProtoSize()
			i -= size
			if _, err := m.Def.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *TableDef_DefType_Properties) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDef_DefType_Properties) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Properties != nil {
		{
			size, err := m.Properties.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *TableFunction) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableFunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableFunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Param) > 0 {
		i -= len(m.Param)
		copy(dAtA[i:], m.Param)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Param)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HashMapStats) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HashMapStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HashMapStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ranges) > 0 {
		for iNdEx := len(m.Ranges) - 1; iNdEx >= 0; iNdEx-- {
			f49 := math.Float64bits(float64(m.Ranges[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f49))
		}
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Ranges)*8))
		i--
		dAtA[i] = 0x5a
	}
	if m.Nullcnt != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Nullcnt))
		i--
		dAtA[i] = 0x50
	}
	if m.ShuffleMethod != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ShuffleMethod))
		i--
		dAtA[i] = 0x48
	}
	if m.ShuffleColMax != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ShuffleColMax))
		i--
		dAtA[i] = 0x40
	}
	if m.ShuffleColMin != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ShuffleColMin))
		i--
		dAtA[i] = 0x38
	}
	if m.ShuffleTypeForMultiCN != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ShuffleTypeForMultiCN))
		i--
		dAtA[i] = 0x30
	}
	if m.ShuffleType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ShuffleType))
		i--
		dAtA[i] = 0x28
	}
	if m.ShuffleColIdx != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ShuffleColIdx))
		i--
		dAtA[i] = 0x20
	}
	if m.Shuffle {
		i--
		if m.Shuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.HashOnPK {
		i--
		if m.HashOnPK {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.HashmapSize != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.HashmapSize))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Stats) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stats) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Stats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HashmapStats != nil {
		{
			size, err := m.HashmapStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.ForceOneCN {
		i--
		if m.ForceOneCN {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Selectivity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Selectivity))))
		i--
		dAtA[i] = 0x31
	}
	if m.TableCnt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TableCnt))))
		i--
		dAtA[i] = 0x29
	}
	if m.Rowsize != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Rowsize))))
		i--
		dAtA[i] = 0x21
	}
	if m.Outcnt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Outcnt))))
		i--
		dAtA[i] = 0x19
	}
	if m.Cost != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Cost))))
		i--
		dAtA[i] = 0x11
	}
	if m.BlockNum != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.BlockNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RowsetExpr) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowsetExpr) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowsetExpr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Pos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Pos))
		i--
		dAtA[i] = 0x10
	}
	if m.RowPos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RowPos))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColData) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColData) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RowsetData) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowsetData) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowsetData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RowCount != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RowCount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Cols) > 0 {
		for iNdEx := len(m.Cols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OrderBySpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderBySpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderBySpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Flag != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Flag))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Collation) > 0 {
		i -= len(m.Collation)
		copy(dAtA[i:], m.Collation)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Collation)))
		i--
		dAtA[i] = 0x12
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WindowSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WindowSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Frame != nil {
		{
			size, err := m.Frame.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.OrderBy) > 0 {
		for iNdEx := len(m.OrderBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OrderBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.PartitionBy) > 0 {
		for iNdEx := len(m.PartitionBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PartitionBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.WindowFunc != nil {
		{
			size, err := m.WindowFunc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SampleFuncSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SampleFuncSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SampleFuncSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UsingRow {
		i--
		if m.UsingRow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Percent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Percent))))
		i--
		dAtA[i] = 0x11
	}
	if m.Rows != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Rows))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FrameClause) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FrameClause) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FrameClause) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.End != nil {
		{
			size, err := m.End.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Start != nil {
		{
			size, err := m.Start.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FrameBound) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FrameBound) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FrameBound) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Val != nil {
		{
			size, err := m.Val.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.UnBounded {
		i--
		if m.UnBounded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OnDuplicateKeyCtx) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnDuplicateKeyCtx) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OnDuplicateKeyCtx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableVersion != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TableVersion))
		i--
		dAtA[i] = 0x50
	}
	if m.TableId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x48
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x42
	}
	if m.IsIgnore {
		i--
		if m.IsIgnore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.OnDuplicateExpr) > 0 {
		for k := range m.OnDuplicateExpr {
			v := m.OnDuplicateExpr[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPlan(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPlan(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPlan(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.OnDuplicateIdx) > 0 {
		dAtA60 := make([]byte, len(m.OnDuplicateIdx)*10)
		var j59 int
		for _, num1 := range m.OnDuplicateIdx {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA60[j59] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j59++
			}
			dAtA60[j59] = uint8(num)
			j59++
		}
		i -= j59
		copy(dAtA[i:], dAtA60[:j59])
		i = encodeVarintPlan(dAtA, i, uint64(j59))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.UniqueCols) > 0 {
		for iNdEx := len(m.UniqueCols) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UniqueCols[iNdEx])
			copy(dAtA[i:], m.UniqueCols[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.UniqueCols[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.UniqueColCheckExpr) > 0 {
		for iNdEx := len(m.UniqueColCheckExpr) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UniqueColCheckExpr[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.InsertColCount != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.InsertColCount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Attrs) > 0 {
		for iNdEx := len(m.Attrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Attrs[iNdEx])
			copy(dAtA[i:], m.Attrs[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.Attrs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *InsertCtx) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsertCtx) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InsertCtx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PartitionIdx != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.PartitionIdx))
		i--
		dAtA[i] = 0x38
	}
	if len(m.PartitionTableNames) > 0 {
		for iNdEx := len(m.PartitionTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionTableNames[iNdEx])
			copy(dAtA[i:], m.PartitionTableNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionTableNames[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.PartitionTableIds) > 0 {
		dAtA62 := make([]byte, len(m.PartitionTableIds)*10)
		var j61 int
		for _, num := range m.PartitionTableIds {
			for num >= 1<<7 {
				dAtA62[j61] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j61++
			}
			dAtA62[j61] = uint8(num)
			j61++
		}
		i -= j61
		copy(dAtA[i:], dAtA62[:j61])
		i = encodeVarintPlan(dAtA, i, uint64(j61))
		i--
		dAtA[i] = 0x2a
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.IsClusterTable {
		i--
		if m.IsClusterTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AddAffectedRows {
		i--
		if m.AddAffectedRows {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Ref != nil {
		{
			size, err := m.Ref.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceCtx) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceCtx) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceCtx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PartitionIdx != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.PartitionIdx))
		i--
		dAtA[i] = 0x40
	}
	if len(m.PartitionTableNames) > 0 {
		for iNdEx := len(m.PartitionTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionTableNames[iNdEx])
			copy(dAtA[i:], m.PartitionTableNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionTableNames[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.PartitionTableIds) > 0 {
		dAtA66 := make([]byte, len(m.PartitionTableIds)*10)
		var j65 int
		for _, num := range m.PartitionTableIds {
			for num >= 1<<7 {
				dAtA66[j65] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j65++
			}
			dAtA66[j65] = uint8(num)
			j65++
		}
		i -= j65
		copy(dAtA[i:], dAtA66[:j65])
		i = encodeVarintPlan(dAtA, i, uint64(j65))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DeleteCond) > 0 {
		i -= len(m.DeleteCond)
		copy(dAtA[i:], m.DeleteCond)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DeleteCond)))
		i--
		dAtA[i] = 0x2a
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.IsClusterTable {
		i--
		if m.IsClusterTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AddAffectedRows {
		i--
		if m.AddAffectedRows {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Ref != nil {
		{
			size, err := m.Ref.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AnalyzeInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalyzeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnalyzeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TimeConsumedArrayMinor) > 0 {
		dAtA70 := make([]byte, len(m.TimeConsumedArrayMinor)*10)
		var j69 int
		for _, num1 := range m.TimeConsumedArrayMinor {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA70[j69] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j69++
			}
			dAtA70[j69] = uint8(num)
			j69++
		}
		i -= j69
		copy(dAtA[i:], dAtA70[:j69])
		i = encodeVarintPlan(dAtA, i, uint64(j69))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.TimeConsumedArrayMajor) > 0 {
		dAtA72 := make([]byte, len(m.TimeConsumedArrayMajor)*10)
		var j71 int
		for _, num1 := range m.TimeConsumedArrayMajor {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA72[j71] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j71++
			}
			dAtA72[j71] = uint8(num)
			j71++
		}
		i -= j71
		copy(dAtA[i:], dAtA72[:j71])
		i = encodeVarintPlan(dAtA, i, uint64(j71))
		i--
		dAtA[i] = 0x7a
	}
	if m.InsertTime != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.InsertTime))
		i--
		dAtA[i] = 0x70
	}
	if m.ScanTime != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ScanTime))
		i--
		dAtA[i] = 0x68
	}
	if m.NetworkIO != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.NetworkIO))
		i--
		dAtA[i] = 0x60
	}
	if m.S3IOOutputCount != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.S3IOOutputCount))
		i--
		dAtA[i] = 0x58
	}
	if m.S3IOInputCount != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.S3IOInputCount))
		i--
		dAtA[i] = 0x50
	}
	if m.S3IOByte != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.S3IOByte))
		i--
		dAtA[i] = 0x48
	}
	if m.DiskIO != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.DiskIO))
		i--
		dAtA[i] = 0x40
	}
	if m.WaitTimeConsumed != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.WaitTimeConsumed))
		i--
		dAtA[i] = 0x38
	}
	if m.MemorySize != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.MemorySize))
		i--
		dAtA[i] = 0x30
	}
	if m.TimeConsumed != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TimeConsumed))
		i--
		dAtA[i] = 0x28
	}
	if m.OutputSize != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.OutputSize))
		i--
		dAtA[i] = 0x20
	}
	if m.InputSize != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.InputSize))
		i--
		dAtA[i] = 0x18
	}
	if m.OutputRows != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.OutputRows))
		i--
		dAtA[i] = 0x10
	}
	if m.InputRows != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.InputRows))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PartitionPrune) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionPrune) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionPrune) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SelectedPartitions) > 0 {
		for iNdEx := len(m.SelectedPartitions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SelectedPartitions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.IsPruned {
		i--
		if m.IsPruned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OriginTableMessageForFuzzy) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OriginTableMessageForFuzzy) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OriginTableMessageForFuzzy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ParentUniqueCols) > 0 {
		for iNdEx := len(m.ParentUniqueCols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ParentUniqueCols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ParentTableName) > 0 {
		i -= len(m.ParentTableName)
		copy(dAtA[i:], m.ParentTableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ParentTableName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ScanSnapshot != nil {
		{
			size, err := m.ScanSnapshot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xca
	}
	if len(m.RecvMsgList) > 0 {
		for iNdEx := len(m.RecvMsgList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RecvMsgList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.SendMsgList) > 0 {
		for iNdEx := len(m.SendMsgList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SendMsgList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xba
		}
	}
	if m.Fuzzymessage != nil {
		{
			size, err := m.Fuzzymessage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xb2
	}
	if len(m.OnUpdateExprs) > 0 {
		for iNdEx := len(m.OnUpdateExprs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OnUpdateExprs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xaa
		}
	}
	if m.WindowIdx != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.WindowIdx))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.SampleFunc != nil {
		{
			size, err := m.SampleFunc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	if len(m.FillVal) > 0 {
		for iNdEx := len(m.FillVal) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FillVal[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x92
		}
	}
	if m.FillType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.FillType))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x88
	}
	if m.Sliding != nil {
		{
			size, err := m.Sliding.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x82
	}
	if m.Interval != nil {
		{
			size, err := m.Interval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xfa
	}
	if m.PreInsertSkCtx != nil {
		{
			size, err := m.PreInsertSkCtx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf2
	}
	if m.PartitionPrune != nil {
		{
			size, err := m.PartitionPrune.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	if m.ExternScan != nil {
		{
			size, err := m.ExternScan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	if m.RecursiveSink {
		i--
		if m.RecursiveSink {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd8
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for iNdEx := len(m.RuntimeFilterBuildList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterBuildList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.RuntimeFilterProbeList) > 0 {
		for iNdEx := len(m.RuntimeFilterProbeList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterProbeList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.BlockFilterList) > 0 {
		for iNdEx := len(m.BlockFilterList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BlockFilterList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.LockTargets) > 0 {
		for iNdEx := len(m.LockTargets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LockTargets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.IsEnd {
		i--
		if m.IsEnd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.OnDuplicateKey != nil {
		{
			size, err := m.OnDuplicateKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if m.PreInsertUkCtx != nil {
		{
			size, err := m.PreInsertUkCtx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.PreInsertCtx != nil {
		{
			size, err := m.PreInsertCtx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if m.PreDeleteCtx != nil {
		{
			size, err := m.PreDeleteCtx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if len(m.SourceStep) > 0 {
		dAtA86 := make([]byte, len(m.SourceStep)*10)
		var j85 int
		for _, num1 := range m.SourceStep {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA86[j85] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j85++
			}
			dAtA86[j85] = uint8(num)
			j85++
		}
		i -= j85
		copy(dAtA[i:], dAtA86[:j85])
		i = encodeVarintPlan(dAtA, i, uint64(j85))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if m.ReplaceCtx != nil {
		{
			size, err := m.ReplaceCtx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.InsertCtx != nil {
		{
			size, err := m.InsertCtx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.NotCacheable {
		i--
		if m.NotCacheable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.ClusterTable != nil {
		{
			size, err := m.ClusterTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.TblFuncExprList) > 0 {
		for iNdEx := len(m.TblFuncExprList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TblFuncExprList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if m.AnalyzeInfo != nil {
		{
			size, err := m.AnalyzeInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.BindingTags) > 0 {
		dAtA92 := make([]byte, len(m.BindingTags)*10)
		var j91 int
		for _, num1 := range m.BindingTags {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA92[j91] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j91++
			}
			dAtA92[j91] = uint8(num)
			j91++
		}
		i -= j91
		copy(dAtA[i:], dAtA92[:j91])
		i = encodeVarintPlan(dAtA, i, uint64(j91))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.DeleteCtx != nil {
		{
			size, err := m.DeleteCtx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.ExtraOptions) > 0 {
		i -= len(m.ExtraOptions)
		copy(dAtA[i:], m.ExtraOptions)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ExtraOptions)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.RowsetData != nil {
		{
			size, err := m.RowsetData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.ParentObjRef != nil {
		{
			size, err := m.ParentObjRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.ObjRef != nil {
		{
			size, err := m.ObjRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.Offset != nil {
		{
			size, err := m.Offset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Limit != nil {
		{
			size, err := m.Limit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if len(m.OrderBy) > 0 {
		for iNdEx := len(m.OrderBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OrderBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.WinSpecList) > 0 {
		for iNdEx := len(m.WinSpecList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WinSpecList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.AggList) > 0 {
		for iNdEx := len(m.AggList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AggList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.GroupingSet) > 0 {
		for iNdEx := len(m.GroupingSet) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GroupingSet[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.GroupBy) > 0 {
		for iNdEx := len(m.GroupBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GroupBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.FilterList) > 0 {
		for iNdEx := len(m.FilterList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FilterList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.BuildOnLeft {
		i--
		if m.BuildOnLeft {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.OnList) > 0 {
		for iNdEx := len(m.OnList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OnList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.JoinType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.JoinType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ProjectList) > 0 {
		for iNdEx := len(m.ProjectList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProjectList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Children) > 0 {
		dAtA101 := make([]byte, len(m.Children)*10)
		var j100 int
		for _, num1 := range m.Children {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA101[j100] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j100++
			}
			dAtA101[j100] = uint8(num)
			j100++
		}
		i -= j100
		copy(dAtA[i:], dAtA101[:j100])
		i = encodeVarintPlan(dAtA, i, uint64(j100))
		i--
		dAtA[i] = 0x22
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.NodeId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x10
	}
	if m.NodeType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.NodeType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Snapshot) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Snapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Snapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CreatedByTenant != nil {
		{
			size, err := m.CreatedByTenant.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TS != nil {
		{
			size, err := m.TS.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SnapshotTenant) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotTenant) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotTenant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TenantID != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TenantID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TenantName) > 0 {
		i -= len(m.TenantName)
		copy(dAtA[i:], m.TenantName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TenantName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExternScan) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternScan) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternScan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.JsonType) > 0 {
		i -= len(m.JsonType)
		copy(dAtA[i:], m.JsonType)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.JsonType)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Terminated) > 0 {
		i -= len(m.Terminated)
		copy(dAtA[i:], m.Terminated)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Terminated)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.EnclosedBy) > 0 {
		i -= len(m.EnclosedBy)
		copy(dAtA[i:], m.EnclosedBy)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.EnclosedBy)))
		i--
		dAtA[i] = 0x2a
	}
	if m.IgnoredLines != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.IgnoredLines))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Format) > 0 {
		i -= len(m.Format)
		copy(dAtA[i:], m.Format)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Format)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LockTarget) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mode != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x50
	}
	if m.Block {
		i--
		if m.Block {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.PartitionTableIds) > 0 {
		dAtA106 := make([]byte, len(m.PartitionTableIds)*10)
		var j105 int
		for _, num := range m.PartitionTableIds {
			for num >= 1<<7 {
				dAtA106[j105] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j105++
			}
			dAtA106[j105] = uint8(num)
			j105++
		}
		i -= j105
		copy(dAtA[i:], dAtA106[:j105])
		i = encodeVarintPlan(dAtA, i, uint64(j105))
		i--
		dAtA[i] = 0x42
	}
	if m.IsPartitionTable {
		i--
		if m.IsPartitionTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.LockTable {
		i--
		if m.LockTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.FilterColIdxInBat != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.FilterColIdxInBat))
		i--
		dAtA[i] = 0x28
	}
	if m.RefreshTsIdxInBat != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RefreshTsIdxInBat))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.PrimaryColTyp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPlan(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.PrimaryColIdxInBat != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.PrimaryColIdxInBat))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PreInsertUkCtx) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreInsertUkCtx) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PreInsertUkCtx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.UkType.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPlan(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.PkType.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPlan(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.PkColumn != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.PkColumn))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Columns) > 0 {
		dAtA111 := make([]byte, len(m.Columns)*10)
		var j110 int
		for _, num1 := range m.Columns {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA111[j110] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j110++
			}
			dAtA111[j110] = uint8(num)
			j110++
		}
		i -= j110
		copy(dAtA[i:], dAtA111[:j110])
		i = encodeVarintPlan(dAtA, i, uint64(j110))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PreDeleteCtx) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreDeleteCtx) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PreDeleteCtx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Idx) > 0 {
		dAtA113 := make([]byte, len(m.Idx)*10)
		var j112 int
		for _, num1 := range m.Idx {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA113[j112] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j112++
			}
			dAtA113[j112] = uint8(num)
			j112++
		}
		i -= j112
		copy(dAtA[i:], dAtA113[:j112])
		i = encodeVarintPlan(dAtA, i, uint64(j112))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PreInsertCtx) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreInsertCtx) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PreInsertCtx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsUpdate {
		i--
		if m.IsUpdate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.HasAutoCol {
		i--
		if m.HasAutoCol {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Ref != nil {
		{
			size, err := m.Ref.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RuntimeFilterSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuntimeFilterSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RuntimeFilterSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Handled {
		i--
		if m.Handled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.UpperLimit != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.UpperLimit))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchPrefix {
		i--
		if m.MatchPrefix {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Tag != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IdList) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdList) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IdList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.List) > 0 {
		dAtA118 := make([]byte, len(m.List)*10)
		var j117 int
		for _, num1 := range m.List {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA118[j117] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j117++
			}
			dAtA118[j117] = uint8(num)
			j117++
		}
		i -= j117
		copy(dAtA[i:], dAtA118[:j117])
		i = encodeVarintPlan(dAtA, i, uint64(j117))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ColPosMap) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColPosMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColPosMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Map) > 0 {
		for k := range m.Map {
			v := m.Map[k]
			baseI := i
			i = encodeVarintPlan(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPlan(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPlan(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeleteCtx) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteCtx) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteCtx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.TruncateTable != nil {
		{
			size, err := m.TruncateTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.PrimaryKeyIdx != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.PrimaryKeyIdx))
		i--
		dAtA[i] = 0x48
	}
	if m.PartitionIdx != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.PartitionIdx))
		i--
		dAtA[i] = 0x40
	}
	if len(m.PartitionTableNames) > 0 {
		for iNdEx := len(m.PartitionTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionTableNames[iNdEx])
			copy(dAtA[i:], m.PartitionTableNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionTableNames[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.PartitionTableIds) > 0 {
		dAtA122 := make([]byte, len(m.PartitionTableIds)*10)
		var j121 int
		for _, num := range m.PartitionTableIds {
			for num >= 1<<7 {
				dAtA122[j121] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j121++
			}
			dAtA122[j121] = uint8(num)
			j121++
		}
		i -= j121
		copy(dAtA[i:], dAtA122[:j121])
		i = encodeVarintPlan(dAtA, i, uint64(j121))
		i--
		dAtA[i] = 0x32
	}
	if m.IsClusterTable {
		i--
		if m.IsClusterTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.AddAffectedRows {
		i--
		if m.AddAffectedRows {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.RowIdIdx != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RowIdIdx))
		i--
		dAtA[i] = 0x18
	}
	if m.Ref != nil {
		{
			size, err := m.Ref.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CanTruncate {
		i--
		if m.CanTruncate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Query) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Query) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Query) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DetectSqls) > 0 {
		for iNdEx := len(m.DetectSqls) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DetectSqls[iNdEx])
			copy(dAtA[i:], m.DetectSqls[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.DetectSqls[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.LoadTag {
		i--
		if m.LoadTag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Headings) > 0 {
		for iNdEx := len(m.Headings) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Headings[iNdEx])
			copy(dAtA[i:], m.Headings[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.Headings[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Params) > 0 {
		for iNdEx := len(m.Params) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Params[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Steps) > 0 {
		dAtA125 := make([]byte, len(m.Steps)*10)
		var j124 int
		for _, num1 := range m.Steps {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA125[j124] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j124++
			}
			dAtA125[j124] = uint8(num)
			j124++
		}
		i -= j124
		copy(dAtA[i:], dAtA125[:j124])
		i = encodeVarintPlan(dAtA, i, uint64(j124))
		i--
		dAtA[i] = 0x12
	}
	if m.StmtType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.StmtType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransationControl) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransationControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Action != nil {
		{
			size := m.Action.ProtoSize()
			i -= size
			if _, err := m.Action.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TclType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TclType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransationControl_Begin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationControl_Begin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Begin != nil {
		{
			size, err := m.Begin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *TransationControl_Commit) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationControl_Commit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *TransationControl_Rollback) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationControl_Rollback) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Rollback != nil {
		{
			size, err := m.Rollback.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *TransationBegin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransationBegin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationBegin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mode != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransationCommit) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransationCommit) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationCommit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CompletionType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.CompletionType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransationRollback) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransationRollback) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationRollback) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CompletionType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.CompletionType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Plan) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Plan) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsPrepare {
		i--
		if m.IsPrepare {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.TryRunTimes != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TryRunTimes))
		i--
		dAtA[i] = 0x28
	}
	if m.Plan != nil {
		{
			size := m.Plan.ProtoSize()
			i -= size
			if _, err := m.Plan.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Plan_Query) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan_Query) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Plan_Tcl) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan_Tcl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Tcl != nil {
		{
			size, err := m.Tcl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Plan_Ddl) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan_Ddl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ddl != nil {
		{
			size, err := m.Ddl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Plan_Dcl) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan_Dcl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Dcl != nil {
		{
			size, err := m.Dcl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Column) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Column) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Column) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Column) > 0 {
		for iNdEx := len(m.Column) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Column[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataControl) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Control != nil {
		{
			size := m.Control.ProtoSize()
			i -= size
			if _, err := m.Control.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DclType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.DclType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataControl_SetVariables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataControl_SetVariables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SetVariables != nil {
		{
			size, err := m.SetVariables.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *DataControl_Prepare) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataControl_Prepare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Prepare != nil {
		{
			size, err := m.Prepare.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DataControl_Execute) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataControl_Execute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Execute != nil {
		{
			size, err := m.Execute.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DataControl_Deallocate) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataControl_Deallocate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Deallocate != nil {
		{
			size, err := m.Deallocate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *DataControl_Other) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataControl_Other) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Other != nil {
		{
			size, err := m.Other.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataDefinition) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Definition != nil {
		{
			size := m.Definition.ProtoSize()
			i -= size
			if _, err := m.Definition.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.DdlType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.DdlType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataDefinition_CreateDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_CreateDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateDatabase != nil {
		{
			size, err := m.CreateDatabase.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_AlterDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_AlterDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterDatabase != nil {
		{
			size, err := m.AlterDatabase.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_DropDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_DropDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DropDatabase != nil {
		{
			size, err := m.DropDatabase.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_CreateTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_CreateTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateTable != nil {
		{
			size, err := m.CreateTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_AlterTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_AlterTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterTable != nil {
		{
			size, err := m.AlterTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_DropTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_DropTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DropTable != nil {
		{
			size, err := m.DropTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_CreateIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_CreateIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateIndex != nil {
		{
			size, err := m.CreateIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_AlterIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_AlterIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterIndex != nil {
		{
			size, err := m.AlterIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_DropIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_DropIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DropIndex != nil {
		{
			size, err := m.DropIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_TruncateTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_TruncateTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TruncateTable != nil {
		{
			size, err := m.TruncateTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_ShowVariables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_ShowVariables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ShowVariables != nil {
		{
			size, err := m.ShowVariables.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_AlterView) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_AlterView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterView != nil {
		{
			size, err := m.AlterView.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_LockTables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_LockTables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LockTables != nil {
		{
			size, err := m.LockTables.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_UnlockTables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_UnlockTables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UnlockTables != nil {
		{
			size, err := m.UnlockTables.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_CreateSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_CreateSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateSequence != nil {
		{
			size, err := m.CreateSequence.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_DropSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_DropSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DropSequence != nil {
		{
			size, err := m.DropSequence.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_AlterSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_AlterSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterSequence != nil {
		{
			size, err := m.AlterSequence.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *SubscriptionOption) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscriptionOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscriptionOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Publication) > 0 {
		i -= len(m.Publication)
		copy(dAtA[i:], m.Publication)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Publication)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateDatabase) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Sql) > 0 {
		i -= len(m.Sql)
		copy(dAtA[i:], m.Sql)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Sql)))
		i--
		dAtA[i] = 0x22
	}
	if m.SubscriptionOption != nil {
		{
			size, err := m.SubscriptionOption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfNotExists {
		i--
		if m.IfNotExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlterDatabase) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfExists {
		i--
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DropDatabase) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CheckFKSql) > 0 {
		i -= len(m.CheckFKSql)
		copy(dAtA[i:], m.CheckFKSql)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.CheckFKSql)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.UpdateFkSql) > 0 {
		i -= len(m.UpdateFkSql)
		copy(dAtA[i:], m.UpdateFkSql)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.UpdateFkSql)))
		i--
		dAtA[i] = 0x22
	}
	if m.DatabaseId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.DatabaseId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfExists {
		i--
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FkColName) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FkColName) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FkColName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cols) > 0 {
		for iNdEx := len(m.Cols) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Cols[iNdEx])
			copy(dAtA[i:], m.Cols[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.Cols[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ForeignKeyInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForeignKeyInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForeignKeyInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Def != nil {
		{
			size, err := m.Def.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ColsReferred != nil {
		{
			size, err := m.ColsReferred.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Cols != nil {
		{
			size, err := m.Cols.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Db) > 0 {
		i -= len(m.Db)
		copy(dAtA[i:], m.Db)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Db)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateTable) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FksReferToMe) > 0 {
		for iNdEx := len(m.FksReferToMe) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FksReferToMe[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.UpdateFkSqls) > 0 {
		for iNdEx := len(m.UpdateFkSqls) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UpdateFkSqls[iNdEx])
			copy(dAtA[i:], m.UpdateFkSqls[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.UpdateFkSqls[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.CreateAsSelectSql) > 0 {
		i -= len(m.CreateAsSelectSql)
		copy(dAtA[i:], m.CreateAsSelectSql)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.CreateAsSelectSql)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.PartitionTables) > 0 {
		for iNdEx := len(m.PartitionTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PartitionTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.FkCols) > 0 {
		for iNdEx := len(m.FkCols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FkCols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.FkTables) > 0 {
		for iNdEx := len(m.FkTables) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FkTables[iNdEx])
			copy(dAtA[i:], m.FkTables[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.FkTables[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.FkDbs) > 0 {
		for iNdEx := len(m.FkDbs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FkDbs[iNdEx])
			copy(dAtA[i:], m.FkDbs[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.FkDbs[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.IndexTables) > 0 {
		for iNdEx := len(m.IndexTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IndexTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Replace {
		i--
		if m.Replace {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Temporary {
		i--
		if m.Temporary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.IfNotExists {
		i--
		if m.IfNotExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlterTableDrop) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTableDrop) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTableDrop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IndexTableName) > 0 {
		i -= len(m.IndexTableName)
		copy(dAtA[i:], m.IndexTableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexTableName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Typ != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Typ))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlterTableAddFk) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTableAddFk) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTableAddFk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Fkey != nil {
		{
			size, err := m.Fkey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Cols) > 0 {
		for iNdEx := len(m.Cols) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Cols[iNdEx])
			copy(dAtA[i:], m.Cols[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.Cols[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterTableAddIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTableAddIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTableAddIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IndexTableExist {
		i--
		if m.IndexTableExist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.IndexInfo != nil {
		{
			size, err := m.IndexInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.OriginTablePrimaryKey) > 0 {
		i -= len(m.OriginTablePrimaryKey)
		copy(dAtA[i:], m.OriginTablePrimaryKey)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.OriginTablePrimaryKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterTableDropIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTableDropIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTableDropIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IndexTableName) > 0 {
		i -= len(m.IndexTableName)
		copy(dAtA[i:], m.IndexTableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexTableName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.IndexName) > 0 {
		i -= len(m.IndexName)
		copy(dAtA[i:], m.IndexName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterTableAlterIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTableAlterIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTableAlterIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Visible {
		i--
		if m.Visible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.IndexName) > 0 {
		i -= len(m.IndexName)
		copy(dAtA[i:], m.IndexName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterTableAlterReIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTableAlterReIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTableAlterReIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IndexAlgoParamList != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.IndexAlgoParamList))
		i--
		dAtA[i] = 0x20
	}
	if len(m.IndexName) > 0 {
		i -= len(m.IndexName)
		copy(dAtA[i:], m.IndexName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterTableAddPartition) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTableAddPartition) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTableAddPartition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PartitionDef != nil {
		{
			size, err := m.PartitionDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PartitionTables) > 0 {
		for iNdEx := len(m.PartitionTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PartitionTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Definitions) > 0 {
		for iNdEx := len(m.Definitions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Definitions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AlterTableComment) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTableComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTableComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NewComment) > 0 {
		i -= len(m.NewComment)
		copy(dAtA[i:], m.NewComment)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.NewComment)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterTableName) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTableName) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTableName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NewName) > 0 {
		i -= len(m.NewName)
		copy(dAtA[i:], m.NewName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.NewName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OldName) > 0 {
		i -= len(m.OldName)
		copy(dAtA[i:], m.OldName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.OldName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterAddColumn) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterAddColumn) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterAddColumn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Pos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Pos))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPlan(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.PreName) > 0 {
		i -= len(m.PreName)
		copy(dAtA[i:], m.PreName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.PreName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterDropColumn) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterDropColumn) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterDropColumn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Seq != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x10
	}
	if m.Idx != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Idx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlterTable) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpdateFkSqls) > 0 {
		for iNdEx := len(m.UpdateFkSqls) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UpdateFkSqls[iNdEx])
			copy(dAtA[i:], m.UpdateFkSqls[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.UpdateFkSqls[iNdEx])))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.DetectSqls) > 0 {
		for iNdEx := len(m.DetectSqls) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DetectSqls[iNdEx])
			copy(dAtA[i:], m.DetectSqls[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.DetectSqls[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.ChangeTblColIdMap) > 0 {
		for k := range m.ChangeTblColIdMap {
			v := m.ChangeTblColIdMap[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPlan(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintPlan(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintPlan(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.InsertDataSql) > 0 {
		i -= len(m.InsertDataSql)
		copy(dAtA[i:], m.InsertDataSql)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.InsertDataSql)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.CreateTableSql) > 0 {
		i -= len(m.CreateTableSql)
		copy(dAtA[i:], m.CreateTableSql)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.CreateTableSql)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.InsertTmpDataSql) > 0 {
		i -= len(m.InsertTmpDataSql)
		copy(dAtA[i:], m.InsertTmpDataSql)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.InsertTmpDataSql)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.CreateTmpTableSql) > 0 {
		i -= len(m.CreateTmpTableSql)
		copy(dAtA[i:], m.CreateTmpTableSql)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.CreateTmpTableSql)))
		i--
		dAtA[i] = 0x3a
	}
	if m.AlgorithmType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.AlgorithmType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Actions) > 0 {
		for iNdEx := len(m.Actions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Actions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.IsClusterTable {
		i--
		if m.IsClusterTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.CopyTableDef != nil {
		{
			size, err := m.CopyTableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterTable_Action) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTable_Action) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Action != nil {
		{
			size := m.Action.ProtoSize()
			i -= size
			if _, err := m.Action.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AlterTable_Action_Drop) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action_Drop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Drop != nil {
		{
			size, err := m.Drop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AlterTable_Action_AddFk) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action_AddFk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddFk != nil {
		{
			size, err := m.AddFk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AlterTable_Action_AddIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action_AddIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddIndex != nil {
		{
			size, err := m.AddIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AlterTable_Action_AlterIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action_AlterIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterIndex != nil {
		{
			size, err := m.AlterIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AlterTable_Action_AlterComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action_AlterComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterComment != nil {
		{
			size, err := m.AlterComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *AlterTable_Action_AlterName) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action_AlterName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterName != nil {
		{
			size, err := m.AlterName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *AlterTable_Action_AddColumn) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action_AddColumn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddColumn != nil {
		{
			size, err := m.AddColumn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *AlterTable_Action_DropColumn) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action_DropColumn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DropColumn != nil {
		{
			size, err := m.DropColumn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *AlterTable_Action_AlterReindex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action_AlterReindex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterReindex != nil {
		{
			size, err := m.AlterReindex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *AlterTable_Action_AddPartition) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action_AddPartition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddPartition != nil {
		{
			size, err := m.AddPartition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *DropTable) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FkChildTblsReferToMe) > 0 {
		dAtA179 := make([]byte, len(m.FkChildTblsReferToMe)*10)
		var j178 int
		for _, num := range m.FkChildTblsReferToMe {
			for num >= 1<<7 {
				dAtA179[j178] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j178++
			}
			dAtA179[j178] = uint8(num)
			j178++
		}
		i -= j178
		copy(dAtA[i:], dAtA179[:j178])
		i = encodeVarintPlan(dAtA, i, uint64(j178))
		i--
		dAtA[i] = 0x62
	}
	if len(m.UpdateFkSqls) > 0 {
		for iNdEx := len(m.UpdateFkSqls) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UpdateFkSqls[iNdEx])
			copy(dAtA[i:], m.UpdateFkSqls[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.UpdateFkSqls[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.IsView {
		i--
		if m.IsView {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.PartitionTableNames) > 0 {
		for iNdEx := len(m.PartitionTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionTableNames[iNdEx])
			copy(dAtA[i:], m.PartitionTableNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionTableNames[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ForeignTbl) > 0 {
		dAtA182 := make([]byte, len(m.ForeignTbl)*10)
		var j181 int
		for _, num := range m.ForeignTbl {
			for num >= 1<<7 {
				dAtA182[j181] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j181++
			}
			dAtA182[j181] = uint8(num)
			j181++
		}
		i -= j181
		copy(dAtA[i:], dAtA182[:j181])
		i = encodeVarintPlan(dAtA, i, uint64(j181))
		i--
		dAtA[i] = 0x3a
	}
	if m.TableId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x30
	}
	if m.ClusterTable != nil {
		{
			size, err := m.ClusterTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.IndexTableNames) > 0 {
		for iNdEx := len(m.IndexTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IndexTableNames[iNdEx])
			copy(dAtA[i:], m.IndexTableNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexTableNames[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfExists {
		i--
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlterView) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterView) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfExists {
		i--
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateSequence) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfNotExists {
		i--
		if m.IfNotExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DropSequence) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfExists {
		i--
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlterSequence) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfExists {
		i--
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableExist {
		i--
		if m.TableExist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Index != nil {
		{
			size, err := m.Index.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OriginTablePrimaryKey) > 0 {
		i -= len(m.OriginTablePrimaryKey)
		copy(dAtA[i:], m.OriginTablePrimaryKey)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.OriginTablePrimaryKey)))
		i--
		dAtA[i] = 0x22
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Index) > 0 {
		i -= len(m.Index)
		copy(dAtA[i:], m.Index)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Index)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DropIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IndexTableName) > 0 {
		i -= len(m.IndexTableName)
		copy(dAtA[i:], m.IndexTableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexTableName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.IndexName) > 0 {
		i -= len(m.IndexName)
		copy(dAtA[i:], m.IndexName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TruncateTable) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TruncateTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TruncateTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsDelete {
		i--
		if m.IsDelete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.ForeignTbl) > 0 {
		dAtA190 := make([]byte, len(m.ForeignTbl)*10)
		var j189 int
		for _, num := range m.ForeignTbl {
			for num >= 1<<7 {
				dAtA190[j189] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j189++
			}
			dAtA190[j189] = uint8(num)
			j189++
		}
		i -= j189
		copy(dAtA[i:], dAtA190[:j189])
		i = encodeVarintPlan(dAtA, i, uint64(j189))
		i--
		dAtA[i] = 0x3a
	}
	if m.TableId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x30
	}
	if m.ClusterTable != nil {
		{
			size, err := m.ClusterTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PartitionTableNames) > 0 {
		for iNdEx := len(m.PartitionTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionTableNames[iNdEx])
			copy(dAtA[i:], m.PartitionTableNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionTableNames[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.IndexTableNames) > 0 {
		for iNdEx := len(m.IndexTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IndexTableNames[iNdEx])
			copy(dAtA[i:], m.IndexTableNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexTableNames[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterTable) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ColumnIndexOfAccountId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ColumnIndexOfAccountId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AccountIDs) > 0 {
		dAtA193 := make([]byte, len(m.AccountIDs)*10)
		var j192 int
		for _, num := range m.AccountIDs {
			for num >= 1<<7 {
				dAtA193[j192] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j192++
			}
			dAtA193[j192] = uint8(num)
			j192++
		}
		i -= j192
		copy(dAtA[i:], dAtA193[:j192])
		i = encodeVarintPlan(dAtA, i, uint64(j192))
		i--
		dAtA[i] = 0x12
	}
	if m.IsClusterTable {
		i--
		if m.IsClusterTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShowVariables) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowVariables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShowVariables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Where) > 0 {
		for iNdEx := len(m.Where) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Where[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Global {
		i--
		if m.Global {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetVariables) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetVariables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetVariables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SetVariablesItem) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetVariablesItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetVariablesItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Reserved != nil {
		{
			size, err := m.Reserved.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Global {
		i--
		if m.Global {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.System {
		i--
		if m.System {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Prepare) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Prepare) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Prepare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ParamTypes) > 0 {
		dAtA197 := make([]byte, len(m.ParamTypes)*10)
		var j196 int
		for _, num1 := range m.ParamTypes {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA197[j196] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j196++
			}
			dAtA197[j196] = uint8(num)
			j196++
		}
		i -= j196
		copy(dAtA[i:], dAtA197[:j196])
		i = encodeVarintPlan(dAtA, i, uint64(j196))
		i--
		dAtA[i] = 0x22
	}
	if m.Plan != nil {
		{
			size, err := m.Plan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Schemas) > 0 {
		for iNdEx := len(m.Schemas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Schemas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Execute) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Execute) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Execute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Args[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Deallocate) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deallocate) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Deallocate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OtherDCL) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OtherDCL) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OtherDCL) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ParamTypes) > 0 {
		dAtA200 := make([]byte, len(m.ParamTypes)*10)
		var j199 int
		for _, num1 := range m.ParamTypes {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA200[j199] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j199++
			}
			dAtA200[j199] = uint8(num)
			j199++
		}
		i -= j199
		copy(dAtA[i:], dAtA200[:j199])
		i = encodeVarintPlan(dAtA, i, uint64(j199))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableLockInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableLockInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableLockInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LockType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.LockType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LockTables) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockTables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockTables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TableLocks) > 0 {
		for iNdEx := len(m.TableLocks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TableLocks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UnLockTables) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnLockTables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnLockTables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *MetadataScanInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetadataScanInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetadataScanInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ZoneMap) > 0 {
		i -= len(m.ZoneMap)
		copy(dAtA[i:], m.ZoneMap)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ZoneMap)))
		i--
		dAtA[i] = 0x5a
	}
	if m.OriginSize != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.OriginSize))
		i--
		dAtA[i] = 0x50
	}
	if m.CompressSize != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.CompressSize))
		i--
		dAtA[i] = 0x48
	}
	if m.NullCnt != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.NullCnt))
		i--
		dAtA[i] = 0x40
	}
	if m.RowCnt != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RowCnt))
		i--
		dAtA[i] = 0x38
	}
	if len(m.DeleteTs) > 0 {
		i -= len(m.DeleteTs)
		copy(dAtA[i:], m.DeleteTs)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DeleteTs)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CreateTs) > 0 {
		i -= len(m.CreateTs)
		copy(dAtA[i:], m.CreateTs)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.CreateTs)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ObjLoc) > 0 {
		i -= len(m.ObjLoc)
		copy(dAtA[i:], m.ObjLoc)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ObjLoc)))
		i--
		dAtA[i] = 0x22
	}
	if m.IsHidden {
		i--
		if m.IsHidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ObjectName) > 0 {
		i -= len(m.ObjectName)
		copy(dAtA[i:], m.ObjectName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ObjectName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ColName) > 0 {
		i -= len(m.ColName)
		copy(dAtA[i:], m.ColName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ColName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPlan(dAtA []byte, offset int, v uint64) int {
	offset -= sovPlan(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Type) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlan(uint64(m.Id))
	}
	if m.NotNullable {
		n += 2
	}
	if m.AutoIncr {
		n += 2
	}
	if m.Width != 0 {
		n += 1 + sovPlan(uint64(m.Width))
	}
	if m.Scale != 0 {
		n += 1 + sovPlan(uint64(m.Scale))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Enumvalues)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MsgHeader) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgTag != 0 {
		n += 1 + sovPlan(uint64(m.MsgTag))
	}
	if m.MsgType != 0 {
		n += 1 + sovPlan(uint64(m.MsgType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Literal) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Isnull {
		n += 2
	}
	if m.Value != nil {
		n += m.Value.ProtoSize()
	}
	if m.IsBin {
		n += 3
	}
	if m.Src != nil {
		l = m.Src.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Literal_I8Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.I8Val))
	return n
}
func (m *Literal_I16Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.I16Val))
	return n
}
func (m *Literal_I32Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.I32Val))
	return n
}
func (m *Literal_I64Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.I64Val))
	return n
}
func (m *Literal_U8Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.U8Val))
	return n
}
func (m *Literal_U16Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.U16Val))
	return n
}
func (m *Literal_U32Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.U32Val))
	return n
}
func (m *Literal_U64Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.U64Val))
	return n
}
func (m *Literal_Dval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *Literal_Sval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sval)
	n += 1 + l + sovPlan(uint64(l))
	return n
}
func (m *Literal_Bval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *Literal_Fval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	return n
}
func (m *Literal_Dateval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.Dateval))
	return n
}
func (m *Literal_Timeval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.Timeval))
	return n
}
func (m *Literal_Datetimeval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sovPlan(uint64(m.Datetimeval))
	return n
}
func (m *Literal_Decimal64Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Decimal64Val != nil {
		l = m.Decimal64Val.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Literal_Decimal128Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Decimal128Val != nil {
		l = m.Decimal128Val.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Literal_Timestampval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sovPlan(uint64(m.Timestampval))
	return n
}
func (m *Literal_Jsonval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Jsonval)
	n += 2 + l + sovPlan(uint64(l))
	return n
}
func (m *Literal_Defaultval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 3
	return n
}
func (m *Literal_UpdateVal) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 3
	return n
}
func (m *Literal_EnumVal) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sovPlan(uint64(m.EnumVal))
	return n
}
func (m *ParamRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pos != 0 {
		n += 1 + sovPlan(uint64(m.Pos))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VarRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.System {
		n += 2
	}
	if m.Global {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RelPos != 0 {
		n += 1 + sovPlan(uint64(m.RelPos))
	}
	if m.ColPos != 0 {
		n += 1 + sovPlan(uint64(m.ColPos))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.TblName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RawColRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TblId != 0 {
		n += 1 + sovPlan(uint64(m.TblId))
	}
	if m.ColId != 0 {
		n += 1 + sovPlan(uint64(m.ColId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CorrColRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RelPos != 0 {
		n += 1 + sovPlan(uint64(m.RelPos))
	}
	if m.ColPos != 0 {
		n += 1 + sovPlan(uint64(m.ColPos))
	}
	if m.Depth != 0 {
		n += 1 + sovPlan(uint64(m.Depth))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExprList) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MaxValue) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TargetType) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubqueryRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Typ != 0 {
		n += 1 + sovPlan(uint64(m.Typ))
	}
	if m.NodeId != 0 {
		n += 1 + sovPlan(uint64(m.NodeId))
	}
	l = len(m.Op)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Child != nil {
		l = m.Child.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.RowSize != 0 {
		n += 1 + sovPlan(uint64(m.RowSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Server != 0 {
		n += 1 + sovPlan(uint64(m.Server))
	}
	if m.Db != 0 {
		n += 1 + sovPlan(uint64(m.Db))
	}
	if m.Schema != 0 {
		n += 1 + sovPlan(uint64(m.Schema))
	}
	if m.Obj != 0 {
		n += 1 + sovPlan(uint64(m.Obj))
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.SchemaName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.ObjName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.SubscriptionName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.PubInfo != nil {
		l = m.PubInfo.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PubInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TenantId != 0 {
		n += 1 + sovPlan(uint64(m.TenantId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubscriptionMeta) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.AccountId != 0 {
		n += 1 + sovPlan(uint64(m.AccountId))
	}
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.AccountName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.SubName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Function) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Func != nil {
		l = m.Func.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, e := range m.Args {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Expr) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Typ.ProtoSize()
	n += 1 + l + sovPlan(uint64(l))
	if m.Expr != nil {
		n += m.Expr.ProtoSize()
	}
	if m.AuxId != 0 {
		n += 1 + sovPlan(uint64(m.AuxId))
	}
	if m.Ndv != 0 {
		n += 10
	}
	if m.Selectivity != 0 {
		n += 10
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Expr_Lit) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lit != nil {
		l = m.Lit.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_P) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.P != nil {
		l = m.P.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_V) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.V != nil {
		l = m.V.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_Col) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Col != nil {
		l = m.Col.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_Raw) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Raw != nil {
		l = m.Raw.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_F) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.F != nil {
		l = m.F.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_W) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.W != nil {
		l = m.W.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_Sub) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sub != nil {
		l = m.Sub.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_Corr) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Corr != nil {
		l = m.Corr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_T) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.T != nil {
		l = m.T.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_List) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.List != nil {
		l = m.List.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_Max) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Max != nil {
		l = m.Max.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_Vec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vec != nil {
		l = m.Vec.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *LiteralVec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Len != 0 {
		n += 1 + sovPlan(uint64(m.Len))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Decimal64) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A != 0 {
		n += 1 + sovPlan(uint64(m.A))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Decimal128) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A != 0 {
		n += 1 + sovPlan(uint64(m.A))
	}
	if m.B != 0 {
		n += 1 + sovPlan(uint64(m.B))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultColDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ResultCols) > 0 {
		for _, e := range m.ResultCols {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColId != 0 {
		n += 1 + sovPlan(uint64(m.ColId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Hidden {
		n += 2
	}
	if m.Alg != 0 {
		n += 1 + sovPlan(uint64(m.Alg))
	}
	l = m.Typ.ProtoSize()
	n += 1 + l + sovPlan(uint64(l))
	if m.NotNull {
		n += 2
	}
	if m.Default != nil {
		l = m.Default.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.OnUpdate != nil {
		l = m.OnUpdate.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.LowCard {
		n += 2
	}
	if m.Seqnum != 0 {
		n += 1 + sovPlan(uint64(m.Seqnum))
	}
	if m.ClusterBy {
		n += 2
	}
	if m.Primary {
		n += 2
	}
	if m.Pkidx != 0 {
		n += 1 + sovPlan(uint64(m.Pkidx))
	}
	if m.Headers {
		n += 2
	}
	l = len(m.Header)
	if l > 0 {
		n += 2 + l + sovPlan(uint64(l))
	}
	l = len(m.TblName)
	if l > 0 {
		n += 2 + l + sovPlan(uint64(l))
	}
	l = len(m.DbName)
	if l > 0 {
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Default) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.OriginString)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.NullAbility {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OnUpdate) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.OriginString)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IndexOption) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateExtraTable {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrimaryKeyDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cols) > 0 {
		l = 0
		for _, e := range m.Cols {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.PkeyColId != 0 {
		n += 1 + sovPlan(uint64(m.PkeyColId))
	}
	if m.Option != nil {
		l = m.Option.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.PkeyColName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.CompPkeyCol != nil {
		l = m.CompPkeyCol.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IndexDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IdxId)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Parts) > 0 {
		for _, s := range m.Parts {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Unique {
		n += 2
	}
	l = len(m.IndexTableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableExist {
		n += 2
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Visible {
		n += 2
	}
	if m.Option != nil {
		l = m.Option.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexAlgo)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexAlgoTableType)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexAlgoParams)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ForeignKeyDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Cols) > 0 {
		l = 0
		for _, e := range m.Cols {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.ForeignTbl != 0 {
		n += 1 + sovPlan(uint64(m.ForeignTbl))
	}
	if len(m.ForeignCols) > 0 {
		l = 0
		for _, e := range m.ForeignCols {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.OnDelete != 0 {
		n += 1 + sovPlan(uint64(m.OnDelete))
	}
	if m.OnUpdate != 0 {
		n += 1 + sovPlan(uint64(m.OnUpdate))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Check != nil {
		l = m.Check.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterByDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.CompCbkeyCol != nil {
		l = m.CompCbkeyCol.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PropertyDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Property) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PropertiesDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Properties) > 0 {
		for _, e := range m.Properties {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionByDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPlan(uint64(m.Type))
	}
	if m.PartitionExpr != nil {
		l = m.PartitionExpr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.PartitionExpression != nil {
		l = m.PartitionExpression.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.PartitionColumns != nil {
		l = m.PartitionColumns.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.PartitionNum != 0 {
		n += 1 + sovPlan(uint64(m.PartitionNum))
	}
	if len(m.Partitions) > 0 {
		for _, e := range m.Partitions {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Algorithm != 0 {
		n += 1 + sovPlan(uint64(m.Algorithm))
	}
	if m.IsSubPartition {
		n += 2
	}
	l = len(m.PartitionMsg)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.PartitionTableNames) > 0 {
		for _, s := range m.PartitionTableNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionExpr) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.ExprStr)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionColumns) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.PartitionColumns) > 0 {
		for _, s := range m.PartitionColumns {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionItem) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PartitionName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.OrdinalPosition != 0 {
		n += 1 + sovPlan(uint64(m.OrdinalPosition))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.LessThan) > 0 {
		for _, e := range m.LessThan {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.InValues) > 0 {
		for _, e := range m.InValues {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	l = len(m.PartitionTableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ViewDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.View)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TblId != 0 {
		n += 1 + sovPlan(uint64(m.TblId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Hidden {
		n += 2
	}
	if len(m.Cols) > 0 {
		for _, e := range m.Cols {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	l = len(m.TableType)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Createsql)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TblFunc != nil {
		l = m.TblFunc.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovPlan(uint64(m.Version))
	}
	if m.Pkey != nil {
		l = m.Pkey.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Indexes) > 0 {
		for _, e := range m.Indexes {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Fkeys) > 0 {
		for _, e := range m.Fkeys {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.RefChildTbls) > 0 {
		l = 0
		for _, e := range m.RefChildTbls {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.Checks) > 0 {
		for _, e := range m.Checks {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Partition != nil {
		l = m.Partition.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.ClusterBy != nil {
		l = m.ClusterBy.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if len(m.Props) > 0 {
		for _, e := range m.Props {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if m.ViewSql != nil {
		l = m.ViewSql.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if len(m.Defs) > 0 {
		for _, e := range m.Defs {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Name2ColIndex) > 0 {
		for k, v := range m.Name2ColIndex {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPlan(uint64(len(k))) + 1 + sovPlan(uint64(v))
			n += mapEntrySize + 2 + sovPlan(uint64(mapEntrySize))
		}
	}
	if m.IsLocked {
		n += 3
	}
	if m.TableLockType != 0 {
		n += 2 + sovPlan(uint64(m.TableLockType))
	}
	if m.IsTemporary {
		n += 3
	}
	if m.AutoIncrOffset != 0 {
		n += 2 + sovPlan(uint64(m.AutoIncrOffset))
	}
	if m.IsDynamic {
		n += 3
	}
	l = len(m.DbName)
	if l > 0 {
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableDef_DefType) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Def != nil {
		n += m.Def.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableDef_DefType_Properties) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Properties != nil {
		l = m.Properties.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TableFunction) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Param)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HashMapStats) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HashmapSize != 0 {
		n += 9
	}
	if m.HashOnPK {
		n += 2
	}
	if m.Shuffle {
		n += 2
	}
	if m.ShuffleColIdx != 0 {
		n += 1 + sovPlan(uint64(m.ShuffleColIdx))
	}
	if m.ShuffleType != 0 {
		n += 1 + sovPlan(uint64(m.ShuffleType))
	}
	if m.ShuffleTypeForMultiCN != 0 {
		n += 1 + sovPlan(uint64(m.ShuffleTypeForMultiCN))
	}
	if m.ShuffleColMin != 0 {
		n += 1 + sovPlan(uint64(m.ShuffleColMin))
	}
	if m.ShuffleColMax != 0 {
		n += 1 + sovPlan(uint64(m.ShuffleColMax))
	}
	if m.ShuffleMethod != 0 {
		n += 1 + sovPlan(uint64(m.ShuffleMethod))
	}
	if m.Nullcnt != 0 {
		n += 1 + sovPlan(uint64(m.Nullcnt))
	}
	if len(m.Ranges) > 0 {
		n += 1 + sovPlan(uint64(len(m.Ranges)*8)) + len(m.Ranges)*8
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Stats) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockNum != 0 {
		n += 1 + sovPlan(uint64(m.BlockNum))
	}
	if m.Cost != 0 {
		n += 9
	}
	if m.Outcnt != 0 {
		n += 9
	}
	if m.Rowsize != 0 {
		n += 9
	}
	if m.TableCnt != 0 {
		n += 9
	}
	if m.Selectivity != 0 {
		n += 9
	}
	if m.ForceOneCN {
		n += 2
	}
	if m.HashmapStats != nil {
		l = m.HashmapStats.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RowsetExpr) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RowPos != 0 {
		n += 1 + sovPlan(uint64(m.RowPos))
	}
	if m.Pos != 0 {
		n += 1 + sovPlan(uint64(m.Pos))
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColData) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RowsetData) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cols) > 0 {
		for _, e := range m.Cols {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.RowCount != 0 {
		n += 1 + sovPlan(uint64(m.RowCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrderBySpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Collation)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Flag != 0 {
		n += 1 + sovPlan(uint64(m.Flag))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WindowSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WindowFunc != nil {
		l = m.WindowFunc.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.PartitionBy) > 0 {
		for _, e := range m.PartitionBy {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OrderBy) > 0 {
		for _, e := range m.OrderBy {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Frame != nil {
		l = m.Frame.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SampleFuncSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rows != 0 {
		n += 1 + sovPlan(uint64(m.Rows))
	}
	if m.Percent != 0 {
		n += 9
	}
	if m.UsingRow {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FrameClause) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPlan(uint64(m.Type))
	}
	if m.Start != nil {
		l = m.Start.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.End != nil {
		l = m.End.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FrameBound) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPlan(uint64(m.Type))
	}
	if m.UnBounded {
		n += 2
	}
	if m.Val != nil {
		l = m.Val.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OnDuplicateKeyCtx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attrs) > 0 {
		for _, s := range m.Attrs {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.InsertColCount != 0 {
		n += 1 + sovPlan(uint64(m.InsertColCount))
	}
	if len(m.UniqueColCheckExpr) > 0 {
		for _, e := range m.UniqueColCheckExpr {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.UniqueCols) > 0 {
		for _, s := range m.UniqueCols {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OnDuplicateIdx) > 0 {
		l = 0
		for _, e := range m.OnDuplicateIdx {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.OnDuplicateExpr) > 0 {
		for k, v := range m.OnDuplicateExpr {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.ProtoSize()
				l += 1 + sovPlan(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPlan(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPlan(uint64(mapEntrySize))
		}
	}
	if m.IsIgnore {
		n += 2
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableId != 0 {
		n += 1 + sovPlan(uint64(m.TableId))
	}
	if m.TableVersion != 0 {
		n += 1 + sovPlan(uint64(m.TableVersion))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InsertCtx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ref != nil {
		l = m.Ref.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.AddAffectedRows {
		n += 2
	}
	if m.IsClusterTable {
		n += 2
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.PartitionTableIds) > 0 {
		l = 0
		for _, e := range m.PartitionTableIds {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.PartitionTableNames) > 0 {
		for _, s := range m.PartitionTableNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.PartitionIdx != 0 {
		n += 1 + sovPlan(uint64(m.PartitionIdx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReplaceCtx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ref != nil {
		l = m.Ref.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.AddAffectedRows {
		n += 2
	}
	if m.IsClusterTable {
		n += 2
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.DeleteCond)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.PartitionTableIds) > 0 {
		l = 0
		for _, e := range m.PartitionTableIds {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.PartitionTableNames) > 0 {
		for _, s := range m.PartitionTableNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.PartitionIdx != 0 {
		n += 1 + sovPlan(uint64(m.PartitionIdx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnalyzeInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InputRows != 0 {
		n += 1 + sovPlan(uint64(m.InputRows))
	}
	if m.OutputRows != 0 {
		n += 1 + sovPlan(uint64(m.OutputRows))
	}
	if m.InputSize != 0 {
		n += 1 + sovPlan(uint64(m.InputSize))
	}
	if m.OutputSize != 0 {
		n += 1 + sovPlan(uint64(m.OutputSize))
	}
	if m.TimeConsumed != 0 {
		n += 1 + sovPlan(uint64(m.TimeConsumed))
	}
	if m.MemorySize != 0 {
		n += 1 + sovPlan(uint64(m.MemorySize))
	}
	if m.WaitTimeConsumed != 0 {
		n += 1 + sovPlan(uint64(m.WaitTimeConsumed))
	}
	if m.DiskIO != 0 {
		n += 1 + sovPlan(uint64(m.DiskIO))
	}
	if m.S3IOByte != 0 {
		n += 1 + sovPlan(uint64(m.S3IOByte))
	}
	if m.S3IOInputCount != 0 {
		n += 1 + sovPlan(uint64(m.S3IOInputCount))
	}
	if m.S3IOOutputCount != 0 {
		n += 1 + sovPlan(uint64(m.S3IOOutputCount))
	}
	if m.NetworkIO != 0 {
		n += 1 + sovPlan(uint64(m.NetworkIO))
	}
	if m.ScanTime != 0 {
		n += 1 + sovPlan(uint64(m.ScanTime))
	}
	if m.InsertTime != 0 {
		n += 1 + sovPlan(uint64(m.InsertTime))
	}
	if len(m.TimeConsumedArrayMajor) > 0 {
		l = 0
		for _, e := range m.TimeConsumedArrayMajor {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.TimeConsumedArrayMinor) > 0 {
		l = 0
		for _, e := range m.TimeConsumedArrayMinor {
			l += sovPlan(uint64(e))
		}
		n += 2 + sovPlan(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionPrune) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsPruned {
		n += 2
	}
	if len(m.SelectedPartitions) > 0 {
		for _, e := range m.SelectedPartitions {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OriginTableMessageForFuzzy) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ParentTableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.ParentUniqueCols) > 0 {
		for _, e := range m.ParentUniqueCols {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Node) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeType != 0 {
		n += 1 + sovPlan(uint64(m.NodeType))
	}
	if m.NodeId != 0 {
		n += 1 + sovPlan(uint64(m.NodeId))
	}
	if m.Stats != nil {
		l = m.Stats.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Children) > 0 {
		l = 0
		for _, e := range m.Children {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.ProjectList) > 0 {
		for _, e := range m.ProjectList {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.JoinType != 0 {
		n += 1 + sovPlan(uint64(m.JoinType))
	}
	if len(m.OnList) > 0 {
		for _, e := range m.OnList {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.BuildOnLeft {
		n += 2
	}
	if len(m.FilterList) > 0 {
		for _, e := range m.FilterList {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.GroupBy) > 0 {
		for _, e := range m.GroupBy {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.GroupingSet) > 0 {
		for _, e := range m.GroupingSet {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.AggList) > 0 {
		for _, e := range m.AggList {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.WinSpecList) > 0 {
		for _, e := range m.WinSpecList {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OrderBy) > 0 {
		for _, e := range m.OrderBy {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Limit != nil {
		l = m.Limit.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Offset != nil {
		l = m.Offset.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.ObjRef != nil {
		l = m.ObjRef.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.ParentObjRef != nil {
		l = m.ParentObjRef.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.RowsetData != nil {
		l = m.RowsetData.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	l = len(m.ExtraOptions)
	if l > 0 {
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.DeleteCtx != nil {
		l = m.DeleteCtx.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if len(m.BindingTags) > 0 {
		l = 0
		for _, e := range m.BindingTags {
			l += sovPlan(uint64(e))
		}
		n += 2 + sovPlan(uint64(l)) + l
	}
	if m.AnalyzeInfo != nil {
		l = m.AnalyzeInfo.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if len(m.TblFuncExprList) > 0 {
		for _, e := range m.TblFuncExprList {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if m.ClusterTable != nil {
		l = m.ClusterTable.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.NotCacheable {
		n += 3
	}
	if m.InsertCtx != nil {
		l = m.InsertCtx.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.ReplaceCtx != nil {
		l = m.ReplaceCtx.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if len(m.SourceStep) > 0 {
		l = 0
		for _, e := range m.SourceStep {
			l += sovPlan(uint64(e))
		}
		n += 2 + sovPlan(uint64(l)) + l
	}
	if m.PreDeleteCtx != nil {
		l = m.PreDeleteCtx.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.PreInsertCtx != nil {
		l = m.PreInsertCtx.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.PreInsertUkCtx != nil {
		l = m.PreInsertUkCtx.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.OnDuplicateKey != nil {
		l = m.OnDuplicateKey.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.IsEnd {
		n += 3
	}
	if len(m.LockTargets) > 0 {
		for _, e := range m.LockTargets {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if len(m.BlockFilterList) > 0 {
		for _, e := range m.BlockFilterList {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if len(m.RuntimeFilterProbeList) > 0 {
		for _, e := range m.RuntimeFilterProbeList {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for _, e := range m.RuntimeFilterBuildList {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.RecursiveSink {
		n += 3
	}
	if m.ExternScan != nil {
		l = m.ExternScan.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.PartitionPrune != nil {
		l = m.PartitionPrune.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.PreInsertSkCtx != nil {
		l = m.PreInsertSkCtx.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.Interval != nil {
		l = m.Interval.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.Sliding != nil {
		l = m.Sliding.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.FillType != 0 {
		n += 2 + sovPlan(uint64(m.FillType))
	}
	if len(m.FillVal) > 0 {
		for _, e := range m.FillVal {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if m.SampleFunc != nil {
		l = m.SampleFunc.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.WindowIdx != 0 {
		n += 2 + sovPlan(uint64(m.WindowIdx))
	}
	if len(m.OnUpdateExprs) > 0 {
		for _, e := range m.OnUpdateExprs {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if m.Fuzzymessage != nil {
		l = m.Fuzzymessage.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if len(m.SendMsgList) > 0 {
		for _, e := range m.SendMsgList {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if len(m.RecvMsgList) > 0 {
		for _, e := range m.RecvMsgList {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if m.ScanSnapshot != nil {
		l = m.ScanSnapshot.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Snapshot) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TS != nil {
		l = m.TS.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.CreatedByTenant != nil {
		l = m.CreatedByTenant.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SnapshotTenant) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TenantName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TenantID != 0 {
		n += 1 + sovPlan(uint64(m.TenantID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExternScan) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPlan(uint64(m.Type))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.IgnoredLines != 0 {
		n += 1 + sovPlan(uint64(m.IgnoredLines))
	}
	l = len(m.EnclosedBy)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Terminated)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.JsonType)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LockTarget) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovPlan(uint64(m.TableId))
	}
	if m.PrimaryColIdxInBat != 0 {
		n += 1 + sovPlan(uint64(m.PrimaryColIdxInBat))
	}
	l = m.PrimaryColTyp.ProtoSize()
	n += 1 + l + sovPlan(uint64(l))
	if m.RefreshTsIdxInBat != 0 {
		n += 1 + sovPlan(uint64(m.RefreshTsIdxInBat))
	}
	if m.FilterColIdxInBat != 0 {
		n += 1 + sovPlan(uint64(m.FilterColIdxInBat))
	}
	if m.LockTable {
		n += 2
	}
	if m.IsPartitionTable {
		n += 2
	}
	if len(m.PartitionTableIds) > 0 {
		l = 0
		for _, e := range m.PartitionTableIds {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.Block {
		n += 2
	}
	if m.Mode != 0 {
		n += 1 + sovPlan(uint64(m.Mode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PreInsertUkCtx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		l = 0
		for _, e := range m.Columns {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.PkColumn != 0 {
		n += 1 + sovPlan(uint64(m.PkColumn))
	}
	l = m.PkType.ProtoSize()
	n += 1 + l + sovPlan(uint64(l))
	l = m.UkType.ProtoSize()
	n += 1 + l + sovPlan(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PreDeleteCtx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Idx) > 0 {
		l = 0
		for _, e := range m.Idx {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PreInsertCtx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ref != nil {
		l = m.Ref.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.HasAutoCol {
		n += 2
	}
	if m.IsUpdate {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RuntimeFilterSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovPlan(uint64(m.Tag))
	}
	if m.MatchPrefix {
		n += 2
	}
	if m.UpperLimit != 0 {
		n += 1 + sovPlan(uint64(m.UpperLimit))
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Handled {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IdList) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		l = 0
		for _, e := range m.List {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColPosMap) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Map) > 0 {
		for k, v := range m.Map {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPlan(uint64(len(k))) + 1 + sovPlan(uint64(v))
			n += mapEntrySize + 1 + sovPlan(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteCtx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CanTruncate {
		n += 2
	}
	if m.Ref != nil {
		l = m.Ref.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.RowIdIdx != 0 {
		n += 1 + sovPlan(uint64(m.RowIdIdx))
	}
	if m.AddAffectedRows {
		n += 2
	}
	if m.IsClusterTable {
		n += 2
	}
	if len(m.PartitionTableIds) > 0 {
		l = 0
		for _, e := range m.PartitionTableIds {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.PartitionTableNames) > 0 {
		for _, s := range m.PartitionTableNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.PartitionIdx != 0 {
		n += 1 + sovPlan(uint64(m.PartitionIdx))
	}
	if m.PrimaryKeyIdx != 0 {
		n += 1 + sovPlan(uint64(m.PrimaryKeyIdx))
	}
	if m.TruncateTable != nil {
		l = m.TruncateTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Query) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StmtType != 0 {
		n += 1 + sovPlan(uint64(m.StmtType))
	}
	if len(m.Steps) > 0 {
		l = 0
		for _, e := range m.Steps {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Params) > 0 {
		for _, e := range m.Params {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Headings) > 0 {
		for _, s := range m.Headings {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.LoadTag {
		n += 2
	}
	if len(m.DetectSqls) > 0 {
		for _, s := range m.DetectSqls {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransationControl) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TclType != 0 {
		n += 1 + sovPlan(uint64(m.TclType))
	}
	if m.Action != nil {
		n += m.Action.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransationControl_Begin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Begin != nil {
		l = m.Begin.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TransationControl_Commit) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TransationControl_Rollback) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rollback != nil {
		l = m.Rollback.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TransationBegin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovPlan(uint64(m.Mode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransationCommit) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompletionType != 0 {
		n += 1 + sovPlan(uint64(m.CompletionType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransationRollback) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompletionType != 0 {
		n += 1 + sovPlan(uint64(m.CompletionType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Plan) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Plan != nil {
		n += m.Plan.ProtoSize()
	}
	if m.TryRunTimes != 0 {
		n += 1 + sovPlan(uint64(m.TryRunTimes))
	}
	if m.IsPrepare {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Plan_Query) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Query != nil {
		l = m.Query.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Plan_Tcl) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tcl != nil {
		l = m.Tcl.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Plan_Ddl) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ddl != nil {
		l = m.Ddl.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Plan_Dcl) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dcl != nil {
		l = m.Dcl.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Column) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Column) > 0 {
		for _, e := range m.Column {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataControl) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DclType != 0 {
		n += 1 + sovPlan(uint64(m.DclType))
	}
	if m.Control != nil {
		n += m.Control.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataControl_SetVariables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SetVariables != nil {
		l = m.SetVariables.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataControl_Prepare) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prepare != nil {
		l = m.Prepare.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataControl_Execute) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Execute != nil {
		l = m.Execute.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataControl_Deallocate) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Deallocate != nil {
		l = m.Deallocate.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataControl_Other) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Other != nil {
		l = m.Other.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DdlType != 0 {
		n += 1 + sovPlan(uint64(m.DdlType))
	}
	if m.Query != nil {
		l = m.Query.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Definition != nil {
		n += m.Definition.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataDefinition_CreateDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateDatabase != nil {
		l = m.CreateDatabase.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_AlterDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterDatabase != nil {
		l = m.AlterDatabase.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_DropDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropDatabase != nil {
		l = m.DropDatabase.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_CreateTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateTable != nil {
		l = m.CreateTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_AlterTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterTable != nil {
		l = m.AlterTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_DropTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropTable != nil {
		l = m.DropTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_CreateIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateIndex != nil {
		l = m.CreateIndex.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_AlterIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterIndex != nil {
		l = m.AlterIndex.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_DropIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropIndex != nil {
		l = m.DropIndex.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_TruncateTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TruncateTable != nil {
		l = m.TruncateTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_ShowVariables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowVariables != nil {
		l = m.ShowVariables.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_AlterView) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterView != nil {
		l = m.AlterView.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_LockTables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LockTables != nil {
		l = m.LockTables.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_UnlockTables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnlockTables != nil {
		l = m.UnlockTables.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_CreateSequence) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateSequence != nil {
		l = m.CreateSequence.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_DropSequence) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropSequence != nil {
		l = m.DropSequence.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_AlterSequence) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterSequence != nil {
		l = m.AlterSequence.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *SubscriptionOption) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Publication)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfNotExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.SubscriptionOption != nil {
		l = m.SubscriptionOption.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Sql)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DropDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.DatabaseId != 0 {
		n += 1 + sovPlan(uint64(m.DatabaseId))
	}
	l = len(m.UpdateFkSql)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.CheckFKSql)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FkColName) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cols) > 0 {
		for _, s := range m.Cols {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ForeignKeyInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Db)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Cols != nil {
		l = m.Cols.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.ColsReferred != nil {
		l = m.ColsReferred.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Def != nil {
		l = m.Def.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfNotExists {
		n += 2
	}
	if m.Temporary {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Replace {
		n += 2
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.IndexTables) > 0 {
		for _, e := range m.IndexTables {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.FkDbs) > 0 {
		for _, s := range m.FkDbs {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.FkTables) > 0 {
		for _, s := range m.FkTables {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.FkCols) > 0 {
		for _, e := range m.FkCols {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.PartitionTables) > 0 {
		for _, e := range m.PartitionTables {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	l = len(m.CreateAsSelectSql)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.UpdateFkSqls) > 0 {
		for _, s := range m.UpdateFkSqls {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.FksReferToMe) > 0 {
		for _, e := range m.FksReferToMe {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTableDrop) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Typ != 0 {
		n += 1 + sovPlan(uint64(m.Typ))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexTableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTableAddFk) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Cols) > 0 {
		for _, s := range m.Cols {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Fkey != nil {
		l = m.Fkey.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTableAddIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.OriginTablePrimaryKey)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.IndexInfo != nil {
		l = m.IndexInfo.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.IndexTableExist {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTableDropIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexTableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTableAlterIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Visible {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTableAlterReIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.IndexAlgoParamList != 0 {
		n += 1 + sovPlan(uint64(m.IndexAlgoParamList))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTableAddPartition) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Definitions) > 0 {
		for _, e := range m.Definitions {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.PartitionTables) > 0 {
		for _, e := range m.PartitionTables {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.PartitionDef != nil {
		l = m.PartitionDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTableComment) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NewComment)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTableName) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OldName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.NewName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterAddColumn) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.PreName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = m.Type.ProtoSize()
	n += 1 + l + sovPlan(uint64(l))
	if m.Pos != 0 {
		n += 1 + sovPlan(uint64(m.Pos))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterDropColumn) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Idx != 0 {
		n += 1 + sovPlan(uint64(m.Idx))
	}
	if m.Seq != 0 {
		n += 1 + sovPlan(uint64(m.Seq))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.CopyTableDef != nil {
		l = m.CopyTableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.IsClusterTable {
		n += 2
	}
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.AlgorithmType != 0 {
		n += 1 + sovPlan(uint64(m.AlgorithmType))
	}
	l = len(m.CreateTmpTableSql)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.InsertTmpDataSql)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.CreateTableSql)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.InsertDataSql)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.ChangeTblColIdMap) > 0 {
		for k, v := range m.ChangeTblColIdMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.ProtoSize()
				l += 1 + sovPlan(uint64(l))
			}
			mapEntrySize := 1 + sovPlan(uint64(k)) + l
			n += mapEntrySize + 1 + sovPlan(uint64(mapEntrySize))
		}
	}
	if len(m.DetectSqls) > 0 {
		for _, s := range m.DetectSqls {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.UpdateFkSqls) > 0 {
		for _, s := range m.UpdateFkSqls {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTable_Action) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != nil {
		n += m.Action.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTable_Action_Drop) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Drop != nil {
		l = m.Drop.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *AlterTable_Action_AddFk) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddFk != nil {
		l = m.AddFk.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *AlterTable_Action_AddIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddIndex != nil {
		l = m.AddIndex.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *AlterTable_Action_AlterIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterIndex != nil {
		l = m.AlterIndex.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *AlterTable_Action_AlterComment) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterComment != nil {
		l = m.AlterComment.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *AlterTable_Action_AlterName) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterName != nil {
		l = m.AlterName.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *AlterTable_Action_AddColumn) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddColumn != nil {
		l = m.AddColumn.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *AlterTable_Action_DropColumn) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropColumn != nil {
		l = m.DropColumn.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *AlterTable_Action_AlterReindex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterReindex != nil {
		l = m.AlterReindex.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *AlterTable_Action_AddPartition) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddPartition != nil {
		l = m.AddPartition.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DropTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.IndexTableNames) > 0 {
		for _, s := range m.IndexTableNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.ClusterTable != nil {
		l = m.ClusterTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableId != 0 {
		n += 1 + sovPlan(uint64(m.TableId))
	}
	if len(m.ForeignTbl) > 0 {
		l = 0
		for _, e := range m.ForeignTbl {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.PartitionTableNames) > 0 {
		for _, s := range m.PartitionTableNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.IsView {
		n += 2
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.UpdateFkSqls) > 0 {
		for _, s := range m.UpdateFkSqls {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.FkChildTblsReferToMe) > 0 {
		l = 0
		for _, e := range m.FkChildTblsReferToMe {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterView) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateSequence) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfNotExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DropSequence) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableId != 0 {
		n += 1 + sovPlan(uint64(m.TableId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterSequence) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.OriginTablePrimaryKey)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Index != nil {
		l = m.Index.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableExist {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Index)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DropIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexTableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TruncateTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.IndexTableNames) > 0 {
		for _, s := range m.IndexTableNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.PartitionTableNames) > 0 {
		for _, s := range m.PartitionTableNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.ClusterTable != nil {
		l = m.ClusterTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableId != 0 {
		n += 1 + sovPlan(uint64(m.TableId))
	}
	if len(m.ForeignTbl) > 0 {
		l = 0
		for _, e := range m.ForeignTbl {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.IsDelete {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsClusterTable {
		n += 2
	}
	if len(m.AccountIDs) > 0 {
		l = 0
		for _, e := range m.AccountIDs {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.ColumnIndexOfAccountId != 0 {
		n += 1 + sovPlan(uint64(m.ColumnIndexOfAccountId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowVariables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Global {
		n += 2
	}
	if len(m.Where) > 0 {
		for _, e := range m.Where {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetVariables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetVariablesItem) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.System {
		n += 2
	}
	if m.Global {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Reserved != nil {
		l = m.Reserved.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Prepare) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Schemas) > 0 {
		for _, e := range m.Schemas {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Plan != nil {
		l = m.Plan.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.ParamTypes) > 0 {
		l = 0
		for _, e := range m.ParamTypes {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Execute) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, e := range m.Args {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Deallocate) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OtherDCL) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ParamTypes) > 0 {
		l = 0
		for _, e := range m.ParamTypes {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableLockInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LockType != 0 {
		n += 1 + sovPlan(uint64(m.LockType))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LockTables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TableLocks) > 0 {
		for _, e := range m.TableLocks {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnLockTables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetadataScanInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ColName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.ObjectName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.IsHidden {
		n += 2
	}
	l = len(m.ObjLoc)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.CreateTs)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.DeleteTs)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.RowCnt != 0 {
		n += 1 + sovPlan(uint64(m.RowCnt))
	}
	if m.NullCnt != 0 {
		n += 1 + sovPlan(uint64(m.NullCnt))
	}
	if m.CompressSize != 0 {
		n += 1 + sovPlan(uint64(m.CompressSize))
	}
	if m.OriginSize != 0 {
		n += 1 + sovPlan(uint64(m.OriginSize))
	}
	l = len(m.ZoneMap)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPlan(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPlan(x uint64) (n int) {
	return sovPlan(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Type) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotNullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotNullable = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoIncr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoIncr = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			m.Scale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scale |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enumvalues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enumvalues = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: msgHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: msgHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgTag", wireType)
			}
			m.MsgTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgTag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			m.MsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Literal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Literal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Literal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isnull", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Isnull = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field I8Val", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Literal_I8Val{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field I16Val", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Literal_I16Val{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field I32Val", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Literal_I32Val{v}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field I64Val", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Literal_I64Val{v}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field U8Val", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Literal_U8Val{v}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field U16Val", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Literal_U16Val{v}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field U32Val", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Literal_U32Val{v}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field U64Val", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Literal_U64Val{v}
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dval", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = &Literal_Dval{float64(math.Float64frombits(v))}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &Literal_Sval{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bval", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &Literal_Bval{b}
		case 13:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fval", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Value = &Literal_Fval{float32(math.Float32frombits(v))}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dateval", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Literal_Dateval{v}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeval", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Literal_Timeval{v}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datetimeval", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Literal_Datetimeval{v}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimal64Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Decimal64{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Literal_Decimal64Val{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimal128Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Decimal128{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Literal_Decimal128Val{v}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestampval", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Literal_Timestampval{v}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jsonval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &Literal_Jsonval{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defaultval", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &Literal_Defaultval{b}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateVal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &Literal_UpdateVal{b}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnumVal", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Literal_EnumVal{v}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBin = bool(v != 0)
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Src == nil {
				m.Src = &Expr{}
			}
			if err := m.Src.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParamRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParamRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParamRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VarRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VarRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VarRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field System", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.System = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Global = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelPos", wireType)
			}
			m.RelPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColPos", wireType)
			}
			m.ColPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TblName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TblName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawColRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawColRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawColRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TblId", wireType)
			}
			m.TblId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TblId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColId", wireType)
			}
			m.ColId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CorrColRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CorrColRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CorrColRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelPos", wireType)
			}
			m.RelPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColPos", wireType)
			}
			m.ColPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depth", wireType)
			}
			m.Depth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Depth |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExprList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExprList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExprList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &Expr{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaxValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaxValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaxValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TargetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubqueryRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubqueryRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubqueryRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			m.Typ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typ |= SubqueryRef_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Op = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Expr{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowSize", wireType)
			}
			m.RowSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			m.Server = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Server |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Db", wireType)
			}
			m.Db = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Db |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			m.Schema = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Schema |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Obj", wireType)
			}
			m.Obj = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Obj |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubscriptionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PubInfo == nil {
				m.PubInfo = &PubInfo{}
			}
			if err := m.PubInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PubInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PubInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PubInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			m.TenantId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscriptionMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriptionMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriptionMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			m.AccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Function) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Function: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Function: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Func", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Func == nil {
				m.Func = &ObjectRef{}
			}
			if err := m.Func.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, &Expr{})
			if err := m.Args[len(m.Args)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Expr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Typ.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Literal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Lit{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ParamRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_P{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VarRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_V{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Col", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Col{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Raw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RawColRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Raw{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Function{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_F{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field W", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WindowSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_W{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sub", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SubqueryRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Sub{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Corr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CorrColRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Corr{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TargetType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_T{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ExprList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_List{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MaxValue{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Max{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LiteralVec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Vec{v}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuxId", wireType)
			}
			m.AuxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuxId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ndv", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Ndv = float64(math.Float64frombits(v))
		case 17:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selectivity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Selectivity = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiteralVec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiteralVec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiteralVec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			m.Len = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Len |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Decimal64) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: decimal64: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: decimal64: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			m.A = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.A |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Decimal128) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: decimal128: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: decimal128: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			m.A = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.A |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			m.B = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.B |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultColDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultColDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultColDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultCols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResultCols = append(m.ResultCols, &ColDef{})
			if err := m.ResultCols[len(m.ResultCols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColId", wireType)
			}
			m.ColId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hidden = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alg", wireType)
			}
			m.Alg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alg |= CompressType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Typ.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotNull", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotNull = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Default == nil {
				m.Default = &Default{}
			}
			if err := m.Default.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OnUpdate == nil {
				m.OnUpdate = &OnUpdate{}
			}
			if err := m.OnUpdate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowCard", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LowCard = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seqnum", wireType)
			}
			m.Seqnum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seqnum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClusterBy = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Primary = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pkidx", wireType)
			}
			m.Pkidx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pkidx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Headers = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Header = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TblName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TblName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Default) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Default: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Default: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullAbility", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NullAbility = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateExtraTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateExtraTable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimaryKeyDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimaryKeyDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimaryKeyDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cols = append(m.Cols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Cols) == 0 {
					m.Cols = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cols = append(m.Cols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkeyColId", wireType)
			}
			m.PkeyColId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PkeyColId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Option == nil {
				m.Option = &IndexOption{}
			}
			if err := m.Option.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkeyColName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PkeyColName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompPkeyCol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompPkeyCol == nil {
				m.CompPkeyCol = &ColDef{}
			}
			if err := m.CompPkeyCol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parts = append(m.Parts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unique = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableExist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TableExist = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Visible = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Option == nil {
				m.Option = &IndexOption{}
			}
			if err := m.Option.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexAlgo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexAlgo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexAlgoTableType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexAlgoTableType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexAlgoParams", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexAlgoParams = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForeignKeyDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForeignKeyDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForeignKeyDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cols = append(m.Cols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Cols) == 0 {
					m.Cols = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cols = append(m.Cols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForeignTbl", wireType)
			}
			m.ForeignTbl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForeignTbl |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ForeignCols = append(m.ForeignCols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ForeignCols) == 0 {
					m.ForeignCols = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ForeignCols = append(m.ForeignCols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ForeignCols", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDelete", wireType)
			}
			m.OnDelete = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnDelete |= ForeignKeyDef_RefAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnUpdate", wireType)
			}
			m.OnUpdate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnUpdate |= ForeignKeyDef_RefAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Check", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Check == nil {
				m.Check = &Expr{}
			}
			if err := m.Check.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterByDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterByDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterByDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompCbkeyCol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompCbkeyCol == nil {
				m.CompCbkeyCol = &ColDef{}
			}
			if err := m.CompCbkeyCol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropertyDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropertyDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropertyDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Property) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Property: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Property: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropertiesDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropertiesDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropertiesDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = append(m.Properties, &Property{})
			if err := m.Properties[len(m.Properties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionByDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionByDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionByDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= PartitionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PartitionExpr == nil {
				m.PartitionExpr = &PartitionExpr{}
			}
			if err := m.PartitionExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionExpression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PartitionExpression == nil {
				m.PartitionExpression = &Expr{}
			}
			if err := m.PartitionExpression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PartitionColumns == nil {
				m.PartitionColumns = &PartitionColumns{}
			}
			if err := m.PartitionColumns.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionNum", wireType)
			}
			m.PartitionNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partitions = append(m.Partitions, &PartitionItem{})
			if err := m.Partitions[len(m.Partitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algorithm", wireType)
			}
			m.Algorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algorithm |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSubPartition", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSubPartition = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTableNames = append(m.PartitionTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExprStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExprStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionColumns) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionColumns: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionColumns: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &Expr{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionColumns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionColumns = append(m.PartitionColumns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrdinalPosition", wireType)
			}
			m.OrdinalPosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrdinalPosition |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LessThan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LessThan = append(m.LessThan, &Expr{})
			if err := m.LessThan[len(m.LessThan)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InValues = append(m.InValues, &Expr{})
			if err := m.InValues[len(m.InValues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.View = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TblId", wireType)
			}
			m.TblId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TblId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hidden = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cols = append(m.Cols, &ColDef{})
			if err := m.Cols[len(m.Cols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Createsql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Createsql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TblFunc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TblFunc == nil {
				m.TblFunc = &TableFunction{}
			}
			if err := m.TblFunc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pkey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pkey == nil {
				m.Pkey = &PrimaryKeyDef{}
			}
			if err := m.Pkey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Indexes = append(m.Indexes, &IndexDef{})
			if err := m.Indexes[len(m.Indexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fkeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fkeys = append(m.Fkeys, &ForeignKeyDef{})
			if err := m.Fkeys[len(m.Fkeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RefChildTbls = append(m.RefChildTbls, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RefChildTbls) == 0 {
					m.RefChildTbls = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RefChildTbls = append(m.RefChildTbls, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RefChildTbls", wireType)
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checks = append(m.Checks, &CheckDef{})
			if err := m.Checks[len(m.Checks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Partition == nil {
				m.Partition = &PartitionByDef{}
			}
			if err := m.Partition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterBy == nil {
				m.ClusterBy = &ClusterByDef{}
			}
			if err := m.ClusterBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Props", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Props = append(m.Props, &PropertyDef{})
			if err := m.Props[len(m.Props)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewSql", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ViewSql == nil {
				m.ViewSql = &ViewDef{}
			}
			if err := m.ViewSql.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Defs = append(m.Defs, &TableDef_DefType{})
			if err := m.Defs[len(m.Defs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name2ColIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name2ColIndex == nil {
				m.Name2ColIndex = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPlan
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPlan
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPlan(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPlan
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Name2ColIndex[mapkey] = mapvalue
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLocked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLocked = bool(v != 0)
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableLockType", wireType)
			}
			m.TableLockType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableLockType |= TableLockType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTemporary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTemporary = bool(v != 0)
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoIncrOffset", wireType)
			}
			m.AutoIncrOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoIncrOffset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDynamic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDynamic = bool(v != 0)
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDef_DefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PropertiesDef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Def = &TableDef_DefType_Properties{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableFunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableFunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableFunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Param = append(m.Param[:0], dAtA[iNdEx:postIndex]...)
			if m.Param == nil {
				m.Param = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HashMapStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HashMapStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HashMapStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashmapSize", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.HashmapSize = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOnPK", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashOnPK = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Shuffle = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleColIdx", wireType)
			}
			m.ShuffleColIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleColIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleType", wireType)
			}
			m.ShuffleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleType |= ShuffleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleTypeForMultiCN", wireType)
			}
			m.ShuffleTypeForMultiCN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleTypeForMultiCN |= ShuffleTypeForMultiCN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleColMin", wireType)
			}
			m.ShuffleColMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleColMin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleColMax", wireType)
			}
			m.ShuffleColMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleColMax |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleMethod", wireType)
			}
			m.ShuffleMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleMethod |= ShuffleMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullcnt", wireType)
			}
			m.Nullcnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nullcnt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Ranges = append(m.Ranges, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Ranges) == 0 {
					m.Ranges = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Ranges = append(m.Ranges, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNum", wireType)
			}
			m.BlockNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Cost = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outcnt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Outcnt = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rowsize", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Rowsize = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableCnt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TableCnt = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selectivity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Selectivity = float64(math.Float64frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceOneCN", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceOneCN = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashmapStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HashmapStats == nil {
				m.HashmapStats = &HashMapStats{}
			}
			if err := m.HashmapStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowsetExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowsetExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowsetExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowPos", wireType)
			}
			m.RowPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &RowsetExpr{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowsetData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowsetData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowsetData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cols = append(m.Cols, &ColData{})
			if err := m.Cols[len(m.Cols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowCount", wireType)
			}
			m.RowCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderBySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderBySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderBySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= OrderBySpec_OrderByFlag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowFunc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WindowFunc == nil {
				m.WindowFunc = &Expr{}
			}
			if err := m.WindowFunc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionBy = append(m.PartitionBy, &Expr{})
			if err := m.PartitionBy[len(m.PartitionBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBy = append(m.OrderBy, &OrderBySpec{})
			if err := m.OrderBy[len(m.OrderBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frame", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Frame == nil {
				m.Frame = &FrameClause{}
			}
			if err := m.Frame.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SampleFuncSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SampleFuncSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SampleFuncSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			m.Rows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rows |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Percent = float64(math.Float64frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsingRow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsingRow = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FrameClause) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FrameClause: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FrameClause: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= FrameClause_FrameType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &FrameBound{}
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &FrameBound{}
			}
			if err := m.End.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FrameBound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FrameBound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FrameBound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= FrameBound_BoundType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnBounded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UnBounded = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Val == nil {
				m.Val = &Expr{}
			}
			if err := m.Val.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnDuplicateKeyCtx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnDuplicateKeyCtx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnDuplicateKeyCtx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attrs = append(m.Attrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertColCount", wireType)
			}
			m.InsertColCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InsertColCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueColCheckExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueColCheckExpr = append(m.UniqueColCheckExpr, &Expr{})
			if err := m.UniqueColCheckExpr[len(m.UniqueColCheckExpr)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueCols", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueCols = append(m.UniqueCols, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OnDuplicateIdx = append(m.OnDuplicateIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OnDuplicateIdx) == 0 {
					m.OnDuplicateIdx = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OnDuplicateIdx = append(m.OnDuplicateIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDuplicateIdx", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDuplicateExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OnDuplicateExpr == nil {
				m.OnDuplicateExpr = make(map[string]*Expr)
			}
			var mapkey string
			var mapvalue *Expr
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPlan
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPlan
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPlan
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPlan
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Expr{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPlan(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPlan
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.OnDuplicateExpr[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsIgnore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsIgnore = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableVersion", wireType)
			}
			m.TableVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsertCtx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsertCtx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsertCtx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ref == nil {
				m.Ref = &ObjectRef{}
			}
			if err := m.Ref.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddAffectedRows", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddAffectedRows = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClusterTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClusterTable = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartitionTableIds = append(m.PartitionTableIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PartitionTableIds) == 0 {
					m.PartitionTableIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartitionTableIds = append(m.PartitionTableIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableIds", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTableNames = append(m.PartitionTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionIdx", wireType)
			}
			m.PartitionIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceCtx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceCtx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceCtx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ref == nil {
				m.Ref = &ObjectRef{}
			}
			if err := m.Ref.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddAffectedRows", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddAffectedRows = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClusterTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClusterTable = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteCond", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeleteCond = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartitionTableIds = append(m.PartitionTableIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PartitionTableIds) == 0 {
					m.PartitionTableIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartitionTableIds = append(m.PartitionTableIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableIds", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTableNames = append(m.PartitionTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionIdx", wireType)
			}
			m.PartitionIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnalyzeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalyzeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalyzeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputRows", wireType)
			}
			m.InputRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputRows |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputRows", wireType)
			}
			m.OutputRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputRows |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputSize", wireType)
			}
			m.InputSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputSize", wireType)
			}
			m.OutputSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeConsumed", wireType)
			}
			m.TimeConsumed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeConsumed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemorySize", wireType)
			}
			m.MemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemorySize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitTimeConsumed", wireType)
			}
			m.WaitTimeConsumed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitTimeConsumed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskIO", wireType)
			}
			m.DiskIO = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskIO |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3IOByte", wireType)
			}
			m.S3IOByte = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.S3IOByte |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3IOInputCount", wireType)
			}
			m.S3IOInputCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.S3IOInputCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3IOOutputCount", wireType)
			}
			m.S3IOOutputCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.S3IOOutputCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkIO", wireType)
			}
			m.NetworkIO = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkIO |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanTime", wireType)
			}
			m.ScanTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScanTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertTime", wireType)
			}
			m.InsertTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InsertTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TimeConsumedArrayMajor = append(m.TimeConsumedArrayMajor, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TimeConsumedArrayMajor) == 0 {
					m.TimeConsumedArrayMajor = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TimeConsumedArrayMajor = append(m.TimeConsumedArrayMajor, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeConsumedArrayMajor", wireType)
			}
		case 16:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TimeConsumedArrayMinor = append(m.TimeConsumedArrayMinor, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TimeConsumedArrayMinor) == 0 {
					m.TimeConsumedArrayMinor = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TimeConsumedArrayMinor = append(m.TimeConsumedArrayMinor, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeConsumedArrayMinor", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionPrune) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionPrune: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionPrune: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPruned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPruned = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectedPartitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SelectedPartitions = append(m.SelectedPartitions, &PartitionItem{})
			if err := m.SelectedPartitions[len(m.SelectedPartitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OriginTableMessageForFuzzy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OriginTableMessageForFuzzy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OriginTableMessageForFuzzy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentUniqueCols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentUniqueCols = append(m.ParentUniqueCols, &ColDef{})
			if err := m.ParentUniqueCols[len(m.ParentUniqueCols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeType", wireType)
			}
			m.NodeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeType |= Node_NodeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &Stats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Children = append(m.Children, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Children) == 0 {
					m.Children = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Children = append(m.Children, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectList = append(m.ProjectList, &Expr{})
			if err := m.ProjectList[len(m.ProjectList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinType", wireType)
			}
			m.JoinType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinType |= Node_JoinType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnList = append(m.OnList, &Expr{})
			if err := m.OnList[len(m.OnList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildOnLeft", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BuildOnLeft = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilterList = append(m.FilterList, &Expr{})
			if err := m.FilterList[len(m.FilterList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = append(m.GroupBy, &Expr{})
			if err := m.GroupBy[len(m.GroupBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupingSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupingSet = append(m.GroupingSet, &Expr{})
			if err := m.GroupingSet[len(m.GroupingSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggList = append(m.AggList, &Expr{})
			if err := m.AggList[len(m.AggList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinSpecList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WinSpecList = append(m.WinSpecList, &Expr{})
			if err := m.WinSpecList[len(m.WinSpecList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBy = append(m.OrderBy, &OrderBySpec{})
			if err := m.OrderBy[len(m.OrderBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limit == nil {
				m.Limit = &Expr{}
			}
			if err := m.Limit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Offset == nil {
				m.Offset = &Expr{}
			}
			if err := m.Offset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjRef == nil {
				m.ObjRef = &ObjectRef{}
			}
			if err := m.ObjRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentObjRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParentObjRef == nil {
				m.ParentObjRef = &ObjectRef{}
			}
			if err := m.ParentObjRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowsetData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RowsetData == nil {
				m.RowsetData = &RowsetData{}
			}
			if err := m.RowsetData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraOptions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraOptions = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteCtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteCtx == nil {
				m.DeleteCtx = &DeleteCtx{}
			}
			if err := m.DeleteCtx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BindingTags = append(m.BindingTags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BindingTags) == 0 {
					m.BindingTags = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BindingTags = append(m.BindingTags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BindingTags", wireType)
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalyzeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnalyzeInfo == nil {
				m.AnalyzeInfo = &AnalyzeInfo{}
			}
			if err := m.AnalyzeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TblFuncExprList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TblFuncExprList = append(m.TblFuncExprList, &Expr{})
			if err := m.TblFuncExprList[len(m.TblFuncExprList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterTable == nil {
				m.ClusterTable = &ClusterTable{}
			}
			if err := m.ClusterTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotCacheable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotCacheable = bool(v != 0)
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertCtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InsertCtx == nil {
				m.InsertCtx = &InsertCtx{}
			}
			if err := m.InsertCtx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaceCtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplaceCtx == nil {
				m.ReplaceCtx = &ReplaceCtx{}
			}
			if err := m.ReplaceCtx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SourceStep = append(m.SourceStep, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SourceStep) == 0 {
					m.SourceStep = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SourceStep = append(m.SourceStep, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceStep", wireType)
			}
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreDeleteCtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreDeleteCtx == nil {
				m.PreDeleteCtx = &PreDeleteCtx{}
			}
			if err := m.PreDeleteCtx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreInsertCtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreInsertCtx == nil {
				m.PreInsertCtx = &PreInsertCtx{}
			}
			if err := m.PreInsertCtx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreInsertUkCtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreInsertUkCtx == nil {
				m.PreInsertUkCtx = &PreInsertUkCtx{}
			}
			if err := m.PreInsertUkCtx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDuplicateKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OnDuplicateKey == nil {
				m.OnDuplicateKey = &OnDuplicateKeyCtx{}
			}
			if err := m.OnDuplicateKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEnd = bool(v != 0)
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTargets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockTargets = append(m.LockTargets, &LockTarget{})
			if err := m.LockTargets[len(m.LockTargets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockFilterList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockFilterList = append(m.BlockFilterList, &Expr{})
			if err := m.BlockFilterList[len(m.BlockFilterList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterProbeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterProbeList = append(m.RuntimeFilterProbeList, &RuntimeFilterSpec{})
			if err := m.RuntimeFilterProbeList[len(m.RuntimeFilterProbeList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterBuildList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterBuildList = append(m.RuntimeFilterBuildList, &RuntimeFilterSpec{})
			if err := m.RuntimeFilterBuildList[len(m.RuntimeFilterBuildList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecursiveSink", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RecursiveSink = bool(v != 0)
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternScan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExternScan == nil {
				m.ExternScan = &ExternScan{}
			}
			if err := m.ExternScan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionPrune", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PartitionPrune == nil {
				m.PartitionPrune = &PartitionPrune{}
			}
			if err := m.PartitionPrune.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreInsertSkCtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreInsertSkCtx == nil {
				m.PreInsertSkCtx = &PreInsertUkCtx{}
			}
			if err := m.PreInsertSkCtx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interval == nil {
				m.Interval = &Expr{}
			}
			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sliding", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sliding == nil {
				m.Sliding = &Expr{}
			}
			if err := m.Sliding.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FillType", wireType)
			}
			m.FillType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FillType |= Node_FillType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FillVal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FillVal = append(m.FillVal, &Expr{})
			if err := m.FillVal[len(m.FillVal)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleFunc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SampleFunc == nil {
				m.SampleFunc = &SampleFuncSpec{}
			}
			if err := m.SampleFunc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowIdx", wireType)
			}
			m.WindowIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnUpdateExprs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnUpdateExprs = append(m.OnUpdateExprs, &Expr{})
			if err := m.OnUpdateExprs[len(m.OnUpdateExprs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fuzzymessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fuzzymessage == nil {
				m.Fuzzymessage = &OriginTableMessageForFuzzy{}
			}
			if err := m.Fuzzymessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 55:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendMsgList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SendMsgList = append(m.SendMsgList, &MsgHeader{})
			if err := m.SendMsgList[len(m.SendMsgList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 56:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecvMsgList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecvMsgList = append(m.RecvMsgList, &MsgHeader{})
			if err := m.RecvMsgList[len(m.RecvMsgList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 57:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanSnapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScanSnapshot == nil {
				m.ScanSnapshot = &Snapshot{}
			}
			if err := m.ScanSnapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Snapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Snapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TS == nil {
				m.TS = &timestamp.Timestamp{}
			}
			if err := m.TS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedByTenant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedByTenant == nil {
				m.CreatedByTenant = &SnapshotTenant{}
			}
			if err := m.CreatedByTenant.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotTenant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotTenant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotTenant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantID", wireType)
			}
			m.TenantID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternScan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternScan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternScan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoredLines", wireType)
			}
			m.IgnoredLines = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IgnoredLines |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnclosedBy", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnclosedBy = append(m.EnclosedBy[:0], dAtA[iNdEx:postIndex]...)
			if m.EnclosedBy == nil {
				m.EnclosedBy = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terminated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Terminated = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsonType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JsonType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryColIdxInBat", wireType)
			}
			m.PrimaryColIdxInBat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryColIdxInBat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryColTyp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrimaryColTyp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshTsIdxInBat", wireType)
			}
			m.RefreshTsIdxInBat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefreshTsIdxInBat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterColIdxInBat", wireType)
			}
			m.FilterColIdxInBat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilterColIdxInBat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LockTable = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPartitionTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPartitionTable = bool(v != 0)
		case 8:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartitionTableIds = append(m.PartitionTableIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PartitionTableIds) == 0 {
					m.PartitionTableIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartitionTableIds = append(m.PartitionTableIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableIds", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Block = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= lock.LockMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreInsertUkCtx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreInsertUkCtx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreInsertUkCtx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Columns = append(m.Columns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Columns) == 0 {
					m.Columns = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Columns = append(m.Columns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkColumn", wireType)
			}
			m.PkColumn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PkColumn |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PkType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UkType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UkType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreDeleteCtx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreDeleteCtx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreDeleteCtx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Idx = append(m.Idx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Idx) == 0 {
					m.Idx = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Idx = append(m.Idx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreInsertCtx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreInsertCtx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreInsertCtx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ref == nil {
				m.Ref = &ObjectRef{}
			}
			if err := m.Ref.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasAutoCol", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasAutoCol = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUpdate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUpdate = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuntimeFilterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuntimeFilterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuntimeFilterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchPrefix", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MatchPrefix = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperLimit", wireType)
			}
			m.UpperLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpperLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Handled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.List = append(m.List, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.List) == 0 {
					m.List = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.List = append(m.List, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColPosMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColPosMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColPosMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Map == nil {
				m.Map = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPlan
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPlan
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPlan(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPlan
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Map[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteCtx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteCtx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteCtx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanTruncate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanTruncate = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ref == nil {
				m.Ref = &ObjectRef{}
			}
			if err := m.Ref.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowIdIdx", wireType)
			}
			m.RowIdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowIdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddAffectedRows", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddAffectedRows = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClusterTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClusterTable = bool(v != 0)
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartitionTableIds = append(m.PartitionTableIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PartitionTableIds) == 0 {
					m.PartitionTableIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartitionTableIds = append(m.PartitionTableIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableIds", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTableNames = append(m.PartitionTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionIdx", wireType)
			}
			m.PartitionIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKeyIdx", wireType)
			}
			m.PrimaryKeyIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryKeyIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TruncateTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TruncateTable == nil {
				m.TruncateTable = &TruncateTable{}
			}
			if err := m.TruncateTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Query) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Query: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Query: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StmtType", wireType)
			}
			m.StmtType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StmtType |= Query_StatementType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Steps = append(m.Steps, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Steps) == 0 {
					m.Steps = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Steps = append(m.Steps, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params, &Expr{})
			if err := m.Params[len(m.Params)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headings = append(m.Headings, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadTag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LoadTag = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectSqls", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DetectSqls = append(m.DetectSqls, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransationControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransationControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransationControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TclType", wireType)
			}
			m.TclType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TclType |= TransationControl_TclType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TransationBegin{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &TransationControl_Begin{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TransationCommit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &TransationControl_Commit{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rollback", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TransationRollback{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &TransationControl_Rollback{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransationBegin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransationBegin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransationBegin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= TransationBegin_TransationMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransationCommit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransationCommit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransationCommit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionType", wireType)
			}
			m.CompletionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletionType |= TransationCompletionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransationRollback) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransationRollback: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransationRollback: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionType", wireType)
			}
			m.CompletionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletionType |= TransationCompletionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Plan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Plan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Plan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Query{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Plan = &Plan_Query{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tcl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TransationControl{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Plan = &Plan_Tcl{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ddl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataDefinition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Plan = &Plan_Ddl{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dcl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataControl{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Plan = &Plan_Dcl{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TryRunTimes", wireType)
			}
			m.TryRunTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TryRunTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrepare", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPrepare = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Column) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: column: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: column: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Column = append(m.Column, &Expr{})
			if err := m.Column[len(m.Column)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DclType", wireType)
			}
			m.DclType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DclType |= DataControl_DclType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetVariables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SetVariables{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Control = &DataControl_SetVariables{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prepare", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Prepare{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Control = &DataControl_Prepare{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Execute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Execute{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Control = &DataControl_Execute{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deallocate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Deallocate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Control = &DataControl_Deallocate{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Other", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OtherDCL{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Control = &DataControl_Other{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DdlType", wireType)
			}
			m.DdlType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DdlType |= DataDefinition_DdlType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &Query{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateDatabase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateDatabase{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_CreateDatabase{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterDatabase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterDatabase{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_AlterDatabase{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropDatabase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DropDatabase{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_DropDatabase{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_CreateTable{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_AlterTable{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DropTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_DropTable{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_CreateIndex{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_AlterIndex{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DropIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_DropIndex{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TruncateTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TruncateTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_TruncateTable{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowVariables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShowVariables{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_ShowVariables{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterView", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterView{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_AlterView{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LockTables{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_LockTables{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UnLockTables{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_UnlockTables{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateSequence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateSequence{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_CreateSequence{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropSequence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DropSequence{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_DropSequence{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterSequence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterSequence{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_AlterSequence{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscriptionOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriptionOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriptionOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publication", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Publication = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateDatabase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateDatabase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateDatabase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfNotExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfNotExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubscriptionOption == nil {
				m.SubscriptionOption = &SubscriptionOption{}
			}
			if err := m.SubscriptionOption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterDatabase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterDatabase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterDatabase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropDatabase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropDatabase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropDatabase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseId", wireType)
			}
			m.DatabaseId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateFkSql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdateFkSql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckFKSql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckFKSql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FkColName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FkColName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FkColName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cols = append(m.Cols, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForeignKeyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForeignKeyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForeignKeyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Db", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Db = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cols == nil {
				m.Cols = &FkColName{}
			}
			if err := m.Cols.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColsReferred", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ColsReferred == nil {
				m.ColsReferred = &FkColName{}
			}
			if err := m.ColsReferred.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Def == nil {
				m.Def = &ForeignKeyDef{}
			}
			if err := m.Def.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfNotExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfNotExists = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temporary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Temporary = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replace", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Replace = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTables = append(m.IndexTables, &TableDef{})
			if err := m.IndexTables[len(m.IndexTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FkDbs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FkDbs = append(m.FkDbs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FkTables", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FkTables = append(m.FkTables, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FkCols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FkCols = append(m.FkCols, &FkColName{})
			if err := m.FkCols[len(m.FkCols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTables = append(m.PartitionTables, &TableDef{})
			if err := m.PartitionTables[len(m.PartitionTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAsSelectSql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreateAsSelectSql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateFkSqls", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdateFkSqls = append(m.UpdateFkSqls, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FksReferToMe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FksReferToMe = append(m.FksReferToMe, &ForeignKeyInfo{})
			if err := m.FksReferToMe[len(m.FksReferToMe)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTableDrop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTableDrop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTableDrop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			m.Typ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typ |= AlterTableDrop_Typ(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTableAddFk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTableAddFk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTableAddFk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cols = append(m.Cols, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fkey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fkey == nil {
				m.Fkey = &ForeignKeyDef{}
			}
			if err := m.Fkey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTableAddIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTableAddIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTableAddIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginTablePrimaryKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginTablePrimaryKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IndexInfo == nil {
				m.IndexInfo = &CreateTable{}
			}
			if err := m.IndexInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTableExist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IndexTableExist = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTableDropIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTableDropIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTableDropIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTableAlterIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTableAlterIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTableAlterIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Visible = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTableAlterReIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTableAlterReIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTableAlterReIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexAlgoParamList", wireType)
			}
			m.IndexAlgoParamList = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexAlgoParamList |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTableAddPartition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTableAddPartition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTableAddPartition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Definitions = append(m.Definitions, &PartitionItem{})
			if err := m.Definitions[len(m.Definitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTables = append(m.PartitionTables, &TableDef{})
			if err := m.PartitionTables[len(m.PartitionTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PartitionDef == nil {
				m.PartitionDef = &PartitionByDef{}
			}
			if err := m.PartitionDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTableComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTableComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTableComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewComment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewComment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTableName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTableName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTableName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterAddColumn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterAddColumn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterAddColumn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterDropColumn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterDropColumn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterDropColumn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyTableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CopyTableDef == nil {
				m.CopyTableDef = &TableDef{}
			}
			if err := m.CopyTableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClusterTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClusterTable = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &AlterTable_Action{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlgorithmType", wireType)
			}
			m.AlgorithmType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlgorithmType |= AlterTable_AlgorithmType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTmpTableSql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreateTmpTableSql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertTmpDataSql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsertTmpDataSql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTableSql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreateTableSql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertDataSql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsertDataSql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeTblColIdMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangeTblColIdMap == nil {
				m.ChangeTblColIdMap = make(map[uint64]*ColDef)
			}
			var mapkey uint64
			var mapvalue *ColDef
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPlan
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPlan
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ColDef{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPlan(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPlan
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ChangeTblColIdMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectSqls", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DetectSqls = append(m.DetectSqls, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateFkSqls", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdateFkSqls = append(m.UpdateFkSqls, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTable_Action) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Action: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Action: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterTableDrop{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AlterTable_Action_Drop{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddFk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterTableAddFk{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AlterTable_Action_AddFk{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterTableAddIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AlterTable_Action_AddIndex{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterTableAlterIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AlterTable_Action_AlterIndex{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterTableComment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AlterTable_Action_AlterComment{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterTableName{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AlterTable_Action_AlterName{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddColumn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterAddColumn{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AlterTable_Action_AddColumn{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropColumn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterDropColumn{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AlterTable_Action_DropColumn{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterReindex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterTableAlterReIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AlterTable_Action_AlterReindex{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddPartition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterTableAddPartition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AlterTable_Action_AddPartition{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTableNames = append(m.IndexTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterTable == nil {
				m.ClusterTable = &ClusterTable{}
			}
			if err := m.ClusterTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ForeignTbl = append(m.ForeignTbl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ForeignTbl) == 0 {
					m.ForeignTbl = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ForeignTbl = append(m.ForeignTbl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ForeignTbl", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTableNames = append(m.PartitionTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsView", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsView = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateFkSqls", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdateFkSqls = append(m.UpdateFkSqls, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FkChildTblsReferToMe = append(m.FkChildTblsReferToMe, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FkChildTblsReferToMe) == 0 {
					m.FkChildTblsReferToMe = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FkChildTblsReferToMe = append(m.FkChildTblsReferToMe, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FkChildTblsReferToMe", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfNotExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfNotExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginTablePrimaryKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginTablePrimaryKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Index == nil {
				m.Index = &CreateTable{}
			}
			if err := m.Index.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableExist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TableExist = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TruncateTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TruncateTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TruncateTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTableNames = append(m.IndexTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTableNames = append(m.PartitionTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterTable == nil {
				m.ClusterTable = &ClusterTable{}
			}
			if err := m.ClusterTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ForeignTbl = append(m.ForeignTbl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ForeignTbl) == 0 {
					m.ForeignTbl = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ForeignTbl = append(m.ForeignTbl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ForeignTbl", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDelete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDelete = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClusterTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClusterTable = bool(v != 0)
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AccountIDs = append(m.AccountIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AccountIDs) == 0 {
					m.AccountIDs = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AccountIDs = append(m.AccountIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountIDs", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIndexOfAccountId", wireType)
			}
			m.ColumnIndexOfAccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnIndexOfAccountId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowVariables) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowVariables: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowVariables: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Global = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Where = append(m.Where, &Expr{})
			if err := m.Where[len(m.Where)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetVariables) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetVariables: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetVariables: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &SetVariablesItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetVariablesItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetVariablesItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetVariablesItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field System", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.System = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Global = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Expr{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reserved == nil {
				m.Reserved = &Expr{}
			}
			if err := m.Reserved.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Prepare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Prepare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Prepare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schemas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schemas = append(m.Schemas, &ObjectRef{})
			if err := m.Schemas[len(m.Schemas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Plan == nil {
				m.Plan = &Plan{}
			}
			if err := m.Plan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ParamTypes = append(m.ParamTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ParamTypes) == 0 {
					m.ParamTypes = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ParamTypes = append(m.ParamTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ParamTypes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Execute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Execute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Execute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, &Expr{})
			if err := m.Args[len(m.Args)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deallocate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deallocate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deallocate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OtherDCL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OtherDCL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OtherDCL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ParamTypes = append(m.ParamTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ParamTypes) == 0 {
					m.ParamTypes = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ParamTypes = append(m.ParamTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ParamTypes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableLockInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableLockInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableLockInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockType", wireType)
			}
			m.LockType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockType |= TableLockType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockTables) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockTables: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockTables: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableLocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableLocks = append(m.TableLocks, &TableLockInfo{})
			if err := m.TableLocks[len(m.TableLocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnLockTables) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnLockTables: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnLockTables: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetadataScanInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetadataScanInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetadataScanInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHidden = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjLoc", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjLoc = append(m.ObjLoc[:0], dAtA[iNdEx:postIndex]...)
			if m.ObjLoc == nil {
				m.ObjLoc = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreateTs = append(m.CreateTs[:0], dAtA[iNdEx:postIndex]...)
			if m.CreateTs == nil {
				m.CreateTs = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteTs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeleteTs = append(m.DeleteTs[:0], dAtA[iNdEx:postIndex]...)
			if m.DeleteTs == nil {
				m.DeleteTs = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowCnt", wireType)
			}
			m.RowCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowCnt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullCnt", wireType)
			}
			m.NullCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NullCnt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressSize", wireType)
			}
			m.CompressSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginSize", wireType)
			}
			m.OriginSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZoneMap", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ZoneMap = append(m.ZoneMap[:0], dAtA[iNdEx:postIndex]...)
			if m.ZoneMap == nil {
				m.ZoneMap = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPlan(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPlan
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPlan
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPlan
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPlan        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPlan          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPlan = fmt.Errorf("proto: unexpected end of group")
)
