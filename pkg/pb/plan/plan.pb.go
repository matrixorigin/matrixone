// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: plan.proto

package plan

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CompressType int32

const (
	CompressType_None CompressType = 0
	CompressType_Lz4  CompressType = 1
)

var CompressType_name = map[int32]string{
	0: "None",
	1: "Lz4",
}

var CompressType_value = map[string]int32{
	"None": 0,
	"Lz4":  1,
}

func (x CompressType) String() string {
	return proto.EnumName(CompressType_name, int32(x))
}

func (CompressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{0}
}

type PartitionType int32

const (
	PartitionType_KEY           PartitionType = 0
	PartitionType_LINEAR_KEY    PartitionType = 1
	PartitionType_HASH          PartitionType = 2
	PartitionType_LINEAR_HASH   PartitionType = 3
	PartitionType_RANGE         PartitionType = 4
	PartitionType_RANGE_COLUMNS PartitionType = 5
	PartitionType_LIST          PartitionType = 6
	PartitionType_LIST_COLUMNS  PartitionType = 7
)

var PartitionType_name = map[int32]string{
	0: "KEY",
	1: "LINEAR_KEY",
	2: "HASH",
	3: "LINEAR_HASH",
	4: "RANGE",
	5: "RANGE_COLUMNS",
	6: "LIST",
	7: "LIST_COLUMNS",
}

var PartitionType_value = map[string]int32{
	"KEY":           0,
	"LINEAR_KEY":    1,
	"HASH":          2,
	"LINEAR_HASH":   3,
	"RANGE":         4,
	"RANGE_COLUMNS": 5,
	"LIST":          6,
	"LIST_COLUMNS":  7,
}

func (x PartitionType) String() string {
	return proto.EnumName(PartitionType_name, int32(x))
}

func (PartitionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{1}
}

type TransationCompletionType int32

const (
	TransationCompletionType_CHAIN    TransationCompletionType = 0
	TransationCompletionType_NO_CHAIN TransationCompletionType = 1
	TransationCompletionType_RELEASE  TransationCompletionType = 2
)

var TransationCompletionType_name = map[int32]string{
	0: "CHAIN",
	1: "NO_CHAIN",
	2: "RELEASE",
}

var TransationCompletionType_value = map[string]int32{
	"CHAIN":    0,
	"NO_CHAIN": 1,
	"RELEASE":  2,
}

func (x TransationCompletionType) String() string {
	return proto.EnumName(TransationCompletionType_name, int32(x))
}

func (TransationCompletionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{2}
}

type SubqueryRef_Type int32

const (
	SubqueryRef_SCALAR     SubqueryRef_Type = 0
	SubqueryRef_EXISTS     SubqueryRef_Type = 1
	SubqueryRef_NOT_EXISTS SubqueryRef_Type = 2
	SubqueryRef_IN         SubqueryRef_Type = 3
	SubqueryRef_NOT_IN     SubqueryRef_Type = 4
	SubqueryRef_ANY        SubqueryRef_Type = 5
	SubqueryRef_ALL        SubqueryRef_Type = 6
)

var SubqueryRef_Type_name = map[int32]string{
	0: "SCALAR",
	1: "EXISTS",
	2: "NOT_EXISTS",
	3: "IN",
	4: "NOT_IN",
	5: "ANY",
	6: "ALL",
}

var SubqueryRef_Type_value = map[string]int32{
	"SCALAR":     0,
	"EXISTS":     1,
	"NOT_EXISTS": 2,
	"IN":         3,
	"NOT_IN":     4,
	"ANY":        5,
	"ALL":        6,
}

func (x SubqueryRef_Type) String() string {
	return proto.EnumName(SubqueryRef_Type_name, int32(x))
}

func (SubqueryRef_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{9, 0}
}

// Function flags
type Function_FuncFlag int32

const (
	Function_NONE Function_FuncFlag = 0
	// Internal function is generated by system, cannot
	// by called by user.
	Function_INTERNAL Function_FuncFlag = 1
	// Function, by default is immutable.
	Function_STABLE   Function_FuncFlag = 2
	Function_VOLATILE Function_FuncFlag = 4
	// Nulls
	Function_STRICT          Function_FuncFlag = 8
	Function_PRODUCE_NULL    Function_FuncFlag = 16
	Function_PRODUCE_NO_NULL Function_FuncFlag = 32
	// Vararg, all trailing args must be of the same type.
	Function_VARARG Function_FuncFlag = 64
	// Window and Agg
	Function_AGG Function_FuncFlag = 128
	Function_WIN Function_FuncFlag = 256
	// Monotonic function can filter by zonemap
	Function_MONOTONIC Function_FuncFlag = 512
)

var Function_FuncFlag_name = map[int32]string{
	0:   "NONE",
	1:   "INTERNAL",
	2:   "STABLE",
	4:   "VOLATILE",
	8:   "STRICT",
	16:  "PRODUCE_NULL",
	32:  "PRODUCE_NO_NULL",
	64:  "VARARG",
	128: "AGG",
	256: "WIN",
	512: "MONOTONIC",
}

var Function_FuncFlag_value = map[string]int32{
	"NONE":            0,
	"INTERNAL":        1,
	"STABLE":          2,
	"VOLATILE":        4,
	"STRICT":          8,
	"PRODUCE_NULL":    16,
	"PRODUCE_NO_NULL": 32,
	"VARARG":          64,
	"AGG":             128,
	"WIN":             256,
	"MONOTONIC":       512,
}

func (x Function_FuncFlag) String() string {
	return proto.EnumName(Function_FuncFlag_name, int32(x))
}

func (Function_FuncFlag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{11, 0}
}

type OrderBySpec_OrderByFlag int32

const (
	OrderBySpec_INTERNAL    OrderBySpec_OrderByFlag = 0
	OrderBySpec_ASC         OrderBySpec_OrderByFlag = 1
	OrderBySpec_DESC        OrderBySpec_OrderByFlag = 2
	OrderBySpec_NULLS_FIRST OrderBySpec_OrderByFlag = 4
	OrderBySpec_NULLS_LAST  OrderBySpec_OrderByFlag = 8
	OrderBySpec_UNIQUE      OrderBySpec_OrderByFlag = 16
)

var OrderBySpec_OrderByFlag_name = map[int32]string{
	0:  "INTERNAL",
	1:  "ASC",
	2:  "DESC",
	4:  "NULLS_FIRST",
	8:  "NULLS_LAST",
	16: "UNIQUE",
}

var OrderBySpec_OrderByFlag_value = map[string]int32{
	"INTERNAL":    0,
	"ASC":         1,
	"DESC":        2,
	"NULLS_FIRST": 4,
	"NULLS_LAST":  8,
	"UNIQUE":      16,
}

func (x OrderBySpec_OrderByFlag) String() string {
	return proto.EnumName(OrderBySpec_OrderByFlag_name, int32(x))
}

func (OrderBySpec_OrderByFlag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{32, 0}
}

type Node_NodeType int32

const (
	Node_UNKNOWN Node_NodeType = 0
	// Scans
	Node_VALUE_SCAN    Node_NodeType = 1
	Node_TABLE_SCAN    Node_NodeType = 2
	Node_FUNCTION_SCAN Node_NodeType = 3
	Node_EXTERNAL_SCAN Node_NodeType = 4
	Node_MATERIAL_SCAN Node_NodeType = 5
	// Proj, for convenience
	Node_PROJECT Node_NodeType = 10
	// External function call (UDF)
	Node_EXTERNAL_FUNCTION Node_NodeType = 11
	// Material, CTE, etc.
	Node_MATERIAL      Node_NodeType = 20
	Node_RECURSIVE_CTE Node_NodeType = 21
	Node_SINK          Node_NodeType = 22
	Node_SINK_SCAN     Node_NodeType = 23
	// Proper Relational Operators
	Node_AGG       Node_NodeType = 30
	Node_DISTINCT  Node_NodeType = 31
	Node_FILTER    Node_NodeType = 32
	Node_JOIN      Node_NodeType = 33
	Node_SAMPLE    Node_NodeType = 34
	Node_SORT      Node_NodeType = 35
	Node_UNION     Node_NodeType = 36
	Node_UNION_ALL Node_NodeType = 37
	Node_UNIQUE    Node_NodeType = 38
	Node_WINDOW    Node_NodeType = 39
	// Physical tuple mover
	Node_BROADCAST Node_NodeType = 40
	Node_SPLIT     Node_NodeType = 41
	Node_GATHER    Node_NodeType = 42
	// Misc
	Node_ASSERT Node_NodeType = 50
	//
	Node_INSERT Node_NodeType = 51
	Node_UPDATE Node_NodeType = 52
	Node_DELETE Node_NodeType = 53
	//
	Node_INTERSECT     Node_NodeType = 54
	Node_INTERSECT_ALL Node_NodeType = 55
	Node_MINUS         Node_NodeType = 56
	Node_MINUS_ALL     Node_NodeType = 57
	//
	Node_TABLE_FUNCTION Node_NodeType = 58
)

var Node_NodeType_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "VALUE_SCAN",
	2:  "TABLE_SCAN",
	3:  "FUNCTION_SCAN",
	4:  "EXTERNAL_SCAN",
	5:  "MATERIAL_SCAN",
	10: "PROJECT",
	11: "EXTERNAL_FUNCTION",
	20: "MATERIAL",
	21: "RECURSIVE_CTE",
	22: "SINK",
	23: "SINK_SCAN",
	30: "AGG",
	31: "DISTINCT",
	32: "FILTER",
	33: "JOIN",
	34: "SAMPLE",
	35: "SORT",
	36: "UNION",
	37: "UNION_ALL",
	38: "UNIQUE",
	39: "WINDOW",
	40: "BROADCAST",
	41: "SPLIT",
	42: "GATHER",
	50: "ASSERT",
	51: "INSERT",
	52: "UPDATE",
	53: "DELETE",
	54: "INTERSECT",
	55: "INTERSECT_ALL",
	56: "MINUS",
	57: "MINUS_ALL",
	58: "TABLE_FUNCTION",
}

var Node_NodeType_value = map[string]int32{
	"UNKNOWN":           0,
	"VALUE_SCAN":        1,
	"TABLE_SCAN":        2,
	"FUNCTION_SCAN":     3,
	"EXTERNAL_SCAN":     4,
	"MATERIAL_SCAN":     5,
	"PROJECT":           10,
	"EXTERNAL_FUNCTION": 11,
	"MATERIAL":          20,
	"RECURSIVE_CTE":     21,
	"SINK":              22,
	"SINK_SCAN":         23,
	"AGG":               30,
	"DISTINCT":          31,
	"FILTER":            32,
	"JOIN":              33,
	"SAMPLE":            34,
	"SORT":              35,
	"UNION":             36,
	"UNION_ALL":         37,
	"UNIQUE":            38,
	"WINDOW":            39,
	"BROADCAST":         40,
	"SPLIT":             41,
	"GATHER":            42,
	"ASSERT":            50,
	"INSERT":            51,
	"UPDATE":            52,
	"DELETE":            53,
	"INTERSECT":         54,
	"INTERSECT_ALL":     55,
	"MINUS":             56,
	"MINUS_ALL":         57,
	"TABLE_FUNCTION":    58,
}

func (x Node_NodeType) String() string {
	return proto.EnumName(Node_NodeType_name, int32(x))
}

func (Node_NodeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{36, 0}
}

type Node_JoinFlag int32

const (
	Node_INNER  Node_JoinFlag = 0
	Node_LEFT   Node_JoinFlag = 1
	Node_RIGHT  Node_JoinFlag = 2
	Node_OUTER  Node_JoinFlag = 3
	Node_SEMI   Node_JoinFlag = 4
	Node_ANTI   Node_JoinFlag = 5
	Node_SINGLE Node_JoinFlag = 6
	Node_MARK   Node_JoinFlag = 7
	Node_APPLY  Node_JoinFlag = 8
)

var Node_JoinFlag_name = map[int32]string{
	0: "INNER",
	1: "LEFT",
	2: "RIGHT",
	3: "OUTER",
	4: "SEMI",
	5: "ANTI",
	6: "SINGLE",
	7: "MARK",
	8: "APPLY",
}

var Node_JoinFlag_value = map[string]int32{
	"INNER":  0,
	"LEFT":   1,
	"RIGHT":  2,
	"OUTER":  3,
	"SEMI":   4,
	"ANTI":   5,
	"SINGLE": 6,
	"MARK":   7,
	"APPLY":  8,
}

func (x Node_JoinFlag) String() string {
	return proto.EnumName(Node_JoinFlag_name, int32(x))
}

func (Node_JoinFlag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{36, 1}
}

type Node_AggMode int32

const (
	Node_FULL   Node_AggMode = 0
	Node_BOTTOM Node_AggMode = 1
	Node_TOP    Node_AggMode = 2
)

var Node_AggMode_name = map[int32]string{
	0: "FULL",
	1: "BOTTOM",
	2: "TOP",
}

var Node_AggMode_value = map[string]int32{
	"FULL":   0,
	"BOTTOM": 1,
	"TOP":    2,
}

func (x Node_AggMode) String() string {
	return proto.EnumName(Node_AggMode_name, int32(x))
}

func (Node_AggMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{36, 2}
}

type Query_StatementType int32

const (
	Query_UNKNOWN Query_StatementType = 0
	Query_SELECT  Query_StatementType = 1
	Query_INSERT  Query_StatementType = 2
	Query_DELETE  Query_StatementType = 3
	Query_UPDATE  Query_StatementType = 4
	Query_MERGE   Query_StatementType = 5
)

var Query_StatementType_name = map[int32]string{
	0: "UNKNOWN",
	1: "SELECT",
	2: "INSERT",
	3: "DELETE",
	4: "UPDATE",
	5: "MERGE",
}

var Query_StatementType_value = map[string]int32{
	"UNKNOWN": 0,
	"SELECT":  1,
	"INSERT":  2,
	"DELETE":  3,
	"UPDATE":  4,
	"MERGE":   5,
}

func (x Query_StatementType) String() string {
	return proto.EnumName(Query_StatementType_name, int32(x))
}

func (Query_StatementType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{38, 0}
}

type TransationControl_TclType int32

const (
	TransationControl_BEGIN    TransationControl_TclType = 0
	TransationControl_COMMIT   TransationControl_TclType = 1
	TransationControl_ROLLBACK TransationControl_TclType = 2
)

var TransationControl_TclType_name = map[int32]string{
	0: "BEGIN",
	1: "COMMIT",
	2: "ROLLBACK",
}

var TransationControl_TclType_value = map[string]int32{
	"BEGIN":    0,
	"COMMIT":   1,
	"ROLLBACK": 2,
}

func (x TransationControl_TclType) String() string {
	return proto.EnumName(TransationControl_TclType_name, int32(x))
}

func (TransationControl_TclType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{39, 0}
}

type TransationBegin_TransationMode int32

const (
	TransationBegin_NONE       TransationBegin_TransationMode = 0
	TransationBegin_READ_ONLY  TransationBegin_TransationMode = 1
	TransationBegin_READ_WRITE TransationBegin_TransationMode = 2
)

var TransationBegin_TransationMode_name = map[int32]string{
	0: "NONE",
	1: "READ_ONLY",
	2: "READ_WRITE",
}

var TransationBegin_TransationMode_value = map[string]int32{
	"NONE":       0,
	"READ_ONLY":  1,
	"READ_WRITE": 2,
}

func (x TransationBegin_TransationMode) String() string {
	return proto.EnumName(TransationBegin_TransationMode_name, int32(x))
}

func (TransationBegin_TransationMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{40, 0}
}

type DataControl_DclType int32

const (
	DataControl_SET_VARIABLES DataControl_DclType = 0
	DataControl_GRANT         DataControl_DclType = 1
	DataControl_REVOKE        DataControl_DclType = 2
	DataControl_DENY          DataControl_DclType = 3
	DataControl_PREPARE       DataControl_DclType = 4
	DataControl_EXECUTE       DataControl_DclType = 5
	DataControl_DEALLOCATE    DataControl_DclType = 6
)

var DataControl_DclType_name = map[int32]string{
	0: "SET_VARIABLES",
	1: "GRANT",
	2: "REVOKE",
	3: "DENY",
	4: "PREPARE",
	5: "EXECUTE",
	6: "DEALLOCATE",
}

var DataControl_DclType_value = map[string]int32{
	"SET_VARIABLES": 0,
	"GRANT":         1,
	"REVOKE":        2,
	"DENY":          3,
	"PREPARE":       4,
	"EXECUTE":       5,
	"DEALLOCATE":    6,
}

func (x DataControl_DclType) String() string {
	return proto.EnumName(DataControl_DclType_name, int32(x))
}

func (DataControl_DclType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{46, 0}
}

type DataDefinition_DdlType int32

const (
	DataDefinition_CREATE_DATABASE     DataDefinition_DdlType = 0
	DataDefinition_ALTER_DATABASE      DataDefinition_DdlType = 1
	DataDefinition_DROP_DATABASE       DataDefinition_DdlType = 2
	DataDefinition_CREATE_TABLE        DataDefinition_DdlType = 3
	DataDefinition_ALTER_TABLE         DataDefinition_DdlType = 4
	DataDefinition_DROP_TABLE          DataDefinition_DdlType = 5
	DataDefinition_CREATE_INDEX        DataDefinition_DdlType = 6
	DataDefinition_ALTER_INDEX         DataDefinition_DdlType = 7
	DataDefinition_DROP_INDEX          DataDefinition_DdlType = 8
	DataDefinition_TRUNCATE_TABLE      DataDefinition_DdlType = 9
	DataDefinition_CREATE_VIEW         DataDefinition_DdlType = 10
	DataDefinition_ALTER_VIEW          DataDefinition_DdlType = 11
	DataDefinition_DROP_VIEW           DataDefinition_DdlType = 12
	DataDefinition_SHOW_CREATEDATABASE DataDefinition_DdlType = 13
	DataDefinition_SHOW_CREATETABLE    DataDefinition_DdlType = 14
	DataDefinition_SHOW_DATABASES      DataDefinition_DdlType = 15
	DataDefinition_SHOW_TABLES         DataDefinition_DdlType = 16
	DataDefinition_SHOW_COLUMNS        DataDefinition_DdlType = 17
	DataDefinition_SHOW_INDEX          DataDefinition_DdlType = 18
	DataDefinition_SHOW_VARIABLES      DataDefinition_DdlType = 19
	DataDefinition_SHOW_WARNINGS       DataDefinition_DdlType = 20
	DataDefinition_SHOW_ERRORS         DataDefinition_DdlType = 21
	DataDefinition_SHOW_STATUS         DataDefinition_DdlType = 22
	DataDefinition_SHOW_PROCESSLIST    DataDefinition_DdlType = 23
	DataDefinition_SHOW_TABLE_STATUS   DataDefinition_DdlType = 24
	DataDefinition_SHOW_TARGET         DataDefinition_DdlType = 25
	DataDefinition_SHOW_COLLATION      DataDefinition_DdlType = 26
)

var DataDefinition_DdlType_name = map[int32]string{
	0:  "CREATE_DATABASE",
	1:  "ALTER_DATABASE",
	2:  "DROP_DATABASE",
	3:  "CREATE_TABLE",
	4:  "ALTER_TABLE",
	5:  "DROP_TABLE",
	6:  "CREATE_INDEX",
	7:  "ALTER_INDEX",
	8:  "DROP_INDEX",
	9:  "TRUNCATE_TABLE",
	10: "CREATE_VIEW",
	11: "ALTER_VIEW",
	12: "DROP_VIEW",
	13: "SHOW_CREATEDATABASE",
	14: "SHOW_CREATETABLE",
	15: "SHOW_DATABASES",
	16: "SHOW_TABLES",
	17: "SHOW_COLUMNS",
	18: "SHOW_INDEX",
	19: "SHOW_VARIABLES",
	20: "SHOW_WARNINGS",
	21: "SHOW_ERRORS",
	22: "SHOW_STATUS",
	23: "SHOW_PROCESSLIST",
	24: "SHOW_TABLE_STATUS",
	25: "SHOW_TARGET",
	26: "SHOW_COLLATION",
}

var DataDefinition_DdlType_value = map[string]int32{
	"CREATE_DATABASE":     0,
	"ALTER_DATABASE":      1,
	"DROP_DATABASE":       2,
	"CREATE_TABLE":        3,
	"ALTER_TABLE":         4,
	"DROP_TABLE":          5,
	"CREATE_INDEX":        6,
	"ALTER_INDEX":         7,
	"DROP_INDEX":          8,
	"TRUNCATE_TABLE":      9,
	"CREATE_VIEW":         10,
	"ALTER_VIEW":          11,
	"DROP_VIEW":           12,
	"SHOW_CREATEDATABASE": 13,
	"SHOW_CREATETABLE":    14,
	"SHOW_DATABASES":      15,
	"SHOW_TABLES":         16,
	"SHOW_COLUMNS":        17,
	"SHOW_INDEX":          18,
	"SHOW_VARIABLES":      19,
	"SHOW_WARNINGS":       20,
	"SHOW_ERRORS":         21,
	"SHOW_STATUS":         22,
	"SHOW_PROCESSLIST":    23,
	"SHOW_TABLE_STATUS":   24,
	"SHOW_TARGET":         25,
	"SHOW_COLLATION":      26,
}

func (x DataDefinition_DdlType) String() string {
	return proto.EnumName(DataDefinition_DdlType_name, int32(x))
}

func (DataDefinition_DdlType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{47, 0}
}

type Type struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Nullable             bool     `protobuf:"varint,2,opt,name=nullable,proto3" json:"nullable,omitempty"`
	AutoIncr             bool     `protobuf:"varint,3,opt,name=auto_incr,json=autoIncr,proto3" json:"auto_incr,omitempty"`
	Width                int32    `protobuf:"varint,4,opt,name=width,proto3" json:"width,omitempty"`
	Precision            int32    `protobuf:"varint,5,opt,name=precision,proto3" json:"precision,omitempty"`
	Size                 int32    `protobuf:"varint,6,opt,name=size,proto3" json:"size,omitempty"`
	Scale                int32    `protobuf:"varint,7,opt,name=scale,proto3" json:"scale,omitempty"`
	Table                string   `protobuf:"bytes,8,opt,name=table,proto3" json:"table,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Type) Reset()         { *m = Type{} }
func (m *Type) String() string { return proto.CompactTextString(m) }
func (*Type) ProtoMessage()    {}
func (*Type) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{0}
}
func (m *Type) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Type) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Type.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Type) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Type.Merge(m, src)
}
func (m *Type) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Type) XXX_DiscardUnknown() {
	xxx_messageInfo_Type.DiscardUnknown(m)
}

var xxx_messageInfo_Type proto.InternalMessageInfo

func (m *Type) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Type) GetNullable() bool {
	if m != nil {
		return m.Nullable
	}
	return false
}

func (m *Type) GetAutoIncr() bool {
	if m != nil {
		return m.AutoIncr
	}
	return false
}

func (m *Type) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Type) GetPrecision() int32 {
	if m != nil {
		return m.Precision
	}
	return 0
}

func (m *Type) GetSize() int32 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *Type) GetScale() int32 {
	if m != nil {
		return m.Scale
	}
	return 0
}

func (m *Type) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

// Const: if a const value can be reprensented by int64 or
// double, use that, otherwise store a string representation.
type Const struct {
	Isnull bool `protobuf:"varint,1,opt,name=isnull,proto3" json:"isnull,omitempty"`
	// Types that are valid to be assigned to Value:
	//
	//	*Const_I8Val
	//	*Const_I16Val
	//	*Const_I32Val
	//	*Const_I64Val
	//	*Const_U8Val
	//	*Const_U16Val
	//	*Const_U32Val
	//	*Const_U64Val
	//	*Const_Dval
	//	*Const_Sval
	//	*Const_Bval
	//	*Const_Fval
	//	*Const_Dateval
	//	*Const_Timeval
	//	*Const_Datetimeval
	//	*Const_Decimal64Val
	//	*Const_Decimal128Val
	//	*Const_Timestampval
	//	*Const_Jsonval
	//	*Const_Defaultval
	//	*Const_UpdateVal
	Value                isConst_Value `protobuf_oneof:"value"`
	IsBin                bool          `protobuf:"varint,23,opt,name=isBin,proto3" json:"isBin,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Const) Reset()         { *m = Const{} }
func (m *Const) String() string { return proto.CompactTextString(m) }
func (*Const) ProtoMessage()    {}
func (*Const) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{1}
}
func (m *Const) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Const) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Const.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Const) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Const.Merge(m, src)
}
func (m *Const) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Const) XXX_DiscardUnknown() {
	xxx_messageInfo_Const.DiscardUnknown(m)
}

var xxx_messageInfo_Const proto.InternalMessageInfo

type isConst_Value interface {
	isConst_Value()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type Const_I8Val struct {
	I8Val int32 `protobuf:"varint,2,opt,name=i8val,proto3,oneof" json:"i8val,omitempty"`
}
type Const_I16Val struct {
	I16Val int32 `protobuf:"varint,3,opt,name=i16val,proto3,oneof" json:"i16val,omitempty"`
}
type Const_I32Val struct {
	I32Val int32 `protobuf:"varint,4,opt,name=i32val,proto3,oneof" json:"i32val,omitempty"`
}
type Const_I64Val struct {
	I64Val int64 `protobuf:"varint,5,opt,name=i64val,proto3,oneof" json:"i64val,omitempty"`
}
type Const_U8Val struct {
	U8Val uint32 `protobuf:"varint,6,opt,name=u8val,proto3,oneof" json:"u8val,omitempty"`
}
type Const_U16Val struct {
	U16Val uint32 `protobuf:"varint,7,opt,name=u16val,proto3,oneof" json:"u16val,omitempty"`
}
type Const_U32Val struct {
	U32Val uint32 `protobuf:"varint,8,opt,name=u32val,proto3,oneof" json:"u32val,omitempty"`
}
type Const_U64Val struct {
	U64Val uint64 `protobuf:"varint,9,opt,name=u64val,proto3,oneof" json:"u64val,omitempty"`
}
type Const_Dval struct {
	Dval float64 `protobuf:"fixed64,10,opt,name=dval,proto3,oneof" json:"dval,omitempty"`
}
type Const_Sval struct {
	Sval string `protobuf:"bytes,11,opt,name=sval,proto3,oneof" json:"sval,omitempty"`
}
type Const_Bval struct {
	Bval bool `protobuf:"varint,12,opt,name=bval,proto3,oneof" json:"bval,omitempty"`
}
type Const_Fval struct {
	Fval float32 `protobuf:"fixed32,13,opt,name=fval,proto3,oneof" json:"fval,omitempty"`
}
type Const_Dateval struct {
	Dateval int32 `protobuf:"varint,14,opt,name=dateval,proto3,oneof" json:"dateval,omitempty"`
}
type Const_Timeval struct {
	Timeval int64 `protobuf:"varint,15,opt,name=timeval,proto3,oneof" json:"timeval,omitempty"`
}
type Const_Datetimeval struct {
	Datetimeval int64 `protobuf:"varint,16,opt,name=datetimeval,proto3,oneof" json:"datetimeval,omitempty"`
}
type Const_Decimal64Val struct {
	Decimal64Val *Decimal64 `protobuf:"bytes,17,opt,name=decimal64val,proto3,oneof" json:"decimal64val,omitempty"`
}
type Const_Decimal128Val struct {
	Decimal128Val *Decimal128 `protobuf:"bytes,18,opt,name=decimal128val,proto3,oneof" json:"decimal128val,omitempty"`
}
type Const_Timestampval struct {
	Timestampval int64 `protobuf:"varint,19,opt,name=timestampval,proto3,oneof" json:"timestampval,omitempty"`
}
type Const_Jsonval struct {
	Jsonval string `protobuf:"bytes,20,opt,name=jsonval,proto3,oneof" json:"jsonval,omitempty"`
}
type Const_Defaultval struct {
	Defaultval bool `protobuf:"varint,21,opt,name=defaultval,proto3,oneof" json:"defaultval,omitempty"`
}
type Const_UpdateVal struct {
	UpdateVal bool `protobuf:"varint,22,opt,name=updateVal,proto3,oneof" json:"updateVal,omitempty"`
}

func (*Const_I8Val) isConst_Value()         {}
func (*Const_I16Val) isConst_Value()        {}
func (*Const_I32Val) isConst_Value()        {}
func (*Const_I64Val) isConst_Value()        {}
func (*Const_U8Val) isConst_Value()         {}
func (*Const_U16Val) isConst_Value()        {}
func (*Const_U32Val) isConst_Value()        {}
func (*Const_U64Val) isConst_Value()        {}
func (*Const_Dval) isConst_Value()          {}
func (*Const_Sval) isConst_Value()          {}
func (*Const_Bval) isConst_Value()          {}
func (*Const_Fval) isConst_Value()          {}
func (*Const_Dateval) isConst_Value()       {}
func (*Const_Timeval) isConst_Value()       {}
func (*Const_Datetimeval) isConst_Value()   {}
func (*Const_Decimal64Val) isConst_Value()  {}
func (*Const_Decimal128Val) isConst_Value() {}
func (*Const_Timestampval) isConst_Value()  {}
func (*Const_Jsonval) isConst_Value()       {}
func (*Const_Defaultval) isConst_Value()    {}
func (*Const_UpdateVal) isConst_Value()     {}

func (m *Const) GetValue() isConst_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Const) GetIsnull() bool {
	if m != nil {
		return m.Isnull
	}
	return false
}

func (m *Const) GetI8Val() int32 {
	if x, ok := m.GetValue().(*Const_I8Val); ok {
		return x.I8Val
	}
	return 0
}

func (m *Const) GetI16Val() int32 {
	if x, ok := m.GetValue().(*Const_I16Val); ok {
		return x.I16Val
	}
	return 0
}

func (m *Const) GetI32Val() int32 {
	if x, ok := m.GetValue().(*Const_I32Val); ok {
		return x.I32Val
	}
	return 0
}

func (m *Const) GetI64Val() int64 {
	if x, ok := m.GetValue().(*Const_I64Val); ok {
		return x.I64Val
	}
	return 0
}

func (m *Const) GetU8Val() uint32 {
	if x, ok := m.GetValue().(*Const_U8Val); ok {
		return x.U8Val
	}
	return 0
}

func (m *Const) GetU16Val() uint32 {
	if x, ok := m.GetValue().(*Const_U16Val); ok {
		return x.U16Val
	}
	return 0
}

func (m *Const) GetU32Val() uint32 {
	if x, ok := m.GetValue().(*Const_U32Val); ok {
		return x.U32Val
	}
	return 0
}

func (m *Const) GetU64Val() uint64 {
	if x, ok := m.GetValue().(*Const_U64Val); ok {
		return x.U64Val
	}
	return 0
}

func (m *Const) GetDval() float64 {
	if x, ok := m.GetValue().(*Const_Dval); ok {
		return x.Dval
	}
	return 0
}

func (m *Const) GetSval() string {
	if x, ok := m.GetValue().(*Const_Sval); ok {
		return x.Sval
	}
	return ""
}

func (m *Const) GetBval() bool {
	if x, ok := m.GetValue().(*Const_Bval); ok {
		return x.Bval
	}
	return false
}

func (m *Const) GetFval() float32 {
	if x, ok := m.GetValue().(*Const_Fval); ok {
		return x.Fval
	}
	return 0
}

func (m *Const) GetDateval() int32 {
	if x, ok := m.GetValue().(*Const_Dateval); ok {
		return x.Dateval
	}
	return 0
}

func (m *Const) GetTimeval() int64 {
	if x, ok := m.GetValue().(*Const_Timeval); ok {
		return x.Timeval
	}
	return 0
}

func (m *Const) GetDatetimeval() int64 {
	if x, ok := m.GetValue().(*Const_Datetimeval); ok {
		return x.Datetimeval
	}
	return 0
}

func (m *Const) GetDecimal64Val() *Decimal64 {
	if x, ok := m.GetValue().(*Const_Decimal64Val); ok {
		return x.Decimal64Val
	}
	return nil
}

func (m *Const) GetDecimal128Val() *Decimal128 {
	if x, ok := m.GetValue().(*Const_Decimal128Val); ok {
		return x.Decimal128Val
	}
	return nil
}

func (m *Const) GetTimestampval() int64 {
	if x, ok := m.GetValue().(*Const_Timestampval); ok {
		return x.Timestampval
	}
	return 0
}

func (m *Const) GetJsonval() string {
	if x, ok := m.GetValue().(*Const_Jsonval); ok {
		return x.Jsonval
	}
	return ""
}

func (m *Const) GetDefaultval() bool {
	if x, ok := m.GetValue().(*Const_Defaultval); ok {
		return x.Defaultval
	}
	return false
}

func (m *Const) GetUpdateVal() bool {
	if x, ok := m.GetValue().(*Const_UpdateVal); ok {
		return x.UpdateVal
	}
	return false
}

func (m *Const) GetIsBin() bool {
	if m != nil {
		return m.IsBin
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Const) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Const_I8Val)(nil),
		(*Const_I16Val)(nil),
		(*Const_I32Val)(nil),
		(*Const_I64Val)(nil),
		(*Const_U8Val)(nil),
		(*Const_U16Val)(nil),
		(*Const_U32Val)(nil),
		(*Const_U64Val)(nil),
		(*Const_Dval)(nil),
		(*Const_Sval)(nil),
		(*Const_Bval)(nil),
		(*Const_Fval)(nil),
		(*Const_Dateval)(nil),
		(*Const_Timeval)(nil),
		(*Const_Datetimeval)(nil),
		(*Const_Decimal64Val)(nil),
		(*Const_Decimal128Val)(nil),
		(*Const_Timestampval)(nil),
		(*Const_Jsonval)(nil),
		(*Const_Defaultval)(nil),
		(*Const_UpdateVal)(nil),
	}
}

// Bounded param for prepared statement.  User fill on execution.
type ParamRef struct {
	Pos                  int32    `protobuf:"varint,1,opt,name=pos,proto3" json:"pos,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ParamRef) Reset()         { *m = ParamRef{} }
func (m *ParamRef) String() string { return proto.CompactTextString(m) }
func (*ParamRef) ProtoMessage()    {}
func (*ParamRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{2}
}
func (m *ParamRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParamRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParamRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParamRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParamRef.Merge(m, src)
}
func (m *ParamRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ParamRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ParamRef.DiscardUnknown(m)
}

var xxx_messageInfo_ParamRef proto.InternalMessageInfo

func (m *ParamRef) GetPos() int32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

// Session variable ref, compiler should fold.
type VarRef struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	System               bool     `protobuf:"varint,2,opt,name=system,proto3" json:"system,omitempty"`
	Global               bool     `protobuf:"varint,3,opt,name=global,proto3" json:"global,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VarRef) Reset()         { *m = VarRef{} }
func (m *VarRef) String() string { return proto.CompactTextString(m) }
func (*VarRef) ProtoMessage()    {}
func (*VarRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{3}
}
func (m *VarRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VarRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VarRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VarRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VarRef.Merge(m, src)
}
func (m *VarRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *VarRef) XXX_DiscardUnknown() {
	xxx_messageInfo_VarRef.DiscardUnknown(m)
}

var xxx_messageInfo_VarRef proto.InternalMessageInfo

func (m *VarRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VarRef) GetSystem() bool {
	if m != nil {
		return m.System
	}
	return false
}

func (m *VarRef) GetGlobal() bool {
	if m != nil {
		return m.Global
	}
	return false
}

// Reference a column in the proj list of a node.
type ColRef struct {
	RelPos               int32    `protobuf:"varint,1,opt,name=rel_pos,json=relPos,proto3" json:"rel_pos,omitempty"`
	ColPos               int32    `protobuf:"varint,2,opt,name=col_pos,json=colPos,proto3" json:"col_pos,omitempty"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ColRef) Reset()         { *m = ColRef{} }
func (m *ColRef) String() string { return proto.CompactTextString(m) }
func (*ColRef) ProtoMessage()    {}
func (*ColRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{4}
}
func (m *ColRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColRef.Merge(m, src)
}
func (m *ColRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ColRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ColRef.DiscardUnknown(m)
}

var xxx_messageInfo_ColRef proto.InternalMessageInfo

func (m *ColRef) GetRelPos() int32 {
	if m != nil {
		return m.RelPos
	}
	return 0
}

func (m *ColRef) GetColPos() int32 {
	if m != nil {
		return m.ColPos
	}
	return 0
}

func (m *ColRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Reference a correlated column in the proj list of a node.
type CorrColRef struct {
	RelPos               int32    `protobuf:"varint,1,opt,name=rel_pos,json=relPos,proto3" json:"rel_pos,omitempty"`
	ColPos               int32    `protobuf:"varint,2,opt,name=col_pos,json=colPos,proto3" json:"col_pos,omitempty"`
	Depth                int32    `protobuf:"varint,3,opt,name=depth,proto3" json:"depth,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CorrColRef) Reset()         { *m = CorrColRef{} }
func (m *CorrColRef) String() string { return proto.CompactTextString(m) }
func (*CorrColRef) ProtoMessage()    {}
func (*CorrColRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{5}
}
func (m *CorrColRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CorrColRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CorrColRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CorrColRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CorrColRef.Merge(m, src)
}
func (m *CorrColRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CorrColRef) XXX_DiscardUnknown() {
	xxx_messageInfo_CorrColRef.DiscardUnknown(m)
}

var xxx_messageInfo_CorrColRef proto.InternalMessageInfo

func (m *CorrColRef) GetRelPos() int32 {
	if m != nil {
		return m.RelPos
	}
	return 0
}

func (m *CorrColRef) GetColPos() int32 {
	if m != nil {
		return m.ColPos
	}
	return 0
}

func (m *CorrColRef) GetDepth() int32 {
	if m != nil {
		return m.Depth
	}
	return 0
}

// ExprList is a type of Expr
type ExprList struct {
	List                 []*Expr  `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExprList) Reset()         { *m = ExprList{} }
func (m *ExprList) String() string { return proto.CompactTextString(m) }
func (*ExprList) ProtoMessage()    {}
func (*ExprList) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{6}
}
func (m *ExprList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExprList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExprList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExprList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExprList.Merge(m, src)
}
func (m *ExprList) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExprList) XXX_DiscardUnknown() {
	xxx_messageInfo_ExprList.DiscardUnknown(m)
}

var xxx_messageInfo_ExprList proto.InternalMessageInfo

func (m *ExprList) GetList() []*Expr {
	if m != nil {
		return m.List
	}
	return nil
}

type MaxValue struct {
	Value                string   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MaxValue) Reset()         { *m = MaxValue{} }
func (m *MaxValue) String() string { return proto.CompactTextString(m) }
func (*MaxValue) ProtoMessage()    {}
func (*MaxValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{7}
}
func (m *MaxValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaxValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaxValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaxValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaxValue.Merge(m, src)
}
func (m *MaxValue) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MaxValue) XXX_DiscardUnknown() {
	xxx_messageInfo_MaxValue.DiscardUnknown(m)
}

var xxx_messageInfo_MaxValue proto.InternalMessageInfo

func (m *MaxValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// TargetType used in cast function as target type
type TargetType struct {
	Typ                  *Type    `protobuf:"bytes,1,opt,name=typ,proto3" json:"typ,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TargetType) Reset()         { *m = TargetType{} }
func (m *TargetType) String() string { return proto.CompactTextString(m) }
func (*TargetType) ProtoMessage()    {}
func (*TargetType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{8}
}
func (m *TargetType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TargetType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TargetType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TargetType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TargetType.Merge(m, src)
}
func (m *TargetType) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TargetType) XXX_DiscardUnknown() {
	xxx_messageInfo_TargetType.DiscardUnknown(m)
}

var xxx_messageInfo_TargetType proto.InternalMessageInfo

func (m *TargetType) GetTyp() *Type {
	if m != nil {
		return m.Typ
	}
	return nil
}

// Reference a subquery
type SubqueryRef struct {
	Typ                  SubqueryRef_Type `protobuf:"varint,1,opt,name=typ,proto3,enum=plan.SubqueryRef_Type" json:"typ,omitempty"`
	NodeId               int32            `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Op                   string           `protobuf:"bytes,3,opt,name=op,proto3" json:"op,omitempty"`
	Child                *Expr            `protobuf:"bytes,4,opt,name=child,proto3" json:"child,omitempty"`
	RowSize              int32            `protobuf:"varint,5,opt,name=row_size,json=rowSize,proto3" json:"row_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SubqueryRef) Reset()         { *m = SubqueryRef{} }
func (m *SubqueryRef) String() string { return proto.CompactTextString(m) }
func (*SubqueryRef) ProtoMessage()    {}
func (*SubqueryRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{9}
}
func (m *SubqueryRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubqueryRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubqueryRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubqueryRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubqueryRef.Merge(m, src)
}
func (m *SubqueryRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SubqueryRef) XXX_DiscardUnknown() {
	xxx_messageInfo_SubqueryRef.DiscardUnknown(m)
}

var xxx_messageInfo_SubqueryRef proto.InternalMessageInfo

func (m *SubqueryRef) GetTyp() SubqueryRef_Type {
	if m != nil {
		return m.Typ
	}
	return SubqueryRef_SCALAR
}

func (m *SubqueryRef) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *SubqueryRef) GetOp() string {
	if m != nil {
		return m.Op
	}
	return ""
}

func (m *SubqueryRef) GetChild() *Expr {
	if m != nil {
		return m.Child
	}
	return nil
}

func (m *SubqueryRef) GetRowSize() int32 {
	if m != nil {
		return m.RowSize
	}
	return 0
}

// Object ref, reference a object in database, 4 part name.
type ObjectRef struct {
	Server               int64    `protobuf:"varint,1,opt,name=server,proto3" json:"server,omitempty"`
	Db                   int64    `protobuf:"varint,2,opt,name=db,proto3" json:"db,omitempty"`
	Schema               int64    `protobuf:"varint,3,opt,name=schema,proto3" json:"schema,omitempty"`
	Obj                  int64    `protobuf:"varint,4,opt,name=obj,proto3" json:"obj,omitempty"`
	ServerName           string   `protobuf:"bytes,5,opt,name=server_name,json=serverName,proto3" json:"server_name,omitempty"`
	DbName               string   `protobuf:"bytes,6,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	SchemaName           string   `protobuf:"bytes,7,opt,name=schema_name,json=schemaName,proto3" json:"schema_name,omitempty"`
	ObjName              string   `protobuf:"bytes,8,opt,name=obj_name,json=objName,proto3" json:"obj_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectRef) Reset()         { *m = ObjectRef{} }
func (m *ObjectRef) String() string { return proto.CompactTextString(m) }
func (*ObjectRef) ProtoMessage()    {}
func (*ObjectRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{10}
}
func (m *ObjectRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectRef.Merge(m, src)
}
func (m *ObjectRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ObjectRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectRef.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectRef proto.InternalMessageInfo

func (m *ObjectRef) GetServer() int64 {
	if m != nil {
		return m.Server
	}
	return 0
}

func (m *ObjectRef) GetDb() int64 {
	if m != nil {
		return m.Db
	}
	return 0
}

func (m *ObjectRef) GetSchema() int64 {
	if m != nil {
		return m.Schema
	}
	return 0
}

func (m *ObjectRef) GetObj() int64 {
	if m != nil {
		return m.Obj
	}
	return 0
}

func (m *ObjectRef) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

func (m *ObjectRef) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *ObjectRef) GetSchemaName() string {
	if m != nil {
		return m.SchemaName
	}
	return ""
}

func (m *ObjectRef) GetObjName() string {
	if m != nil {
		return m.ObjName
	}
	return ""
}

type Function struct {
	Func                 *ObjectRef `protobuf:"bytes,1,opt,name=func,proto3" json:"func,omitempty"`
	Args                 []*Expr    `protobuf:"bytes,2,rep,name=args,proto3" json:"args,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Function) Reset()         { *m = Function{} }
func (m *Function) String() string { return proto.CompactTextString(m) }
func (*Function) ProtoMessage()    {}
func (*Function) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{11}
}
func (m *Function) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Function) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Function.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Function) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Function.Merge(m, src)
}
func (m *Function) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Function) XXX_DiscardUnknown() {
	xxx_messageInfo_Function.DiscardUnknown(m)
}

var xxx_messageInfo_Function proto.InternalMessageInfo

func (m *Function) GetFunc() *ObjectRef {
	if m != nil {
		return m.Func
	}
	return nil
}

func (m *Function) GetArgs() []*Expr {
	if m != nil {
		return m.Args
	}
	return nil
}

type Expr struct {
	Typ *Type `protobuf:"bytes,1,opt,name=typ,proto3" json:"typ,omitempty"`
	// Types that are valid to be assigned to Expr:
	//
	//	*Expr_C
	//	*Expr_P
	//	*Expr_V
	//	*Expr_Col
	//	*Expr_F
	//	*Expr_Sub
	//	*Expr_Corr
	//	*Expr_T
	//	*Expr_List
	//	*Expr_Max
	Expr                 isExpr_Expr `protobuf_oneof:"expr"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Expr) Reset()         { *m = Expr{} }
func (m *Expr) String() string { return proto.CompactTextString(m) }
func (*Expr) ProtoMessage()    {}
func (*Expr) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{12}
}
func (m *Expr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Expr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Expr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Expr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Expr.Merge(m, src)
}
func (m *Expr) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Expr) XXX_DiscardUnknown() {
	xxx_messageInfo_Expr.DiscardUnknown(m)
}

var xxx_messageInfo_Expr proto.InternalMessageInfo

type isExpr_Expr interface {
	isExpr_Expr()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type Expr_C struct {
	C *Const `protobuf:"bytes,2,opt,name=c,proto3,oneof" json:"c,omitempty"`
}
type Expr_P struct {
	P *ParamRef `protobuf:"bytes,3,opt,name=p,proto3,oneof" json:"p,omitempty"`
}
type Expr_V struct {
	V *VarRef `protobuf:"bytes,4,opt,name=v,proto3,oneof" json:"v,omitempty"`
}
type Expr_Col struct {
	Col *ColRef `protobuf:"bytes,5,opt,name=col,proto3,oneof" json:"col,omitempty"`
}
type Expr_F struct {
	F *Function `protobuf:"bytes,6,opt,name=f,proto3,oneof" json:"f,omitempty"`
}
type Expr_Sub struct {
	Sub *SubqueryRef `protobuf:"bytes,7,opt,name=sub,proto3,oneof" json:"sub,omitempty"`
}
type Expr_Corr struct {
	Corr *CorrColRef `protobuf:"bytes,8,opt,name=corr,proto3,oneof" json:"corr,omitempty"`
}
type Expr_T struct {
	T *TargetType `protobuf:"bytes,9,opt,name=t,proto3,oneof" json:"t,omitempty"`
}
type Expr_List struct {
	List *ExprList `protobuf:"bytes,10,opt,name=list,proto3,oneof" json:"list,omitempty"`
}
type Expr_Max struct {
	Max *MaxValue `protobuf:"bytes,11,opt,name=max,proto3,oneof" json:"max,omitempty"`
}

func (*Expr_C) isExpr_Expr()    {}
func (*Expr_P) isExpr_Expr()    {}
func (*Expr_V) isExpr_Expr()    {}
func (*Expr_Col) isExpr_Expr()  {}
func (*Expr_F) isExpr_Expr()    {}
func (*Expr_Sub) isExpr_Expr()  {}
func (*Expr_Corr) isExpr_Expr() {}
func (*Expr_T) isExpr_Expr()    {}
func (*Expr_List) isExpr_Expr() {}
func (*Expr_Max) isExpr_Expr()  {}

func (m *Expr) GetExpr() isExpr_Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Expr) GetTyp() *Type {
	if m != nil {
		return m.Typ
	}
	return nil
}

func (m *Expr) GetC() *Const {
	if x, ok := m.GetExpr().(*Expr_C); ok {
		return x.C
	}
	return nil
}

func (m *Expr) GetP() *ParamRef {
	if x, ok := m.GetExpr().(*Expr_P); ok {
		return x.P
	}
	return nil
}

func (m *Expr) GetV() *VarRef {
	if x, ok := m.GetExpr().(*Expr_V); ok {
		return x.V
	}
	return nil
}

func (m *Expr) GetCol() *ColRef {
	if x, ok := m.GetExpr().(*Expr_Col); ok {
		return x.Col
	}
	return nil
}

func (m *Expr) GetF() *Function {
	if x, ok := m.GetExpr().(*Expr_F); ok {
		return x.F
	}
	return nil
}

func (m *Expr) GetSub() *SubqueryRef {
	if x, ok := m.GetExpr().(*Expr_Sub); ok {
		return x.Sub
	}
	return nil
}

func (m *Expr) GetCorr() *CorrColRef {
	if x, ok := m.GetExpr().(*Expr_Corr); ok {
		return x.Corr
	}
	return nil
}

func (m *Expr) GetT() *TargetType {
	if x, ok := m.GetExpr().(*Expr_T); ok {
		return x.T
	}
	return nil
}

func (m *Expr) GetList() *ExprList {
	if x, ok := m.GetExpr().(*Expr_List); ok {
		return x.List
	}
	return nil
}

func (m *Expr) GetMax() *MaxValue {
	if x, ok := m.GetExpr().(*Expr_Max); ok {
		return x.Max
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Expr) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Expr_C)(nil),
		(*Expr_P)(nil),
		(*Expr_V)(nil),
		(*Expr_Col)(nil),
		(*Expr_F)(nil),
		(*Expr_Sub)(nil),
		(*Expr_Corr)(nil),
		(*Expr_T)(nil),
		(*Expr_List)(nil),
		(*Expr_Max)(nil),
	}
}

type Decimal64 struct {
	A                    int64    `protobuf:"varint,1,opt,name=a,proto3" json:"a,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Decimal64) Reset()         { *m = Decimal64{} }
func (m *Decimal64) String() string { return proto.CompactTextString(m) }
func (*Decimal64) ProtoMessage()    {}
func (*Decimal64) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{13}
}
func (m *Decimal64) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Decimal64) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Decimal64.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Decimal64) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Decimal64.Merge(m, src)
}
func (m *Decimal64) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Decimal64) XXX_DiscardUnknown() {
	xxx_messageInfo_Decimal64.DiscardUnknown(m)
}

var xxx_messageInfo_Decimal64 proto.InternalMessageInfo

func (m *Decimal64) GetA() int64 {
	if m != nil {
		return m.A
	}
	return 0
}

type Decimal128 struct {
	A                    int64    `protobuf:"varint,1,opt,name=a,proto3" json:"a,omitempty"`
	B                    int64    `protobuf:"varint,2,opt,name=b,proto3" json:"b,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Decimal128) Reset()         { *m = Decimal128{} }
func (m *Decimal128) String() string { return proto.CompactTextString(m) }
func (*Decimal128) ProtoMessage()    {}
func (*Decimal128) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{14}
}
func (m *Decimal128) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Decimal128) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Decimal128.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Decimal128) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Decimal128.Merge(m, src)
}
func (m *Decimal128) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Decimal128) XXX_DiscardUnknown() {
	xxx_messageInfo_Decimal128.DiscardUnknown(m)
}

var xxx_messageInfo_Decimal128 proto.InternalMessageInfo

func (m *Decimal128) GetA() int64 {
	if m != nil {
		return m.A
	}
	return 0
}

func (m *Decimal128) GetB() int64 {
	if m != nil {
		return m.B
	}
	return 0
}

type ColDef struct {
	Name                 string       `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Alg                  CompressType `protobuf:"varint,2,opt,name=alg,proto3,enum=plan.CompressType" json:"alg,omitempty"`
	Typ                  *Type        `protobuf:"bytes,3,opt,name=typ,proto3" json:"typ,omitempty"`
	Default              *Default     `protobuf:"bytes,4,opt,name=default,proto3" json:"default,omitempty"`
	Primary              bool         `protobuf:"varint,5,opt,name=primary,proto3" json:"primary,omitempty"`
	Pkidx                int32        `protobuf:"varint,6,opt,name=pkidx,proto3" json:"pkidx,omitempty"`
	Comment              string       `protobuf:"bytes,7,opt,name=comment,proto3" json:"comment,omitempty"`
	IsCPkey              bool         `protobuf:"varint,8,opt,name=is_cPkey,json=isCPkey,proto3" json:"is_cPkey,omitempty"`
	OnUpdate             *OnUpdate    `protobuf:"bytes,9,opt,name=on_update,json=onUpdate,proto3" json:"on_update,omitempty"`
	LowCardinality       bool         `protobuf:"varint,10,opt,name=low_cardinality,json=lowCardinality,proto3" json:"low_cardinality,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ColDef) Reset()         { *m = ColDef{} }
func (m *ColDef) String() string { return proto.CompactTextString(m) }
func (*ColDef) ProtoMessage()    {}
func (*ColDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{15}
}
func (m *ColDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColDef.Merge(m, src)
}
func (m *ColDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ColDef) XXX_DiscardUnknown() {
	xxx_messageInfo_ColDef.DiscardUnknown(m)
}

var xxx_messageInfo_ColDef proto.InternalMessageInfo

func (m *ColDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ColDef) GetAlg() CompressType {
	if m != nil {
		return m.Alg
	}
	return CompressType_None
}

func (m *ColDef) GetTyp() *Type {
	if m != nil {
		return m.Typ
	}
	return nil
}

func (m *ColDef) GetDefault() *Default {
	if m != nil {
		return m.Default
	}
	return nil
}

func (m *ColDef) GetPrimary() bool {
	if m != nil {
		return m.Primary
	}
	return false
}

func (m *ColDef) GetPkidx() int32 {
	if m != nil {
		return m.Pkidx
	}
	return 0
}

func (m *ColDef) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *ColDef) GetIsCPkey() bool {
	if m != nil {
		return m.IsCPkey
	}
	return false
}

func (m *ColDef) GetOnUpdate() *OnUpdate {
	if m != nil {
		return m.OnUpdate
	}
	return nil
}

func (m *ColDef) GetLowCardinality() bool {
	if m != nil {
		return m.LowCardinality
	}
	return false
}

type Default struct {
	NullAbility          bool     `protobuf:"varint,1,opt,name=null_ability,json=nullAbility,proto3" json:"null_ability,omitempty"`
	Expr                 *Expr    `protobuf:"bytes,2,opt,name=expr,proto3" json:"expr,omitempty"`
	OriginString         string   `protobuf:"bytes,3,opt,name=origin_string,json=originString,proto3" json:"origin_string,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Default) Reset()         { *m = Default{} }
func (m *Default) String() string { return proto.CompactTextString(m) }
func (*Default) ProtoMessage()    {}
func (*Default) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{16}
}
func (m *Default) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Default) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Default.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Default) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Default.Merge(m, src)
}
func (m *Default) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Default) XXX_DiscardUnknown() {
	xxx_messageInfo_Default.DiscardUnknown(m)
}

var xxx_messageInfo_Default proto.InternalMessageInfo

func (m *Default) GetNullAbility() bool {
	if m != nil {
		return m.NullAbility
	}
	return false
}

func (m *Default) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Default) GetOriginString() string {
	if m != nil {
		return m.OriginString
	}
	return ""
}

type OnUpdate struct {
	Expr                 *Expr    `protobuf:"bytes,1,opt,name=expr,proto3" json:"expr,omitempty"`
	OriginString         string   `protobuf:"bytes,2,opt,name=origin_string,json=originString,proto3" json:"origin_string,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OnUpdate) Reset()         { *m = OnUpdate{} }
func (m *OnUpdate) String() string { return proto.CompactTextString(m) }
func (*OnUpdate) ProtoMessage()    {}
func (*OnUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{17}
}
func (m *OnUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OnUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OnUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OnUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnUpdate.Merge(m, src)
}
func (m *OnUpdate) XXX_Size() int {
	return m.ProtoSize()
}
func (m *OnUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_OnUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_OnUpdate proto.InternalMessageInfo

func (m *OnUpdate) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *OnUpdate) GetOriginString() string {
	if m != nil {
		return m.OriginString
	}
	return ""
}

type PrimaryKeyDef struct {
	Names                []string `protobuf:"bytes,1,rep,name=names,proto3" json:"names,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PrimaryKeyDef) Reset()         { *m = PrimaryKeyDef{} }
func (m *PrimaryKeyDef) String() string { return proto.CompactTextString(m) }
func (*PrimaryKeyDef) ProtoMessage()    {}
func (*PrimaryKeyDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{18}
}
func (m *PrimaryKeyDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrimaryKeyDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrimaryKeyDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrimaryKeyDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrimaryKeyDef.Merge(m, src)
}
func (m *PrimaryKeyDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PrimaryKeyDef) XXX_DiscardUnknown() {
	xxx_messageInfo_PrimaryKeyDef.DiscardUnknown(m)
}

var xxx_messageInfo_PrimaryKeyDef proto.InternalMessageInfo

func (m *PrimaryKeyDef) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

type Property struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Property) Reset()         { *m = Property{} }
func (m *Property) String() string { return proto.CompactTextString(m) }
func (*Property) ProtoMessage()    {}
func (*Property) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{19}
}
func (m *Property) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Property) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Property.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Property) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Property.Merge(m, src)
}
func (m *Property) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Property) XXX_DiscardUnknown() {
	xxx_messageInfo_Property.DiscardUnknown(m)
}

var xxx_messageInfo_Property proto.InternalMessageInfo

func (m *Property) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Property) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type PropertiesDef struct {
	Properties           []*Property `protobuf:"bytes,1,rep,name=properties,proto3" json:"properties,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *PropertiesDef) Reset()         { *m = PropertiesDef{} }
func (m *PropertiesDef) String() string { return proto.CompactTextString(m) }
func (*PropertiesDef) ProtoMessage()    {}
func (*PropertiesDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{20}
}
func (m *PropertiesDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropertiesDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropertiesDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropertiesDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropertiesDef.Merge(m, src)
}
func (m *PropertiesDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PropertiesDef) XXX_DiscardUnknown() {
	xxx_messageInfo_PropertiesDef.DiscardUnknown(m)
}

var xxx_messageInfo_PropertiesDef proto.InternalMessageInfo

func (m *PropertiesDef) GetProperties() []*Property {
	if m != nil {
		return m.Properties
	}
	return nil
}

type PartitionInfo struct {
	Type                 PartitionType    `protobuf:"varint,1,opt,name=type,proto3,enum=plan.PartitionType" json:"type,omitempty"`
	Expr                 *Expr            `protobuf:"bytes,2,opt,name=Expr,proto3" json:"Expr,omitempty"`
	PartitionExpression  *Expr            `protobuf:"bytes,3,opt,name=partitionExpression,proto3" json:"partitionExpression,omitempty"`
	Columns              []*Expr          `protobuf:"bytes,4,rep,name=Columns,proto3" json:"Columns,omitempty"`
	PartitionColumns     []string         `protobuf:"bytes,5,rep,name=partitionColumns,proto3" json:"partitionColumns,omitempty"`
	PartitionNum         uint64           `protobuf:"varint,6,opt,name=partitionNum,proto3" json:"partitionNum,omitempty"`
	Partitions           []*PartitionItem `protobuf:"bytes,7,rep,name=partitions,proto3" json:"partitions,omitempty"`
	Algorithm            int64            `protobuf:"varint,8,opt,name=algorithm,proto3" json:"algorithm,omitempty"`
	IsSubPartition       bool             `protobuf:"varint,9,opt,name=isSubPartition,proto3" json:"isSubPartition,omitempty"`
	PartitionMsg         string           `protobuf:"bytes,10,opt,name=partition_msg,json=partitionMsg,proto3" json:"partition_msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *PartitionInfo) Reset()         { *m = PartitionInfo{} }
func (m *PartitionInfo) String() string { return proto.CompactTextString(m) }
func (*PartitionInfo) ProtoMessage()    {}
func (*PartitionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{21}
}
func (m *PartitionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionInfo.Merge(m, src)
}
func (m *PartitionInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PartitionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionInfo proto.InternalMessageInfo

func (m *PartitionInfo) GetType() PartitionType {
	if m != nil {
		return m.Type
	}
	return PartitionType_KEY
}

func (m *PartitionInfo) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *PartitionInfo) GetPartitionExpression() *Expr {
	if m != nil {
		return m.PartitionExpression
	}
	return nil
}

func (m *PartitionInfo) GetColumns() []*Expr {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *PartitionInfo) GetPartitionColumns() []string {
	if m != nil {
		return m.PartitionColumns
	}
	return nil
}

func (m *PartitionInfo) GetPartitionNum() uint64 {
	if m != nil {
		return m.PartitionNum
	}
	return 0
}

func (m *PartitionInfo) GetPartitions() []*PartitionItem {
	if m != nil {
		return m.Partitions
	}
	return nil
}

func (m *PartitionInfo) GetAlgorithm() int64 {
	if m != nil {
		return m.Algorithm
	}
	return 0
}

func (m *PartitionInfo) GetIsSubPartition() bool {
	if m != nil {
		return m.IsSubPartition
	}
	return false
}

func (m *PartitionInfo) GetPartitionMsg() string {
	if m != nil {
		return m.PartitionMsg
	}
	return ""
}

type PartitionItem struct {
	PartitionName        string   `protobuf:"bytes,1,opt,name=partitionName,proto3" json:"partitionName,omitempty"`
	OrdinalPosition      uint32   `protobuf:"varint,2,opt,name=ordinalPosition,proto3" json:"ordinalPosition,omitempty"`
	Description          string   `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Comment              string   `protobuf:"bytes,4,opt,name=comment,proto3" json:"comment,omitempty"`
	LessThan             []*Expr  `protobuf:"bytes,5,rep,name=lessThan,proto3" json:"lessThan,omitempty"`
	InValues             []*Expr  `protobuf:"bytes,6,rep,name=inValues,proto3" json:"inValues,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartitionItem) Reset()         { *m = PartitionItem{} }
func (m *PartitionItem) String() string { return proto.CompactTextString(m) }
func (*PartitionItem) ProtoMessage()    {}
func (*PartitionItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{22}
}
func (m *PartitionItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionItem.Merge(m, src)
}
func (m *PartitionItem) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PartitionItem) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionItem.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionItem proto.InternalMessageInfo

func (m *PartitionItem) GetPartitionName() string {
	if m != nil {
		return m.PartitionName
	}
	return ""
}

func (m *PartitionItem) GetOrdinalPosition() uint32 {
	if m != nil {
		return m.OrdinalPosition
	}
	return 0
}

func (m *PartitionItem) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *PartitionItem) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *PartitionItem) GetLessThan() []*Expr {
	if m != nil {
		return m.LessThan
	}
	return nil
}

func (m *PartitionItem) GetInValues() []*Expr {
	if m != nil {
		return m.InValues
	}
	return nil
}

type ViewDef struct {
	View                 string   `protobuf:"bytes,1,opt,name=view,proto3" json:"view,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ViewDef) Reset()         { *m = ViewDef{} }
func (m *ViewDef) String() string { return proto.CompactTextString(m) }
func (*ViewDef) ProtoMessage()    {}
func (*ViewDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{23}
}
func (m *ViewDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewDef.Merge(m, src)
}
func (m *ViewDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ViewDef) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewDef.DiscardUnknown(m)
}

var xxx_messageInfo_ViewDef proto.InternalMessageInfo

func (m *ViewDef) GetView() string {
	if m != nil {
		return m.View
	}
	return ""
}

type IndexDef struct {
	IndexNames           []string `protobuf:"bytes,1,rep,name=index_names,json=indexNames,proto3" json:"index_names,omitempty"`
	TableNames           []string `protobuf:"bytes,2,rep,name=table_names,json=tableNames,proto3" json:"table_names,omitempty"`
	Uniques              []bool   `protobuf:"varint,3,rep,packed,name=uniques,proto3" json:"uniques,omitempty"`
	Fields               []*Field `protobuf:"bytes,4,rep,name=fields,proto3" json:"fields,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IndexDef) Reset()         { *m = IndexDef{} }
func (m *IndexDef) String() string { return proto.CompactTextString(m) }
func (*IndexDef) ProtoMessage()    {}
func (*IndexDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{24}
}
func (m *IndexDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexDef.Merge(m, src)
}
func (m *IndexDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *IndexDef) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexDef.DiscardUnknown(m)
}

var xxx_messageInfo_IndexDef proto.InternalMessageInfo

func (m *IndexDef) GetIndexNames() []string {
	if m != nil {
		return m.IndexNames
	}
	return nil
}

func (m *IndexDef) GetTableNames() []string {
	if m != nil {
		return m.TableNames
	}
	return nil
}

func (m *IndexDef) GetUniques() []bool {
	if m != nil {
		return m.Uniques
	}
	return nil
}

func (m *IndexDef) GetFields() []*Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

type Field struct {
	ColNames             []string `protobuf:"bytes,1,rep,name=col_names,json=colNames,proto3" json:"col_names,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Field) Reset()         { *m = Field{} }
func (m *Field) String() string { return proto.CompactTextString(m) }
func (*Field) ProtoMessage()    {}
func (*Field) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{25}
}
func (m *Field) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Field) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Field.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Field) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Field.Merge(m, src)
}
func (m *Field) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Field) XXX_DiscardUnknown() {
	xxx_messageInfo_Field.DiscardUnknown(m)
}

var xxx_messageInfo_Field proto.InternalMessageInfo

func (m *Field) GetColNames() []string {
	if m != nil {
		return m.ColNames
	}
	return nil
}

type IndexInfo struct {
	TableName            string    `protobuf:"bytes,1,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	ColNames             []string  `protobuf:"bytes,2,rep,name=col_names,json=colNames,proto3" json:"col_names,omitempty"`
	Cols                 []*ColDef `protobuf:"bytes,3,rep,name=cols,proto3" json:"cols,omitempty"`
	Field                *Field    `protobuf:"bytes,4,opt,name=field,proto3" json:"field,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *IndexInfo) Reset()         { *m = IndexInfo{} }
func (m *IndexInfo) String() string { return proto.CompactTextString(m) }
func (*IndexInfo) ProtoMessage()    {}
func (*IndexInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{26}
}
func (m *IndexInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexInfo.Merge(m, src)
}
func (m *IndexInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *IndexInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexInfo.DiscardUnknown(m)
}

var xxx_messageInfo_IndexInfo proto.InternalMessageInfo

func (m *IndexInfo) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *IndexInfo) GetColNames() []string {
	if m != nil {
		return m.ColNames
	}
	return nil
}

func (m *IndexInfo) GetCols() []*ColDef {
	if m != nil {
		return m.Cols
	}
	return nil
}

func (m *IndexInfo) GetField() *Field {
	if m != nil {
		return m.Field
	}
	return nil
}

type TableDef struct {
	Name                 string              `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Cols                 []*ColDef           `protobuf:"bytes,2,rep,name=cols,proto3" json:"cols,omitempty"`
	Defs                 []*TableDef_DefType `protobuf:"bytes,3,rep,name=defs,proto3" json:"defs,omitempty"`
	TableType            string              `protobuf:"bytes,4,opt,name=table_type,json=tableType,proto3" json:"table_type,omitempty"`
	Createsql            string              `protobuf:"bytes,5,opt,name=createsql,proto3" json:"createsql,omitempty"`
	Name2ColIndex        map[string]int32    `protobuf:"bytes,6,rep,name=name2col_index,json=name2colIndex,proto3" json:"name2col_index,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	CompositePkey        *ColDef             `protobuf:"bytes,7,opt,name=composite_pkey,json=compositePkey,proto3" json:"composite_pkey,omitempty"`
	TblFunc              *TableFunction      `protobuf:"bytes,8,opt,name=tbl_func,json=tblFunc,proto3" json:"tbl_func,omitempty"`
	IndexInfos           []*IndexInfo        `protobuf:"bytes,9,rep,name=index_infos,json=indexInfos,proto3" json:"index_infos,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TableDef) Reset()         { *m = TableDef{} }
func (m *TableDef) String() string { return proto.CompactTextString(m) }
func (*TableDef) ProtoMessage()    {}
func (*TableDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{27}
}
func (m *TableDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDef.Merge(m, src)
}
func (m *TableDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableDef) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDef.DiscardUnknown(m)
}

var xxx_messageInfo_TableDef proto.InternalMessageInfo

func (m *TableDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TableDef) GetCols() []*ColDef {
	if m != nil {
		return m.Cols
	}
	return nil
}

func (m *TableDef) GetDefs() []*TableDef_DefType {
	if m != nil {
		return m.Defs
	}
	return nil
}

func (m *TableDef) GetTableType() string {
	if m != nil {
		return m.TableType
	}
	return ""
}

func (m *TableDef) GetCreatesql() string {
	if m != nil {
		return m.Createsql
	}
	return ""
}

func (m *TableDef) GetName2ColIndex() map[string]int32 {
	if m != nil {
		return m.Name2ColIndex
	}
	return nil
}

func (m *TableDef) GetCompositePkey() *ColDef {
	if m != nil {
		return m.CompositePkey
	}
	return nil
}

func (m *TableDef) GetTblFunc() *TableFunction {
	if m != nil {
		return m.TblFunc
	}
	return nil
}

func (m *TableDef) GetIndexInfos() []*IndexInfo {
	if m != nil {
		return m.IndexInfos
	}
	return nil
}

type TableDef_DefType struct {
	// Types that are valid to be assigned to Def:
	//
	//	*TableDef_DefType_Pk
	//	*TableDef_DefType_Idx
	//	*TableDef_DefType_Properties
	//	*TableDef_DefType_View
	//	*TableDef_DefType_Partition
	Def                  isTableDef_DefType_Def `protobuf_oneof:"def"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *TableDef_DefType) Reset()         { *m = TableDef_DefType{} }
func (m *TableDef_DefType) String() string { return proto.CompactTextString(m) }
func (*TableDef_DefType) ProtoMessage()    {}
func (*TableDef_DefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{27, 0}
}
func (m *TableDef_DefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDef_DefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableDef_DefType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableDef_DefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDef_DefType.Merge(m, src)
}
func (m *TableDef_DefType) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableDef_DefType) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDef_DefType.DiscardUnknown(m)
}

var xxx_messageInfo_TableDef_DefType proto.InternalMessageInfo

type isTableDef_DefType_Def interface {
	isTableDef_DefType_Def()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type TableDef_DefType_Pk struct {
	Pk *PrimaryKeyDef `protobuf:"bytes,1,opt,name=pk,proto3,oneof" json:"pk,omitempty"`
}
type TableDef_DefType_Idx struct {
	Idx *IndexDef `protobuf:"bytes,2,opt,name=idx,proto3,oneof" json:"idx,omitempty"`
}
type TableDef_DefType_Properties struct {
	Properties *PropertiesDef `protobuf:"bytes,3,opt,name=properties,proto3,oneof" json:"properties,omitempty"`
}
type TableDef_DefType_View struct {
	View *ViewDef `protobuf:"bytes,4,opt,name=view,proto3,oneof" json:"view,omitempty"`
}
type TableDef_DefType_Partition struct {
	Partition *PartitionInfo `protobuf:"bytes,5,opt,name=partition,proto3,oneof" json:"partition,omitempty"`
}

func (*TableDef_DefType_Pk) isTableDef_DefType_Def()         {}
func (*TableDef_DefType_Idx) isTableDef_DefType_Def()        {}
func (*TableDef_DefType_Properties) isTableDef_DefType_Def() {}
func (*TableDef_DefType_View) isTableDef_DefType_Def()       {}
func (*TableDef_DefType_Partition) isTableDef_DefType_Def()  {}

func (m *TableDef_DefType) GetDef() isTableDef_DefType_Def {
	if m != nil {
		return m.Def
	}
	return nil
}

func (m *TableDef_DefType) GetPk() *PrimaryKeyDef {
	if x, ok := m.GetDef().(*TableDef_DefType_Pk); ok {
		return x.Pk
	}
	return nil
}

func (m *TableDef_DefType) GetIdx() *IndexDef {
	if x, ok := m.GetDef().(*TableDef_DefType_Idx); ok {
		return x.Idx
	}
	return nil
}

func (m *TableDef_DefType) GetProperties() *PropertiesDef {
	if x, ok := m.GetDef().(*TableDef_DefType_Properties); ok {
		return x.Properties
	}
	return nil
}

func (m *TableDef_DefType) GetView() *ViewDef {
	if x, ok := m.GetDef().(*TableDef_DefType_View); ok {
		return x.View
	}
	return nil
}

func (m *TableDef_DefType) GetPartition() *PartitionInfo {
	if x, ok := m.GetDef().(*TableDef_DefType_Partition); ok {
		return x.Partition
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TableDef_DefType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TableDef_DefType_Pk)(nil),
		(*TableDef_DefType_Idx)(nil),
		(*TableDef_DefType_Properties)(nil),
		(*TableDef_DefType_View)(nil),
		(*TableDef_DefType_Partition)(nil),
	}
}

type TableFunction struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Param                []byte   `protobuf:"bytes,2,opt,name=param,proto3" json:"param,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TableFunction) Reset()         { *m = TableFunction{} }
func (m *TableFunction) String() string { return proto.CompactTextString(m) }
func (*TableFunction) ProtoMessage()    {}
func (*TableFunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{28}
}
func (m *TableFunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableFunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableFunction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableFunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableFunction.Merge(m, src)
}
func (m *TableFunction) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableFunction) XXX_DiscardUnknown() {
	xxx_messageInfo_TableFunction.DiscardUnknown(m)
}

var xxx_messageInfo_TableFunction proto.InternalMessageInfo

func (m *TableFunction) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TableFunction) GetParam() []byte {
	if m != nil {
		return m.Param
	}
	return nil
}

type Cost struct {
	Card                 float64  `protobuf:"fixed64,1,opt,name=card,proto3" json:"card,omitempty"`
	Rowsize              float64  `protobuf:"fixed64,2,opt,name=rowsize,proto3" json:"rowsize,omitempty"`
	Ndv                  float64  `protobuf:"fixed64,3,opt,name=ndv,proto3" json:"ndv,omitempty"`
	Start                float64  `protobuf:"fixed64,4,opt,name=start,proto3" json:"start,omitempty"`
	Total                float64  `protobuf:"fixed64,5,opt,name=total,proto3" json:"total,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Cost) Reset()         { *m = Cost{} }
func (m *Cost) String() string { return proto.CompactTextString(m) }
func (*Cost) ProtoMessage()    {}
func (*Cost) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{29}
}
func (m *Cost) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cost) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cost.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cost) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cost.Merge(m, src)
}
func (m *Cost) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Cost) XXX_DiscardUnknown() {
	xxx_messageInfo_Cost.DiscardUnknown(m)
}

var xxx_messageInfo_Cost proto.InternalMessageInfo

func (m *Cost) GetCard() float64 {
	if m != nil {
		return m.Card
	}
	return 0
}

func (m *Cost) GetRowsize() float64 {
	if m != nil {
		return m.Rowsize
	}
	return 0
}

func (m *Cost) GetNdv() float64 {
	if m != nil {
		return m.Ndv
	}
	return 0
}

func (m *Cost) GetStart() float64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Cost) GetTotal() float64 {
	if m != nil {
		return m.Total
	}
	return 0
}

type ColData struct {
	RowCount             int32     `protobuf:"varint,1,opt,name=row_count,json=rowCount,proto3" json:"row_count,omitempty"`
	NullCount            int32     `protobuf:"varint,2,opt,name=null_count,json=nullCount,proto3" json:"null_count,omitempty"`
	Nulls                []bool    `protobuf:"varint,3,rep,packed,name=nulls,proto3" json:"nulls,omitempty"`
	I32                  []int32   `protobuf:"varint,4,rep,packed,name=i32,proto3" json:"i32,omitempty"`
	I64                  []int64   `protobuf:"varint,5,rep,packed,name=i64,proto3" json:"i64,omitempty"`
	F32                  []float32 `protobuf:"fixed32,6,rep,packed,name=f32,proto3" json:"f32,omitempty"`
	F64                  []float64 `protobuf:"fixed64,7,rep,packed,name=f64,proto3" json:"f64,omitempty"`
	S                    []string  `protobuf:"bytes,8,rep,name=s,proto3" json:"s,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ColData) Reset()         { *m = ColData{} }
func (m *ColData) String() string { return proto.CompactTextString(m) }
func (*ColData) ProtoMessage()    {}
func (*ColData) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{30}
}
func (m *ColData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColData.Merge(m, src)
}
func (m *ColData) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ColData) XXX_DiscardUnknown() {
	xxx_messageInfo_ColData.DiscardUnknown(m)
}

var xxx_messageInfo_ColData proto.InternalMessageInfo

func (m *ColData) GetRowCount() int32 {
	if m != nil {
		return m.RowCount
	}
	return 0
}

func (m *ColData) GetNullCount() int32 {
	if m != nil {
		return m.NullCount
	}
	return 0
}

func (m *ColData) GetNulls() []bool {
	if m != nil {
		return m.Nulls
	}
	return nil
}

func (m *ColData) GetI32() []int32 {
	if m != nil {
		return m.I32
	}
	return nil
}

func (m *ColData) GetI64() []int64 {
	if m != nil {
		return m.I64
	}
	return nil
}

func (m *ColData) GetF32() []float32 {
	if m != nil {
		return m.F32
	}
	return nil
}

func (m *ColData) GetF64() []float64 {
	if m != nil {
		return m.F64
	}
	return nil
}

func (m *ColData) GetS() []string {
	if m != nil {
		return m.S
	}
	return nil
}

type RowsetData struct {
	Schema               *TableDef  `protobuf:"bytes,1,opt,name=schema,proto3" json:"schema,omitempty"`
	Cols                 []*ColData `protobuf:"bytes,2,rep,name=cols,proto3" json:"cols,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RowsetData) Reset()         { *m = RowsetData{} }
func (m *RowsetData) String() string { return proto.CompactTextString(m) }
func (*RowsetData) ProtoMessage()    {}
func (*RowsetData) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{31}
}
func (m *RowsetData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowsetData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RowsetData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RowsetData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowsetData.Merge(m, src)
}
func (m *RowsetData) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RowsetData) XXX_DiscardUnknown() {
	xxx_messageInfo_RowsetData.DiscardUnknown(m)
}

var xxx_messageInfo_RowsetData proto.InternalMessageInfo

func (m *RowsetData) GetSchema() *TableDef {
	if m != nil {
		return m.Schema
	}
	return nil
}

func (m *RowsetData) GetCols() []*ColData {
	if m != nil {
		return m.Cols
	}
	return nil
}

type OrderBySpec struct {
	Expr                 *Expr                   `protobuf:"bytes,1,opt,name=expr,proto3" json:"expr,omitempty"`
	Collation            string                  `protobuf:"bytes,2,opt,name=collation,proto3" json:"collation,omitempty"`
	Flag                 OrderBySpec_OrderByFlag `protobuf:"varint,3,opt,name=flag,proto3,enum=plan.OrderBySpec_OrderByFlag" json:"flag,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *OrderBySpec) Reset()         { *m = OrderBySpec{} }
func (m *OrderBySpec) String() string { return proto.CompactTextString(m) }
func (*OrderBySpec) ProtoMessage()    {}
func (*OrderBySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{32}
}
func (m *OrderBySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderBySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderBySpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderBySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderBySpec.Merge(m, src)
}
func (m *OrderBySpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *OrderBySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderBySpec.DiscardUnknown(m)
}

var xxx_messageInfo_OrderBySpec proto.InternalMessageInfo

func (m *OrderBySpec) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *OrderBySpec) GetCollation() string {
	if m != nil {
		return m.Collation
	}
	return ""
}

func (m *OrderBySpec) GetFlag() OrderBySpec_OrderByFlag {
	if m != nil {
		return m.Flag
	}
	return OrderBySpec_INTERNAL
}

type WindowSpec struct {
	PartitionBy          []*Expr        `protobuf:"bytes,1,rep,name=partition_by,json=partitionBy,proto3" json:"partition_by,omitempty"`
	OrderBy              []*OrderBySpec `protobuf:"bytes,2,rep,name=order_by,json=orderBy,proto3" json:"order_by,omitempty"`
	Lead                 int32          `protobuf:"varint,3,opt,name=lead,proto3" json:"lead,omitempty"`
	Lag                  int32          `protobuf:"varint,4,opt,name=lag,proto3" json:"lag,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *WindowSpec) Reset()         { *m = WindowSpec{} }
func (m *WindowSpec) String() string { return proto.CompactTextString(m) }
func (*WindowSpec) ProtoMessage()    {}
func (*WindowSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{33}
}
func (m *WindowSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WindowSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WindowSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowSpec.Merge(m, src)
}
func (m *WindowSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *WindowSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowSpec.DiscardUnknown(m)
}

var xxx_messageInfo_WindowSpec proto.InternalMessageInfo

func (m *WindowSpec) GetPartitionBy() []*Expr {
	if m != nil {
		return m.PartitionBy
	}
	return nil
}

func (m *WindowSpec) GetOrderBy() []*OrderBySpec {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *WindowSpec) GetLead() int32 {
	if m != nil {
		return m.Lead
	}
	return 0
}

func (m *WindowSpec) GetLag() int32 {
	if m != nil {
		return m.Lag
	}
	return 0
}

type UpdateCtx struct {
	DbName               string    `protobuf:"bytes,1,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	TblName              string    `protobuf:"bytes,2,opt,name=tbl_name,json=tblName,proto3" json:"tbl_name,omitempty"`
	PriKey               string    `protobuf:"bytes,3,opt,name=pri_key,json=priKey,proto3" json:"pri_key,omitempty"`
	PriKeyIdx            int32     `protobuf:"varint,4,opt,name=pri_key_idx,json=priKeyIdx,proto3" json:"pri_key_idx,omitempty"`
	HideKey              string    `protobuf:"bytes,5,opt,name=hide_key,json=hideKey,proto3" json:"hide_key,omitempty"`
	HideKeyIdx           int32     `protobuf:"varint,6,opt,name=hide_key_idx,json=hideKeyIdx,proto3" json:"hide_key_idx,omitempty"`
	UpdateCols           []*ColDef `protobuf:"bytes,7,rep,name=update_cols,json=updateCols,proto3" json:"update_cols,omitempty"`
	OtherAttrs           []string  `protobuf:"bytes,8,rep,name=other_attrs,json=otherAttrs,proto3" json:"other_attrs,omitempty"`
	OrderAttrs           []string  `protobuf:"bytes,9,rep,name=order_attrs,json=orderAttrs,proto3" json:"order_attrs,omitempty"`
	CompositePkey        *ColDef   `protobuf:"bytes,10,opt,name=composite_pkey,json=compositePkey,proto3" json:"composite_pkey,omitempty"`
	IndexAttrs           []string  `protobuf:"bytes,11,rep,name=index_attrs,json=indexAttrs,proto3" json:"index_attrs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *UpdateCtx) Reset()         { *m = UpdateCtx{} }
func (m *UpdateCtx) String() string { return proto.CompactTextString(m) }
func (*UpdateCtx) ProtoMessage()    {}
func (*UpdateCtx) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{34}
}
func (m *UpdateCtx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateCtx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateCtx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateCtx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateCtx.Merge(m, src)
}
func (m *UpdateCtx) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UpdateCtx) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateCtx.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateCtx proto.InternalMessageInfo

func (m *UpdateCtx) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *UpdateCtx) GetTblName() string {
	if m != nil {
		return m.TblName
	}
	return ""
}

func (m *UpdateCtx) GetPriKey() string {
	if m != nil {
		return m.PriKey
	}
	return ""
}

func (m *UpdateCtx) GetPriKeyIdx() int32 {
	if m != nil {
		return m.PriKeyIdx
	}
	return 0
}

func (m *UpdateCtx) GetHideKey() string {
	if m != nil {
		return m.HideKey
	}
	return ""
}

func (m *UpdateCtx) GetHideKeyIdx() int32 {
	if m != nil {
		return m.HideKeyIdx
	}
	return 0
}

func (m *UpdateCtx) GetUpdateCols() []*ColDef {
	if m != nil {
		return m.UpdateCols
	}
	return nil
}

func (m *UpdateCtx) GetOtherAttrs() []string {
	if m != nil {
		return m.OtherAttrs
	}
	return nil
}

func (m *UpdateCtx) GetOrderAttrs() []string {
	if m != nil {
		return m.OrderAttrs
	}
	return nil
}

func (m *UpdateCtx) GetCompositePkey() *ColDef {
	if m != nil {
		return m.CompositePkey
	}
	return nil
}

func (m *UpdateCtx) GetIndexAttrs() []string {
	if m != nil {
		return m.IndexAttrs
	}
	return nil
}

type AnalyzeInfo struct {
	InputRows            int64    `protobuf:"varint,1,opt,name=input_rows,json=inputRows,proto3" json:"input_rows,omitempty"`
	OutputRows           int64    `protobuf:"varint,2,opt,name=output_rows,json=outputRows,proto3" json:"output_rows,omitempty"`
	InputSize            int64    `protobuf:"varint,3,opt,name=input_size,json=inputSize,proto3" json:"input_size,omitempty"`
	OutputSize           int64    `protobuf:"varint,4,opt,name=output_size,json=outputSize,proto3" json:"output_size,omitempty"`
	TimeConsumed         int64    `protobuf:"varint,5,opt,name=time_consumed,json=timeConsumed,proto3" json:"time_consumed,omitempty"`
	MemorySize           int64    `protobuf:"varint,6,opt,name=memory_size,json=memorySize,proto3" json:"memory_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AnalyzeInfo) Reset()         { *m = AnalyzeInfo{} }
func (m *AnalyzeInfo) String() string { return proto.CompactTextString(m) }
func (*AnalyzeInfo) ProtoMessage()    {}
func (*AnalyzeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{35}
}
func (m *AnalyzeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnalyzeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnalyzeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AnalyzeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnalyzeInfo.Merge(m, src)
}
func (m *AnalyzeInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AnalyzeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AnalyzeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AnalyzeInfo proto.InternalMessageInfo

func (m *AnalyzeInfo) GetInputRows() int64 {
	if m != nil {
		return m.InputRows
	}
	return 0
}

func (m *AnalyzeInfo) GetOutputRows() int64 {
	if m != nil {
		return m.OutputRows
	}
	return 0
}

func (m *AnalyzeInfo) GetInputSize() int64 {
	if m != nil {
		return m.InputSize
	}
	return 0
}

func (m *AnalyzeInfo) GetOutputSize() int64 {
	if m != nil {
		return m.OutputSize
	}
	return 0
}

func (m *AnalyzeInfo) GetTimeConsumed() int64 {
	if m != nil {
		return m.TimeConsumed
	}
	return 0
}

func (m *AnalyzeInfo) GetMemorySize() int64 {
	if m != nil {
		return m.MemorySize
	}
	return 0
}

type Node struct {
	NodeType             Node_NodeType     `protobuf:"varint,1,opt,name=node_type,json=nodeType,proto3,enum=plan.Node_NodeType" json:"node_type,omitempty"`
	NodeId               int32             `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Cost                 *Cost             `protobuf:"bytes,3,opt,name=cost,proto3" json:"cost,omitempty"`
	ProjectList          []*Expr           `protobuf:"bytes,4,rep,name=project_list,json=projectList,proto3" json:"project_list,omitempty"`
	Children             []int32           `protobuf:"varint,5,rep,packed,name=children,proto3" json:"children,omitempty"`
	JoinType             Node_JoinFlag     `protobuf:"varint,6,opt,name=join_type,json=joinType,proto3,enum=plan.Node_JoinFlag" json:"join_type,omitempty"`
	OnList               []*Expr           `protobuf:"bytes,7,rep,name=on_list,json=onList,proto3" json:"on_list,omitempty"`
	FilterList           []*Expr           `protobuf:"bytes,8,rep,name=filter_list,json=filterList,proto3" json:"filter_list,omitempty"`
	GroupBy              []*Expr           `protobuf:"bytes,9,rep,name=group_by,json=groupBy,proto3" json:"group_by,omitempty"`
	GroupingSet          []*Expr           `protobuf:"bytes,10,rep,name=grouping_set,json=groupingSet,proto3" json:"grouping_set,omitempty"`
	AggList              []*Expr           `protobuf:"bytes,11,rep,name=agg_list,json=aggList,proto3" json:"agg_list,omitempty"`
	OrderBy              []*OrderBySpec    `protobuf:"bytes,12,rep,name=order_by,json=orderBy,proto3" json:"order_by,omitempty"`
	UpdateCtxs           []*UpdateCtx      `protobuf:"bytes,13,rep,name=update_ctxs,json=updateCtxs,proto3" json:"update_ctxs,omitempty"`
	WinSpec              *WindowSpec       `protobuf:"bytes,14,opt,name=win_spec,json=winSpec,proto3" json:"win_spec,omitempty"`
	Limit                *Expr             `protobuf:"bytes,15,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset               *Expr             `protobuf:"bytes,16,opt,name=offset,proto3" json:"offset,omitempty"`
	TableDef             *TableDef         `protobuf:"bytes,17,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	TableDefVec          []*TableDef       `protobuf:"bytes,18,rep,name=table_def_vec,json=tableDefVec,proto3" json:"table_def_vec,omitempty"`
	ObjRef               *ObjectRef        `protobuf:"bytes,19,opt,name=obj_ref,json=objRef,proto3" json:"obj_ref,omitempty"`
	RowsetData           *RowsetData       `protobuf:"bytes,20,opt,name=rowset_data,json=rowsetData,proto3" json:"rowset_data,omitempty"`
	ExtraOptions         string            `protobuf:"bytes,21,opt,name=extra_options,json=extraOptions,proto3" json:"extra_options,omitempty"`
	DeleteTablesCtx      []*DeleteTableCtx `protobuf:"bytes,22,rep,name=deleteTablesCtx,proto3" json:"deleteTablesCtx,omitempty"`
	BindingTags          []int32           `protobuf:"varint,23,rep,packed,name=binding_tags,json=bindingTags,proto3" json:"binding_tags,omitempty"`
	AnalyzeInfo          *AnalyzeInfo      `protobuf:"bytes,24,opt,name=analyze_info,json=analyzeInfo,proto3" json:"analyze_info,omitempty"`
	TblFuncExprList      []*Expr           `protobuf:"bytes,25,rep,name=tbl_func_expr_list,json=tblFuncExprList,proto3" json:"tbl_func_expr_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{36}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetNodeType() Node_NodeType {
	if m != nil {
		return m.NodeType
	}
	return Node_UNKNOWN
}

func (m *Node) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *Node) GetCost() *Cost {
	if m != nil {
		return m.Cost
	}
	return nil
}

func (m *Node) GetProjectList() []*Expr {
	if m != nil {
		return m.ProjectList
	}
	return nil
}

func (m *Node) GetChildren() []int32 {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *Node) GetJoinType() Node_JoinFlag {
	if m != nil {
		return m.JoinType
	}
	return Node_INNER
}

func (m *Node) GetOnList() []*Expr {
	if m != nil {
		return m.OnList
	}
	return nil
}

func (m *Node) GetFilterList() []*Expr {
	if m != nil {
		return m.FilterList
	}
	return nil
}

func (m *Node) GetGroupBy() []*Expr {
	if m != nil {
		return m.GroupBy
	}
	return nil
}

func (m *Node) GetGroupingSet() []*Expr {
	if m != nil {
		return m.GroupingSet
	}
	return nil
}

func (m *Node) GetAggList() []*Expr {
	if m != nil {
		return m.AggList
	}
	return nil
}

func (m *Node) GetOrderBy() []*OrderBySpec {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *Node) GetUpdateCtxs() []*UpdateCtx {
	if m != nil {
		return m.UpdateCtxs
	}
	return nil
}

func (m *Node) GetWinSpec() *WindowSpec {
	if m != nil {
		return m.WinSpec
	}
	return nil
}

func (m *Node) GetLimit() *Expr {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *Node) GetOffset() *Expr {
	if m != nil {
		return m.Offset
	}
	return nil
}

func (m *Node) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *Node) GetTableDefVec() []*TableDef {
	if m != nil {
		return m.TableDefVec
	}
	return nil
}

func (m *Node) GetObjRef() *ObjectRef {
	if m != nil {
		return m.ObjRef
	}
	return nil
}

func (m *Node) GetRowsetData() *RowsetData {
	if m != nil {
		return m.RowsetData
	}
	return nil
}

func (m *Node) GetExtraOptions() string {
	if m != nil {
		return m.ExtraOptions
	}
	return ""
}

func (m *Node) GetDeleteTablesCtx() []*DeleteTableCtx {
	if m != nil {
		return m.DeleteTablesCtx
	}
	return nil
}

func (m *Node) GetBindingTags() []int32 {
	if m != nil {
		return m.BindingTags
	}
	return nil
}

func (m *Node) GetAnalyzeInfo() *AnalyzeInfo {
	if m != nil {
		return m.AnalyzeInfo
	}
	return nil
}

func (m *Node) GetTblFuncExprList() []*Expr {
	if m != nil {
		return m.TblFuncExprList
	}
	return nil
}

type DeleteTableCtx struct {
	DbName               string       `protobuf:"bytes,1,opt,name=dbName,proto3" json:"dbName,omitempty"`
	TblName              string       `protobuf:"bytes,2,opt,name=tblName,proto3" json:"tblName,omitempty"`
	UseDeleteKey         string       `protobuf:"bytes,3,opt,name=useDeleteKey,proto3" json:"useDeleteKey,omitempty"`
	CanTruncate          bool         `protobuf:"varint,4,opt,name=canTruncate,proto3" json:"canTruncate,omitempty"`
	ColIndex             int32        `protobuf:"varint,5,opt,name=colIndex,proto3" json:"colIndex,omitempty"`
	IndexInfos           []*IndexInfo `protobuf:"bytes,6,rep,name=index_infos,json=indexInfos,proto3" json:"index_infos,omitempty"`
	IndexAttrs           []string     `protobuf:"bytes,7,rep,name=index_attrs,json=indexAttrs,proto3" json:"index_attrs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *DeleteTableCtx) Reset()         { *m = DeleteTableCtx{} }
func (m *DeleteTableCtx) String() string { return proto.CompactTextString(m) }
func (*DeleteTableCtx) ProtoMessage()    {}
func (*DeleteTableCtx) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{37}
}
func (m *DeleteTableCtx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteTableCtx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteTableCtx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteTableCtx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteTableCtx.Merge(m, src)
}
func (m *DeleteTableCtx) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeleteTableCtx) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteTableCtx.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteTableCtx proto.InternalMessageInfo

func (m *DeleteTableCtx) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *DeleteTableCtx) GetTblName() string {
	if m != nil {
		return m.TblName
	}
	return ""
}

func (m *DeleteTableCtx) GetUseDeleteKey() string {
	if m != nil {
		return m.UseDeleteKey
	}
	return ""
}

func (m *DeleteTableCtx) GetCanTruncate() bool {
	if m != nil {
		return m.CanTruncate
	}
	return false
}

func (m *DeleteTableCtx) GetColIndex() int32 {
	if m != nil {
		return m.ColIndex
	}
	return 0
}

func (m *DeleteTableCtx) GetIndexInfos() []*IndexInfo {
	if m != nil {
		return m.IndexInfos
	}
	return nil
}

func (m *DeleteTableCtx) GetIndexAttrs() []string {
	if m != nil {
		return m.IndexAttrs
	}
	return nil
}

type Query struct {
	StmtType Query_StatementType `protobuf:"varint,1,opt,name=stmt_type,json=stmtType,proto3,enum=plan.Query_StatementType" json:"stmt_type,omitempty"`
	// Each step is simply a root node.  Root node refers to other
	// node as children and the whole step is a DAG.
	Steps []int32 `protobuf:"varint,2,rep,packed,name=steps,proto3" json:"steps,omitempty"`
	// All the nodes.  It is OK to have dangle nodes, we only excute nodes
	// reachable from step roots.
	Nodes []*Node `protobuf:"bytes,3,rep,name=nodes,proto3" json:"nodes,omitempty"`
	// Bound Parameter for the query.
	Params []*Expr `protobuf:"bytes,4,rep,name=params,proto3" json:"params,omitempty"`
	// return head
	Headings []string `protobuf:"bytes,5,rep,name=headings,proto3" json:"headings,omitempty"`
	// load Tag
	LoadTag              bool     `protobuf:"varint,6,opt,name=loadTag,proto3" json:"loadTag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Query) Reset()         { *m = Query{} }
func (m *Query) String() string { return proto.CompactTextString(m) }
func (*Query) ProtoMessage()    {}
func (*Query) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{38}
}
func (m *Query) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Query) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Query.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Query) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Query.Merge(m, src)
}
func (m *Query) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Query) XXX_DiscardUnknown() {
	xxx_messageInfo_Query.DiscardUnknown(m)
}

var xxx_messageInfo_Query proto.InternalMessageInfo

func (m *Query) GetStmtType() Query_StatementType {
	if m != nil {
		return m.StmtType
	}
	return Query_UNKNOWN
}

func (m *Query) GetSteps() []int32 {
	if m != nil {
		return m.Steps
	}
	return nil
}

func (m *Query) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *Query) GetParams() []*Expr {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *Query) GetHeadings() []string {
	if m != nil {
		return m.Headings
	}
	return nil
}

func (m *Query) GetLoadTag() bool {
	if m != nil {
		return m.LoadTag
	}
	return false
}

type TransationControl struct {
	// TransationControl type
	TclType TransationControl_TclType `protobuf:"varint,1,opt,name=tcl_type,json=tclType,proto3,enum=plan.TransationControl_TclType" json:"tcl_type,omitempty"`
	// Types that are valid to be assigned to Action:
	//
	//	*TransationControl_Begin
	//	*TransationControl_Commit
	//	*TransationControl_Rollback
	Action               isTransationControl_Action `protobuf_oneof:"action"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *TransationControl) Reset()         { *m = TransationControl{} }
func (m *TransationControl) String() string { return proto.CompactTextString(m) }
func (*TransationControl) ProtoMessage()    {}
func (*TransationControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{39}
}
func (m *TransationControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransationControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransationControl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransationControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransationControl.Merge(m, src)
}
func (m *TransationControl) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransationControl) XXX_DiscardUnknown() {
	xxx_messageInfo_TransationControl.DiscardUnknown(m)
}

var xxx_messageInfo_TransationControl proto.InternalMessageInfo

type isTransationControl_Action interface {
	isTransationControl_Action()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type TransationControl_Begin struct {
	Begin *TransationBegin `protobuf:"bytes,2,opt,name=begin,proto3,oneof" json:"begin,omitempty"`
}
type TransationControl_Commit struct {
	Commit *TransationCommit `protobuf:"bytes,3,opt,name=commit,proto3,oneof" json:"commit,omitempty"`
}
type TransationControl_Rollback struct {
	Rollback *TransationRollback `protobuf:"bytes,4,opt,name=rollback,proto3,oneof" json:"rollback,omitempty"`
}

func (*TransationControl_Begin) isTransationControl_Action()    {}
func (*TransationControl_Commit) isTransationControl_Action()   {}
func (*TransationControl_Rollback) isTransationControl_Action() {}

func (m *TransationControl) GetAction() isTransationControl_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *TransationControl) GetTclType() TransationControl_TclType {
	if m != nil {
		return m.TclType
	}
	return TransationControl_BEGIN
}

func (m *TransationControl) GetBegin() *TransationBegin {
	if x, ok := m.GetAction().(*TransationControl_Begin); ok {
		return x.Begin
	}
	return nil
}

func (m *TransationControl) GetCommit() *TransationCommit {
	if x, ok := m.GetAction().(*TransationControl_Commit); ok {
		return x.Commit
	}
	return nil
}

func (m *TransationControl) GetRollback() *TransationRollback {
	if x, ok := m.GetAction().(*TransationControl_Rollback); ok {
		return x.Rollback
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TransationControl) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TransationControl_Begin)(nil),
		(*TransationControl_Commit)(nil),
		(*TransationControl_Rollback)(nil),
	}
}

type TransationBegin struct {
	Mode                 TransationBegin_TransationMode `protobuf:"varint,1,opt,name=mode,proto3,enum=plan.TransationBegin_TransationMode" json:"mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *TransationBegin) Reset()         { *m = TransationBegin{} }
func (m *TransationBegin) String() string { return proto.CompactTextString(m) }
func (*TransationBegin) ProtoMessage()    {}
func (*TransationBegin) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{40}
}
func (m *TransationBegin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransationBegin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransationBegin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransationBegin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransationBegin.Merge(m, src)
}
func (m *TransationBegin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransationBegin) XXX_DiscardUnknown() {
	xxx_messageInfo_TransationBegin.DiscardUnknown(m)
}

var xxx_messageInfo_TransationBegin proto.InternalMessageInfo

func (m *TransationBegin) GetMode() TransationBegin_TransationMode {
	if m != nil {
		return m.Mode
	}
	return TransationBegin_NONE
}

type TransationCommit struct {
	CompletionType       TransationCompletionType `protobuf:"varint,1,opt,name=completion_type,json=completionType,proto3,enum=plan.TransationCompletionType" json:"completion_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *TransationCommit) Reset()         { *m = TransationCommit{} }
func (m *TransationCommit) String() string { return proto.CompactTextString(m) }
func (*TransationCommit) ProtoMessage()    {}
func (*TransationCommit) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{41}
}
func (m *TransationCommit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransationCommit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransationCommit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransationCommit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransationCommit.Merge(m, src)
}
func (m *TransationCommit) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransationCommit) XXX_DiscardUnknown() {
	xxx_messageInfo_TransationCommit.DiscardUnknown(m)
}

var xxx_messageInfo_TransationCommit proto.InternalMessageInfo

func (m *TransationCommit) GetCompletionType() TransationCompletionType {
	if m != nil {
		return m.CompletionType
	}
	return TransationCompletionType_CHAIN
}

type TransationRollback struct {
	CompletionType       TransationCompletionType `protobuf:"varint,1,opt,name=completion_type,json=completionType,proto3,enum=plan.TransationCompletionType" json:"completion_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *TransationRollback) Reset()         { *m = TransationRollback{} }
func (m *TransationRollback) String() string { return proto.CompactTextString(m) }
func (*TransationRollback) ProtoMessage()    {}
func (*TransationRollback) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{42}
}
func (m *TransationRollback) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransationRollback) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransationRollback.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransationRollback) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransationRollback.Merge(m, src)
}
func (m *TransationRollback) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransationRollback) XXX_DiscardUnknown() {
	xxx_messageInfo_TransationRollback.DiscardUnknown(m)
}

var xxx_messageInfo_TransationRollback proto.InternalMessageInfo

func (m *TransationRollback) GetCompletionType() TransationCompletionType {
	if m != nil {
		return m.CompletionType
	}
	return TransationCompletionType_CHAIN
}

type Plan struct {
	// Types that are valid to be assigned to Plan:
	//
	//	*Plan_Query
	//	*Plan_Tcl
	//	*Plan_Ddl
	//	*Plan_Dcl
	//	*Plan_Ins
	Plan                 isPlan_Plan `protobuf_oneof:"plan"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Plan) Reset()         { *m = Plan{} }
func (m *Plan) String() string { return proto.CompactTextString(m) }
func (*Plan) ProtoMessage()    {}
func (*Plan) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{43}
}
func (m *Plan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Plan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Plan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Plan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Plan.Merge(m, src)
}
func (m *Plan) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Plan) XXX_DiscardUnknown() {
	xxx_messageInfo_Plan.DiscardUnknown(m)
}

var xxx_messageInfo_Plan proto.InternalMessageInfo

type isPlan_Plan interface {
	isPlan_Plan()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type Plan_Query struct {
	Query *Query `protobuf:"bytes,1,opt,name=query,proto3,oneof" json:"query,omitempty"`
}
type Plan_Tcl struct {
	Tcl *TransationControl `protobuf:"bytes,2,opt,name=tcl,proto3,oneof" json:"tcl,omitempty"`
}
type Plan_Ddl struct {
	Ddl *DataDefinition `protobuf:"bytes,3,opt,name=ddl,proto3,oneof" json:"ddl,omitempty"`
}
type Plan_Dcl struct {
	Dcl *DataControl `protobuf:"bytes,4,opt,name=dcl,proto3,oneof" json:"dcl,omitempty"`
}
type Plan_Ins struct {
	Ins *InsertValues `protobuf:"bytes,5,opt,name=ins,proto3,oneof" json:"ins,omitempty"`
}

func (*Plan_Query) isPlan_Plan() {}
func (*Plan_Tcl) isPlan_Plan()   {}
func (*Plan_Ddl) isPlan_Plan()   {}
func (*Plan_Dcl) isPlan_Plan()   {}
func (*Plan_Ins) isPlan_Plan()   {}

func (m *Plan) GetPlan() isPlan_Plan {
	if m != nil {
		return m.Plan
	}
	return nil
}

func (m *Plan) GetQuery() *Query {
	if x, ok := m.GetPlan().(*Plan_Query); ok {
		return x.Query
	}
	return nil
}

func (m *Plan) GetTcl() *TransationControl {
	if x, ok := m.GetPlan().(*Plan_Tcl); ok {
		return x.Tcl
	}
	return nil
}

func (m *Plan) GetDdl() *DataDefinition {
	if x, ok := m.GetPlan().(*Plan_Ddl); ok {
		return x.Ddl
	}
	return nil
}

func (m *Plan) GetDcl() *DataControl {
	if x, ok := m.GetPlan().(*Plan_Dcl); ok {
		return x.Dcl
	}
	return nil
}

func (m *Plan) GetIns() *InsertValues {
	if x, ok := m.GetPlan().(*Plan_Ins); ok {
		return x.Ins
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Plan) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Plan_Query)(nil),
		(*Plan_Tcl)(nil),
		(*Plan_Ddl)(nil),
		(*Plan_Dcl)(nil),
		(*Plan_Ins)(nil),
	}
}

type InsertValues struct {
	DbName               string       `protobuf:"bytes,1,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	TblName              string       `protobuf:"bytes,2,opt,name=tbl_name,json=tblName,proto3" json:"tbl_name,omitempty"`
	ExplicitCols         []*ColDef    `protobuf:"bytes,3,rep,name=explicit_cols,json=explicitCols,proto3" json:"explicit_cols,omitempty"`
	OtherCols            []*ColDef    `protobuf:"bytes,4,rep,name=other_cols,json=otherCols,proto3" json:"other_cols,omitempty"`
	OrderAttrs           []string     `protobuf:"bytes,5,rep,name=order_attrs,json=orderAttrs,proto3" json:"order_attrs,omitempty"`
	Columns              []*Column    `protobuf:"bytes,6,rep,name=columns,proto3" json:"columns,omitempty"`
	CompositePkey        *ColDef      `protobuf:"bytes,7,opt,name=composite_pkey,json=compositePkey,proto3" json:"composite_pkey,omitempty"`
	IndexInfos           []*IndexInfo `protobuf:"bytes,8,rep,name=index_infos,json=indexInfos,proto3" json:"index_infos,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *InsertValues) Reset()         { *m = InsertValues{} }
func (m *InsertValues) String() string { return proto.CompactTextString(m) }
func (*InsertValues) ProtoMessage()    {}
func (*InsertValues) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{44}
}
func (m *InsertValues) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InsertValues) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InsertValues.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InsertValues) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InsertValues.Merge(m, src)
}
func (m *InsertValues) XXX_Size() int {
	return m.ProtoSize()
}
func (m *InsertValues) XXX_DiscardUnknown() {
	xxx_messageInfo_InsertValues.DiscardUnknown(m)
}

var xxx_messageInfo_InsertValues proto.InternalMessageInfo

func (m *InsertValues) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *InsertValues) GetTblName() string {
	if m != nil {
		return m.TblName
	}
	return ""
}

func (m *InsertValues) GetExplicitCols() []*ColDef {
	if m != nil {
		return m.ExplicitCols
	}
	return nil
}

func (m *InsertValues) GetOtherCols() []*ColDef {
	if m != nil {
		return m.OtherCols
	}
	return nil
}

func (m *InsertValues) GetOrderAttrs() []string {
	if m != nil {
		return m.OrderAttrs
	}
	return nil
}

func (m *InsertValues) GetColumns() []*Column {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *InsertValues) GetCompositePkey() *ColDef {
	if m != nil {
		return m.CompositePkey
	}
	return nil
}

func (m *InsertValues) GetIndexInfos() []*IndexInfo {
	if m != nil {
		return m.IndexInfos
	}
	return nil
}

type Column struct {
	Column               []*Expr  `protobuf:"bytes,1,rep,name=column,proto3" json:"column,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Column) Reset()         { *m = Column{} }
func (m *Column) String() string { return proto.CompactTextString(m) }
func (*Column) ProtoMessage()    {}
func (*Column) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{45}
}
func (m *Column) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Column) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Column.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Column) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Column.Merge(m, src)
}
func (m *Column) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Column) XXX_DiscardUnknown() {
	xxx_messageInfo_Column.DiscardUnknown(m)
}

var xxx_messageInfo_Column proto.InternalMessageInfo

func (m *Column) GetColumn() []*Expr {
	if m != nil {
		return m.Column
	}
	return nil
}

type DataControl struct {
	// DataDefinition type
	DclType DataControl_DclType `protobuf:"varint,1,opt,name=dcl_type,json=dclType,proto3,enum=plan.DataControl_DclType" json:"dcl_type,omitempty"`
	// Types that are valid to be assigned to Control:
	//
	//	*DataControl_SetVariables
	//	*DataControl_Prepare
	//	*DataControl_Execute
	//	*DataControl_Deallocate
	Control              isDataControl_Control `protobuf_oneof:"control"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *DataControl) Reset()         { *m = DataControl{} }
func (m *DataControl) String() string { return proto.CompactTextString(m) }
func (*DataControl) ProtoMessage()    {}
func (*DataControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{46}
}
func (m *DataControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataControl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataControl.Merge(m, src)
}
func (m *DataControl) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DataControl) XXX_DiscardUnknown() {
	xxx_messageInfo_DataControl.DiscardUnknown(m)
}

var xxx_messageInfo_DataControl proto.InternalMessageInfo

type isDataControl_Control interface {
	isDataControl_Control()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type DataControl_SetVariables struct {
	SetVariables *SetVariables `protobuf:"bytes,2,opt,name=set_variables,json=setVariables,proto3,oneof" json:"set_variables,omitempty"`
}
type DataControl_Prepare struct {
	Prepare *Prepare `protobuf:"bytes,3,opt,name=prepare,proto3,oneof" json:"prepare,omitempty"`
}
type DataControl_Execute struct {
	Execute *Execute `protobuf:"bytes,4,opt,name=execute,proto3,oneof" json:"execute,omitempty"`
}
type DataControl_Deallocate struct {
	Deallocate *Deallocate `protobuf:"bytes,5,opt,name=deallocate,proto3,oneof" json:"deallocate,omitempty"`
}

func (*DataControl_SetVariables) isDataControl_Control() {}
func (*DataControl_Prepare) isDataControl_Control()      {}
func (*DataControl_Execute) isDataControl_Control()      {}
func (*DataControl_Deallocate) isDataControl_Control()   {}

func (m *DataControl) GetControl() isDataControl_Control {
	if m != nil {
		return m.Control
	}
	return nil
}

func (m *DataControl) GetDclType() DataControl_DclType {
	if m != nil {
		return m.DclType
	}
	return DataControl_SET_VARIABLES
}

func (m *DataControl) GetSetVariables() *SetVariables {
	if x, ok := m.GetControl().(*DataControl_SetVariables); ok {
		return x.SetVariables
	}
	return nil
}

func (m *DataControl) GetPrepare() *Prepare {
	if x, ok := m.GetControl().(*DataControl_Prepare); ok {
		return x.Prepare
	}
	return nil
}

func (m *DataControl) GetExecute() *Execute {
	if x, ok := m.GetControl().(*DataControl_Execute); ok {
		return x.Execute
	}
	return nil
}

func (m *DataControl) GetDeallocate() *Deallocate {
	if x, ok := m.GetControl().(*DataControl_Deallocate); ok {
		return x.Deallocate
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DataControl) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DataControl_SetVariables)(nil),
		(*DataControl_Prepare)(nil),
		(*DataControl_Execute)(nil),
		(*DataControl_Deallocate)(nil),
	}
}

type DataDefinition struct {
	// DataDefinition type
	DdlType DataDefinition_DdlType `protobuf:"varint,1,opt,name=ddl_type,json=ddlType,proto3,enum=plan.DataDefinition_DdlType" json:"ddl_type,omitempty"`
	// other show statement we will rewrite to a select statement
	// then we will get a Query
	// eg: 'show databases' will rewrite to 'select md.datname as `Database` from mo_database md'
	Query *Query `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// Types that are valid to be assigned to Definition:
	//
	//	*DataDefinition_CreateDatabase
	//	*DataDefinition_AlterDatabase
	//	*DataDefinition_DropDatabase
	//	*DataDefinition_CreateTable
	//	*DataDefinition_AlterTable
	//	*DataDefinition_DropTable
	//	*DataDefinition_CreateIndex
	//	*DataDefinition_AlterIndex
	//	*DataDefinition_DropIndex
	//	*DataDefinition_TruncateTable
	//	*DataDefinition_ShowVariables
	Definition           isDataDefinition_Definition `protobuf_oneof:"definition"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *DataDefinition) Reset()         { *m = DataDefinition{} }
func (m *DataDefinition) String() string { return proto.CompactTextString(m) }
func (*DataDefinition) ProtoMessage()    {}
func (*DataDefinition) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{47}
}
func (m *DataDefinition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataDefinition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataDefinition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataDefinition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataDefinition.Merge(m, src)
}
func (m *DataDefinition) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DataDefinition) XXX_DiscardUnknown() {
	xxx_messageInfo_DataDefinition.DiscardUnknown(m)
}

var xxx_messageInfo_DataDefinition proto.InternalMessageInfo

type isDataDefinition_Definition interface {
	isDataDefinition_Definition()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type DataDefinition_CreateDatabase struct {
	CreateDatabase *CreateDatabase `protobuf:"bytes,3,opt,name=create_database,json=createDatabase,proto3,oneof" json:"create_database,omitempty"`
}
type DataDefinition_AlterDatabase struct {
	AlterDatabase *AlterDatabase `protobuf:"bytes,4,opt,name=alter_database,json=alterDatabase,proto3,oneof" json:"alter_database,omitempty"`
}
type DataDefinition_DropDatabase struct {
	DropDatabase *DropDatabase `protobuf:"bytes,5,opt,name=drop_database,json=dropDatabase,proto3,oneof" json:"drop_database,omitempty"`
}
type DataDefinition_CreateTable struct {
	CreateTable *CreateTable `protobuf:"bytes,6,opt,name=create_table,json=createTable,proto3,oneof" json:"create_table,omitempty"`
}
type DataDefinition_AlterTable struct {
	AlterTable *AlterTable `protobuf:"bytes,7,opt,name=alter_table,json=alterTable,proto3,oneof" json:"alter_table,omitempty"`
}
type DataDefinition_DropTable struct {
	DropTable *DropTable `protobuf:"bytes,8,opt,name=drop_table,json=dropTable,proto3,oneof" json:"drop_table,omitempty"`
}
type DataDefinition_CreateIndex struct {
	CreateIndex *CreateIndex `protobuf:"bytes,9,opt,name=create_index,json=createIndex,proto3,oneof" json:"create_index,omitempty"`
}
type DataDefinition_AlterIndex struct {
	AlterIndex *AlterIndex `protobuf:"bytes,10,opt,name=alter_index,json=alterIndex,proto3,oneof" json:"alter_index,omitempty"`
}
type DataDefinition_DropIndex struct {
	DropIndex *DropIndex `protobuf:"bytes,11,opt,name=drop_index,json=dropIndex,proto3,oneof" json:"drop_index,omitempty"`
}
type DataDefinition_TruncateTable struct {
	TruncateTable *TruncateTable `protobuf:"bytes,12,opt,name=truncate_table,json=truncateTable,proto3,oneof" json:"truncate_table,omitempty"`
}
type DataDefinition_ShowVariables struct {
	ShowVariables *ShowVariables `protobuf:"bytes,13,opt,name=show_variables,json=showVariables,proto3,oneof" json:"show_variables,omitempty"`
}

func (*DataDefinition_CreateDatabase) isDataDefinition_Definition() {}
func (*DataDefinition_AlterDatabase) isDataDefinition_Definition()  {}
func (*DataDefinition_DropDatabase) isDataDefinition_Definition()   {}
func (*DataDefinition_CreateTable) isDataDefinition_Definition()    {}
func (*DataDefinition_AlterTable) isDataDefinition_Definition()     {}
func (*DataDefinition_DropTable) isDataDefinition_Definition()      {}
func (*DataDefinition_CreateIndex) isDataDefinition_Definition()    {}
func (*DataDefinition_AlterIndex) isDataDefinition_Definition()     {}
func (*DataDefinition_DropIndex) isDataDefinition_Definition()      {}
func (*DataDefinition_TruncateTable) isDataDefinition_Definition()  {}
func (*DataDefinition_ShowVariables) isDataDefinition_Definition()  {}

func (m *DataDefinition) GetDefinition() isDataDefinition_Definition {
	if m != nil {
		return m.Definition
	}
	return nil
}

func (m *DataDefinition) GetDdlType() DataDefinition_DdlType {
	if m != nil {
		return m.DdlType
	}
	return DataDefinition_CREATE_DATABASE
}

func (m *DataDefinition) GetQuery() *Query {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *DataDefinition) GetCreateDatabase() *CreateDatabase {
	if x, ok := m.GetDefinition().(*DataDefinition_CreateDatabase); ok {
		return x.CreateDatabase
	}
	return nil
}

func (m *DataDefinition) GetAlterDatabase() *AlterDatabase {
	if x, ok := m.GetDefinition().(*DataDefinition_AlterDatabase); ok {
		return x.AlterDatabase
	}
	return nil
}

func (m *DataDefinition) GetDropDatabase() *DropDatabase {
	if x, ok := m.GetDefinition().(*DataDefinition_DropDatabase); ok {
		return x.DropDatabase
	}
	return nil
}

func (m *DataDefinition) GetCreateTable() *CreateTable {
	if x, ok := m.GetDefinition().(*DataDefinition_CreateTable); ok {
		return x.CreateTable
	}
	return nil
}

func (m *DataDefinition) GetAlterTable() *AlterTable {
	if x, ok := m.GetDefinition().(*DataDefinition_AlterTable); ok {
		return x.AlterTable
	}
	return nil
}

func (m *DataDefinition) GetDropTable() *DropTable {
	if x, ok := m.GetDefinition().(*DataDefinition_DropTable); ok {
		return x.DropTable
	}
	return nil
}

func (m *DataDefinition) GetCreateIndex() *CreateIndex {
	if x, ok := m.GetDefinition().(*DataDefinition_CreateIndex); ok {
		return x.CreateIndex
	}
	return nil
}

func (m *DataDefinition) GetAlterIndex() *AlterIndex {
	if x, ok := m.GetDefinition().(*DataDefinition_AlterIndex); ok {
		return x.AlterIndex
	}
	return nil
}

func (m *DataDefinition) GetDropIndex() *DropIndex {
	if x, ok := m.GetDefinition().(*DataDefinition_DropIndex); ok {
		return x.DropIndex
	}
	return nil
}

func (m *DataDefinition) GetTruncateTable() *TruncateTable {
	if x, ok := m.GetDefinition().(*DataDefinition_TruncateTable); ok {
		return x.TruncateTable
	}
	return nil
}

func (m *DataDefinition) GetShowVariables() *ShowVariables {
	if x, ok := m.GetDefinition().(*DataDefinition_ShowVariables); ok {
		return x.ShowVariables
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DataDefinition) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DataDefinition_CreateDatabase)(nil),
		(*DataDefinition_AlterDatabase)(nil),
		(*DataDefinition_DropDatabase)(nil),
		(*DataDefinition_CreateTable)(nil),
		(*DataDefinition_AlterTable)(nil),
		(*DataDefinition_DropTable)(nil),
		(*DataDefinition_CreateIndex)(nil),
		(*DataDefinition_AlterIndex)(nil),
		(*DataDefinition_DropIndex)(nil),
		(*DataDefinition_TruncateTable)(nil),
		(*DataDefinition_ShowVariables)(nil),
	}
}

type CreateDatabase struct {
	IfNotExists          bool     `protobuf:"varint,1,opt,name=if_not_exists,json=ifNotExists,proto3" json:"if_not_exists,omitempty"`
	Database             string   `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateDatabase) Reset()         { *m = CreateDatabase{} }
func (m *CreateDatabase) String() string { return proto.CompactTextString(m) }
func (*CreateDatabase) ProtoMessage()    {}
func (*CreateDatabase) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{48}
}
func (m *CreateDatabase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateDatabase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateDatabase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateDatabase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateDatabase.Merge(m, src)
}
func (m *CreateDatabase) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CreateDatabase) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateDatabase.DiscardUnknown(m)
}

var xxx_messageInfo_CreateDatabase proto.InternalMessageInfo

func (m *CreateDatabase) GetIfNotExists() bool {
	if m != nil {
		return m.IfNotExists
	}
	return false
}

func (m *CreateDatabase) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

type AlterDatabase struct {
	IfExists             bool     `protobuf:"varint,1,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	Database             string   `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterDatabase) Reset()         { *m = AlterDatabase{} }
func (m *AlterDatabase) String() string { return proto.CompactTextString(m) }
func (*AlterDatabase) ProtoMessage()    {}
func (*AlterDatabase) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{49}
}
func (m *AlterDatabase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterDatabase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterDatabase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterDatabase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterDatabase.Merge(m, src)
}
func (m *AlterDatabase) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterDatabase) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterDatabase.DiscardUnknown(m)
}

var xxx_messageInfo_AlterDatabase proto.InternalMessageInfo

func (m *AlterDatabase) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

func (m *AlterDatabase) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

type DropDatabase struct {
	IfExists             bool     `protobuf:"varint,1,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	Database             string   `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DropDatabase) Reset()         { *m = DropDatabase{} }
func (m *DropDatabase) String() string { return proto.CompactTextString(m) }
func (*DropDatabase) ProtoMessage()    {}
func (*DropDatabase) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{50}
}
func (m *DropDatabase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropDatabase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropDatabase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropDatabase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropDatabase.Merge(m, src)
}
func (m *DropDatabase) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DropDatabase) XXX_DiscardUnknown() {
	xxx_messageInfo_DropDatabase.DiscardUnknown(m)
}

var xxx_messageInfo_DropDatabase proto.InternalMessageInfo

func (m *DropDatabase) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

func (m *DropDatabase) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

type CreateTable struct {
	IfNotExists          bool        `protobuf:"varint,1,opt,name=if_not_exists,json=ifNotExists,proto3" json:"if_not_exists,omitempty"`
	Temporary            bool        `protobuf:"varint,2,opt,name=temporary,proto3" json:"temporary,omitempty"`
	Database             string      `protobuf:"bytes,3,opt,name=database,proto3" json:"database,omitempty"`
	TableDef             *TableDef   `protobuf:"bytes,4,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	IndexTables          []*TableDef `protobuf:"bytes,5,rep,name=index_tables,json=indexTables,proto3" json:"index_tables,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *CreateTable) Reset()         { *m = CreateTable{} }
func (m *CreateTable) String() string { return proto.CompactTextString(m) }
func (*CreateTable) ProtoMessage()    {}
func (*CreateTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{51}
}
func (m *CreateTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateTable.Merge(m, src)
}
func (m *CreateTable) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CreateTable) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateTable.DiscardUnknown(m)
}

var xxx_messageInfo_CreateTable proto.InternalMessageInfo

func (m *CreateTable) GetIfNotExists() bool {
	if m != nil {
		return m.IfNotExists
	}
	return false
}

func (m *CreateTable) GetTemporary() bool {
	if m != nil {
		return m.Temporary
	}
	return false
}

func (m *CreateTable) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *CreateTable) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *CreateTable) GetIndexTables() []*TableDef {
	if m != nil {
		return m.IndexTables
	}
	return nil
}

type AlterTable struct {
	Table                string    `protobuf:"bytes,1,opt,name=table,proto3" json:"table,omitempty"`
	TableDef             *TableDef `protobuf:"bytes,2,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *AlterTable) Reset()         { *m = AlterTable{} }
func (m *AlterTable) String() string { return proto.CompactTextString(m) }
func (*AlterTable) ProtoMessage()    {}
func (*AlterTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{52}
}
func (m *AlterTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTable.Merge(m, src)
}
func (m *AlterTable) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTable) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTable.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTable proto.InternalMessageInfo

func (m *AlterTable) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *AlterTable) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

type DropTable struct {
	IfExists             bool     `protobuf:"varint,1,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	Database             string   `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	Table                string   `protobuf:"bytes,3,opt,name=table,proto3" json:"table,omitempty"`
	IndexTableNames      []string `protobuf:"bytes,4,rep,name=index_table_names,json=indexTableNames,proto3" json:"index_table_names,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DropTable) Reset()         { *m = DropTable{} }
func (m *DropTable) String() string { return proto.CompactTextString(m) }
func (*DropTable) ProtoMessage()    {}
func (*DropTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{53}
}
func (m *DropTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropTable.Merge(m, src)
}
func (m *DropTable) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DropTable) XXX_DiscardUnknown() {
	xxx_messageInfo_DropTable.DiscardUnknown(m)
}

var xxx_messageInfo_DropTable proto.InternalMessageInfo

func (m *DropTable) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

func (m *DropTable) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *DropTable) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *DropTable) GetIndexTableNames() []string {
	if m != nil {
		return m.IndexTableNames
	}
	return nil
}

type CreateIndex struct {
	IfNotExists          bool     `protobuf:"varint,1,opt,name=if_not_exists,json=ifNotExists,proto3" json:"if_not_exists,omitempty"`
	Index                string   `protobuf:"bytes,2,opt,name=index,proto3" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateIndex) Reset()         { *m = CreateIndex{} }
func (m *CreateIndex) String() string { return proto.CompactTextString(m) }
func (*CreateIndex) ProtoMessage()    {}
func (*CreateIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{54}
}
func (m *CreateIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateIndex.Merge(m, src)
}
func (m *CreateIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CreateIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateIndex.DiscardUnknown(m)
}

var xxx_messageInfo_CreateIndex proto.InternalMessageInfo

func (m *CreateIndex) GetIfNotExists() bool {
	if m != nil {
		return m.IfNotExists
	}
	return false
}

func (m *CreateIndex) GetIndex() string {
	if m != nil {
		return m.Index
	}
	return ""
}

type AlterIndex struct {
	Index                string   `protobuf:"bytes,1,opt,name=index,proto3" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterIndex) Reset()         { *m = AlterIndex{} }
func (m *AlterIndex) String() string { return proto.CompactTextString(m) }
func (*AlterIndex) ProtoMessage()    {}
func (*AlterIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{55}
}
func (m *AlterIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterIndex.Merge(m, src)
}
func (m *AlterIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterIndex.DiscardUnknown(m)
}

var xxx_messageInfo_AlterIndex proto.InternalMessageInfo

func (m *AlterIndex) GetIndex() string {
	if m != nil {
		return m.Index
	}
	return ""
}

type DropIndex struct {
	IfExists             bool     `protobuf:"varint,1,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	Index                string   `protobuf:"bytes,2,opt,name=index,proto3" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DropIndex) Reset()         { *m = DropIndex{} }
func (m *DropIndex) String() string { return proto.CompactTextString(m) }
func (*DropIndex) ProtoMessage()    {}
func (*DropIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{56}
}
func (m *DropIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropIndex.Merge(m, src)
}
func (m *DropIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DropIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_DropIndex.DiscardUnknown(m)
}

var xxx_messageInfo_DropIndex proto.InternalMessageInfo

func (m *DropIndex) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

func (m *DropIndex) GetIndex() string {
	if m != nil {
		return m.Index
	}
	return ""
}

type TruncateTable struct {
	Database             string   `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	Table                string   `protobuf:"bytes,2,opt,name=table,proto3" json:"table,omitempty"`
	IndexTableNames      []string `protobuf:"bytes,3,rep,name=index_table_names,json=indexTableNames,proto3" json:"index_table_names,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TruncateTable) Reset()         { *m = TruncateTable{} }
func (m *TruncateTable) String() string { return proto.CompactTextString(m) }
func (*TruncateTable) ProtoMessage()    {}
func (*TruncateTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{57}
}
func (m *TruncateTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TruncateTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TruncateTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TruncateTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TruncateTable.Merge(m, src)
}
func (m *TruncateTable) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TruncateTable) XXX_DiscardUnknown() {
	xxx_messageInfo_TruncateTable.DiscardUnknown(m)
}

var xxx_messageInfo_TruncateTable proto.InternalMessageInfo

func (m *TruncateTable) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *TruncateTable) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *TruncateTable) GetIndexTableNames() []string {
	if m != nil {
		return m.IndexTableNames
	}
	return nil
}

type ShowVariables struct {
	Global               bool     `protobuf:"varint,1,opt,name=global,proto3" json:"global,omitempty"`
	Where                []*Expr  `protobuf:"bytes,2,rep,name=where,proto3" json:"where,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShowVariables) Reset()         { *m = ShowVariables{} }
func (m *ShowVariables) String() string { return proto.CompactTextString(m) }
func (*ShowVariables) ProtoMessage()    {}
func (*ShowVariables) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{58}
}
func (m *ShowVariables) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowVariables) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowVariables.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowVariables) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowVariables.Merge(m, src)
}
func (m *ShowVariables) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ShowVariables) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowVariables.DiscardUnknown(m)
}

var xxx_messageInfo_ShowVariables proto.InternalMessageInfo

func (m *ShowVariables) GetGlobal() bool {
	if m != nil {
		return m.Global
	}
	return false
}

func (m *ShowVariables) GetWhere() []*Expr {
	if m != nil {
		return m.Where
	}
	return nil
}

type SetVariables struct {
	Items                []*SetVariablesItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *SetVariables) Reset()         { *m = SetVariables{} }
func (m *SetVariables) String() string { return proto.CompactTextString(m) }
func (*SetVariables) ProtoMessage()    {}
func (*SetVariables) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{59}
}
func (m *SetVariables) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetVariables) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetVariables.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetVariables) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetVariables.Merge(m, src)
}
func (m *SetVariables) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SetVariables) XXX_DiscardUnknown() {
	xxx_messageInfo_SetVariables.DiscardUnknown(m)
}

var xxx_messageInfo_SetVariables proto.InternalMessageInfo

func (m *SetVariables) GetItems() []*SetVariablesItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type SetVariablesItem struct {
	System               bool     `protobuf:"varint,1,opt,name=system,proto3" json:"system,omitempty"`
	Global               bool     `protobuf:"varint,2,opt,name=global,proto3" json:"global,omitempty"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Value                *Expr    `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`
	Reserved             *Expr    `protobuf:"bytes,5,opt,name=reserved,proto3" json:"reserved,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetVariablesItem) Reset()         { *m = SetVariablesItem{} }
func (m *SetVariablesItem) String() string { return proto.CompactTextString(m) }
func (*SetVariablesItem) ProtoMessage()    {}
func (*SetVariablesItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{60}
}
func (m *SetVariablesItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetVariablesItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetVariablesItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetVariablesItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetVariablesItem.Merge(m, src)
}
func (m *SetVariablesItem) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SetVariablesItem) XXX_DiscardUnknown() {
	xxx_messageInfo_SetVariablesItem.DiscardUnknown(m)
}

var xxx_messageInfo_SetVariablesItem proto.InternalMessageInfo

func (m *SetVariablesItem) GetSystem() bool {
	if m != nil {
		return m.System
	}
	return false
}

func (m *SetVariablesItem) GetGlobal() bool {
	if m != nil {
		return m.Global
	}
	return false
}

func (m *SetVariablesItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SetVariablesItem) GetValue() *Expr {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *SetVariablesItem) GetReserved() *Expr {
	if m != nil {
		return m.Reserved
	}
	return nil
}

type Prepare struct {
	Name                 string       `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Schemas              []*ObjectRef `protobuf:"bytes,2,rep,name=schemas,proto3" json:"schemas,omitempty"`
	Plan                 *Plan        `protobuf:"bytes,3,opt,name=plan,proto3" json:"plan,omitempty"`
	ParamTypes           []int32      `protobuf:"varint,4,rep,packed,name=param_types,json=paramTypes,proto3" json:"param_types,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Prepare) Reset()         { *m = Prepare{} }
func (m *Prepare) String() string { return proto.CompactTextString(m) }
func (*Prepare) ProtoMessage()    {}
func (*Prepare) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{61}
}
func (m *Prepare) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Prepare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Prepare.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Prepare) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Prepare.Merge(m, src)
}
func (m *Prepare) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Prepare) XXX_DiscardUnknown() {
	xxx_messageInfo_Prepare.DiscardUnknown(m)
}

var xxx_messageInfo_Prepare proto.InternalMessageInfo

func (m *Prepare) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Prepare) GetSchemas() []*ObjectRef {
	if m != nil {
		return m.Schemas
	}
	return nil
}

func (m *Prepare) GetPlan() *Plan {
	if m != nil {
		return m.Plan
	}
	return nil
}

func (m *Prepare) GetParamTypes() []int32 {
	if m != nil {
		return m.ParamTypes
	}
	return nil
}

type Execute struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Args                 []*Expr  `protobuf:"bytes,2,rep,name=args,proto3" json:"args,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Execute) Reset()         { *m = Execute{} }
func (m *Execute) String() string { return proto.CompactTextString(m) }
func (*Execute) ProtoMessage()    {}
func (*Execute) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{62}
}
func (m *Execute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Execute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Execute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Execute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Execute.Merge(m, src)
}
func (m *Execute) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Execute) XXX_DiscardUnknown() {
	xxx_messageInfo_Execute.DiscardUnknown(m)
}

var xxx_messageInfo_Execute proto.InternalMessageInfo

func (m *Execute) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Execute) GetArgs() []*Expr {
	if m != nil {
		return m.Args
	}
	return nil
}

type Deallocate struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Deallocate) Reset()         { *m = Deallocate{} }
func (m *Deallocate) String() string { return proto.CompactTextString(m) }
func (*Deallocate) ProtoMessage()    {}
func (*Deallocate) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{63}
}
func (m *Deallocate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deallocate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deallocate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deallocate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deallocate.Merge(m, src)
}
func (m *Deallocate) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Deallocate) XXX_DiscardUnknown() {
	xxx_messageInfo_Deallocate.DiscardUnknown(m)
}

var xxx_messageInfo_Deallocate proto.InternalMessageInfo

func (m *Deallocate) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func init() {
	proto.RegisterEnum("plan.CompressType", CompressType_name, CompressType_value)
	proto.RegisterEnum("plan.PartitionType", PartitionType_name, PartitionType_value)
	proto.RegisterEnum("plan.TransationCompletionType", TransationCompletionType_name, TransationCompletionType_value)
	proto.RegisterEnum("plan.SubqueryRef_Type", SubqueryRef_Type_name, SubqueryRef_Type_value)
	proto.RegisterEnum("plan.Function_FuncFlag", Function_FuncFlag_name, Function_FuncFlag_value)
	proto.RegisterEnum("plan.OrderBySpec_OrderByFlag", OrderBySpec_OrderByFlag_name, OrderBySpec_OrderByFlag_value)
	proto.RegisterEnum("plan.Node_NodeType", Node_NodeType_name, Node_NodeType_value)
	proto.RegisterEnum("plan.Node_JoinFlag", Node_JoinFlag_name, Node_JoinFlag_value)
	proto.RegisterEnum("plan.Node_AggMode", Node_AggMode_name, Node_AggMode_value)
	proto.RegisterEnum("plan.Query_StatementType", Query_StatementType_name, Query_StatementType_value)
	proto.RegisterEnum("plan.TransationControl_TclType", TransationControl_TclType_name, TransationControl_TclType_value)
	proto.RegisterEnum("plan.TransationBegin_TransationMode", TransationBegin_TransationMode_name, TransationBegin_TransationMode_value)
	proto.RegisterEnum("plan.DataControl_DclType", DataControl_DclType_name, DataControl_DclType_value)
	proto.RegisterEnum("plan.DataDefinition_DdlType", DataDefinition_DdlType_name, DataDefinition_DdlType_value)
	proto.RegisterType((*Type)(nil), "plan.Type")
	proto.RegisterType((*Const)(nil), "plan.Const")
	proto.RegisterType((*ParamRef)(nil), "plan.ParamRef")
	proto.RegisterType((*VarRef)(nil), "plan.VarRef")
	proto.RegisterType((*ColRef)(nil), "plan.ColRef")
	proto.RegisterType((*CorrColRef)(nil), "plan.CorrColRef")
	proto.RegisterType((*ExprList)(nil), "plan.ExprList")
	proto.RegisterType((*MaxValue)(nil), "plan.MaxValue")
	proto.RegisterType((*TargetType)(nil), "plan.TargetType")
	proto.RegisterType((*SubqueryRef)(nil), "plan.SubqueryRef")
	proto.RegisterType((*ObjectRef)(nil), "plan.ObjectRef")
	proto.RegisterType((*Function)(nil), "plan.Function")
	proto.RegisterType((*Expr)(nil), "plan.Expr")
	proto.RegisterType((*Decimal64)(nil), "plan.decimal64")
	proto.RegisterType((*Decimal128)(nil), "plan.decimal128")
	proto.RegisterType((*ColDef)(nil), "plan.ColDef")
	proto.RegisterType((*Default)(nil), "plan.Default")
	proto.RegisterType((*OnUpdate)(nil), "plan.OnUpdate")
	proto.RegisterType((*PrimaryKeyDef)(nil), "plan.PrimaryKeyDef")
	proto.RegisterType((*Property)(nil), "plan.Property")
	proto.RegisterType((*PropertiesDef)(nil), "plan.PropertiesDef")
	proto.RegisterType((*PartitionInfo)(nil), "plan.PartitionInfo")
	proto.RegisterType((*PartitionItem)(nil), "plan.PartitionItem")
	proto.RegisterType((*ViewDef)(nil), "plan.ViewDef")
	proto.RegisterType((*IndexDef)(nil), "plan.IndexDef")
	proto.RegisterType((*Field)(nil), "plan.Field")
	proto.RegisterType((*IndexInfo)(nil), "plan.IndexInfo")
	proto.RegisterType((*TableDef)(nil), "plan.TableDef")
	proto.RegisterMapType((map[string]int32)(nil), "plan.TableDef.Name2colIndexEntry")
	proto.RegisterType((*TableDef_DefType)(nil), "plan.TableDef.DefType")
	proto.RegisterType((*TableFunction)(nil), "plan.TableFunction")
	proto.RegisterType((*Cost)(nil), "plan.Cost")
	proto.RegisterType((*ColData)(nil), "plan.ColData")
	proto.RegisterType((*RowsetData)(nil), "plan.RowsetData")
	proto.RegisterType((*OrderBySpec)(nil), "plan.OrderBySpec")
	proto.RegisterType((*WindowSpec)(nil), "plan.WindowSpec")
	proto.RegisterType((*UpdateCtx)(nil), "plan.UpdateCtx")
	proto.RegisterType((*AnalyzeInfo)(nil), "plan.AnalyzeInfo")
	proto.RegisterType((*Node)(nil), "plan.Node")
	proto.RegisterType((*DeleteTableCtx)(nil), "plan.DeleteTableCtx")
	proto.RegisterType((*Query)(nil), "plan.Query")
	proto.RegisterType((*TransationControl)(nil), "plan.TransationControl")
	proto.RegisterType((*TransationBegin)(nil), "plan.TransationBegin")
	proto.RegisterType((*TransationCommit)(nil), "plan.TransationCommit")
	proto.RegisterType((*TransationRollback)(nil), "plan.TransationRollback")
	proto.RegisterType((*Plan)(nil), "plan.Plan")
	proto.RegisterType((*InsertValues)(nil), "plan.InsertValues")
	proto.RegisterType((*Column)(nil), "plan.column")
	proto.RegisterType((*DataControl)(nil), "plan.DataControl")
	proto.RegisterType((*DataDefinition)(nil), "plan.DataDefinition")
	proto.RegisterType((*CreateDatabase)(nil), "plan.CreateDatabase")
	proto.RegisterType((*AlterDatabase)(nil), "plan.AlterDatabase")
	proto.RegisterType((*DropDatabase)(nil), "plan.DropDatabase")
	proto.RegisterType((*CreateTable)(nil), "plan.CreateTable")
	proto.RegisterType((*AlterTable)(nil), "plan.AlterTable")
	proto.RegisterType((*DropTable)(nil), "plan.DropTable")
	proto.RegisterType((*CreateIndex)(nil), "plan.CreateIndex")
	proto.RegisterType((*AlterIndex)(nil), "plan.AlterIndex")
	proto.RegisterType((*DropIndex)(nil), "plan.DropIndex")
	proto.RegisterType((*TruncateTable)(nil), "plan.TruncateTable")
	proto.RegisterType((*ShowVariables)(nil), "plan.ShowVariables")
	proto.RegisterType((*SetVariables)(nil), "plan.SetVariables")
	proto.RegisterType((*SetVariablesItem)(nil), "plan.SetVariablesItem")
	proto.RegisterType((*Prepare)(nil), "plan.Prepare")
	proto.RegisterType((*Execute)(nil), "plan.Execute")
	proto.RegisterType((*Deallocate)(nil), "plan.Deallocate")
}

func init() { proto.RegisterFile("plan.proto", fileDescriptor_2d655ab2f7683c23) }

var fileDescriptor_2d655ab2f7683c23 = []byte{
	// 5409 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x7b, 0xcd, 0x6f, 0x1b, 0x49,
	0x76, 0xb8, 0x9a, 0x9f, 0xcd, 0x47, 0x52, 0x6a, 0x97, 0xbf, 0x68, 0xaf, 0xd7, 0x23, 0xb7, 0x3f,
	0x46, 0x6b, 0xef, 0x78, 0xc6, 0xb2, 0xd7, 0xeb, 0x59, 0xcc, 0x6f, 0x77, 0x28, 0xaa, 0x2d, 0x71,
	0x4c, 0x91, 0xda, 0x22, 0x25, 0xcf, 0xfc, 0x16, 0x01, 0xd1, 0x64, 0x37, 0xa9, 0xb6, 0x9b, 0xdd,
	0x9c, 0xee, 0xa6, 0x25, 0x0d, 0x10, 0x60, 0x0e, 0x41, 0x80, 0x20, 0x01, 0xf2, 0x27, 0x64, 0x91,
	0x63, 0x90, 0x4b, 0x90, 0x63, 0x8e, 0x09, 0x90, 0x00, 0xb9, 0x04, 0xd9, 0x53, 0x90, 0x4b, 0x30,
	0x39, 0x05, 0xc9, 0x65, 0x91, 0x43, 0x2e, 0x7b, 0x08, 0xde, 0xab, 0xea, 0x66, 0x53, 0x94, 0xc7,
	0x83, 0x41, 0x2e, 0x42, 0xbd, 0xcf, 0x7a, 0xf5, 0xaa, 0xea, 0x7d, 0x14, 0x5b, 0x00, 0x53, 0xd7,
	0xf4, 0x1e, 0x4e, 0x03, 0x3f, 0xf2, 0x59, 0x0e, 0xc7, 0xd7, 0x3f, 0x18, 0x3b, 0xd1, 0xd1, 0x6c,
	0xf0, 0x70, 0xe8, 0x4f, 0x3e, 0x1c, 0xfb, 0x63, 0xff, 0x43, 0x22, 0x0e, 0x66, 0x23, 0x82, 0x08,
	0xa0, 0x91, 0x10, 0xd2, 0xff, 0x56, 0x81, 0x5c, 0xef, 0x74, 0x6a, 0xb3, 0x55, 0xc8, 0x38, 0x56,
	0x4d, 0x59, 0x57, 0x36, 0xf2, 0x3c, 0xe3, 0x58, 0xec, 0x3a, 0xa8, 0xde, 0xcc, 0x75, 0xcd, 0x81,
	0x6b, 0xd7, 0x32, 0xeb, 0xca, 0x86, 0xca, 0x13, 0x98, 0xfd, 0x00, 0x4a, 0xe6, 0x2c, 0xf2, 0xfb,
	0x8e, 0x37, 0x0c, 0x6a, 0x59, 0x41, 0x44, 0x44, 0xd3, 0x1b, 0x06, 0xec, 0x12, 0xe4, 0x8f, 0x1d,
	0x2b, 0x3a, 0xaa, 0xe5, 0x48, 0x97, 0x00, 0xd8, 0x0d, 0x28, 0x4d, 0x03, 0x7b, 0xe8, 0x84, 0x8e,
	0xef, 0xd5, 0xf2, 0x44, 0x99, 0x23, 0x18, 0x83, 0x5c, 0xe8, 0x7c, 0x65, 0xd7, 0x0a, 0x44, 0xa0,
	0x31, 0xea, 0x09, 0x87, 0xa6, 0x6b, 0xd7, 0x8a, 0x42, 0x0f, 0x01, 0x88, 0x8d, 0xc8, 0x26, 0x75,
	0x5d, 0xd9, 0x28, 0x71, 0x01, 0xe8, 0x7f, 0x9d, 0x87, 0x7c, 0xc3, 0xf7, 0xc2, 0x88, 0x5d, 0x81,
	0x82, 0x13, 0xa2, 0xa1, 0xb4, 0x14, 0x95, 0x4b, 0x88, 0x5d, 0x81, 0xbc, 0xf3, 0xec, 0x8d, 0xe9,
	0xd2, 0x5a, 0xf2, 0xbb, 0x2b, 0x5c, 0x80, 0xac, 0x06, 0x05, 0xe7, 0xd1, 0x53, 0x24, 0x64, 0x25,
	0x41, 0xc2, 0x44, 0x79, 0xbc, 0x89, 0x94, 0x5c, 0x42, 0x21, 0x98, 0x28, 0x4f, 0x9f, 0x20, 0x05,
	0x17, 0x92, 0x25, 0x0a, 0xc1, 0x38, 0xcb, 0x8c, 0x66, 0xc1, 0x85, 0x54, 0x71, 0x96, 0x59, 0x3c,
	0xcb, 0x4c, 0xcc, 0x52, 0x94, 0x04, 0x09, 0x13, 0x45, 0xcc, 0xa2, 0x26, 0x94, 0x64, 0x96, 0x99,
	0x98, 0xa5, 0xb4, 0xae, 0x6c, 0xe4, 0x88, 0x22, 0x66, 0xb9, 0x04, 0x39, 0x0b, 0xf1, 0xb0, 0xae,
	0x6c, 0x28, 0xbb, 0x2b, 0x9c, 0x20, 0xc4, 0x86, 0x88, 0x2d, 0xa3, 0x63, 0x10, 0x1b, 0x4a, 0xec,
	0x00, 0xb1, 0x15, 0xf4, 0x06, 0x62, 0x07, 0x12, 0x3b, 0x42, 0x6c, 0x75, 0x5d, 0xd9, 0xc8, 0x20,
	0x16, 0x21, 0x76, 0x1d, 0x8a, 0x96, 0x19, 0xd9, 0x48, 0x58, 0x95, 0x4b, 0x8e, 0x11, 0x48, 0x8b,
	0x9c, 0x09, 0xd1, 0xd6, 0xe4, 0xa2, 0x63, 0x04, 0xd3, 0xa1, 0x8c, 0x6c, 0x31, 0x5d, 0x93, 0xf4,
	0x34, 0x92, 0xfd, 0x04, 0x2a, 0x96, 0x3d, 0x74, 0x26, 0xa6, 0x2b, 0xd6, 0x74, 0x61, 0x5d, 0xd9,
	0x28, 0x6f, 0xae, 0x3d, 0xa4, 0xf3, 0x9b, 0x50, 0x76, 0x57, 0xf8, 0x02, 0x1b, 0x7b, 0x06, 0x55,
	0x09, 0x3f, 0xda, 0x24, 0xc7, 0x32, 0x92, 0xd3, 0x16, 0xe4, 0x1e, 0x6d, 0x3e, 0xdb, 0x5d, 0xe1,
	0x8b, 0x8c, 0xec, 0x0e, 0x54, 0x70, 0xee, 0x30, 0x32, 0x27, 0x53, 0x14, 0xbc, 0x28, 0xad, 0x5a,
	0xc0, 0xe2, 0xb2, 0x5e, 0x85, 0xbe, 0x87, 0x0c, 0x97, 0xa4, 0xdf, 0x62, 0x04, 0x5b, 0x07, 0xb0,
	0xec, 0x91, 0x39, 0x73, 0x23, 0x24, 0x5f, 0x96, 0x0e, 0x4c, 0xe1, 0xd8, 0x4d, 0x28, 0xcd, 0xa6,
	0xb8, 0xca, 0x43, 0xd3, 0xad, 0x5d, 0x91, 0x0c, 0x73, 0x14, 0x1e, 0x56, 0x27, 0xdc, 0x72, 0xbc,
	0xda, 0x55, 0x3a, 0x8b, 0x02, 0xd8, 0x2a, 0x42, 0xfe, 0x8d, 0xe9, 0xce, 0x6c, 0xfd, 0x06, 0xa8,
	0xfb, 0x66, 0x60, 0x4e, 0xb8, 0x3d, 0x62, 0x1a, 0x64, 0xa7, 0x7e, 0x28, 0xef, 0x1f, 0x0e, 0xf5,
	0x16, 0x14, 0x0e, 0xcd, 0x00, 0x69, 0x0c, 0x72, 0x9e, 0x39, 0xb1, 0x89, 0x58, 0xe2, 0x34, 0xc6,
	0x73, 0x1e, 0x9e, 0x86, 0x91, 0x3d, 0x91, 0x97, 0x53, 0x42, 0x88, 0x1f, 0xbb, 0xfe, 0x40, 0x9e,
	0x67, 0x95, 0x4b, 0x48, 0x6f, 0x43, 0xa1, 0xe1, 0xbb, 0xa8, 0xed, 0x2a, 0x14, 0x03, 0xdb, 0xed,
	0xcf, 0x67, 0x2b, 0x04, 0xb6, 0xbb, 0xef, 0x87, 0x48, 0x18, 0xfa, 0x82, 0x90, 0x11, 0x84, 0xa1,
	0x4f, 0x84, 0x78, 0xfe, 0xec, 0x7c, 0x7e, 0xbd, 0x07, 0xd0, 0xf0, 0x83, 0xe0, 0x7b, 0xeb, 0xbc,
	0x04, 0x79, 0xcb, 0x9e, 0x46, 0x47, 0xe2, 0xda, 0x71, 0x01, 0xe8, 0xf7, 0x41, 0x35, 0x4e, 0xa6,
	0x41, 0xcb, 0x09, 0x23, 0x76, 0x13, 0x72, 0xae, 0x13, 0x46, 0x35, 0x65, 0x3d, 0xbb, 0x51, 0xde,
	0x04, 0xb1, 0xe3, 0x48, 0xe5, 0x84, 0xd7, 0xd7, 0x41, 0xdd, 0x33, 0x4f, 0x0e, 0xd1, 0x93, 0xa8,
	0x8d, 0x5c, 0x2a, 0x5d, 0x24, 0xfd, 0x7b, 0x1f, 0xa0, 0x67, 0x06, 0x63, 0x3b, 0xa2, 0x00, 0x77,
	0x03, 0xb2, 0xd1, 0xe9, 0x94, 0x38, 0x12, 0x75, 0x48, 0xe0, 0x88, 0xd6, 0xff, 0x5b, 0x81, 0x72,
	0x77, 0x36, 0xf8, 0x72, 0x66, 0x07, 0xa7, 0xb8, 0xa2, 0x8d, 0x39, 0xf7, 0xea, 0xe6, 0x15, 0xc1,
	0x9d, 0xa2, 0xcf, 0x25, 0x71, 0x89, 0x9e, 0x6f, 0xd9, 0x7d, 0xc7, 0x8a, 0x97, 0x88, 0x60, 0xd3,
	0xc2, 0x88, 0xea, 0x4f, 0xa5, 0xd3, 0x32, 0xfe, 0x94, 0xad, 0x43, 0x7e, 0x78, 0xe4, 0xb8, 0x16,
	0xc5, 0x93, 0xc5, 0x15, 0x09, 0x02, 0xbb, 0x06, 0x6a, 0xe0, 0x1f, 0xf7, 0x29, 0x14, 0x8a, 0x18,
	0x59, 0x0c, 0xfc, 0xe3, 0xae, 0xf3, 0x15, 0xfa, 0x5b, 0x84, 0x69, 0x80, 0x42, 0xb7, 0x51, 0x6f,
	0xd5, 0xb9, 0xb6, 0x82, 0x63, 0xe3, 0xf3, 0x66, 0xb7, 0xd7, 0xd5, 0x14, 0xb6, 0x0a, 0xd0, 0xee,
	0xf4, 0xfa, 0x12, 0xce, 0xb0, 0x02, 0x64, 0x9a, 0x6d, 0x2d, 0x8b, 0x3c, 0x88, 0x6f, 0xb6, 0xb5,
	0x1c, 0x2b, 0x42, 0xb6, 0xde, 0xfe, 0x42, 0xcb, 0xd3, 0xa0, 0xd5, 0xd2, 0x0a, 0xfa, 0x6f, 0x14,
	0x28, 0x75, 0x06, 0xaf, 0xec, 0x61, 0x84, 0x6b, 0xc6, 0x33, 0x65, 0x07, 0x6f, 0xec, 0x80, 0x96,
	0x9d, 0xe5, 0x12, 0xc2, 0x85, 0x58, 0x03, 0x5a, 0x5c, 0x96, 0x67, 0xac, 0x01, 0xf1, 0x0d, 0x8f,
	0xec, 0x89, 0x49, 0x8b, 0x43, 0x3e, 0x82, 0xf0, 0x0c, 0xfb, 0x83, 0x57, 0xb4, 0xbc, 0x2c, 0xc7,
	0x21, 0x7b, 0x0f, 0xca, 0x42, 0x47, 0x9f, 0x0e, 0x50, 0x9e, 0x7c, 0x01, 0x02, 0xd5, 0xc6, 0x63,
	0x7c, 0x15, 0x8a, 0xd6, 0x40, 0x10, 0x0b, 0x44, 0x2c, 0x58, 0x03, 0x22, 0xa0, 0x24, 0x69, 0x15,
	0xc4, 0xa2, 0x94, 0x24, 0x14, 0x31, 0x5c, 0x03, 0xd5, 0x1f, 0xbc, 0x12, 0x54, 0x91, 0x0b, 0x8a,
	0xfe, 0xe0, 0x15, 0x92, 0xf4, 0xdf, 0x2a, 0xa0, 0x3e, 0x9f, 0x79, 0xc3, 0x08, 0x53, 0xcb, 0x6d,
	0xc8, 0x8d, 0x66, 0xde, 0x50, 0xee, 0xbb, 0x0c, 0x38, 0xc9, 0x9a, 0x39, 0x11, 0xf1, 0xac, 0x99,
	0xc1, 0x18, 0xcf, 0xe8, 0xd2, 0x59, 0x43, 0xbc, 0xfe, 0x67, 0x52, 0xe3, 0x73, 0xd7, 0x1c, 0x33,
	0x15, 0x72, 0xed, 0x4e, 0xdb, 0xd0, 0x56, 0x58, 0x05, 0xd4, 0x66, 0xbb, 0x67, 0xf0, 0x76, 0xbd,
	0xa5, 0x29, 0xb4, 0x35, 0xbd, 0xfa, 0x56, 0xcb, 0xd0, 0x32, 0x48, 0x39, 0xec, 0xb4, 0xea, 0xbd,
	0x66, 0xcb, 0xd0, 0x72, 0x82, 0xc2, 0x9b, 0x8d, 0x9e, 0xa6, 0x32, 0x0d, 0x2a, 0xfb, 0xbc, 0xb3,
	0x7d, 0xd0, 0x30, 0xfa, 0xed, 0x83, 0x56, 0x4b, 0xd3, 0xd8, 0x45, 0x58, 0x4b, 0x30, 0x1d, 0x81,
	0x5c, 0x47, 0x91, 0xc3, 0x3a, 0xaf, 0xf3, 0x1d, 0xed, 0x53, 0xa6, 0x42, 0xb6, 0xbe, 0xb3, 0xa3,
	0x7d, 0xad, 0xe0, 0xe8, 0x65, 0xb3, 0xad, 0x7d, 0x9d, 0x61, 0xab, 0x50, 0xda, 0xeb, 0xb4, 0x3b,
	0xbd, 0x4e, 0xbb, 0xd9, 0xd0, 0xbe, 0xce, 0xe9, 0x7f, 0x90, 0x85, 0x1c, 0x1a, 0xfc, 0xed, 0xc7,
	0x9c, 0xfd, 0x00, 0x94, 0x21, 0xed, 0x64, 0x79, 0xb3, 0x2c, 0x68, 0x94, 0x36, 0x77, 0x57, 0xb8,
	0x82, 0x5e, 0x50, 0xc4, 0x79, 0x2d, 0x6f, 0xae, 0x0a, 0x62, 0x1c, 0x9e, 0x90, 0x3e, 0x65, 0x37,
	0x40, 0x79, 0x23, 0x0f, 0x6f, 0x45, 0xd0, 0x45, 0x80, 0x42, 0xea, 0x1b, 0xb6, 0x0e, 0xd9, 0xa1,
	0x2f, 0x52, 0x62, 0x42, 0x17, 0xe1, 0x61, 0x77, 0x85, 0x23, 0x09, 0xf5, 0x8f, 0x68, 0x9b, 0x13,
	0xfd, 0xf1, 0x2e, 0xa1, 0x86, 0x11, 0xbb, 0x0b, 0xd9, 0x70, 0x36, 0xa0, 0xbd, 0x2e, 0x6f, 0x5e,
	0x58, 0xba, 0x73, 0xa8, 0x26, 0x9c, 0x0d, 0xd8, 0x3d, 0xc8, 0x0d, 0xfd, 0x20, 0xa0, 0x5d, 0x4f,
	0x52, 0xc1, 0x3c, 0x18, 0x61, 0x3a, 0x43, 0x3a, 0x5b, 0x07, 0x25, 0xa2, 0xdc, 0x99, 0x30, 0xcd,
	0xa3, 0x01, 0x4e, 0x18, 0xb1, 0x3b, 0x32, 0xc4, 0x40, 0xda, 0xa6, 0x38, 0x00, 0xa1, 0x1e, 0xa4,
	0x32, 0x1d, 0xb2, 0x13, 0xf3, 0x84, 0xf2, 0x6a, 0xc2, 0x14, 0x47, 0x1e, 0xb4, 0x69, 0x62, 0x9e,
	0x6c, 0x15, 0x20, 0x67, 0x9f, 0x4c, 0x03, 0xfd, 0x1a, 0x94, 0x92, 0xfc, 0xc5, 0x2a, 0xa0, 0x98,
	0xf2, 0x2a, 0x29, 0xa6, 0xbe, 0x81, 0xe9, 0x24, 0xce, 0x50, 0x8b, 0x34, 0x84, 0xe2, 0x0b, 0xa6,
	0x0c, 0xf4, 0xbf, 0xcb, 0x50, 0xb0, 0xde, 0x7e, 0x4b, 0xe8, 0xbf, 0x03, 0x59, 0xd3, 0x1d, 0x13,
	0xfb, 0xea, 0x26, 0x8b, 0x97, 0x3f, 0x99, 0x06, 0x76, 0x18, 0x8a, 0x9d, 0x36, 0xdd, 0x71, 0x7c,
	0x0e, 0xb2, 0xe7, 0x9f, 0x83, 0xf7, 0xa1, 0x28, 0xf3, 0x98, 0xdc, 0xd0, 0xaa, 0xe0, 0xd8, 0x16,
	0x48, 0x1e, 0x53, 0x59, 0x0d, 0x8a, 0xd3, 0xc0, 0x99, 0x98, 0xc1, 0x29, 0xed, 0xac, 0xca, 0x63,
	0x10, 0x63, 0xee, 0xf4, 0xb5, 0x63, 0x9d, 0xc8, 0xa2, 0x4d, 0x00, 0xc8, 0x3f, 0xf4, 0x27, 0x13,
	0xdb, 0x8b, 0xe4, 0x9d, 0x8d, 0x41, 0xbc, 0xb0, 0x4e, 0xd8, 0x1f, 0xee, 0xbf, 0xb6, 0x4f, 0x69,
	0xeb, 0x54, 0x5e, 0x74, 0xc2, 0x06, 0x82, 0xec, 0x01, 0x94, 0x7c, 0xaf, 0x2f, 0xf2, 0xa6, 0xdc,
	0x31, 0xe9, 0xe7, 0x8e, 0x77, 0x40, 0x58, 0xae, 0xfa, 0x72, 0xc4, 0xde, 0x87, 0x35, 0xd7, 0x3f,
	0xee, 0x0f, 0xcd, 0xc0, 0x72, 0x3c, 0xd3, 0x75, 0xa2, 0x53, 0xda, 0x3f, 0x95, 0xaf, 0xba, 0xfe,
	0x71, 0x63, 0x8e, 0xd5, 0xbf, 0x84, 0xa2, 0x5c, 0x0e, 0xbb, 0x05, 0x15, 0xac, 0x02, 0xfb, 0xe6,
	0xc0, 0x21, 0x01, 0x51, 0x1b, 0x96, 0x11, 0x57, 0x17, 0x28, 0x0c, 0x01, 0xb8, 0x83, 0xf2, 0x72,
	0x2c, 0x84, 0x00, 0xc4, 0xb3, 0xdb, 0x50, 0xf5, 0x03, 0x67, 0xec, 0x78, 0xfd, 0x30, 0x0a, 0x1c,
	0x6f, 0x2c, 0x03, 0x7b, 0x45, 0x20, 0xbb, 0x84, 0xd3, 0x3b, 0xa0, 0xc6, 0x16, 0x27, 0x0a, 0x95,
	0xef, 0xaa, 0x30, 0x73, 0x8e, 0xc2, 0xbb, 0x50, 0xdd, 0x17, 0xfe, 0x7e, 0x61, 0x9f, 0xe2, 0x81,
	0xb8, 0x04, 0x79, 0x3c, 0x04, 0x21, 0xa5, 0xc5, 0x12, 0x17, 0x80, 0xbe, 0x09, 0xea, 0x7e, 0xe0,
	0x4f, 0xed, 0x20, 0x3a, 0xc5, 0x28, 0x8c, 0x2e, 0x16, 0x27, 0x06, 0x87, 0xf3, 0xec, 0x98, 0x49,
	0x67, 0xc7, 0x5f, 0xa0, 0x6a, 0x92, 0x71, 0xec, 0x10, 0x55, 0x3f, 0x04, 0x98, 0x26, 0x08, 0x99,
	0x76, 0xe3, 0x38, 0x20, 0x95, 0xf3, 0x14, 0x87, 0xfe, 0x97, 0x59, 0xa8, 0xee, 0x9b, 0x41, 0xe4,
	0xe0, 0x0d, 0x6e, 0x7a, 0x23, 0x9f, 0xbd, 0x0f, 0xb9, 0xe8, 0x74, 0x6a, 0xcb, 0xac, 0x79, 0x31,
	0x89, 0x21, 0x82, 0x85, 0x4e, 0x1f, 0x31, 0xa0, 0x6f, 0x8c, 0xb7, 0x38, 0x9b, 0x82, 0xd8, 0x27,
	0x70, 0x71, 0x1a, 0x8b, 0x21, 0xc2, 0x0e, 0xa9, 0x6f, 0xc8, 0x2e, 0xb1, 0x9f, 0xc7, 0xc6, 0xee,
	0x40, 0xb1, 0xe1, 0xbb, 0xb3, 0x89, 0x17, 0xd6, 0x72, 0x4b, 0x01, 0x3d, 0x26, 0xb1, 0xfb, 0xa0,
	0x25, 0xc2, 0x31, 0x7b, 0x9e, 0x9c, 0xba, 0x84, 0x67, 0x3a, 0x54, 0x12, 0x5c, 0x7b, 0x36, 0xa1,
	0x23, 0x9f, 0xe3, 0x0b, 0x38, 0xf6, 0x18, 0x20, 0x81, 0xc3, 0x5a, 0x91, 0x26, 0x3e, 0xeb, 0x82,
	0x66, 0x64, 0x4f, 0x78, 0x8a, 0x0d, 0xdb, 0x22, 0xd3, 0x1d, 0xfb, 0x81, 0x13, 0x1d, 0x4d, 0xe8,
	0x56, 0x64, 0xf9, 0x1c, 0xc1, 0xee, 0xc1, 0xaa, 0x13, 0x76, 0x67, 0x83, 0x44, 0x9e, 0x2e, 0x87,
	0xca, 0xcf, 0x60, 0xf1, 0x28, 0x25, 0x3a, 0xfb, 0x93, 0x70, 0x4c, 0x17, 0xa2, 0x94, 0xb2, 0x6f,
	0x2f, 0x1c, 0xeb, 0xff, 0xa9, 0xa4, 0xb7, 0x0b, 0x6b, 0xc5, 0x3b, 0x29, 0xb1, 0xf6, 0x3c, 0xca,
	0x2c, 0x22, 0xd9, 0x06, 0xac, 0xf9, 0xe2, 0x52, 0xed, 0xfb, 0xa1, 0xb0, 0x02, 0xb7, 0xad, 0xca,
	0xcf, 0xa2, 0xd9, 0x3a, 0x94, 0x2d, 0x3b, 0x1c, 0x06, 0xce, 0x34, 0x8a, 0x77, 0xab, 0xc4, 0xd3,
	0xa8, 0x74, 0x74, 0xc8, 0x2d, 0x46, 0x87, 0x7b, 0xa0, 0xba, 0x18, 0xbf, 0x8e, 0x4c, 0x8f, 0x76,
	0x61, 0x71, 0xd3, 0x12, 0x1a, 0xf2, 0x39, 0x1e, 0x85, 0xde, 0xb0, 0x56, 0x58, 0xe6, 0x8b, 0x69,
	0xfa, 0x0f, 0xa1, 0x78, 0xe8, 0xd8, 0xc7, 0x32, 0x86, 0xbe, 0x71, 0xec, 0xe3, 0x38, 0x86, 0xe2,
	0x58, 0xff, 0x63, 0x05, 0xd4, 0xa6, 0x67, 0xd9, 0x27, 0xc8, 0xf0, 0x1e, 0x94, 0x1d, 0x1c, 0xf7,
	0xd3, 0x37, 0x0b, 0x08, 0x85, 0x1e, 0x08, 0x91, 0x81, 0xfa, 0x4c, 0xc9, 0x90, 0x11, 0x0c, 0x84,
	0x12, 0x0c, 0x35, 0x28, 0xce, 0x3c, 0xe7, 0x4b, 0x34, 0x2a, 0xbb, 0x9e, 0xc5, 0xd0, 0x26, 0x41,
	0x76, 0x1b, 0x0a, 0x23, 0xc7, 0x76, 0xad, 0xf8, 0x28, 0xca, 0xac, 0xfb, 0x1c, 0x71, 0x5c, 0x92,
	0xf4, 0x3b, 0x90, 0x27, 0x04, 0x36, 0xd6, 0x58, 0x2e, 0xa7, 0xed, 0x50, 0x87, 0xbe, 0x4b, 0x93,
	0xe8, 0x7f, 0xa2, 0x40, 0x89, 0x6c, 0xa6, 0xbb, 0xf6, 0x43, 0x80, 0xb9, 0x4d, 0x72, 0x6d, 0xa5,
	0xc4, 0xa4, 0x45, 0x4d, 0x99, 0x45, 0x4d, 0x6c, 0x1d, 0x33, 0xa8, 0x2b, 0x6c, 0x4d, 0xe7, 0xea,
	0x6d, 0x2c, 0x88, 0x90, 0xc2, 0x6e, 0x41, 0x9e, 0x6c, 0x93, 0xd9, 0x61, 0xc1, 0x6a, 0x41, 0xd1,
	0xff, 0x26, 0x0f, 0x6a, 0x0f, 0xe7, 0x7b, 0x5b, 0x9e, 0x8a, 0x67, 0xc9, 0xbc, 0x75, 0x96, 0xfb,
	0x90, 0xb3, 0xec, 0x51, 0x6c, 0xc7, 0x95, 0x38, 0x49, 0x0b, 0x9d, 0x98, 0x8b, 0x44, 0xc8, 0x40,
	0x9e, 0xf9, 0x7a, 0x29, 0xc2, 0xe4, 0x52, 0xeb, 0x95, 0xd5, 0x7d, 0x69, 0x18, 0xd8, 0x66, 0x64,
	0x87, 0x5f, 0xba, 0xb2, 0xce, 0x9c, 0x23, 0xd8, 0x2e, 0xac, 0xa2, 0x49, 0x9b, 0xe8, 0x12, 0xda,
	0x57, 0x79, 0x76, 0x6e, 0x9d, 0x99, 0xb2, 0x2d, 0x99, 0xc8, 0xcd, 0x86, 0x17, 0x05, 0xa7, 0xbc,
	0xea, 0xa5, 0x71, 0xec, 0x31, 0xac, 0x0e, 0xfd, 0xc9, 0x14, 0x8f, 0xbc, 0xdd, 0x9f, 0x62, 0xa0,
	0x2d, 0x9e, 0x29, 0x78, 0x70, 0x79, 0xd5, 0x84, 0x87, 0xf2, 0xdb, 0x43, 0x50, 0xa3, 0x81, 0xdb,
	0xa7, 0x3a, 0x54, 0x54, 0x2d, 0x17, 0x53, 0x13, 0xc7, 0x45, 0x10, 0x2f, 0x46, 0x03, 0x17, 0x01,
	0xf6, 0x51, 0x7c, 0x20, 0x1d, 0x6f, 0xe4, 0x87, 0xb5, 0x12, 0xd9, 0x2a, 0x4b, 0xd7, 0xe4, 0x04,
	0xc8, 0x13, 0x8a, 0xc3, 0xf0, 0xfa, 0x7f, 0x29, 0x94, 0xec, 0xc8, 0x15, 0x77, 0x21, 0x33, 0x7d,
	0x2d, 0xd3, 0x4e, 0x1c, 0x80, 0xd2, 0x39, 0x64, 0x77, 0x85, 0x67, 0xa6, 0xaf, 0xb1, 0xac, 0xc1,
	0xec, 0x9d, 0x49, 0xa7, 0xdb, 0xf8, 0x4a, 0x60, 0x59, 0x83, 0xd9, 0xfc, 0x27, 0x0b, 0x29, 0x21,
	0xbb, 0xa8, 0x32, 0x95, 0x3b, 0xb0, 0x2f, 0x9e, 0x33, 0x62, 0xcd, 0x4d, 0x37, 0x6e, 0xa1, 0xb4,
	0x90, 0xd7, 0x11, 0xcb, 0x2a, 0x24, 0xb2, 0xc7, 0x50, 0x4a, 0x02, 0x8d, 0xac, 0x1a, 0x97, 0xc2,
	0xa5, 0x37, 0xf2, 0xb1, 0xa3, 0x4e, 0xf8, 0xb6, 0xf2, 0x90, 0xb5, 0xec, 0xd1, 0xf5, 0x4f, 0x81,
	0x2d, 0x6f, 0xd5, 0xbb, 0x32, 0x5f, 0x5e, 0x66, 0xbe, 0x9f, 0x65, 0x9e, 0x29, 0xfa, 0xc7, 0x50,
	0x5d, 0x70, 0xfe, 0xb9, 0x27, 0x18, 0x4b, 0x1c, 0xac, 0x80, 0x49, 0xbc, 0xc2, 0x05, 0xa0, 0x07,
	0x90, 0x6b, 0xf8, 0x61, 0x84, 0x12, 0x58, 0x84, 0x90, 0x84, 0xc2, 0x69, 0x8c, 0x81, 0x20, 0xf0,
	0x8f, 0xa9, 0x81, 0xcb, 0x10, 0x3a, 0x06, 0xd1, 0x38, 0xcf, 0x7a, 0x43, 0x3e, 0x54, 0x38, 0x0e,
	0xe9, 0x81, 0x2b, 0x32, 0x03, 0x11, 0x0a, 0x15, 0x2e, 0x00, 0x7a, 0xe0, 0xf2, 0x23, 0xf9, 0xb6,
	0xa4, 0x70, 0x01, 0xe8, 0x7f, 0xa5, 0x50, 0x4e, 0xdb, 0x36, 0x23, 0x13, 0xaf, 0x36, 0x76, 0x89,
	0x43, 0x7f, 0xe6, 0x45, 0xb2, 0xdd, 0xc6, 0xb6, 0xb1, 0x81, 0x30, 0x5e, 0x13, 0xaa, 0x74, 0x04,
	0x55, 0x2c, 0xbb, 0x84, 0x18, 0x41, 0xc6, 0xf2, 0x61, 0xe6, 0xba, 0x71, 0x98, 0x12, 0x00, 0xda,
	0xe6, 0x3c, 0xde, 0xa4, 0x08, 0x95, 0xe7, 0x38, 0x24, 0xcc, 0xd3, 0x27, 0x14, 0x89, 0xb3, 0x1c,
	0x87, 0x88, 0x19, 0x3d, 0xde, 0xa4, 0x7b, 0x93, 0xe1, 0x38, 0x24, 0xcc, 0xd3, 0x27, 0x94, 0xe9,
	0x14, 0x8e, 0x43, 0x2c, 0x63, 0xc3, 0x9a, 0x4a, 0xc1, 0x46, 0x09, 0xf5, 0x97, 0x00, 0xdc, 0x3f,
	0x0e, 0xed, 0x88, 0xac, 0xbe, 0x97, 0x34, 0x8d, 0x4a, 0xfa, 0xc4, 0xc5, 0x57, 0x2f, 0x69, 0x22,
	0x6f, 0x2d, 0x44, 0x8d, 0xea, 0xfc, 0x5a, 0x99, 0x91, 0x29, 0xc2, 0x86, 0xfe, 0xaf, 0x0a, 0x94,
	0x3b, 0x81, 0x65, 0x07, 0x5b, 0xa7, 0xdd, 0xa9, 0x3d, 0x7c, 0x67, 0xa5, 0x75, 0x83, 0x62, 0xa1,
	0x6b, 0x26, 0xb9, 0x0b, 0x63, 0x43, 0x8c, 0x60, 0x8f, 0x20, 0x37, 0x72, 0x4d, 0x51, 0xcf, 0xad,
	0x6e, 0xfe, 0x50, 0xd6, 0x9d, 0x73, 0xf5, 0xf1, 0x18, 0x7b, 0x3f, 0x4e, 0xac, 0xfa, 0xaf, 0x92,
	0xf9, 0xa9, 0x21, 0x4c, 0xb7, 0x81, 0x2b, 0xd4, 0x5c, 0x77, 0x1b, 0x1a, 0x36, 0x6b, 0xb9, 0x6d,
	0xa3, 0xdb, 0xd0, 0x32, 0x6c, 0x0d, 0xca, 0xd8, 0xd6, 0x75, 0xfb, 0xcf, 0x9b, 0xbc, 0xdb, 0xd3,
	0x72, 0xd4, 0xad, 0x13, 0xa2, 0x55, 0xef, 0x62, 0x53, 0x08, 0x50, 0x38, 0x68, 0x37, 0x7f, 0x79,
	0x60, 0x68, 0x9a, 0xfe, 0xa7, 0x0a, 0xc0, 0x4b, 0xc7, 0xb3, 0xfc, 0x63, 0x5a, 0xdc, 0x07, 0xa9,
	0xd2, 0xa3, 0x3f, 0x38, 0x3d, 0xe7, 0x39, 0xa4, 0x3c, 0xbf, 0x1e, 0xa7, 0xec, 0xc7, 0xa0, 0xfa,
	0x68, 0x1a, 0xb2, 0x0a, 0x17, 0x5e, 0x58, 0x5a, 0x11, 0x2f, 0xfa, 0x02, 0xc0, 0x23, 0xec, 0xda,
	0xa6, 0x25, 0x1f, 0x61, 0x68, 0x8c, 0xdb, 0x8a, 0xee, 0x10, 0xaf, 0xb7, 0x38, 0xd4, 0x7f, 0x97,
	0x81, 0x92, 0x28, 0x6a, 0x1b, 0xd1, 0x49, 0xba, 0x65, 0x57, 0x16, 0x5a, 0xf6, 0x6b, 0x22, 0xca,
	0x11, 0x45, 0x78, 0x19, 0x03, 0x5a, 0xdc, 0xe6, 0x4f, 0x03, 0xa7, 0x8f, 0xb7, 0x53, 0x54, 0x05,
	0x85, 0x69, 0xe0, 0xbc, 0xb0, 0xb1, 0xea, 0x2e, 0x4b, 0x42, 0x1f, 0x83, 0x51, 0x2e, 0x7e, 0x18,
	0x46, 0x62, 0xd3, 0x3a, 0x41, 0x9d, 0x47, 0x8e, 0x65, 0x93, 0xa4, 0x88, 0xea, 0x45, 0x84, 0x51,
	0x74, 0x1d, 0x2a, 0x31, 0xa9, 0x3f, 0x6f, 0x43, 0x40, 0x92, 0x51, 0xf8, 0x03, 0x28, 0x8b, 0x9e,
	0xa2, 0x4f, 0x27, 0xaa, 0x78, 0x4e, 0x1e, 0x02, 0xc1, 0xd0, 0xc0, 0x6c, 0xf4, 0x1e, 0x94, 0xfd,
	0xe8, 0xc8, 0x0e, 0xfa, 0x66, 0x14, 0x05, 0xf1, 0x39, 0x06, 0x42, 0xd5, 0x11, 0x43, 0x0c, 0xe4,
	0x5b, 0xc1, 0x50, 0x92, 0x0c, 0x88, 0x12, 0x0c, 0xcb, 0xc9, 0x01, 0xde, 0x9d, 0x1c, 0x92, 0xea,
	0x43, 0x68, 0x2d, 0xa7, 0xaa, 0x0f, 0xd2, 0xaa, 0xff, 0x46, 0x81, 0x72, 0xdd, 0x33, 0xdd, 0xd3,
	0xaf, 0xec, 0x38, 0xf3, 0x3b, 0xde, 0x74, 0x16, 0xf5, 0x31, 0xb4, 0xc8, 0x1e, 0xb2, 0x44, 0x18,
	0xbc, 0x6e, 0x64, 0xe5, 0x2c, 0x4a, 0xe8, 0xa2, 0xab, 0x04, 0x81, 0x22, 0x86, 0x44, 0x9e, 0xc2,
	0x54, 0x36, 0x25, 0xdf, 0xc5, 0x40, 0x35, 0x97, 0x27, 0x7a, 0x2e, 0x2d, 0x4f, 0x0c, 0xb7, 0xa1,
	0x1a, 0x39, 0x13, 0x74, 0xaa, 0x17, 0xce, 0x26, 0xb6, 0x25, 0x5e, 0xc1, 0xc5, 0xc3, 0x6a, 0x43,
	0xe2, 0x50, 0xcb, 0xc4, 0x9e, 0xf8, 0xc1, 0x69, 0x3f, 0x79, 0xd8, 0xcf, 0x72, 0x10, 0x28, 0x7a,
	0xd0, 0xfa, 0xfb, 0x2a, 0xe4, 0xda, 0xbe, 0x65, 0xb3, 0x8f, 0xa0, 0x44, 0xef, 0x67, 0xcb, 0x9d,
	0x03, 0x92, 0xe9, 0x0f, 0x95, 0x01, 0xaa, 0x27, 0x47, 0x6f, 0x7f, 0x71, 0xbb, 0x89, 0xb1, 0x23,
	0x8c, 0x16, 0xfb, 0x04, 0x8c, 0xd5, 0x9c, 0xf0, 0x74, 0x97, 0x02, 0xff, 0x95, 0x3d, 0x8c, 0xfa,
	0xd4, 0xf7, 0xe7, 0xce, 0xb9, 0x4b, 0x82, 0x4e, 0x2f, 0x90, 0xd7, 0x41, 0xa5, 0x77, 0xb9, 0xc0,
	0x16, 0x35, 0x69, 0x9e, 0x27, 0x30, 0x5a, 0xfd, 0xca, 0x77, 0x3c, 0x61, 0x75, 0x61, 0xc9, 0xea,
	0xcf, 0x7c, 0xc7, 0xa3, 0x80, 0xa1, 0x22, 0x17, 0x59, 0x7d, 0x1b, 0x8a, 0xbe, 0x27, 0xe6, 0x2d,
	0x2e, 0xcd, 0x5b, 0xf0, 0x3d, 0x9a, 0xf2, 0x01, 0x94, 0x47, 0x8e, 0x1b, 0xd9, 0x81, 0x60, 0x54,
	0x97, 0x18, 0x41, 0x90, 0x89, 0xf9, 0x2e, 0xa8, 0xe3, 0xc0, 0x9f, 0x4d, 0xf1, 0xae, 0x97, 0x96,
	0x1b, 0x1d, 0xa2, 0x6d, 0x9d, 0xe2, 0xaa, 0x69, 0xe8, 0x78, 0xe3, 0x7e, 0x68, 0x47, 0x35, 0x58,
	0x5e, 0x75, 0x4c, 0xef, 0xda, 0xa4, 0xd5, 0x1c, 0x8f, 0xc5, 0xfc, 0xe5, 0x65, 0xad, 0xe6, 0x78,
	0x4c, 0x93, 0xa7, 0x03, 0x4d, 0xe5, 0x9d, 0x81, 0xe6, 0xa3, 0xf9, 0x55, 0x8c, 0x4e, 0xc2, 0x5a,
	0x35, 0x5d, 0xd1, 0x24, 0xa1, 0x25, 0xb9, 0x8d, 0xd1, 0x49, 0xc8, 0x1e, 0x80, 0x7a, 0x8c, 0xbd,
	0xf1, 0xd4, 0x1e, 0xd2, 0xaf, 0x11, 0xc9, 0x23, 0xce, 0x3c, 0x36, 0xf2, 0xe2, 0xb1, 0xe3, 0x51,
	0x90, 0x5c, 0x87, 0xbc, 0xeb, 0x4c, 0x9c, 0x88, 0x7e, 0x9b, 0x38, 0xf3, 0xb4, 0x4a, 0x04, 0xa6,
	0x43, 0xc1, 0x1f, 0x8d, 0x70, 0xf9, 0xda, 0x12, 0x8b, 0xa4, 0xb0, 0x07, 0x20, 0x0a, 0xca, 0xbe,
	0x65, 0x8f, 0xe4, 0x0f, 0x14, 0x67, 0xb3, 0x94, 0x1a, 0xc5, 0x15, 0xef, 0x26, 0x54, 0x13, 0xe6,
	0xfe, 0x1b, 0x7b, 0x58, 0x63, 0xe9, 0x86, 0x39, 0x11, 0x28, 0xc7, 0x02, 0x87, 0xf6, 0x90, 0x6d,
	0x40, 0xd1, 0x1f, 0xbc, 0xea, 0x07, 0xf6, 0x88, 0x7e, 0x8e, 0x38, 0xe7, 0x39, 0xb2, 0xe0, 0x0f,
	0x5e, 0x71, 0x7b, 0xc4, 0x1e, 0x41, 0x39, 0xa0, 0xdc, 0xd9, 0xb7, 0xcc, 0xc8, 0xa4, 0xdf, 0x26,
	0x12, 0x07, 0xcc, 0x93, 0x2a, 0x87, 0x60, 0x9e, 0x60, 0x6f, 0x43, 0xd5, 0x3e, 0x89, 0x02, 0xb3,
	0xef, 0x4f, 0x45, 0x0b, 0x7a, 0x59, 0x34, 0x81, 0x84, 0xec, 0x08, 0x1c, 0xfb, 0x39, 0xac, 0x59,
	0xb6, 0x6b, 0x47, 0x36, 0x19, 0x18, 0x36, 0xa2, 0x93, 0xda, 0x15, 0xb2, 0xfb, 0x52, 0xfc, 0xfe,
	0x93, 0x10, 0x71, 0x43, 0xce, 0x32, 0xb3, 0x5b, 0x50, 0x19, 0x38, 0x9e, 0x85, 0x47, 0x29, 0x32,
	0xc7, 0x61, 0xed, 0x2a, 0x5d, 0x8b, 0xb2, 0xc4, 0xf5, 0xcc, 0x71, 0xc8, 0x9e, 0x40, 0xc5, 0x14,
	0xd1, 0x8a, 0xca, 0xd7, 0x5a, 0x2d, 0xfd, 0x9c, 0x97, 0x8a, 0x63, 0xbc, 0x6c, 0xa6, 0x82, 0xda,
	0x4f, 0x81, 0xc5, 0x25, 0x72, 0x1f, 0x93, 0xb6, 0x38, 0x7f, 0xd7, 0x96, 0xce, 0xdf, 0x9a, 0xac,
	0x91, 0xe3, 0x57, 0x3a, 0xfd, 0x3f, 0xb2, 0xa0, 0xc6, 0x31, 0x82, 0x95, 0xa1, 0x78, 0xd0, 0x7e,
	0xd1, 0xee, 0xbc, 0x6c, 0x6b, 0x2b, 0x98, 0x64, 0x0f, 0xeb, 0xad, 0x03, 0xa3, 0xdf, 0x6d, 0xd4,
	0xdb, 0xe2, 0x89, 0x9c, 0x9e, 0x67, 0x05, 0x9c, 0x61, 0x17, 0xa0, 0xfa, 0xfc, 0xa0, 0xdd, 0xe8,
	0x35, 0x3b, 0x6d, 0x81, 0xca, 0x22, 0xca, 0xf8, 0x5c, 0x64, 0x72, 0x81, 0xca, 0x21, 0x6a, 0xaf,
	0xde, 0x33, 0x78, 0x33, 0x46, 0xe5, 0x71, 0x96, 0x7d, 0xde, 0xf9, 0xcc, 0x68, 0xf4, 0x34, 0x60,
	0x97, 0xe1, 0x42, 0x22, 0x12, 0xab, 0xd3, 0xca, 0x58, 0x13, 0xc4, 0x62, 0xda, 0x25, 0x54, 0xc2,
	0x8d, 0xc6, 0x01, 0xef, 0x36, 0x0f, 0x8d, 0x7e, 0xa3, 0x67, 0x68, 0x97, 0xb1, 0x3a, 0xe8, 0x36,
	0xdb, 0x2f, 0xb4, 0x2b, 0xac, 0x0a, 0x25, 0x1c, 0x09, 0xed, 0x57, 0xa9, 0x7e, 0xd8, 0xd9, 0xd1,
	0x6e, 0xa2, 0x8a, 0xed, 0x66, 0xb7, 0xd7, 0x6c, 0x37, 0x7a, 0xda, 0x7b, 0x58, 0x22, 0x3c, 0x6f,
	0xb6, 0x7a, 0x06, 0xd7, 0xd6, 0x51, 0xf6, 0xb3, 0x4e, 0xb3, 0xad, 0xdd, 0xa2, 0x97, 0xe5, 0xfa,
	0xde, 0x7e, 0xcb, 0xd0, 0x74, 0xd2, 0xd8, 0xe1, 0x3d, 0xed, 0x36, 0x2b, 0x41, 0xfe, 0xa0, 0x8d,
	0x76, 0xdc, 0x41, 0xe5, 0x34, 0xec, 0xd7, 0x5b, 0x2d, 0xed, 0x6e, 0xaa, 0xd0, 0xb8, 0x87, 0xe3,
	0x97, 0xcd, 0xf6, 0x76, 0xe7, 0xa5, 0xf6, 0x3e, 0xb2, 0x6d, 0xf1, 0x4e, 0x7d, 0xbb, 0x81, 0xf5,
	0xc8, 0x06, 0x2a, 0xe8, 0xee, 0xb7, 0x9a, 0x3d, 0xed, 0x47, 0xc8, 0xb5, 0x53, 0xef, 0xed, 0x1a,
	0x5c, 0xbb, 0x8f, 0xe3, 0x7a, 0xb7, 0x6b, 0xf0, 0x9e, 0xb6, 0x89, 0xe3, 0x66, 0x9b, 0xc6, 0x8f,
	0x49, 0xeb, 0xfe, 0x76, 0xbd, 0x67, 0x68, 0x4f, 0x70, 0xbc, 0x6d, 0xb4, 0x8c, 0x9e, 0xa1, 0xfd,
	0x04, 0xb5, 0x52, 0x61, 0xd4, 0x45, 0x57, 0x3d, 0x45, 0x2f, 0x24, 0x20, 0xd9, 0xf3, 0x53, 0x9c,
	0x68, 0xaf, 0xd9, 0x3e, 0xe8, 0x6a, 0xcf, 0x90, 0x99, 0x86, 0x44, 0xf9, 0x98, 0x31, 0x58, 0x15,
	0xbb, 0x95, 0x38, 0xf5, 0x67, 0xfa, 0x2b, 0x50, 0xe3, 0xc0, 0x8a, 0x92, 0xcd, 0x76, 0xdb, 0xe0,
	0xda, 0x0a, 0x2e, 0xbc, 0x65, 0x3c, 0xef, 0x69, 0x0a, 0x22, 0x79, 0x73, 0x67, 0xb7, 0xa7, 0x65,
	0x70, 0xd8, 0x39, 0x40, 0x77, 0x65, 0xc9, 0x31, 0xc6, 0x5e, 0x53, 0xcb, 0xe1, 0xa8, 0xde, 0xee,
	0x35, 0xb5, 0x3c, 0x39, 0xae, 0xd9, 0xde, 0x69, 0x19, 0x5a, 0x01, 0xb1, 0x7b, 0x75, 0xfe, 0x42,
	0x2b, 0xa2, 0x50, 0x7d, 0x7f, 0xbf, 0xf5, 0x85, 0xa6, 0xea, 0x1b, 0x50, 0xac, 0x8f, 0xc7, 0x7b,
	0x98, 0xa1, 0x54, 0xc8, 0x3d, 0x3f, 0x68, 0xb5, 0xc4, 0x2f, 0x2e, 0x5b, 0x9d, 0x5e, 0xaf, 0xb3,
	0xa7, 0x29, 0xb8, 0x4f, 0xbd, 0xce, 0xbe, 0x96, 0xd1, 0xff, 0x47, 0x81, 0xd5, 0xc5, 0x7b, 0xc3,
	0xae, 0x80, 0x2c, 0x8a, 0xce, 0x94, 0x48, 0x35, 0x88, 0x4b, 0xa2, 0xb3, 0x15, 0x92, 0x0e, 0x95,
	0x59, 0x68, 0x0b, 0x35, 0x2f, 0x92, 0x32, 0x69, 0x01, 0xc7, 0xd6, 0xa1, 0x3c, 0x34, 0xbd, 0x5e,
	0x30, 0xf3, 0x86, 0x66, 0x24, 0x32, 0xb3, 0xca, 0xd3, 0x28, 0xca, 0x58, 0xb2, 0x25, 0x92, 0x3f,
	0x20, 0x25, 0xf0, 0xd9, 0xa6, 0xb2, 0xf0, 0xce, 0xa6, 0xf2, 0x6c, 0x65, 0x52, 0x5c, 0xaa, 0x4c,
	0xfe, 0x22, 0x03, 0xf9, 0x5f, 0xce, 0xec, 0xe0, 0x94, 0x3d, 0x85, 0x52, 0x18, 0x4d, 0xa2, 0x74,
	0x12, 0xbf, 0x26, 0x54, 0x13, 0xfd, 0x61, 0x37, 0x32, 0x23, 0x7b, 0x62, 0x7b, 0x91, 0x48, 0xe5,
	0xc8, 0x4b, 0x17, 0x96, 0x7a, 0x20, 0x7b, 0x2a, 0xca, 0xfd, 0x3c, 0x17, 0x00, 0x86, 0x73, 0xcc,
	0xe8, 0xf1, 0xc3, 0x00, 0xcc, 0x13, 0x2b, 0x17, 0x04, 0x0c, 0xe7, 0xd4, 0x8c, 0x9d, 0xf7, 0xc2,
	0x27, 0x29, 0xe8, 0x8c, 0x23, 0xdb, 0xc4, 0xb8, 0x14, 0x3f, 0xec, 0x25, 0x30, 0x6e, 0x84, 0xeb,
	0x9b, 0x56, 0xcf, 0x1c, 0x53, 0xf2, 0x56, 0x79, 0x0c, 0xea, 0x2f, 0xa1, 0xba, 0x60, 0xec, 0x62,
	0x4c, 0xc1, 0x63, 0x63, 0xb4, 0xf0, 0x38, 0x2b, 0xa9, 0x1b, 0x90, 0x49, 0x9d, 0xfa, 0x6c, 0xea,
	0x36, 0xe4, 0xe8, 0x7c, 0x1b, 0x7c, 0xc7, 0xd0, 0xf2, 0xfa, 0x9f, 0x67, 0xe0, 0x42, 0x2f, 0x30,
	0xbd, 0xd0, 0x14, 0x2f, 0x8b, 0x5e, 0x14, 0xf8, 0x2e, 0xfb, 0x19, 0xa8, 0xd1, 0xd0, 0x4d, 0xfb,
	0xed, 0x3d, 0x99, 0x41, 0xce, 0xb2, 0x3e, 0xec, 0x0d, 0x5d, 0xf2, 0x5e, 0x31, 0x12, 0x03, 0xf6,
	0x01, 0xe4, 0x07, 0xf6, 0xd8, 0xf1, 0x64, 0x0f, 0x7f, 0xf9, 0xac, 0xe0, 0x16, 0x12, 0x77, 0x57,
	0xb8, 0xe0, 0x62, 0x1f, 0x41, 0x61, 0xe8, 0x4f, 0x30, 0x4b, 0x8a, 0xfa, 0xe8, 0xca, 0xf2, 0x44,
	0x48, 0xdd, 0x5d, 0xe1, 0x92, 0x8f, 0x3d, 0x05, 0x35, 0xf0, 0x5d, 0x77, 0x60, 0x0e, 0x5f, 0xcb,
	0x5e, 0xbe, 0x76, 0x56, 0x86, 0x4b, 0xfa, 0xee, 0x0a, 0x4f, 0x78, 0xf5, 0x87, 0x50, 0x94, 0xc6,
	0xa2, 0x03, 0xb6, 0x8c, 0x9d, 0xa6, 0xf4, 0x5d, 0xa3, 0xb3, 0xb7, 0xd7, 0x44, 0xdf, 0x55, 0x40,
	0xe5, 0x9d, 0x56, 0x6b, 0xab, 0xde, 0x78, 0xa1, 0x65, 0xb6, 0x54, 0x28, 0x98, 0xd4, 0x85, 0xeb,
	0x7f, 0xa8, 0xc0, 0xda, 0x99, 0x05, 0xb0, 0x67, 0x90, 0x9b, 0xf8, 0x56, 0xec, 0x9e, 0x3b, 0xe7,
	0xae, 0x32, 0x05, 0xe3, 0x95, 0xe5, 0x24, 0xa1, 0x7f, 0x0c, 0xab, 0x8b, 0xf8, 0xd4, 0x6f, 0x77,
	0x55, 0x28, 0x71, 0xa3, 0xbe, 0xdd, 0xef, 0xb4, 0x5b, 0x5f, 0x88, 0xe4, 0x40, 0xe0, 0x4b, 0xde,
	0xec, 0x19, 0x5a, 0x46, 0xff, 0x15, 0x68, 0x67, 0x1d, 0xc3, 0x76, 0x60, 0x0d, 0x4b, 0x77, 0xd7,
	0xa6, 0x5e, 0x2c, 0xb5, 0x65, 0x37, 0xcf, 0xf1, 0xa4, 0x64, 0xa3, 0x1d, 0x5b, 0x1d, 0x2e, 0xc0,
	0xfa, 0xef, 0x01, 0x5b, 0xf6, 0xe0, 0xff, 0x9d, 0xfa, 0x7f, 0x51, 0x20, 0xb7, 0xef, 0x9a, 0x1e,
	0xbb, 0x0d, 0x79, 0xfa, 0xf1, 0x4c, 0x76, 0xc6, 0xe5, 0xd4, 0x8d, 0xc4, 0x63, 0x41, 0x34, 0xf6,
	0x00, 0xb2, 0xd1, 0xd0, 0x95, 0x67, 0xe8, 0xea, 0x5b, 0x0e, 0xdf, 0xee, 0x0a, 0x47, 0x2e, 0xb6,
	0x01, 0x59, 0xcb, 0x72, 0xe5, 0x01, 0x8a, 0x6b, 0x06, 0x33, 0x32, 0xb7, 0xed, 0x91, 0xe3, 0x39,
	0xf2, 0xa7, 0x3c, 0x64, 0x61, 0x77, 0x21, 0x6b, 0x0d, 0x5d, 0x79, 0x6c, 0x2e, 0xcc, 0x39, 0x53,
	0x0a, 0xad, 0xa1, 0xcb, 0xee, 0x41, 0xd6, 0xa1, 0x87, 0x77, 0x64, 0x63, 0x71, 0x34, 0x0a, 0xed,
	0x20, 0x12, 0x0f, 0xb9, 0xf4, 0x12, 0xe5, 0x85, 0x5b, 0x05, 0xa0, 0xcf, 0x9b, 0xf4, 0x7f, 0xce,
	0x40, 0x25, 0x4d, 0xff, 0x5e, 0xed, 0xe8, 0x23, 0x2c, 0x95, 0xa6, 0xae, 0x33, 0x74, 0xa2, 0xfe,
	0x5b, 0x1f, 0x42, 0x2b, 0x31, 0x0b, 0x35, 0x87, 0x0f, 0x40, 0x74, 0x82, 0x82, 0x3f, 0x77, 0x0e,
	0x7f, 0x89, 0xe8, 0x49, 0x27, 0x99, 0x6a, 0x14, 0xf3, 0x4b, 0x8d, 0xe2, 0x3d, 0xfa, 0x2c, 0x82,
	0x7e, 0x72, 0x28, 0xa4, 0x55, 0x09, 0x24, 0x8f, 0x89, 0xdf, 0xef, 0xb5, 0xf1, 0x4c, 0xa0, 0x57,
	0xdf, 0x19, 0xe8, 0xf5, 0x1f, 0x63, 0x64, 0xc0, 0x19, 0x31, 0xae, 0x8a, 0xd1, 0x39, 0xef, 0x0c,
	0x92, 0xa2, 0xff, 0x2e, 0x03, 0xe5, 0xd4, 0x4e, 0xb2, 0x27, 0xa0, 0x5a, 0x8b, 0x21, 0xec, 0xda,
	0xd2, 0x76, 0x3f, 0xdc, 0x8e, 0x83, 0x97, 0x25, 0x03, 0xc3, 0xc7, 0x50, 0xc5, 0xf2, 0xf6, 0x8d,
	0x19, 0x38, 0x54, 0x5d, 0xca, 0x03, 0x28, 0x8f, 0x40, 0xd7, 0x8e, 0x0e, 0x63, 0xca, 0xee, 0x0a,
	0xaf, 0x84, 0x29, 0x98, 0xfd, 0x08, 0x8a, 0xd3, 0xc0, 0x9e, 0x9a, 0x81, 0x2d, 0x0f, 0x62, 0x35,
	0x7e, 0x92, 0x24, 0xe4, 0xee, 0x0a, 0x8f, 0xe9, 0xc8, 0x6a, 0x9f, 0xd8, 0xc3, 0x99, 0x4c, 0x97,
	0x09, 0xab, 0x21, 0x90, 0xc8, 0x2a, 0xe9, 0x6c, 0x13, 0xc0, 0xb2, 0x4d, 0xd7, 0xf5, 0x29, 0xb9,
	0xe6, 0xd3, 0x15, 0xf7, 0x76, 0x82, 0x17, 0x1f, 0x00, 0xc5, 0x90, 0x3e, 0x86, 0xa2, 0x5c, 0x18,
	0x16, 0x37, 0x5d, 0xa3, 0xd7, 0x3f, 0xac, 0xf3, 0x26, 0x96, 0x2d, 0x5d, 0x6d, 0x05, 0x63, 0xdf,
	0x0e, 0xaf, 0xb7, 0x65, 0xae, 0xe0, 0xc6, 0x61, 0xe7, 0x85, 0xa1, 0x65, 0xc4, 0xbb, 0x50, 0xfb,
	0x0b, 0x2d, 0x2b, 0x0a, 0x49, 0x63, 0xbf, 0xce, 0x31, 0x55, 0x94, 0xa1, 0x68, 0x7c, 0x6e, 0x34,
	0x0e, 0x7a, 0x86, 0x96, 0xc7, 0x70, 0xb4, 0x6d, 0xd4, 0x5b, 0xad, 0x4e, 0x03, 0xf3, 0x48, 0x61,
	0xab, 0x84, 0x07, 0x86, 0x3c, 0xa9, 0xff, 0xb6, 0x04, 0xab, 0x8b, 0x57, 0x8e, 0xfd, 0x14, 0x54,
	0xcb, 0x5a, 0xd8, 0x81, 0x1b, 0xe7, 0x5d, 0xcd, 0x87, 0xdb, 0x56, 0xbc, 0x09, 0x62, 0xc0, 0x6e,
	0xc5, 0x01, 0x22, 0xb3, 0x14, 0x20, 0xe2, 0xf0, 0xf0, 0x0b, 0x58, 0x13, 0xef, 0xe8, 0xd4, 0x89,
	0x0c, 0xcc, 0xd0, 0x5e, 0xbc, 0xfd, 0x0d, 0x22, 0x6e, 0x4b, 0xda, 0xee, 0x0a, 0x5f, 0x1d, 0x2e,
	0x60, 0xd8, 0x27, 0xb0, 0x6a, 0x52, 0x47, 0x9b, 0xc8, 0xe7, 0xd2, 0x8f, 0xbd, 0x75, 0xa4, 0xa5,
	0xc4, 0xab, 0x66, 0x1a, 0x81, 0xc7, 0xc4, 0x0a, 0xfc, 0xe9, 0x5c, 0x78, 0x21, 0x52, 0x6c, 0x07,
	0xfe, 0x34, 0x25, 0x5b, 0xb1, 0x52, 0x30, 0x7b, 0x0a, 0x15, 0x69, 0xb9, 0xf8, 0x62, 0xb0, 0x90,
	0x0e, 0x45, 0xc2, 0x6c, 0x2a, 0xd8, 0x76, 0x57, 0x78, 0x79, 0x38, 0x07, 0xd9, 0x63, 0x28, 0x0b,
	0x83, 0x85, 0x58, 0x31, 0x7d, 0x12, 0xc8, 0xda, 0x58, 0x0a, 0xcc, 0x04, 0x62, 0x1f, 0x01, 0x90,
	0x9d, 0xf3, 0x8f, 0x13, 0x93, 0x3b, 0x87, 0x46, 0xc6, 0x22, 0x25, 0x2b, 0x06, 0x52, 0xe6, 0x89,
	0x5f, 0x24, 0x4a, 0xcb, 0xe6, 0xd1, 0x6d, 0x9d, 0x9b, 0x17, 0xff, 0x02, 0x21, 0xcd, 0x13, 0x62,
	0xb0, 0x64, 0x5e, 0x2c, 0x25, 0xcc, 0x8b, 0x8b, 0x3f, 0x61, 0x9e, 0x90, 0x29, 0x9f, 0x35, 0x2f,
	0x16, 0x21, 0xf3, 0x84, 0xc4, 0x27, 0xb0, 0x1a, 0xc9, 0xb2, 0x52, 0x2e, 0xaa, 0xb2, 0xf0, 0xcb,
	0x85, 0xa4, 0xc5, 0x0b, 0xab, 0x46, 0x69, 0x04, 0x4a, 0x87, 0x47, 0xfe, 0x71, 0xea, 0x7a, 0x57,
	0xd3, 0xd2, 0xdd, 0x23, 0xff, 0x38, 0x7d, 0xbf, 0xab, 0x61, 0x1a, 0xa1, 0x7f, 0x9d, 0x83, 0xa2,
	0x3c, 0xab, 0xec, 0x22, 0xac, 0x35, 0xb8, 0x51, 0xef, 0x19, 0xfd, 0xed, 0x7a, 0xaf, 0xbe, 0x55,
	0xef, 0x62, 0xf2, 0x66, 0xb0, 0x5a, 0xc7, 0x5e, 0x68, 0x8e, 0x53, 0xf0, 0x02, 0x6e, 0xf3, 0xce,
	0xfe, 0x1c, 0x95, 0x61, 0x1a, 0x54, 0xa4, 0xac, 0xf8, 0x2e, 0x27, 0xcb, 0xd6, 0xa0, 0x2c, 0x04,
	0x05, 0x82, 0x5e, 0x62, 0x49, 0x4a, 0xc0, 0xf9, 0x94, 0x48, 0xb3, 0xbd, 0x6d, 0x7c, 0xae, 0x15,
	0xe6, 0x22, 0x02, 0x51, 0x4c, 0x44, 0x04, 0xac, 0x52, 0xa7, 0xc2, 0x0f, 0xda, 0x8d, 0xf9, 0x3c,
	0x25, 0x14, 0x92, 0x6a, 0x0e, 0x9b, 0xc6, 0x4b, 0x0d, 0x50, 0x48, 0x68, 0x21, 0xb8, 0x8c, 0xe5,
	0x07, 0x29, 0x21, 0xb0, 0xc2, 0xae, 0xc2, 0xc5, 0xee, 0x6e, 0xe7, 0x65, 0x5f, 0x08, 0x25, 0x4b,
	0xa8, 0xb2, 0x4b, 0xa0, 0xa5, 0x08, 0x42, 0xfd, 0x2a, 0x4e, 0x49, 0xd8, 0x98, 0xb1, 0xab, 0xad,
	0xe1, 0x94, 0x84, 0xeb, 0x89, 0xf0, 0xa3, 0xe1, 0x52, 0x84, 0x68, 0xa7, 0x75, 0xb0, 0xd7, 0xee,
	0x6a, 0x17, 0xd0, 0x08, 0xc2, 0x08, 0xcb, 0x59, 0xa2, 0x66, 0x1e, 0xb4, 0x2e, 0x52, 0x1c, 0x43,
	0xdc, 0xcb, 0x3a, 0x6f, 0x37, 0xdb, 0x3b, 0x5d, 0xed, 0x52, 0xa2, 0xd9, 0xe0, 0xbc, 0xc3, 0xbb,
	0xda, 0xe5, 0x04, 0xd1, 0xed, 0xd5, 0x7b, 0x07, 0x5d, 0xed, 0x4a, 0x62, 0xe5, 0x3e, 0xef, 0x34,
	0x8c, 0x6e, 0xb7, 0xd5, 0xec, 0xf6, 0xb4, 0xab, 0xd8, 0x1a, 0xcf, 0x2d, 0x8a, 0x99, 0x6b, 0x29,
	0x43, 0xf9, 0x8e, 0xd1, 0xd3, 0xae, 0x25, 0x66, 0x34, 0x3a, 0xad, 0x56, 0x9d, 0x5a, 0xbd, 0xeb,
	0x5b, 0x15, 0xfa, 0xf8, 0x52, 0x06, 0x2e, 0x7d, 0x1f, 0x56, 0x17, 0xe3, 0x0c, 0xd3, 0xa1, 0xea,
	0x8c, 0xfa, 0x9e, 0x1f, 0xf5, 0xed, 0x13, 0x27, 0x8c, 0xc2, 0xf8, 0x93, 0x0e, 0x67, 0xd4, 0xf6,
	0x23, 0x83, 0x50, 0xd8, 0x00, 0x24, 0x61, 0x43, 0x54, 0x00, 0x09, 0xac, 0xef, 0x42, 0x75, 0x21,
	0xf2, 0xb0, 0x1f, 0x40, 0xc9, 0x19, 0x2d, 0x2a, 0x53, 0x9d, 0xd1, 0x77, 0xd0, 0xb4, 0x03, 0x95,
	0x74, 0x18, 0xfa, 0xfe, 0x8a, 0xfe, 0x51, 0x81, 0x72, 0x2a, 0x2c, 0x7d, 0xa7, 0x25, 0xde, 0x80,
	0x52, 0x64, 0x4f, 0xa6, 0x7e, 0x60, 0xca, 0x20, 0xae, 0xf2, 0x39, 0x62, 0x61, 0xb6, 0xec, 0xe2,
	0x6c, 0x8b, 0x8f, 0x5d, 0xb9, 0x77, 0x3c, 0x76, 0x3d, 0x82, 0x8a, 0x28, 0x29, 0x22, 0x71, 0x99,
	0xf3, 0xe7, 0xbf, 0x75, 0x11, 0x8f, 0x78, 0x2c, 0xd2, 0x3b, 0x00, 0xf3, 0x60, 0x39, 0xff, 0x6c,
	0x5b, 0x49, 0x7d, 0xb6, 0xbd, 0x68, 0x43, 0xe6, 0xdb, 0x6d, 0xc0, 0xd6, 0xa0, 0x94, 0x84, 0xd2,
	0xef, 0xed, 0xe5, 0xb9, 0x25, 0xd9, 0xb4, 0x25, 0xf7, 0xe1, 0x42, 0x6a, 0x81, 0xf2, 0x67, 0xf3,
	0x1c, 0xd5, 0x6d, 0x6b, 0xf3, 0x55, 0x89, 0xdf, 0xe1, 0x77, 0xe2, 0x6d, 0x12, 0x81, 0xf2, 0xbb,
	0x6c, 0xd3, 0x25, 0xc8, 0x8b, 0xc8, 0x2b, 0xbf, 0xc0, 0x21, 0x40, 0xd7, 0xa5, 0x8b, 0x84, 0x9e,
	0x84, 0x47, 0x49, 0xf3, 0xfc, 0x5c, 0x2c, 0x5a, 0xb0, 0x7c, 0xeb, 0xa2, 0xcf, 0x9f, 0x63, 0x02,
	0xd5, 0x85, 0x50, 0xbd, 0xe0, 0x1b, 0xe5, 0x6d, 0xbe, 0xc9, 0xbc, 0xd3, 0x37, 0xd9, 0xf3, 0x7d,
	0xd3, 0x84, 0xea, 0x42, 0x6c, 0x4f, 0x7d, 0x8f, 0xac, 0xa4, 0xbf, 0x47, 0xc6, 0x16, 0xff, 0xf8,
	0xc8, 0x0e, 0xec, 0x73, 0x3e, 0xb9, 0x14, 0x04, 0xfd, 0x13, 0xa8, 0xa4, 0xab, 0x40, 0xf6, 0x63,
	0xc8, 0x3b, 0x91, 0x3d, 0x89, 0xbf, 0x4c, 0xba, 0xb2, 0x5c, 0x28, 0xd2, 0xd7, 0x35, 0x82, 0x49,
	0xff, 0xb5, 0x02, 0xda, 0x59, 0x5a, 0xea, 0xa3, 0x69, 0xe5, 0x2d, 0x1f, 0x4d, 0x67, 0x16, 0x8c,
	0x3c, 0xe7, 0xc3, 0x67, 0x34, 0x5c, 0xfc, 0xa4, 0x7c, 0xce, 0x57, 0xbc, 0x44, 0x60, 0xf7, 0x40,
	0x0d, 0x6c, 0xfa, 0xc6, 0xd5, 0x92, 0xd5, 0xca, 0xc2, 0x27, 0x2a, 0x31, 0x4d, 0xff, 0x23, 0x05,
	0x8a, 0xb2, 0x64, 0x3d, 0xf7, 0xd7, 0xe7, 0x1f, 0x41, 0x51, 0xfc, 0x26, 0x1a, 0xff, 0x18, 0xba,
	0xf4, 0x5a, 0x1c, 0xd3, 0xd9, 0x4d, 0xd1, 0x1d, 0x2d, 0xfe, 0xf0, 0x81, 0x2d, 0x20, 0x27, 0x3c,
	0x36, 0x24, 0xf4, 0x28, 0x42, 0x25, 0x62, 0x28, 0x7f, 0xe8, 0x05, 0x42, 0x61, 0x92, 0x0d, 0xf5,
	0xff, 0x07, 0x45, 0x59, 0x12, 0x9f, 0x6b, 0xca, 0xbb, 0xbe, 0x8f, 0x5d, 0x07, 0x98, 0xd7, 0xc8,
	0xe7, 0x69, 0xb8, 0x7f, 0x0b, 0x2a, 0xe9, 0x6f, 0x14, 0xa9, 0x11, 0xf7, 0x3d, 0x5b, 0xfc, 0x5e,
	0xda, 0xfa, 0xea, 0x89, 0xa6, 0xdc, 0xff, 0xfd, 0xd4, 0xf7, 0x49, 0xc4, 0x53, 0x84, 0xec, 0x0b,
	0xe3, 0x0b, 0xf1, 0x92, 0xdb, 0x6a, 0xb6, 0x8d, 0x3a, 0xef, 0x23, 0x4c, 0xbf, 0xac, 0xee, 0xd6,
	0xbb, 0xbb, 0xe2, 0x97, 0x55, 0x49, 0x21, 0x44, 0x96, 0x5e, 0x00, 0xeb, 0xed, 0x1d, 0x43, 0xbc,
	0xdc, 0xd2, 0x30, 0x49, 0x80, 0x79, 0x7a, 0x29, 0xc4, 0xdc, 0x54, 0xc0, 0xe4, 0x88, 0xa3, 0x84,
	0x56, 0xbc, 0xff, 0x29, 0xd4, 0xde, 0xd6, 0x61, 0xa3, 0xd6, 0xc6, 0x6e, 0x9d, 0x5e, 0x31, 0x2a,
	0xa0, 0xb6, 0x3b, 0x7d, 0x01, 0x29, 0x58, 0xb4, 0x73, 0xa3, 0x65, 0x50, 0xb9, 0xb1, 0xf5, 0x8b,
	0x7f, 0xf8, 0xe6, 0xa6, 0xf2, 0x4f, 0xdf, 0xdc, 0x54, 0xfe, 0xed, 0x9b, 0x9b, 0x2b, 0xbf, 0xfe,
	0xf7, 0x9b, 0xca, 0xff, 0x4f, 0xff, 0x33, 0xce, 0xc4, 0x8c, 0x02, 0xe7, 0x44, 0x7c, 0xdd, 0x17,
	0x03, 0x9e, 0xfd, 0xe1, 0xf4, 0xf5, 0xf8, 0xc3, 0xe9, 0xe0, 0x43, 0xf4, 0xe8, 0xa0, 0x40, 0xff,
	0x93, 0xf3, 0xf8, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x81, 0x20, 0x13, 0x54, 0xd6, 0x33, 0x00,
	0x00,
}

func (m *Type) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Type) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Type) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x42
	}
	if m.Scale != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Scale))
		i--
		dAtA[i] = 0x38
	}
	if m.Size != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Size))
		i--
		dAtA[i] = 0x30
	}
	if m.Precision != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Precision))
		i--
		dAtA[i] = 0x28
	}
	if m.Width != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x20
	}
	if m.AutoIncr {
		i--
		if m.AutoIncr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Nullable {
		i--
		if m.Nullable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Const) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Const) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsBin {
		i--
		if m.IsBin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.Value != nil {
		{
			size := m.Value.ProtoSize()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Isnull {
		i--
		if m.Isnull {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Const_I8Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_I8Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.I8Val))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *Const_I16Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_I16Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.I16Val))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *Const_I32Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_I32Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.I32Val))
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *Const_I64Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_I64Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.I64Val))
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *Const_U8Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_U8Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.U8Val))
	i--
	dAtA[i] = 0x30
	return len(dAtA) - i, nil
}
func (m *Const_U16Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_U16Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.U16Val))
	i--
	dAtA[i] = 0x38
	return len(dAtA) - i, nil
}
func (m *Const_U32Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_U32Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.U32Val))
	i--
	dAtA[i] = 0x40
	return len(dAtA) - i, nil
}
func (m *Const_U64Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_U64Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.U64Val))
	i--
	dAtA[i] = 0x48
	return len(dAtA) - i, nil
}
func (m *Const_Dval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Dval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Dval))))
	i--
	dAtA[i] = 0x51
	return len(dAtA) - i, nil
}
func (m *Const_Sval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Sval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Sval)
	copy(dAtA[i:], m.Sval)
	i = encodeVarintPlan(dAtA, i, uint64(len(m.Sval)))
	i--
	dAtA[i] = 0x5a
	return len(dAtA) - i, nil
}
func (m *Const_Bval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Bval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Bval {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x60
	return len(dAtA) - i, nil
}
func (m *Const_Fval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Fval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Fval))))
	i--
	dAtA[i] = 0x6d
	return len(dAtA) - i, nil
}
func (m *Const_Dateval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Dateval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.Dateval))
	i--
	dAtA[i] = 0x70
	return len(dAtA) - i, nil
}
func (m *Const_Timeval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Timeval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.Timeval))
	i--
	dAtA[i] = 0x78
	return len(dAtA) - i, nil
}
func (m *Const_Datetimeval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Datetimeval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.Datetimeval))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	return len(dAtA) - i, nil
}
func (m *Const_Decimal64Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Decimal64Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Decimal64Val != nil {
		{
			size, err := m.Decimal64Val.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *Const_Decimal128Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Decimal128Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Decimal128Val != nil {
		{
			size, err := m.Decimal128Val.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *Const_Timestampval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Timestampval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.Timestampval))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x98
	return len(dAtA) - i, nil
}
func (m *Const_Jsonval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Jsonval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Jsonval)
	copy(dAtA[i:], m.Jsonval)
	i = encodeVarintPlan(dAtA, i, uint64(len(m.Jsonval)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa2
	return len(dAtA) - i, nil
}
func (m *Const_Defaultval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Defaultval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Defaultval {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa8
	return len(dAtA) - i, nil
}
func (m *Const_UpdateVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_UpdateVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.UpdateVal {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb0
	return len(dAtA) - i, nil
}
func (m *ParamRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParamRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParamRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Pos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Pos))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VarRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VarRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VarRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Global {
		i--
		if m.Global {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.System {
		i--
		if m.System {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ColRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ColPos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ColPos))
		i--
		dAtA[i] = 0x10
	}
	if m.RelPos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RelPos))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CorrColRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CorrColRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CorrColRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Depth != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Depth))
		i--
		dAtA[i] = 0x18
	}
	if m.ColPos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ColPos))
		i--
		dAtA[i] = 0x10
	}
	if m.RelPos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RelPos))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExprList) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExprList) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExprList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MaxValue) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaxValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaxValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TargetType) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TargetType) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TargetType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Typ != nil {
		{
			size, err := m.Typ.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubqueryRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubqueryRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubqueryRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RowSize != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RowSize))
		i--
		dAtA[i] = 0x28
	}
	if m.Child != nil {
		{
			size, err := m.Child.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Op) > 0 {
		i -= len(m.Op)
		copy(dAtA[i:], m.Op)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Op)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NodeId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x10
	}
	if m.Typ != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Typ))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ObjectRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ObjName) > 0 {
		i -= len(m.ObjName)
		copy(dAtA[i:], m.ObjName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ObjName)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SchemaName) > 0 {
		i -= len(m.SchemaName)
		copy(dAtA[i:], m.SchemaName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.SchemaName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ServerName) > 0 {
		i -= len(m.ServerName)
		copy(dAtA[i:], m.ServerName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ServerName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Obj != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Obj))
		i--
		dAtA[i] = 0x20
	}
	if m.Schema != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Schema))
		i--
		dAtA[i] = 0x18
	}
	if m.Db != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Db))
		i--
		dAtA[i] = 0x10
	}
	if m.Server != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Server))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Function) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Function) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Function) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Args[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Func != nil {
		{
			size, err := m.Func.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Expr) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Expr) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Expr != nil {
		{
			size := m.Expr.ProtoSize()
			i -= size
			if _, err := m.Expr.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Typ != nil {
		{
			size, err := m.Typ.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Expr_C) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_C) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.C != nil {
		{
			size, err := m.C.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Expr_P) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_P) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.P != nil {
		{
			size, err := m.P.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Expr_V) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_V) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.V != nil {
		{
			size, err := m.V.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Expr_Col) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_Col) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Col != nil {
		{
			size, err := m.Col.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Expr_F) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_F) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.F != nil {
		{
			size, err := m.F.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Expr_Sub) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_Sub) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Sub != nil {
		{
			size, err := m.Sub.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Expr_Corr) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_Corr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Corr != nil {
		{
			size, err := m.Corr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Expr_T) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_T) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.T != nil {
		{
			size, err := m.T.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Expr_List) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_List) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.List != nil {
		{
			size, err := m.List.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *Expr_Max) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_Max) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Max != nil {
		{
			size, err := m.Max.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *Decimal64) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Decimal64) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Decimal64) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.A != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.A))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Decimal128) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Decimal128) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Decimal128) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.B != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.B))
		i--
		dAtA[i] = 0x10
	}
	if m.A != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.A))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LowCardinality {
		i--
		if m.LowCardinality {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.OnUpdate != nil {
		{
			size, err := m.OnUpdate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.IsCPkey {
		i--
		if m.IsCPkey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Pkidx != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Pkidx))
		i--
		dAtA[i] = 0x30
	}
	if m.Primary {
		i--
		if m.Primary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Default != nil {
		{
			size, err := m.Default.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Typ != nil {
		{
			size, err := m.Typ.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Alg != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Alg))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Default) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Default) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Default) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OriginString) > 0 {
		i -= len(m.OriginString)
		copy(dAtA[i:], m.OriginString)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.OriginString)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NullAbility {
		i--
		if m.NullAbility {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OnUpdate) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OnUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OriginString) > 0 {
		i -= len(m.OriginString)
		copy(dAtA[i:], m.OriginString)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.OriginString)))
		i--
		dAtA[i] = 0x12
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PrimaryKeyDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrimaryKeyDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrimaryKeyDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Names) > 0 {
		for iNdEx := len(m.Names) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Names[iNdEx])
			copy(dAtA[i:], m.Names[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.Names[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Property) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Property) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Property) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PropertiesDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropertiesDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PropertiesDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Properties) > 0 {
		for iNdEx := len(m.Properties) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Properties[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PartitionInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PartitionMsg) > 0 {
		i -= len(m.PartitionMsg)
		copy(dAtA[i:], m.PartitionMsg)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionMsg)))
		i--
		dAtA[i] = 0x52
	}
	if m.IsSubPartition {
		i--
		if m.IsSubPartition {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Algorithm != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Algorithm))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Partitions) > 0 {
		for iNdEx := len(m.Partitions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Partitions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.PartitionNum != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.PartitionNum))
		i--
		dAtA[i] = 0x30
	}
	if len(m.PartitionColumns) > 0 {
		for iNdEx := len(m.PartitionColumns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionColumns[iNdEx])
			copy(dAtA[i:], m.PartitionColumns[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionColumns[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.PartitionExpression != nil {
		{
			size, err := m.PartitionExpression.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PartitionItem) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.InValues) > 0 {
		for iNdEx := len(m.InValues) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InValues[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.LessThan) > 0 {
		for iNdEx := len(m.LessThan) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LessThan[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OrdinalPosition != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.OrdinalPosition))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PartitionName) > 0 {
		i -= len(m.PartitionName)
		copy(dAtA[i:], m.PartitionName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ViewDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ViewDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.View) > 0 {
		i -= len(m.View)
		copy(dAtA[i:], m.View)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.View)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IndexDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fields[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Uniques) > 0 {
		for iNdEx := len(m.Uniques) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.Uniques[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Uniques)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TableNames) > 0 {
		for iNdEx := len(m.TableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TableNames[iNdEx])
			copy(dAtA[i:], m.TableNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.TableNames[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.IndexNames) > 0 {
		for iNdEx := len(m.IndexNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IndexNames[iNdEx])
			copy(dAtA[i:], m.IndexNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexNames[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Field) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Field) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Field) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ColNames) > 0 {
		for iNdEx := len(m.ColNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ColNames[iNdEx])
			copy(dAtA[i:], m.ColNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.ColNames[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IndexInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Field != nil {
		{
			size, err := m.Field.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Cols) > 0 {
		for iNdEx := len(m.Cols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ColNames) > 0 {
		for iNdEx := len(m.ColNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ColNames[iNdEx])
			copy(dAtA[i:], m.ColNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.ColNames[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IndexInfos) > 0 {
		for iNdEx := len(m.IndexInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IndexInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.TblFunc != nil {
		{
			size, err := m.TblFunc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.CompositePkey != nil {
		{
			size, err := m.CompositePkey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Name2ColIndex) > 0 {
		for k := range m.Name2ColIndex {
			v := m.Name2ColIndex[k]
			baseI := i
			i = encodeVarintPlan(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPlan(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPlan(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Createsql) > 0 {
		i -= len(m.Createsql)
		copy(dAtA[i:], m.Createsql)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Createsql)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TableType) > 0 {
		i -= len(m.TableType)
		copy(dAtA[i:], m.TableType)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TableType)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Defs) > 0 {
		for iNdEx := len(m.Defs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Defs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Cols) > 0 {
		for iNdEx := len(m.Cols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableDef_DefType) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDef_DefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDef_DefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Def != nil {
		{
			size := m.Def.ProtoSize()
			i -= size
			if _, err := m.Def.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *TableDef_DefType_Pk) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDef_DefType_Pk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Pk != nil {
		{
			size, err := m.Pk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *TableDef_DefType_Idx) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDef_DefType_Idx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Idx != nil {
		{
			size, err := m.Idx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *TableDef_DefType_Properties) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDef_DefType_Properties) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Properties != nil {
		{
			size, err := m.Properties.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *TableDef_DefType_View) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDef_DefType_View) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.View != nil {
		{
			size, err := m.View.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *TableDef_DefType_Partition) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDef_DefType_Partition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Partition != nil {
		{
			size, err := m.Partition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *TableFunction) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableFunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableFunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Param) > 0 {
		i -= len(m.Param)
		copy(dAtA[i:], m.Param)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Param)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Cost) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cost) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cost) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Total != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Total))))
		i--
		dAtA[i] = 0x29
	}
	if m.Start != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Start))))
		i--
		dAtA[i] = 0x21
	}
	if m.Ndv != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Ndv))))
		i--
		dAtA[i] = 0x19
	}
	if m.Rowsize != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Rowsize))))
		i--
		dAtA[i] = 0x11
	}
	if m.Card != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Card))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *ColData) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColData) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.S) > 0 {
		for iNdEx := len(m.S) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.S[iNdEx])
			copy(dAtA[i:], m.S[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.S[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.F64) > 0 {
		for iNdEx := len(m.F64) - 1; iNdEx >= 0; iNdEx-- {
			f32 := math.Float64bits(float64(m.F64[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f32))
		}
		i = encodeVarintPlan(dAtA, i, uint64(len(m.F64)*8))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.F32) > 0 {
		for iNdEx := len(m.F32) - 1; iNdEx >= 0; iNdEx-- {
			f33 := math.Float32bits(float32(m.F32[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f33))
		}
		i = encodeVarintPlan(dAtA, i, uint64(len(m.F32)*4))
		i--
		dAtA[i] = 0x32
	}
	if len(m.I64) > 0 {
		dAtA35 := make([]byte, len(m.I64)*10)
		var j34 int
		for _, num1 := range m.I64 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA35[j34] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j34++
			}
			dAtA35[j34] = uint8(num)
			j34++
		}
		i -= j34
		copy(dAtA[i:], dAtA35[:j34])
		i = encodeVarintPlan(dAtA, i, uint64(j34))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.I32) > 0 {
		dAtA37 := make([]byte, len(m.I32)*10)
		var j36 int
		for _, num1 := range m.I32 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA37[j36] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j36++
			}
			dAtA37[j36] = uint8(num)
			j36++
		}
		i -= j36
		copy(dAtA[i:], dAtA37[:j36])
		i = encodeVarintPlan(dAtA, i, uint64(j36))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Nulls) > 0 {
		for iNdEx := len(m.Nulls) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.Nulls[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Nulls)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NullCount != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.NullCount))
		i--
		dAtA[i] = 0x10
	}
	if m.RowCount != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RowCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RowsetData) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowsetData) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowsetData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cols) > 0 {
		for iNdEx := len(m.Cols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Schema != nil {
		{
			size, err := m.Schema.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OrderBySpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderBySpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderBySpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Flag != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Flag))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Collation) > 0 {
		i -= len(m.Collation)
		copy(dAtA[i:], m.Collation)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Collation)))
		i--
		dAtA[i] = 0x12
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WindowSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WindowSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Lag != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Lag))
		i--
		dAtA[i] = 0x20
	}
	if m.Lead != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Lead))
		i--
		dAtA[i] = 0x18
	}
	if len(m.OrderBy) > 0 {
		for iNdEx := len(m.OrderBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OrderBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PartitionBy) > 0 {
		for iNdEx := len(m.PartitionBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PartitionBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpdateCtx) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateCtx) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateCtx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IndexAttrs) > 0 {
		for iNdEx := len(m.IndexAttrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IndexAttrs[iNdEx])
			copy(dAtA[i:], m.IndexAttrs[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexAttrs[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.CompositePkey != nil {
		{
			size, err := m.CompositePkey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.OrderAttrs) > 0 {
		for iNdEx := len(m.OrderAttrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OrderAttrs[iNdEx])
			copy(dAtA[i:], m.OrderAttrs[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.OrderAttrs[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.OtherAttrs) > 0 {
		for iNdEx := len(m.OtherAttrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OtherAttrs[iNdEx])
			copy(dAtA[i:], m.OtherAttrs[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.OtherAttrs[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.UpdateCols) > 0 {
		for iNdEx := len(m.UpdateCols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UpdateCols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.HideKeyIdx != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.HideKeyIdx))
		i--
		dAtA[i] = 0x30
	}
	if len(m.HideKey) > 0 {
		i -= len(m.HideKey)
		copy(dAtA[i:], m.HideKey)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.HideKey)))
		i--
		dAtA[i] = 0x2a
	}
	if m.PriKeyIdx != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.PriKeyIdx))
		i--
		dAtA[i] = 0x20
	}
	if len(m.PriKey) > 0 {
		i -= len(m.PriKey)
		copy(dAtA[i:], m.PriKey)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.PriKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TblName) > 0 {
		i -= len(m.TblName)
		copy(dAtA[i:], m.TblName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TblName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AnalyzeInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalyzeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnalyzeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MemorySize != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.MemorySize))
		i--
		dAtA[i] = 0x30
	}
	if m.TimeConsumed != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TimeConsumed))
		i--
		dAtA[i] = 0x28
	}
	if m.OutputSize != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.OutputSize))
		i--
		dAtA[i] = 0x20
	}
	if m.InputSize != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.InputSize))
		i--
		dAtA[i] = 0x18
	}
	if m.OutputRows != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.OutputRows))
		i--
		dAtA[i] = 0x10
	}
	if m.InputRows != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.InputRows))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TblFuncExprList) > 0 {
		for iNdEx := len(m.TblFuncExprList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TblFuncExprList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	if m.AnalyzeInfo != nil {
		{
			size, err := m.AnalyzeInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.BindingTags) > 0 {
		dAtA43 := make([]byte, len(m.BindingTags)*10)
		var j42 int
		for _, num1 := range m.BindingTags {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA43[j42] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j42++
			}
			dAtA43[j42] = uint8(num)
			j42++
		}
		i -= j42
		copy(dAtA[i:], dAtA43[:j42])
		i = encodeVarintPlan(dAtA, i, uint64(j42))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.DeleteTablesCtx) > 0 {
		for iNdEx := len(m.DeleteTablesCtx) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DeleteTablesCtx[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.ExtraOptions) > 0 {
		i -= len(m.ExtraOptions)
		copy(dAtA[i:], m.ExtraOptions)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ExtraOptions)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.RowsetData != nil {
		{
			size, err := m.RowsetData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.ObjRef != nil {
		{
			size, err := m.ObjRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.TableDefVec) > 0 {
		for iNdEx := len(m.TableDefVec) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TableDefVec[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.Offset != nil {
		{
			size, err := m.Offset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Limit != nil {
		{
			size, err := m.Limit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.WinSpec != nil {
		{
			size, err := m.WinSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if len(m.UpdateCtxs) > 0 {
		for iNdEx := len(m.UpdateCtxs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UpdateCtxs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.OrderBy) > 0 {
		for iNdEx := len(m.OrderBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OrderBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.AggList) > 0 {
		for iNdEx := len(m.AggList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AggList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.GroupingSet) > 0 {
		for iNdEx := len(m.GroupingSet) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GroupingSet[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.GroupBy) > 0 {
		for iNdEx := len(m.GroupBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GroupBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.FilterList) > 0 {
		for iNdEx := len(m.FilterList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FilterList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.OnList) > 0 {
		for iNdEx := len(m.OnList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OnList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.JoinType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.JoinType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Children) > 0 {
		dAtA51 := make([]byte, len(m.Children)*10)
		var j50 int
		for _, num1 := range m.Children {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA51[j50] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j50++
			}
			dAtA51[j50] = uint8(num)
			j50++
		}
		i -= j50
		copy(dAtA[i:], dAtA51[:j50])
		i = encodeVarintPlan(dAtA, i, uint64(j50))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ProjectList) > 0 {
		for iNdEx := len(m.ProjectList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProjectList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Cost != nil {
		{
			size, err := m.Cost.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.NodeId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x10
	}
	if m.NodeType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.NodeType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteTableCtx) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteTableCtx) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteTableCtx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IndexAttrs) > 0 {
		for iNdEx := len(m.IndexAttrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IndexAttrs[iNdEx])
			copy(dAtA[i:], m.IndexAttrs[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexAttrs[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.IndexInfos) > 0 {
		for iNdEx := len(m.IndexInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IndexInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.ColIndex != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ColIndex))
		i--
		dAtA[i] = 0x28
	}
	if m.CanTruncate {
		i--
		if m.CanTruncate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.UseDeleteKey) > 0 {
		i -= len(m.UseDeleteKey)
		copy(dAtA[i:], m.UseDeleteKey)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.UseDeleteKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TblName) > 0 {
		i -= len(m.TblName)
		copy(dAtA[i:], m.TblName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TblName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Query) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Query) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Query) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LoadTag {
		i--
		if m.LoadTag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Headings) > 0 {
		for iNdEx := len(m.Headings) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Headings[iNdEx])
			copy(dAtA[i:], m.Headings[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.Headings[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Params) > 0 {
		for iNdEx := len(m.Params) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Params[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Steps) > 0 {
		dAtA54 := make([]byte, len(m.Steps)*10)
		var j53 int
		for _, num1 := range m.Steps {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA54[j53] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j53++
			}
			dAtA54[j53] = uint8(num)
			j53++
		}
		i -= j53
		copy(dAtA[i:], dAtA54[:j53])
		i = encodeVarintPlan(dAtA, i, uint64(j53))
		i--
		dAtA[i] = 0x12
	}
	if m.StmtType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.StmtType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransationControl) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransationControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Action != nil {
		{
			size := m.Action.ProtoSize()
			i -= size
			if _, err := m.Action.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TclType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TclType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransationControl_Begin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationControl_Begin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Begin != nil {
		{
			size, err := m.Begin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *TransationControl_Commit) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationControl_Commit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *TransationControl_Rollback) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationControl_Rollback) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Rollback != nil {
		{
			size, err := m.Rollback.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *TransationBegin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransationBegin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationBegin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mode != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransationCommit) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransationCommit) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationCommit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CompletionType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.CompletionType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransationRollback) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransationRollback) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationRollback) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CompletionType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.CompletionType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Plan) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Plan) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Plan != nil {
		{
			size := m.Plan.ProtoSize()
			i -= size
			if _, err := m.Plan.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Plan_Query) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan_Query) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Plan_Tcl) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan_Tcl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Tcl != nil {
		{
			size, err := m.Tcl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Plan_Ddl) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan_Ddl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ddl != nil {
		{
			size, err := m.Ddl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Plan_Dcl) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan_Dcl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Dcl != nil {
		{
			size, err := m.Dcl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Plan_Ins) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan_Ins) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ins != nil {
		{
			size, err := m.Ins.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *InsertValues) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsertValues) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InsertValues) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IndexInfos) > 0 {
		for iNdEx := len(m.IndexInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IndexInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.CompositePkey != nil {
		{
			size, err := m.CompositePkey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.OrderAttrs) > 0 {
		for iNdEx := len(m.OrderAttrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OrderAttrs[iNdEx])
			copy(dAtA[i:], m.OrderAttrs[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.OrderAttrs[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.OtherCols) > 0 {
		for iNdEx := len(m.OtherCols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OtherCols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ExplicitCols) > 0 {
		for iNdEx := len(m.ExplicitCols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExplicitCols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.TblName) > 0 {
		i -= len(m.TblName)
		copy(dAtA[i:], m.TblName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TblName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Column) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Column) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Column) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Column) > 0 {
		for iNdEx := len(m.Column) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Column[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataControl) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Control != nil {
		{
			size := m.Control.ProtoSize()
			i -= size
			if _, err := m.Control.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DclType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.DclType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataControl_SetVariables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataControl_SetVariables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SetVariables != nil {
		{
			size, err := m.SetVariables.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *DataControl_Prepare) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataControl_Prepare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Prepare != nil {
		{
			size, err := m.Prepare.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DataControl_Execute) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataControl_Execute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Execute != nil {
		{
			size, err := m.Execute.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DataControl_Deallocate) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataControl_Deallocate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Deallocate != nil {
		{
			size, err := m.Deallocate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataDefinition) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Definition != nil {
		{
			size := m.Definition.ProtoSize()
			i -= size
			if _, err := m.Definition.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.DdlType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.DdlType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataDefinition_CreateDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_CreateDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateDatabase != nil {
		{
			size, err := m.CreateDatabase.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_AlterDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_AlterDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterDatabase != nil {
		{
			size, err := m.AlterDatabase.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_DropDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_DropDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DropDatabase != nil {
		{
			size, err := m.DropDatabase.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_CreateTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_CreateTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateTable != nil {
		{
			size, err := m.CreateTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_AlterTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_AlterTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterTable != nil {
		{
			size, err := m.AlterTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_DropTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_DropTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DropTable != nil {
		{
			size, err := m.DropTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_CreateIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_CreateIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateIndex != nil {
		{
			size, err := m.CreateIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_AlterIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_AlterIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterIndex != nil {
		{
			size, err := m.AlterIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_DropIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_DropIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DropIndex != nil {
		{
			size, err := m.DropIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_TruncateTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_TruncateTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TruncateTable != nil {
		{
			size, err := m.TruncateTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_ShowVariables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_ShowVariables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ShowVariables != nil {
		{
			size, err := m.ShowVariables.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *CreateDatabase) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfNotExists {
		i--
		if m.IfNotExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlterDatabase) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfExists {
		i--
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DropDatabase) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfExists {
		i--
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateTable) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IndexTables) > 0 {
		for iNdEx := len(m.IndexTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IndexTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Temporary {
		i--
		if m.Temporary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.IfNotExists {
		i--
		if m.IfNotExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlterTable) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DropTable) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IndexTableNames) > 0 {
		for iNdEx := len(m.IndexTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IndexTableNames[iNdEx])
			copy(dAtA[i:], m.IndexTableNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexTableNames[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfExists {
		i--
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Index) > 0 {
		i -= len(m.Index)
		copy(dAtA[i:], m.Index)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Index)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfNotExists {
		i--
		if m.IfNotExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlterIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Index) > 0 {
		i -= len(m.Index)
		copy(dAtA[i:], m.Index)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Index)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DropIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Index) > 0 {
		i -= len(m.Index)
		copy(dAtA[i:], m.Index)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Index)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfExists {
		i--
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TruncateTable) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TruncateTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TruncateTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IndexTableNames) > 0 {
		for iNdEx := len(m.IndexTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IndexTableNames[iNdEx])
			copy(dAtA[i:], m.IndexTableNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexTableNames[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShowVariables) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowVariables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShowVariables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Where) > 0 {
		for iNdEx := len(m.Where) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Where[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Global {
		i--
		if m.Global {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetVariables) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetVariables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetVariables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SetVariablesItem) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetVariablesItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetVariablesItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Reserved != nil {
		{
			size, err := m.Reserved.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Global {
		i--
		if m.Global {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.System {
		i--
		if m.System {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Prepare) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Prepare) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Prepare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ParamTypes) > 0 {
		dAtA85 := make([]byte, len(m.ParamTypes)*10)
		var j84 int
		for _, num1 := range m.ParamTypes {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA85[j84] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j84++
			}
			dAtA85[j84] = uint8(num)
			j84++
		}
		i -= j84
		copy(dAtA[i:], dAtA85[:j84])
		i = encodeVarintPlan(dAtA, i, uint64(j84))
		i--
		dAtA[i] = 0x22
	}
	if m.Plan != nil {
		{
			size, err := m.Plan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Schemas) > 0 {
		for iNdEx := len(m.Schemas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Schemas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Execute) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Execute) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Execute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Args[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Deallocate) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deallocate) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Deallocate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPlan(dAtA []byte, offset int, v uint64) int {
	offset -= sovPlan(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Type) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlan(uint64(m.Id))
	}
	if m.Nullable {
		n += 2
	}
	if m.AutoIncr {
		n += 2
	}
	if m.Width != 0 {
		n += 1 + sovPlan(uint64(m.Width))
	}
	if m.Precision != 0 {
		n += 1 + sovPlan(uint64(m.Precision))
	}
	if m.Size != 0 {
		n += 1 + sovPlan(uint64(m.Size))
	}
	if m.Scale != 0 {
		n += 1 + sovPlan(uint64(m.Scale))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Const) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Isnull {
		n += 2
	}
	if m.Value != nil {
		n += m.Value.ProtoSize()
	}
	if m.IsBin {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Const_I8Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.I8Val))
	return n
}
func (m *Const_I16Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.I16Val))
	return n
}
func (m *Const_I32Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.I32Val))
	return n
}
func (m *Const_I64Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.I64Val))
	return n
}
func (m *Const_U8Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.U8Val))
	return n
}
func (m *Const_U16Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.U16Val))
	return n
}
func (m *Const_U32Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.U32Val))
	return n
}
func (m *Const_U64Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.U64Val))
	return n
}
func (m *Const_Dval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *Const_Sval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sval)
	n += 1 + l + sovPlan(uint64(l))
	return n
}
func (m *Const_Bval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *Const_Fval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	return n
}
func (m *Const_Dateval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.Dateval))
	return n
}
func (m *Const_Timeval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.Timeval))
	return n
}
func (m *Const_Datetimeval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sovPlan(uint64(m.Datetimeval))
	return n
}
func (m *Const_Decimal64Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Decimal64Val != nil {
		l = m.Decimal64Val.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Const_Decimal128Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Decimal128Val != nil {
		l = m.Decimal128Val.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Const_Timestampval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sovPlan(uint64(m.Timestampval))
	return n
}
func (m *Const_Jsonval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Jsonval)
	n += 2 + l + sovPlan(uint64(l))
	return n
}
func (m *Const_Defaultval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 3
	return n
}
func (m *Const_UpdateVal) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 3
	return n
}
func (m *ParamRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pos != 0 {
		n += 1 + sovPlan(uint64(m.Pos))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VarRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.System {
		n += 2
	}
	if m.Global {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RelPos != 0 {
		n += 1 + sovPlan(uint64(m.RelPos))
	}
	if m.ColPos != 0 {
		n += 1 + sovPlan(uint64(m.ColPos))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CorrColRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RelPos != 0 {
		n += 1 + sovPlan(uint64(m.RelPos))
	}
	if m.ColPos != 0 {
		n += 1 + sovPlan(uint64(m.ColPos))
	}
	if m.Depth != 0 {
		n += 1 + sovPlan(uint64(m.Depth))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExprList) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MaxValue) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TargetType) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Typ != nil {
		l = m.Typ.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubqueryRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Typ != 0 {
		n += 1 + sovPlan(uint64(m.Typ))
	}
	if m.NodeId != 0 {
		n += 1 + sovPlan(uint64(m.NodeId))
	}
	l = len(m.Op)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Child != nil {
		l = m.Child.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.RowSize != 0 {
		n += 1 + sovPlan(uint64(m.RowSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Server != 0 {
		n += 1 + sovPlan(uint64(m.Server))
	}
	if m.Db != 0 {
		n += 1 + sovPlan(uint64(m.Db))
	}
	if m.Schema != 0 {
		n += 1 + sovPlan(uint64(m.Schema))
	}
	if m.Obj != 0 {
		n += 1 + sovPlan(uint64(m.Obj))
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.SchemaName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.ObjName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Function) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Func != nil {
		l = m.Func.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, e := range m.Args {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Expr) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Typ != nil {
		l = m.Typ.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Expr != nil {
		n += m.Expr.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Expr_C) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.C != nil {
		l = m.C.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_P) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.P != nil {
		l = m.P.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_V) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.V != nil {
		l = m.V.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_Col) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Col != nil {
		l = m.Col.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_F) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.F != nil {
		l = m.F.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_Sub) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sub != nil {
		l = m.Sub.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_Corr) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Corr != nil {
		l = m.Corr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_T) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.T != nil {
		l = m.T.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_List) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.List != nil {
		l = m.List.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_Max) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Max != nil {
		l = m.Max.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Decimal64) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A != 0 {
		n += 1 + sovPlan(uint64(m.A))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Decimal128) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A != 0 {
		n += 1 + sovPlan(uint64(m.A))
	}
	if m.B != 0 {
		n += 1 + sovPlan(uint64(m.B))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Alg != 0 {
		n += 1 + sovPlan(uint64(m.Alg))
	}
	if m.Typ != nil {
		l = m.Typ.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Default != nil {
		l = m.Default.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Primary {
		n += 2
	}
	if m.Pkidx != 0 {
		n += 1 + sovPlan(uint64(m.Pkidx))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.IsCPkey {
		n += 2
	}
	if m.OnUpdate != nil {
		l = m.OnUpdate.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.LowCardinality {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Default) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NullAbility {
		n += 2
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.OriginString)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OnUpdate) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.OriginString)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrimaryKeyDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Property) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PropertiesDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Properties) > 0 {
		for _, e := range m.Properties {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPlan(uint64(m.Type))
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.PartitionExpression != nil {
		l = m.PartitionExpression.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.PartitionColumns) > 0 {
		for _, s := range m.PartitionColumns {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.PartitionNum != 0 {
		n += 1 + sovPlan(uint64(m.PartitionNum))
	}
	if len(m.Partitions) > 0 {
		for _, e := range m.Partitions {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Algorithm != 0 {
		n += 1 + sovPlan(uint64(m.Algorithm))
	}
	if m.IsSubPartition {
		n += 2
	}
	l = len(m.PartitionMsg)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionItem) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PartitionName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.OrdinalPosition != 0 {
		n += 1 + sovPlan(uint64(m.OrdinalPosition))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.LessThan) > 0 {
		for _, e := range m.LessThan {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.InValues) > 0 {
		for _, e := range m.InValues {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ViewDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.View)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IndexDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IndexNames) > 0 {
		for _, s := range m.IndexNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.TableNames) > 0 {
		for _, s := range m.TableNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Uniques) > 0 {
		n += 1 + sovPlan(uint64(len(m.Uniques))) + len(m.Uniques)*1
	}
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Field) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ColNames) > 0 {
		for _, s := range m.ColNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IndexInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.ColNames) > 0 {
		for _, s := range m.ColNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Cols) > 0 {
		for _, e := range m.Cols {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Field != nil {
		l = m.Field.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Cols) > 0 {
		for _, e := range m.Cols {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Defs) > 0 {
		for _, e := range m.Defs {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	l = len(m.TableType)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Createsql)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Name2ColIndex) > 0 {
		for k, v := range m.Name2ColIndex {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPlan(uint64(len(k))) + 1 + sovPlan(uint64(v))
			n += mapEntrySize + 1 + sovPlan(uint64(mapEntrySize))
		}
	}
	if m.CompositePkey != nil {
		l = m.CompositePkey.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TblFunc != nil {
		l = m.TblFunc.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.IndexInfos) > 0 {
		for _, e := range m.IndexInfos {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableDef_DefType) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Def != nil {
		n += m.Def.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableDef_DefType_Pk) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pk != nil {
		l = m.Pk.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TableDef_DefType_Idx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Idx != nil {
		l = m.Idx.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TableDef_DefType_Properties) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Properties != nil {
		l = m.Properties.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TableDef_DefType_View) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.View != nil {
		l = m.View.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TableDef_DefType_Partition) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Partition != nil {
		l = m.Partition.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TableFunction) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Param)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cost) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Card != 0 {
		n += 9
	}
	if m.Rowsize != 0 {
		n += 9
	}
	if m.Ndv != 0 {
		n += 9
	}
	if m.Start != 0 {
		n += 9
	}
	if m.Total != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColData) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RowCount != 0 {
		n += 1 + sovPlan(uint64(m.RowCount))
	}
	if m.NullCount != 0 {
		n += 1 + sovPlan(uint64(m.NullCount))
	}
	if len(m.Nulls) > 0 {
		n += 1 + sovPlan(uint64(len(m.Nulls))) + len(m.Nulls)*1
	}
	if len(m.I32) > 0 {
		l = 0
		for _, e := range m.I32 {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.I64) > 0 {
		l = 0
		for _, e := range m.I64 {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.F32) > 0 {
		n += 1 + sovPlan(uint64(len(m.F32)*4)) + len(m.F32)*4
	}
	if len(m.F64) > 0 {
		n += 1 + sovPlan(uint64(len(m.F64)*8)) + len(m.F64)*8
	}
	if len(m.S) > 0 {
		for _, s := range m.S {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RowsetData) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Schema != nil {
		l = m.Schema.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Cols) > 0 {
		for _, e := range m.Cols {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrderBySpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Collation)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Flag != 0 {
		n += 1 + sovPlan(uint64(m.Flag))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WindowSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PartitionBy) > 0 {
		for _, e := range m.PartitionBy {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OrderBy) > 0 {
		for _, e := range m.OrderBy {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Lead != 0 {
		n += 1 + sovPlan(uint64(m.Lead))
	}
	if m.Lag != 0 {
		n += 1 + sovPlan(uint64(m.Lag))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateCtx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.TblName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.PriKey)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.PriKeyIdx != 0 {
		n += 1 + sovPlan(uint64(m.PriKeyIdx))
	}
	l = len(m.HideKey)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.HideKeyIdx != 0 {
		n += 1 + sovPlan(uint64(m.HideKeyIdx))
	}
	if len(m.UpdateCols) > 0 {
		for _, e := range m.UpdateCols {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OtherAttrs) > 0 {
		for _, s := range m.OtherAttrs {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OrderAttrs) > 0 {
		for _, s := range m.OrderAttrs {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.CompositePkey != nil {
		l = m.CompositePkey.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.IndexAttrs) > 0 {
		for _, s := range m.IndexAttrs {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnalyzeInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InputRows != 0 {
		n += 1 + sovPlan(uint64(m.InputRows))
	}
	if m.OutputRows != 0 {
		n += 1 + sovPlan(uint64(m.OutputRows))
	}
	if m.InputSize != 0 {
		n += 1 + sovPlan(uint64(m.InputSize))
	}
	if m.OutputSize != 0 {
		n += 1 + sovPlan(uint64(m.OutputSize))
	}
	if m.TimeConsumed != 0 {
		n += 1 + sovPlan(uint64(m.TimeConsumed))
	}
	if m.MemorySize != 0 {
		n += 1 + sovPlan(uint64(m.MemorySize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Node) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeType != 0 {
		n += 1 + sovPlan(uint64(m.NodeType))
	}
	if m.NodeId != 0 {
		n += 1 + sovPlan(uint64(m.NodeId))
	}
	if m.Cost != nil {
		l = m.Cost.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.ProjectList) > 0 {
		for _, e := range m.ProjectList {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Children) > 0 {
		l = 0
		for _, e := range m.Children {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.JoinType != 0 {
		n += 1 + sovPlan(uint64(m.JoinType))
	}
	if len(m.OnList) > 0 {
		for _, e := range m.OnList {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.FilterList) > 0 {
		for _, e := range m.FilterList {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.GroupBy) > 0 {
		for _, e := range m.GroupBy {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.GroupingSet) > 0 {
		for _, e := range m.GroupingSet {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.AggList) > 0 {
		for _, e := range m.AggList {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OrderBy) > 0 {
		for _, e := range m.OrderBy {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.UpdateCtxs) > 0 {
		for _, e := range m.UpdateCtxs {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.WinSpec != nil {
		l = m.WinSpec.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Limit != nil {
		l = m.Limit.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Offset != nil {
		l = m.Offset.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if len(m.TableDefVec) > 0 {
		for _, e := range m.TableDefVec {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if m.ObjRef != nil {
		l = m.ObjRef.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.RowsetData != nil {
		l = m.RowsetData.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	l = len(m.ExtraOptions)
	if l > 0 {
		n += 2 + l + sovPlan(uint64(l))
	}
	if len(m.DeleteTablesCtx) > 0 {
		for _, e := range m.DeleteTablesCtx {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if len(m.BindingTags) > 0 {
		l = 0
		for _, e := range m.BindingTags {
			l += sovPlan(uint64(e))
		}
		n += 2 + sovPlan(uint64(l)) + l
	}
	if m.AnalyzeInfo != nil {
		l = m.AnalyzeInfo.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if len(m.TblFuncExprList) > 0 {
		for _, e := range m.TblFuncExprList {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteTableCtx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.TblName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.UseDeleteKey)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.CanTruncate {
		n += 2
	}
	if m.ColIndex != 0 {
		n += 1 + sovPlan(uint64(m.ColIndex))
	}
	if len(m.IndexInfos) > 0 {
		for _, e := range m.IndexInfos {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.IndexAttrs) > 0 {
		for _, s := range m.IndexAttrs {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Query) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StmtType != 0 {
		n += 1 + sovPlan(uint64(m.StmtType))
	}
	if len(m.Steps) > 0 {
		l = 0
		for _, e := range m.Steps {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Params) > 0 {
		for _, e := range m.Params {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Headings) > 0 {
		for _, s := range m.Headings {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.LoadTag {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransationControl) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TclType != 0 {
		n += 1 + sovPlan(uint64(m.TclType))
	}
	if m.Action != nil {
		n += m.Action.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransationControl_Begin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Begin != nil {
		l = m.Begin.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TransationControl_Commit) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TransationControl_Rollback) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rollback != nil {
		l = m.Rollback.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TransationBegin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovPlan(uint64(m.Mode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransationCommit) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompletionType != 0 {
		n += 1 + sovPlan(uint64(m.CompletionType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransationRollback) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompletionType != 0 {
		n += 1 + sovPlan(uint64(m.CompletionType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Plan) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Plan != nil {
		n += m.Plan.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Plan_Query) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Query != nil {
		l = m.Query.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Plan_Tcl) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tcl != nil {
		l = m.Tcl.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Plan_Ddl) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ddl != nil {
		l = m.Ddl.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Plan_Dcl) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dcl != nil {
		l = m.Dcl.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Plan_Ins) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ins != nil {
		l = m.Ins.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *InsertValues) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.TblName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.ExplicitCols) > 0 {
		for _, e := range m.ExplicitCols {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OtherCols) > 0 {
		for _, e := range m.OtherCols {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OrderAttrs) > 0 {
		for _, s := range m.OrderAttrs {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.CompositePkey != nil {
		l = m.CompositePkey.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.IndexInfos) > 0 {
		for _, e := range m.IndexInfos {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Column) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Column) > 0 {
		for _, e := range m.Column {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataControl) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DclType != 0 {
		n += 1 + sovPlan(uint64(m.DclType))
	}
	if m.Control != nil {
		n += m.Control.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataControl_SetVariables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SetVariables != nil {
		l = m.SetVariables.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataControl_Prepare) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prepare != nil {
		l = m.Prepare.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataControl_Execute) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Execute != nil {
		l = m.Execute.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataControl_Deallocate) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Deallocate != nil {
		l = m.Deallocate.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DdlType != 0 {
		n += 1 + sovPlan(uint64(m.DdlType))
	}
	if m.Query != nil {
		l = m.Query.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Definition != nil {
		n += m.Definition.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataDefinition_CreateDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateDatabase != nil {
		l = m.CreateDatabase.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_AlterDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterDatabase != nil {
		l = m.AlterDatabase.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_DropDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropDatabase != nil {
		l = m.DropDatabase.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_CreateTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateTable != nil {
		l = m.CreateTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_AlterTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterTable != nil {
		l = m.AlterTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_DropTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropTable != nil {
		l = m.DropTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_CreateIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateIndex != nil {
		l = m.CreateIndex.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_AlterIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterIndex != nil {
		l = m.AlterIndex.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_DropIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropIndex != nil {
		l = m.DropIndex.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_TruncateTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TruncateTable != nil {
		l = m.TruncateTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_ShowVariables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowVariables != nil {
		l = m.ShowVariables.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *CreateDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfNotExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DropDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfNotExists {
		n += 2
	}
	if m.Temporary {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.IndexTables) > 0 {
		for _, e := range m.IndexTables {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DropTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.IndexTableNames) > 0 {
		for _, s := range m.IndexTableNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfNotExists {
		n += 2
	}
	l = len(m.Index)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Index)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DropIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfExists {
		n += 2
	}
	l = len(m.Index)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TruncateTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.IndexTableNames) > 0 {
		for _, s := range m.IndexTableNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowVariables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Global {
		n += 2
	}
	if len(m.Where) > 0 {
		for _, e := range m.Where {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetVariables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetVariablesItem) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.System {
		n += 2
	}
	if m.Global {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Reserved != nil {
		l = m.Reserved.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Prepare) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Schemas) > 0 {
		for _, e := range m.Schemas {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Plan != nil {
		l = m.Plan.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.ParamTypes) > 0 {
		l = 0
		for _, e := range m.ParamTypes {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Execute) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, e := range m.Args {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Deallocate) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPlan(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPlan(x uint64) (n int) {
	return sovPlan(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Type) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nullable = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoIncr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoIncr = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precision", wireType)
			}
			m.Precision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Precision |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size", wireType)
			}
			m.Size = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			m.Scale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scale |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Const) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Const: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Const: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isnull", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Isnull = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field I8Val", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_I8Val{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field I16Val", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_I16Val{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field I32Val", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_I32Val{v}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field I64Val", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_I64Val{v}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field U8Val", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_U8Val{v}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field U16Val", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_U16Val{v}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field U32Val", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_U32Val{v}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field U64Val", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_U64Val{v}
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dval", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = &Const_Dval{float64(math.Float64frombits(v))}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &Const_Sval{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bval", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &Const_Bval{b}
		case 13:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fval", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Value = &Const_Fval{float32(math.Float32frombits(v))}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dateval", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_Dateval{v}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeval", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_Timeval{v}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datetimeval", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_Datetimeval{v}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimal64Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Decimal64{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Const_Decimal64Val{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimal128Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Decimal128{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Const_Decimal128Val{v}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestampval", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_Timestampval{v}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jsonval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &Const_Jsonval{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defaultval", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &Const_Defaultval{b}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateVal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &Const_UpdateVal{b}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBin = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParamRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParamRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParamRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VarRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VarRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VarRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field System", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.System = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Global = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelPos", wireType)
			}
			m.RelPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColPos", wireType)
			}
			m.ColPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CorrColRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CorrColRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CorrColRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelPos", wireType)
			}
			m.RelPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColPos", wireType)
			}
			m.ColPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depth", wireType)
			}
			m.Depth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Depth |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExprList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExprList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExprList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &Expr{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaxValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaxValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaxValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TargetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Typ == nil {
				m.Typ = &Type{}
			}
			if err := m.Typ.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubqueryRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubqueryRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubqueryRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			m.Typ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typ |= SubqueryRef_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Op = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Expr{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowSize", wireType)
			}
			m.RowSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			m.Server = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Server |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Db", wireType)
			}
			m.Db = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Db |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			m.Schema = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Schema |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Obj", wireType)
			}
			m.Obj = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Obj |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Function) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Function: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Function: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Func", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Func == nil {
				m.Func = &ObjectRef{}
			}
			if err := m.Func.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, &Expr{})
			if err := m.Args[len(m.Args)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Expr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Typ == nil {
				m.Typ = &Type{}
			}
			if err := m.Typ.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field C", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Const{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_C{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ParamRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_P{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VarRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_V{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Col", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Col{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Function{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_F{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sub", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SubqueryRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Sub{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Corr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CorrColRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Corr{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TargetType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_T{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ExprList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_List{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MaxValue{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Max{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Decimal64) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: decimal64: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: decimal64: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			m.A = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.A |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Decimal128) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: decimal128: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: decimal128: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			m.A = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.A |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			m.B = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.B |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alg", wireType)
			}
			m.Alg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alg |= CompressType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Typ == nil {
				m.Typ = &Type{}
			}
			if err := m.Typ.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Default == nil {
				m.Default = &Default{}
			}
			if err := m.Default.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Primary = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pkidx", wireType)
			}
			m.Pkidx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pkidx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCPkey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCPkey = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OnUpdate == nil {
				m.OnUpdate = &OnUpdate{}
			}
			if err := m.OnUpdate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowCardinality", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LowCardinality = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Default) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Default: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Default: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullAbility", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NullAbility = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimaryKeyDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimaryKeyDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimaryKeyDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Property) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Property: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Property: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropertiesDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropertiesDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropertiesDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = append(m.Properties, &Property{})
			if err := m.Properties[len(m.Properties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= PartitionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionExpression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PartitionExpression == nil {
				m.PartitionExpression = &Expr{}
			}
			if err := m.PartitionExpression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &Expr{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionColumns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionColumns = append(m.PartitionColumns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionNum", wireType)
			}
			m.PartitionNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partitions = append(m.Partitions, &PartitionItem{})
			if err := m.Partitions[len(m.Partitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algorithm", wireType)
			}
			m.Algorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algorithm |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSubPartition", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSubPartition = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrdinalPosition", wireType)
			}
			m.OrdinalPosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrdinalPosition |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LessThan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LessThan = append(m.LessThan, &Expr{})
			if err := m.LessThan[len(m.LessThan)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InValues = append(m.InValues, &Expr{})
			if err := m.InValues[len(m.InValues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.View = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexNames = append(m.IndexNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableNames = append(m.TableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uniques = append(m.Uniques, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.Uniques) == 0 {
					m.Uniques = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uniques = append(m.Uniques, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uniques", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, &Field{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Field) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Field: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Field: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColNames = append(m.ColNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColNames = append(m.ColNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cols = append(m.Cols, &ColDef{})
			if err := m.Cols[len(m.Cols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Field == nil {
				m.Field = &Field{}
			}
			if err := m.Field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cols = append(m.Cols, &ColDef{})
			if err := m.Cols[len(m.Cols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Defs = append(m.Defs, &TableDef_DefType{})
			if err := m.Defs[len(m.Defs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Createsql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Createsql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name2ColIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name2ColIndex == nil {
				m.Name2ColIndex = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPlan
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPlan
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPlan(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPlan
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Name2ColIndex[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompositePkey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompositePkey == nil {
				m.CompositePkey = &ColDef{}
			}
			if err := m.CompositePkey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TblFunc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TblFunc == nil {
				m.TblFunc = &TableFunction{}
			}
			if err := m.TblFunc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexInfos = append(m.IndexInfos, &IndexInfo{})
			if err := m.IndexInfos[len(m.IndexInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDef_DefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PrimaryKeyDef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Def = &TableDef_DefType_Pk{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IndexDef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Def = &TableDef_DefType_Idx{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PropertiesDef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Def = &TableDef_DefType_Properties{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ViewDef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Def = &TableDef_DefType_View{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PartitionInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Def = &TableDef_DefType_Partition{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableFunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableFunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableFunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Param = append(m.Param[:0], dAtA[iNdEx:postIndex]...)
			if m.Param == nil {
				m.Param = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cost) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cost: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cost: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Card = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rowsize", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Rowsize = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ndv", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Ndv = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Start = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Total = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowCount", wireType)
			}
			m.RowCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullCount", wireType)
			}
			m.NullCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NullCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Nulls = append(m.Nulls, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.Nulls) == 0 {
					m.Nulls = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Nulls = append(m.Nulls, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Nulls", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.I32 = append(m.I32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.I32) == 0 {
					m.I32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.I32 = append(m.I32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field I32", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.I64 = append(m.I64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.I64) == 0 {
					m.I64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.I64 = append(m.I64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field I64", wireType)
			}
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.F32 = append(m.F32, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.F32) == 0 {
					m.F32 = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.F32 = append(m.F32, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field F32", wireType)
			}
		case 7:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.F64 = append(m.F64, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.F64) == 0 {
					m.F64 = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.F64 = append(m.F64, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field F64", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S = append(m.S, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowsetData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowsetData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowsetData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schema == nil {
				m.Schema = &TableDef{}
			}
			if err := m.Schema.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cols = append(m.Cols, &ColData{})
			if err := m.Cols[len(m.Cols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderBySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderBySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderBySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= OrderBySpec_OrderByFlag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionBy = append(m.PartitionBy, &Expr{})
			if err := m.PartitionBy[len(m.PartitionBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBy = append(m.OrderBy, &OrderBySpec{})
			if err := m.OrderBy[len(m.OrderBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lead", wireType)
			}
			m.Lead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lead |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lag", wireType)
			}
			m.Lag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateCtx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateCtx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateCtx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TblName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TblName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriKeyIdx", wireType)
			}
			m.PriKeyIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PriKeyIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HideKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HideKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HideKeyIdx", wireType)
			}
			m.HideKeyIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HideKeyIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdateCols = append(m.UpdateCols, &ColDef{})
			if err := m.UpdateCols[len(m.UpdateCols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherAttrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OtherAttrs = append(m.OtherAttrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderAttrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderAttrs = append(m.OrderAttrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompositePkey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompositePkey == nil {
				m.CompositePkey = &ColDef{}
			}
			if err := m.CompositePkey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexAttrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexAttrs = append(m.IndexAttrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnalyzeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalyzeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalyzeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputRows", wireType)
			}
			m.InputRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputRows |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputRows", wireType)
			}
			m.OutputRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputRows |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputSize", wireType)
			}
			m.InputSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputSize", wireType)
			}
			m.OutputSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeConsumed", wireType)
			}
			m.TimeConsumed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeConsumed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemorySize", wireType)
			}
			m.MemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemorySize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeType", wireType)
			}
			m.NodeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeType |= Node_NodeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cost == nil {
				m.Cost = &Cost{}
			}
			if err := m.Cost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectList = append(m.ProjectList, &Expr{})
			if err := m.ProjectList[len(m.ProjectList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Children = append(m.Children, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Children) == 0 {
					m.Children = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Children = append(m.Children, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinType", wireType)
			}
			m.JoinType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinType |= Node_JoinFlag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnList = append(m.OnList, &Expr{})
			if err := m.OnList[len(m.OnList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilterList = append(m.FilterList, &Expr{})
			if err := m.FilterList[len(m.FilterList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = append(m.GroupBy, &Expr{})
			if err := m.GroupBy[len(m.GroupBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupingSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupingSet = append(m.GroupingSet, &Expr{})
			if err := m.GroupingSet[len(m.GroupingSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggList = append(m.AggList, &Expr{})
			if err := m.AggList[len(m.AggList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBy = append(m.OrderBy, &OrderBySpec{})
			if err := m.OrderBy[len(m.OrderBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCtxs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdateCtxs = append(m.UpdateCtxs, &UpdateCtx{})
			if err := m.UpdateCtxs[len(m.UpdateCtxs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WinSpec == nil {
				m.WinSpec = &WindowSpec{}
			}
			if err := m.WinSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limit == nil {
				m.Limit = &Expr{}
			}
			if err := m.Limit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Offset == nil {
				m.Offset = &Expr{}
			}
			if err := m.Offset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDefVec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableDefVec = append(m.TableDefVec, &TableDef{})
			if err := m.TableDefVec[len(m.TableDefVec)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjRef == nil {
				m.ObjRef = &ObjectRef{}
			}
			if err := m.ObjRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowsetData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RowsetData == nil {
				m.RowsetData = &RowsetData{}
			}
			if err := m.RowsetData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraOptions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraOptions = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteTablesCtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeleteTablesCtx = append(m.DeleteTablesCtx, &DeleteTableCtx{})
			if err := m.DeleteTablesCtx[len(m.DeleteTablesCtx)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BindingTags = append(m.BindingTags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BindingTags) == 0 {
					m.BindingTags = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BindingTags = append(m.BindingTags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BindingTags", wireType)
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalyzeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnalyzeInfo == nil {
				m.AnalyzeInfo = &AnalyzeInfo{}
			}
			if err := m.AnalyzeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TblFuncExprList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TblFuncExprList = append(m.TblFuncExprList, &Expr{})
			if err := m.TblFuncExprList[len(m.TblFuncExprList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteTableCtx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteTableCtx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteTableCtx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TblName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TblName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseDeleteKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UseDeleteKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanTruncate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanTruncate = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColIndex", wireType)
			}
			m.ColIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexInfos = append(m.IndexInfos, &IndexInfo{})
			if err := m.IndexInfos[len(m.IndexInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexAttrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexAttrs = append(m.IndexAttrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Query) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Query: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Query: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StmtType", wireType)
			}
			m.StmtType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StmtType |= Query_StatementType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Steps = append(m.Steps, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Steps) == 0 {
					m.Steps = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Steps = append(m.Steps, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params, &Expr{})
			if err := m.Params[len(m.Params)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headings = append(m.Headings, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadTag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LoadTag = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransationControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransationControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransationControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TclType", wireType)
			}
			m.TclType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TclType |= TransationControl_TclType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TransationBegin{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &TransationControl_Begin{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TransationCommit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &TransationControl_Commit{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rollback", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TransationRollback{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &TransationControl_Rollback{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransationBegin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransationBegin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransationBegin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= TransationBegin_TransationMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransationCommit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransationCommit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransationCommit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionType", wireType)
			}
			m.CompletionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletionType |= TransationCompletionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransationRollback) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransationRollback: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransationRollback: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionType", wireType)
			}
			m.CompletionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletionType |= TransationCompletionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Plan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Plan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Plan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Query{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Plan = &Plan_Query{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tcl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TransationControl{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Plan = &Plan_Tcl{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ddl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataDefinition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Plan = &Plan_Ddl{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dcl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataControl{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Plan = &Plan_Dcl{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InsertValues{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Plan = &Plan_Ins{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsertValues) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsertValues: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsertValues: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TblName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TblName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExplicitCols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExplicitCols = append(m.ExplicitCols, &ColDef{})
			if err := m.ExplicitCols[len(m.ExplicitCols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherCols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OtherCols = append(m.OtherCols, &ColDef{})
			if err := m.OtherCols[len(m.OtherCols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderAttrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderAttrs = append(m.OrderAttrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &Column{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompositePkey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompositePkey == nil {
				m.CompositePkey = &ColDef{}
			}
			if err := m.CompositePkey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexInfos = append(m.IndexInfos, &IndexInfo{})
			if err := m.IndexInfos[len(m.IndexInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Column) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: column: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: column: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Column = append(m.Column, &Expr{})
			if err := m.Column[len(m.Column)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DclType", wireType)
			}
			m.DclType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DclType |= DataControl_DclType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetVariables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SetVariables{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Control = &DataControl_SetVariables{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prepare", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Prepare{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Control = &DataControl_Prepare{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Execute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Execute{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Control = &DataControl_Execute{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deallocate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Deallocate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Control = &DataControl_Deallocate{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DdlType", wireType)
			}
			m.DdlType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DdlType |= DataDefinition_DdlType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &Query{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateDatabase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateDatabase{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_CreateDatabase{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterDatabase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterDatabase{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_AlterDatabase{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropDatabase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DropDatabase{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_DropDatabase{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_CreateTable{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_AlterTable{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DropTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_DropTable{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_CreateIndex{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_AlterIndex{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DropIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_DropIndex{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TruncateTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TruncateTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_TruncateTable{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowVariables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShowVariables{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_ShowVariables{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateDatabase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateDatabase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateDatabase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfNotExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfNotExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterDatabase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterDatabase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterDatabase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropDatabase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropDatabase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropDatabase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfNotExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfNotExists = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temporary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Temporary = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTables = append(m.IndexTables, &TableDef{})
			if err := m.IndexTables[len(m.IndexTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTableNames = append(m.IndexTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfNotExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfNotExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TruncateTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TruncateTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TruncateTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTableNames = append(m.IndexTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowVariables) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowVariables: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowVariables: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Global = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Where = append(m.Where, &Expr{})
			if err := m.Where[len(m.Where)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetVariables) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetVariables: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetVariables: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &SetVariablesItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetVariablesItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetVariablesItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetVariablesItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field System", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.System = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Global = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Expr{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reserved == nil {
				m.Reserved = &Expr{}
			}
			if err := m.Reserved.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Prepare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Prepare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Prepare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schemas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schemas = append(m.Schemas, &ObjectRef{})
			if err := m.Schemas[len(m.Schemas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Plan == nil {
				m.Plan = &Plan{}
			}
			if err := m.Plan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ParamTypes = append(m.ParamTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ParamTypes) == 0 {
					m.ParamTypes = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ParamTypes = append(m.ParamTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ParamTypes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Execute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Execute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Execute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, &Expr{})
			if err := m.Args[len(m.Args)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deallocate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deallocate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deallocate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPlan(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPlan
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPlan
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPlan
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPlan        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPlan          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPlan = fmt.Errorf("proto: unexpected end of group")
)
