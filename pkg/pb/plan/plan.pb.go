// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: plan.proto

package plan

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CompressType int32

const (
	CompressType_None CompressType = 0
	CompressType_Lz4  CompressType = 1
)

var CompressType_name = map[int32]string{
	0: "None",
	1: "Lz4",
}

var CompressType_value = map[string]int32{
	"None": 0,
	"Lz4":  1,
}

func (x CompressType) String() string {
	return proto.EnumName(CompressType_name, int32(x))
}

func (CompressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{0}
}

type PartitionType int32

const (
	PartitionType_KEY           PartitionType = 0
	PartitionType_LINEAR_KEY    PartitionType = 1
	PartitionType_HASH          PartitionType = 2
	PartitionType_LINEAR_HASH   PartitionType = 3
	PartitionType_RANGE         PartitionType = 4
	PartitionType_RANGE_COLUMNS PartitionType = 5
	PartitionType_LIST          PartitionType = 6
	PartitionType_LIST_COLUMNS  PartitionType = 7
)

var PartitionType_name = map[int32]string{
	0: "KEY",
	1: "LINEAR_KEY",
	2: "HASH",
	3: "LINEAR_HASH",
	4: "RANGE",
	5: "RANGE_COLUMNS",
	6: "LIST",
	7: "LIST_COLUMNS",
}

var PartitionType_value = map[string]int32{
	"KEY":           0,
	"LINEAR_KEY":    1,
	"HASH":          2,
	"LINEAR_HASH":   3,
	"RANGE":         4,
	"RANGE_COLUMNS": 5,
	"LIST":          6,
	"LIST_COLUMNS":  7,
}

func (x PartitionType) String() string {
	return proto.EnumName(PartitionType_name, int32(x))
}

func (PartitionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{1}
}

type TransationCompletionType int32

const (
	TransationCompletionType_CHAIN    TransationCompletionType = 0
	TransationCompletionType_NO_CHAIN TransationCompletionType = 1
	TransationCompletionType_RELEASE  TransationCompletionType = 2
)

var TransationCompletionType_name = map[int32]string{
	0: "CHAIN",
	1: "NO_CHAIN",
	2: "RELEASE",
}

var TransationCompletionType_value = map[string]int32{
	"CHAIN":    0,
	"NO_CHAIN": 1,
	"RELEASE":  2,
}

func (x TransationCompletionType) String() string {
	return proto.EnumName(TransationCompletionType_name, int32(x))
}

func (TransationCompletionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{2}
}

type TableLockType int32

const (
	TableLockType_TableLockNone             TableLockType = 0
	TableLockType_TableLockRead             TableLockType = 1
	TableLockType_TableLockReadLocal        TableLockType = 2
	TableLockType_TableLockWrite            TableLockType = 3
	TableLockType_TableLockLowPriorityWrite TableLockType = 4
)

var TableLockType_name = map[int32]string{
	0: "TableLockNone",
	1: "TableLockRead",
	2: "TableLockReadLocal",
	3: "TableLockWrite",
	4: "TableLockLowPriorityWrite",
}

var TableLockType_value = map[string]int32{
	"TableLockNone":             0,
	"TableLockRead":             1,
	"TableLockReadLocal":        2,
	"TableLockWrite":            3,
	"TableLockLowPriorityWrite": 4,
}

func (x TableLockType) String() string {
	return proto.EnumName(TableLockType_name, int32(x))
}

func (TableLockType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{3}
}

type SubqueryRef_Type int32

const (
	SubqueryRef_SCALAR     SubqueryRef_Type = 0
	SubqueryRef_EXISTS     SubqueryRef_Type = 1
	SubqueryRef_NOT_EXISTS SubqueryRef_Type = 2
	SubqueryRef_IN         SubqueryRef_Type = 3
	SubqueryRef_NOT_IN     SubqueryRef_Type = 4
	SubqueryRef_ANY        SubqueryRef_Type = 5
	SubqueryRef_ALL        SubqueryRef_Type = 6
)

var SubqueryRef_Type_name = map[int32]string{
	0: "SCALAR",
	1: "EXISTS",
	2: "NOT_EXISTS",
	3: "IN",
	4: "NOT_IN",
	5: "ANY",
	6: "ALL",
}

var SubqueryRef_Type_value = map[string]int32{
	"SCALAR":     0,
	"EXISTS":     1,
	"NOT_EXISTS": 2,
	"IN":         3,
	"NOT_IN":     4,
	"ANY":        5,
	"ALL":        6,
}

func (x SubqueryRef_Type) String() string {
	return proto.EnumName(SubqueryRef_Type_name, int32(x))
}

func (SubqueryRef_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{10, 0}
}

// Function flags
type Function_FuncFlag int32

const (
	Function_NONE Function_FuncFlag = 0
	// Internal function is generated by system, cannot
	// by called by user.
	Function_INTERNAL Function_FuncFlag = 1
	// Function, by default is immutable.
	Function_STABLE   Function_FuncFlag = 2
	Function_VOLATILE Function_FuncFlag = 4
	// Nulls
	Function_STRICT          Function_FuncFlag = 8
	Function_PRODUCE_NULL    Function_FuncFlag = 16
	Function_PRODUCE_NO_NULL Function_FuncFlag = 32
	// Vararg, all trailing args must be of the same type.
	Function_VARARG Function_FuncFlag = 64
	// Window and Agg
	Function_AGG Function_FuncFlag = 128
	Function_WIN Function_FuncFlag = 256
	// Monotonic function can filter by zonemap
	Function_MONOTONIC Function_FuncFlag = 512
)

var Function_FuncFlag_name = map[int32]string{
	0:   "NONE",
	1:   "INTERNAL",
	2:   "STABLE",
	4:   "VOLATILE",
	8:   "STRICT",
	16:  "PRODUCE_NULL",
	32:  "PRODUCE_NO_NULL",
	64:  "VARARG",
	128: "AGG",
	256: "WIN",
	512: "MONOTONIC",
}

var Function_FuncFlag_value = map[string]int32{
	"NONE":            0,
	"INTERNAL":        1,
	"STABLE":          2,
	"VOLATILE":        4,
	"STRICT":          8,
	"PRODUCE_NULL":    16,
	"PRODUCE_NO_NULL": 32,
	"VARARG":          64,
	"AGG":             128,
	"WIN":             256,
	"MONOTONIC":       512,
}

func (x Function_FuncFlag) String() string {
	return proto.EnumName(Function_FuncFlag_name, int32(x))
}

func (Function_FuncFlag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{13, 0}
}

type ForeignKeyDef_RefAction int32

const (
	ForeignKeyDef_RESTRICT    ForeignKeyDef_RefAction = 0
	ForeignKeyDef_CASCADE     ForeignKeyDef_RefAction = 1
	ForeignKeyDef_SET_NULL    ForeignKeyDef_RefAction = 2
	ForeignKeyDef_SET_DEFAULT ForeignKeyDef_RefAction = 3
	ForeignKeyDef_NO_ACTION   ForeignKeyDef_RefAction = 4
)

var ForeignKeyDef_RefAction_name = map[int32]string{
	0: "RESTRICT",
	1: "CASCADE",
	2: "SET_NULL",
	3: "SET_DEFAULT",
	4: "NO_ACTION",
}

var ForeignKeyDef_RefAction_value = map[string]int32{
	"RESTRICT":    0,
	"CASCADE":     1,
	"SET_NULL":    2,
	"SET_DEFAULT": 3,
	"NO_ACTION":   4,
}

func (x ForeignKeyDef_RefAction) String() string {
	return proto.EnumName(ForeignKeyDef_RefAction_name, int32(x))
}

func (ForeignKeyDef_RefAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{24, 0}
}

type OrderBySpec_OrderByFlag int32

const (
	OrderBySpec_INTERNAL    OrderBySpec_OrderByFlag = 0
	OrderBySpec_ASC         OrderBySpec_OrderByFlag = 1
	OrderBySpec_DESC        OrderBySpec_OrderByFlag = 2
	OrderBySpec_NULLS_FIRST OrderBySpec_OrderByFlag = 4
	OrderBySpec_NULLS_LAST  OrderBySpec_OrderByFlag = 8
	OrderBySpec_UNIQUE      OrderBySpec_OrderByFlag = 16
)

var OrderBySpec_OrderByFlag_name = map[int32]string{
	0:  "INTERNAL",
	1:  "ASC",
	2:  "DESC",
	4:  "NULLS_FIRST",
	8:  "NULLS_LAST",
	16: "UNIQUE",
}

var OrderBySpec_OrderByFlag_value = map[string]int32{
	"INTERNAL":    0,
	"ASC":         1,
	"DESC":        2,
	"NULLS_FIRST": 4,
	"NULLS_LAST":  8,
	"UNIQUE":      16,
}

func (x OrderBySpec_OrderByFlag) String() string {
	return proto.EnumName(OrderBySpec_OrderByFlag_name, int32(x))
}

func (OrderBySpec_OrderByFlag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{40, 0}
}

type Node_NodeType int32

const (
	Node_UNKNOWN Node_NodeType = 0
	// Scans
	Node_VALUE_SCAN    Node_NodeType = 1
	Node_TABLE_SCAN    Node_NodeType = 2
	Node_FUNCTION_SCAN Node_NodeType = 3
	Node_EXTERNAL_SCAN Node_NodeType = 4
	Node_MATERIAL_SCAN Node_NodeType = 5
	// Proj, for convenience
	Node_PROJECT Node_NodeType = 10
	// External function call (UDF)
	Node_EXTERNAL_FUNCTION Node_NodeType = 11
	// Material, CTE, etc.
	Node_MATERIAL      Node_NodeType = 20
	Node_RECURSIVE_CTE Node_NodeType = 21
	Node_SINK          Node_NodeType = 22
	Node_SINK_SCAN     Node_NodeType = 23
	// Proper Relational Operators
	Node_AGG       Node_NodeType = 30
	Node_DISTINCT  Node_NodeType = 31
	Node_FILTER    Node_NodeType = 32
	Node_JOIN      Node_NodeType = 33
	Node_SAMPLE    Node_NodeType = 34
	Node_SORT      Node_NodeType = 35
	Node_UNION     Node_NodeType = 36
	Node_UNION_ALL Node_NodeType = 37
	Node_UNIQUE    Node_NodeType = 38
	Node_WINDOW    Node_NodeType = 39
	// Physical tuple mover
	Node_BROADCAST Node_NodeType = 40
	Node_SPLIT     Node_NodeType = 41
	Node_GATHER    Node_NodeType = 42
	// Misc
	Node_ASSERT Node_NodeType = 50
	//
	Node_INSERT Node_NodeType = 51
	Node_UPDATE Node_NodeType = 52
	Node_DELETE Node_NodeType = 53
	//
	Node_INTERSECT     Node_NodeType = 54
	Node_INTERSECT_ALL Node_NodeType = 55
	Node_MINUS         Node_NodeType = 56
	Node_MINUS_ALL     Node_NodeType = 57
)

var Node_NodeType_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "VALUE_SCAN",
	2:  "TABLE_SCAN",
	3:  "FUNCTION_SCAN",
	4:  "EXTERNAL_SCAN",
	5:  "MATERIAL_SCAN",
	10: "PROJECT",
	11: "EXTERNAL_FUNCTION",
	20: "MATERIAL",
	21: "RECURSIVE_CTE",
	22: "SINK",
	23: "SINK_SCAN",
	30: "AGG",
	31: "DISTINCT",
	32: "FILTER",
	33: "JOIN",
	34: "SAMPLE",
	35: "SORT",
	36: "UNION",
	37: "UNION_ALL",
	38: "UNIQUE",
	39: "WINDOW",
	40: "BROADCAST",
	41: "SPLIT",
	42: "GATHER",
	50: "ASSERT",
	51: "INSERT",
	52: "UPDATE",
	53: "DELETE",
	54: "INTERSECT",
	55: "INTERSECT_ALL",
	56: "MINUS",
	57: "MINUS_ALL",
}

var Node_NodeType_value = map[string]int32{
	"UNKNOWN":           0,
	"VALUE_SCAN":        1,
	"TABLE_SCAN":        2,
	"FUNCTION_SCAN":     3,
	"EXTERNAL_SCAN":     4,
	"MATERIAL_SCAN":     5,
	"PROJECT":           10,
	"EXTERNAL_FUNCTION": 11,
	"MATERIAL":          20,
	"RECURSIVE_CTE":     21,
	"SINK":              22,
	"SINK_SCAN":         23,
	"AGG":               30,
	"DISTINCT":          31,
	"FILTER":            32,
	"JOIN":              33,
	"SAMPLE":            34,
	"SORT":              35,
	"UNION":             36,
	"UNION_ALL":         37,
	"UNIQUE":            38,
	"WINDOW":            39,
	"BROADCAST":         40,
	"SPLIT":             41,
	"GATHER":            42,
	"ASSERT":            50,
	"INSERT":            51,
	"UPDATE":            52,
	"DELETE":            53,
	"INTERSECT":         54,
	"INTERSECT_ALL":     55,
	"MINUS":             56,
	"MINUS_ALL":         57,
}

func (x Node_NodeType) String() string {
	return proto.EnumName(Node_NodeType_name, int32(x))
}

func (Node_NodeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{45, 0}
}

type Node_JoinType int32

const (
	Node_INNER  Node_JoinType = 0
	Node_LEFT   Node_JoinType = 1
	Node_RIGHT  Node_JoinType = 2
	Node_OUTER  Node_JoinType = 3
	Node_SEMI   Node_JoinType = 4
	Node_ANTI   Node_JoinType = 5
	Node_SINGLE Node_JoinType = 6
	Node_MARK   Node_JoinType = 7
	Node_APPLY  Node_JoinType = 8
)

var Node_JoinType_name = map[int32]string{
	0: "INNER",
	1: "LEFT",
	2: "RIGHT",
	3: "OUTER",
	4: "SEMI",
	5: "ANTI",
	6: "SINGLE",
	7: "MARK",
	8: "APPLY",
}

var Node_JoinType_value = map[string]int32{
	"INNER":  0,
	"LEFT":   1,
	"RIGHT":  2,
	"OUTER":  3,
	"SEMI":   4,
	"ANTI":   5,
	"SINGLE": 6,
	"MARK":   7,
	"APPLY":  8,
}

func (x Node_JoinType) String() string {
	return proto.EnumName(Node_JoinType_name, int32(x))
}

func (Node_JoinType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{45, 1}
}

type Node_AggMode int32

const (
	Node_FULL   Node_AggMode = 0
	Node_BOTTOM Node_AggMode = 1
	Node_TOP    Node_AggMode = 2
)

var Node_AggMode_name = map[int32]string{
	0: "FULL",
	1: "BOTTOM",
	2: "TOP",
}

var Node_AggMode_value = map[string]int32{
	"FULL":   0,
	"BOTTOM": 1,
	"TOP":    2,
}

func (x Node_AggMode) String() string {
	return proto.EnumName(Node_AggMode_name, int32(x))
}

func (Node_AggMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{45, 2}
}

type Query_StatementType int32

const (
	Query_UNKNOWN Query_StatementType = 0
	Query_SELECT  Query_StatementType = 1
	Query_INSERT  Query_StatementType = 2
	Query_DELETE  Query_StatementType = 3
	Query_UPDATE  Query_StatementType = 4
	Query_MERGE   Query_StatementType = 5
)

var Query_StatementType_name = map[int32]string{
	0: "UNKNOWN",
	1: "SELECT",
	2: "INSERT",
	3: "DELETE",
	4: "UPDATE",
	5: "MERGE",
}

var Query_StatementType_value = map[string]int32{
	"UNKNOWN": 0,
	"SELECT":  1,
	"INSERT":  2,
	"DELETE":  3,
	"UPDATE":  4,
	"MERGE":   5,
}

func (x Query_StatementType) String() string {
	return proto.EnumName(Query_StatementType_name, int32(x))
}

func (Query_StatementType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{49, 0}
}

type TransationControl_TclType int32

const (
	TransationControl_BEGIN    TransationControl_TclType = 0
	TransationControl_COMMIT   TransationControl_TclType = 1
	TransationControl_ROLLBACK TransationControl_TclType = 2
)

var TransationControl_TclType_name = map[int32]string{
	0: "BEGIN",
	1: "COMMIT",
	2: "ROLLBACK",
}

var TransationControl_TclType_value = map[string]int32{
	"BEGIN":    0,
	"COMMIT":   1,
	"ROLLBACK": 2,
}

func (x TransationControl_TclType) String() string {
	return proto.EnumName(TransationControl_TclType_name, int32(x))
}

func (TransationControl_TclType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{50, 0}
}

type TransationBegin_TransationMode int32

const (
	TransationBegin_NONE       TransationBegin_TransationMode = 0
	TransationBegin_READ_ONLY  TransationBegin_TransationMode = 1
	TransationBegin_READ_WRITE TransationBegin_TransationMode = 2
)

var TransationBegin_TransationMode_name = map[int32]string{
	0: "NONE",
	1: "READ_ONLY",
	2: "READ_WRITE",
}

var TransationBegin_TransationMode_value = map[string]int32{
	"NONE":       0,
	"READ_ONLY":  1,
	"READ_WRITE": 2,
}

func (x TransationBegin_TransationMode) String() string {
	return proto.EnumName(TransationBegin_TransationMode_name, int32(x))
}

func (TransationBegin_TransationMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{51, 0}
}

type DataControl_DclType int32

const (
	DataControl_SET_VARIABLES DataControl_DclType = 0
	DataControl_GRANT         DataControl_DclType = 1
	DataControl_REVOKE        DataControl_DclType = 2
	DataControl_DENY          DataControl_DclType = 3
	DataControl_PREPARE       DataControl_DclType = 4
	DataControl_EXECUTE       DataControl_DclType = 5
	DataControl_DEALLOCATE    DataControl_DclType = 6
)

var DataControl_DclType_name = map[int32]string{
	0: "SET_VARIABLES",
	1: "GRANT",
	2: "REVOKE",
	3: "DENY",
	4: "PREPARE",
	5: "EXECUTE",
	6: "DEALLOCATE",
}

var DataControl_DclType_value = map[string]int32{
	"SET_VARIABLES": 0,
	"GRANT":         1,
	"REVOKE":        2,
	"DENY":          3,
	"PREPARE":       4,
	"EXECUTE":       5,
	"DEALLOCATE":    6,
}

func (x DataControl_DclType) String() string {
	return proto.EnumName(DataControl_DclType_name, int32(x))
}

func (DataControl_DclType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{56, 0}
}

type DataDefinition_DdlType int32

const (
	DataDefinition_CREATE_DATABASE     DataDefinition_DdlType = 0
	DataDefinition_ALTER_DATABASE      DataDefinition_DdlType = 1
	DataDefinition_DROP_DATABASE       DataDefinition_DdlType = 2
	DataDefinition_CREATE_TABLE        DataDefinition_DdlType = 3
	DataDefinition_ALTER_TABLE         DataDefinition_DdlType = 4
	DataDefinition_DROP_TABLE          DataDefinition_DdlType = 5
	DataDefinition_CREATE_INDEX        DataDefinition_DdlType = 6
	DataDefinition_ALTER_INDEX         DataDefinition_DdlType = 7
	DataDefinition_DROP_INDEX          DataDefinition_DdlType = 8
	DataDefinition_TRUNCATE_TABLE      DataDefinition_DdlType = 9
	DataDefinition_CREATE_VIEW         DataDefinition_DdlType = 10
	DataDefinition_ALTER_VIEW          DataDefinition_DdlType = 11
	DataDefinition_DROP_VIEW           DataDefinition_DdlType = 12
	DataDefinition_SHOW_CREATEDATABASE DataDefinition_DdlType = 13
	DataDefinition_SHOW_CREATETABLE    DataDefinition_DdlType = 14
	DataDefinition_SHOW_DATABASES      DataDefinition_DdlType = 15
	DataDefinition_SHOW_TABLES         DataDefinition_DdlType = 16
	DataDefinition_SHOW_COLUMNS        DataDefinition_DdlType = 17
	DataDefinition_SHOW_INDEX          DataDefinition_DdlType = 18
	DataDefinition_SHOW_VARIABLES      DataDefinition_DdlType = 19
	DataDefinition_SHOW_WARNINGS       DataDefinition_DdlType = 20
	DataDefinition_SHOW_ERRORS         DataDefinition_DdlType = 21
	DataDefinition_SHOW_STATUS         DataDefinition_DdlType = 22
	DataDefinition_SHOW_PROCESSLIST    DataDefinition_DdlType = 23
	DataDefinition_SHOW_TABLE_STATUS   DataDefinition_DdlType = 24
	DataDefinition_SHOW_TARGET         DataDefinition_DdlType = 25
	DataDefinition_SHOW_COLLATION      DataDefinition_DdlType = 26
	DataDefinition_LOCK_TABLES         DataDefinition_DdlType = 27
	DataDefinition_UNLOCK_TABLES       DataDefinition_DdlType = 28
	DataDefinition_CREATE_SEQUENCE     DataDefinition_DdlType = 29
	DataDefinition_ALTER_SEQUENCE      DataDefinition_DdlType = 30
	DataDefinition_DROP_SEQUENCE       DataDefinition_DdlType = 31
	DataDefinition_SHOW_SEQUENCES      DataDefinition_DdlType = 32
)

var DataDefinition_DdlType_name = map[int32]string{
	0:  "CREATE_DATABASE",
	1:  "ALTER_DATABASE",
	2:  "DROP_DATABASE",
	3:  "CREATE_TABLE",
	4:  "ALTER_TABLE",
	5:  "DROP_TABLE",
	6:  "CREATE_INDEX",
	7:  "ALTER_INDEX",
	8:  "DROP_INDEX",
	9:  "TRUNCATE_TABLE",
	10: "CREATE_VIEW",
	11: "ALTER_VIEW",
	12: "DROP_VIEW",
	13: "SHOW_CREATEDATABASE",
	14: "SHOW_CREATETABLE",
	15: "SHOW_DATABASES",
	16: "SHOW_TABLES",
	17: "SHOW_COLUMNS",
	18: "SHOW_INDEX",
	19: "SHOW_VARIABLES",
	20: "SHOW_WARNINGS",
	21: "SHOW_ERRORS",
	22: "SHOW_STATUS",
	23: "SHOW_PROCESSLIST",
	24: "SHOW_TABLE_STATUS",
	25: "SHOW_TARGET",
	26: "SHOW_COLLATION",
	27: "LOCK_TABLES",
	28: "UNLOCK_TABLES",
	29: "CREATE_SEQUENCE",
	30: "ALTER_SEQUENCE",
	31: "DROP_SEQUENCE",
	32: "SHOW_SEQUENCES",
}

var DataDefinition_DdlType_value = map[string]int32{
	"CREATE_DATABASE":     0,
	"ALTER_DATABASE":      1,
	"DROP_DATABASE":       2,
	"CREATE_TABLE":        3,
	"ALTER_TABLE":         4,
	"DROP_TABLE":          5,
	"CREATE_INDEX":        6,
	"ALTER_INDEX":         7,
	"DROP_INDEX":          8,
	"TRUNCATE_TABLE":      9,
	"CREATE_VIEW":         10,
	"ALTER_VIEW":          11,
	"DROP_VIEW":           12,
	"SHOW_CREATEDATABASE": 13,
	"SHOW_CREATETABLE":    14,
	"SHOW_DATABASES":      15,
	"SHOW_TABLES":         16,
	"SHOW_COLUMNS":        17,
	"SHOW_INDEX":          18,
	"SHOW_VARIABLES":      19,
	"SHOW_WARNINGS":       20,
	"SHOW_ERRORS":         21,
	"SHOW_STATUS":         22,
	"SHOW_PROCESSLIST":    23,
	"SHOW_TABLE_STATUS":   24,
	"SHOW_TARGET":         25,
	"SHOW_COLLATION":      26,
	"LOCK_TABLES":         27,
	"UNLOCK_TABLES":       28,
	"CREATE_SEQUENCE":     29,
	"ALTER_SEQUENCE":      30,
	"DROP_SEQUENCE":       31,
	"SHOW_SEQUENCES":      32,
}

func (x DataDefinition_DdlType) String() string {
	return proto.EnumName(DataDefinition_DdlType_name, int32(x))
}

func (DataDefinition_DdlType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{57, 0}
}

type AlterTableDrop_Typ int32

const (
	AlterTableDrop_COLUMN      AlterTableDrop_Typ = 0
	AlterTableDrop_INDEX       AlterTableDrop_Typ = 1
	AlterTableDrop_KEY         AlterTableDrop_Typ = 2
	AlterTableDrop_PRIMARY_KEY AlterTableDrop_Typ = 3
	AlterTableDrop_FOREIGN_KEY AlterTableDrop_Typ = 4
)

var AlterTableDrop_Typ_name = map[int32]string{
	0: "COLUMN",
	1: "INDEX",
	2: "KEY",
	3: "PRIMARY_KEY",
	4: "FOREIGN_KEY",
}

var AlterTableDrop_Typ_value = map[string]int32{
	"COLUMN":      0,
	"INDEX":       1,
	"KEY":         2,
	"PRIMARY_KEY": 3,
	"FOREIGN_KEY": 4,
}

func (x AlterTableDrop_Typ) String() string {
	return proto.EnumName(AlterTableDrop_Typ_name, int32(x))
}

func (AlterTableDrop_Typ) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{64, 0}
}

type Type struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	NotNullable          bool     `protobuf:"varint,2,opt,name=notNullable,proto3" json:"notNullable,omitempty"`
	AutoIncr             bool     `protobuf:"varint,3,opt,name=auto_incr,json=autoIncr,proto3" json:"auto_incr,omitempty"`
	Width                int32    `protobuf:"varint,4,opt,name=width,proto3" json:"width,omitempty"`
	Scale                int32    `protobuf:"varint,5,opt,name=scale,proto3" json:"scale,omitempty"`
	Table                string   `protobuf:"bytes,6,opt,name=table,proto3" json:"table,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Type) Reset()         { *m = Type{} }
func (m *Type) String() string { return proto.CompactTextString(m) }
func (*Type) ProtoMessage()    {}
func (*Type) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{0}
}
func (m *Type) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Type) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Type.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Type) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Type.Merge(m, src)
}
func (m *Type) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Type) XXX_DiscardUnknown() {
	xxx_messageInfo_Type.DiscardUnknown(m)
}

var xxx_messageInfo_Type proto.InternalMessageInfo

func (m *Type) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Type) GetNotNullable() bool {
	if m != nil {
		return m.NotNullable
	}
	return false
}

func (m *Type) GetAutoIncr() bool {
	if m != nil {
		return m.AutoIncr
	}
	return false
}

func (m *Type) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Type) GetScale() int32 {
	if m != nil {
		return m.Scale
	}
	return 0
}

func (m *Type) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

// Const: if a const value can be reprensented by int64 or
// double, use that, otherwise store a string representation.
type Const struct {
	Isnull bool `protobuf:"varint,1,opt,name=isnull,proto3" json:"isnull,omitempty"`
	// Types that are valid to be assigned to Value:
	//
	//	*Const_I8Val
	//	*Const_I16Val
	//	*Const_I32Val
	//	*Const_I64Val
	//	*Const_U8Val
	//	*Const_U16Val
	//	*Const_U32Val
	//	*Const_U64Val
	//	*Const_Dval
	//	*Const_Sval
	//	*Const_Bval
	//	*Const_Fval
	//	*Const_Dateval
	//	*Const_Timeval
	//	*Const_Datetimeval
	//	*Const_Decimal64Val
	//	*Const_Decimal128Val
	//	*Const_Timestampval
	//	*Const_Jsonval
	//	*Const_Defaultval
	//	*Const_UpdateVal
	Value                isConst_Value `protobuf_oneof:"value"`
	IsBin                bool          `protobuf:"varint,23,opt,name=isBin,proto3" json:"isBin,omitempty"`
	Src                  *Expr         `protobuf:"bytes,24,opt,name=src,proto3" json:"src,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Const) Reset()         { *m = Const{} }
func (m *Const) String() string { return proto.CompactTextString(m) }
func (*Const) ProtoMessage()    {}
func (*Const) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{1}
}
func (m *Const) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Const) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Const.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Const) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Const.Merge(m, src)
}
func (m *Const) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Const) XXX_DiscardUnknown() {
	xxx_messageInfo_Const.DiscardUnknown(m)
}

var xxx_messageInfo_Const proto.InternalMessageInfo

type isConst_Value interface {
	isConst_Value()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type Const_I8Val struct {
	I8Val int32 `protobuf:"varint,2,opt,name=i8val,proto3,oneof" json:"i8val,omitempty"`
}
type Const_I16Val struct {
	I16Val int32 `protobuf:"varint,3,opt,name=i16val,proto3,oneof" json:"i16val,omitempty"`
}
type Const_I32Val struct {
	I32Val int32 `protobuf:"varint,4,opt,name=i32val,proto3,oneof" json:"i32val,omitempty"`
}
type Const_I64Val struct {
	I64Val int64 `protobuf:"varint,5,opt,name=i64val,proto3,oneof" json:"i64val,omitempty"`
}
type Const_U8Val struct {
	U8Val uint32 `protobuf:"varint,6,opt,name=u8val,proto3,oneof" json:"u8val,omitempty"`
}
type Const_U16Val struct {
	U16Val uint32 `protobuf:"varint,7,opt,name=u16val,proto3,oneof" json:"u16val,omitempty"`
}
type Const_U32Val struct {
	U32Val uint32 `protobuf:"varint,8,opt,name=u32val,proto3,oneof" json:"u32val,omitempty"`
}
type Const_U64Val struct {
	U64Val uint64 `protobuf:"varint,9,opt,name=u64val,proto3,oneof" json:"u64val,omitempty"`
}
type Const_Dval struct {
	Dval float64 `protobuf:"fixed64,10,opt,name=dval,proto3,oneof" json:"dval,omitempty"`
}
type Const_Sval struct {
	Sval string `protobuf:"bytes,11,opt,name=sval,proto3,oneof" json:"sval,omitempty"`
}
type Const_Bval struct {
	Bval bool `protobuf:"varint,12,opt,name=bval,proto3,oneof" json:"bval,omitempty"`
}
type Const_Fval struct {
	Fval float32 `protobuf:"fixed32,13,opt,name=fval,proto3,oneof" json:"fval,omitempty"`
}
type Const_Dateval struct {
	Dateval int32 `protobuf:"varint,14,opt,name=dateval,proto3,oneof" json:"dateval,omitempty"`
}
type Const_Timeval struct {
	Timeval int64 `protobuf:"varint,15,opt,name=timeval,proto3,oneof" json:"timeval,omitempty"`
}
type Const_Datetimeval struct {
	Datetimeval int64 `protobuf:"varint,16,opt,name=datetimeval,proto3,oneof" json:"datetimeval,omitempty"`
}
type Const_Decimal64Val struct {
	Decimal64Val *Decimal64 `protobuf:"bytes,17,opt,name=decimal64val,proto3,oneof" json:"decimal64val,omitempty"`
}
type Const_Decimal128Val struct {
	Decimal128Val *Decimal128 `protobuf:"bytes,18,opt,name=decimal128val,proto3,oneof" json:"decimal128val,omitempty"`
}
type Const_Timestampval struct {
	Timestampval int64 `protobuf:"varint,19,opt,name=timestampval,proto3,oneof" json:"timestampval,omitempty"`
}
type Const_Jsonval struct {
	Jsonval string `protobuf:"bytes,20,opt,name=jsonval,proto3,oneof" json:"jsonval,omitempty"`
}
type Const_Defaultval struct {
	Defaultval bool `protobuf:"varint,21,opt,name=defaultval,proto3,oneof" json:"defaultval,omitempty"`
}
type Const_UpdateVal struct {
	UpdateVal bool `protobuf:"varint,22,opt,name=updateVal,proto3,oneof" json:"updateVal,omitempty"`
}

func (*Const_I8Val) isConst_Value()         {}
func (*Const_I16Val) isConst_Value()        {}
func (*Const_I32Val) isConst_Value()        {}
func (*Const_I64Val) isConst_Value()        {}
func (*Const_U8Val) isConst_Value()         {}
func (*Const_U16Val) isConst_Value()        {}
func (*Const_U32Val) isConst_Value()        {}
func (*Const_U64Val) isConst_Value()        {}
func (*Const_Dval) isConst_Value()          {}
func (*Const_Sval) isConst_Value()          {}
func (*Const_Bval) isConst_Value()          {}
func (*Const_Fval) isConst_Value()          {}
func (*Const_Dateval) isConst_Value()       {}
func (*Const_Timeval) isConst_Value()       {}
func (*Const_Datetimeval) isConst_Value()   {}
func (*Const_Decimal64Val) isConst_Value()  {}
func (*Const_Decimal128Val) isConst_Value() {}
func (*Const_Timestampval) isConst_Value()  {}
func (*Const_Jsonval) isConst_Value()       {}
func (*Const_Defaultval) isConst_Value()    {}
func (*Const_UpdateVal) isConst_Value()     {}

func (m *Const) GetValue() isConst_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Const) GetIsnull() bool {
	if m != nil {
		return m.Isnull
	}
	return false
}

func (m *Const) GetI8Val() int32 {
	if x, ok := m.GetValue().(*Const_I8Val); ok {
		return x.I8Val
	}
	return 0
}

func (m *Const) GetI16Val() int32 {
	if x, ok := m.GetValue().(*Const_I16Val); ok {
		return x.I16Val
	}
	return 0
}

func (m *Const) GetI32Val() int32 {
	if x, ok := m.GetValue().(*Const_I32Val); ok {
		return x.I32Val
	}
	return 0
}

func (m *Const) GetI64Val() int64 {
	if x, ok := m.GetValue().(*Const_I64Val); ok {
		return x.I64Val
	}
	return 0
}

func (m *Const) GetU8Val() uint32 {
	if x, ok := m.GetValue().(*Const_U8Val); ok {
		return x.U8Val
	}
	return 0
}

func (m *Const) GetU16Val() uint32 {
	if x, ok := m.GetValue().(*Const_U16Val); ok {
		return x.U16Val
	}
	return 0
}

func (m *Const) GetU32Val() uint32 {
	if x, ok := m.GetValue().(*Const_U32Val); ok {
		return x.U32Val
	}
	return 0
}

func (m *Const) GetU64Val() uint64 {
	if x, ok := m.GetValue().(*Const_U64Val); ok {
		return x.U64Val
	}
	return 0
}

func (m *Const) GetDval() float64 {
	if x, ok := m.GetValue().(*Const_Dval); ok {
		return x.Dval
	}
	return 0
}

func (m *Const) GetSval() string {
	if x, ok := m.GetValue().(*Const_Sval); ok {
		return x.Sval
	}
	return ""
}

func (m *Const) GetBval() bool {
	if x, ok := m.GetValue().(*Const_Bval); ok {
		return x.Bval
	}
	return false
}

func (m *Const) GetFval() float32 {
	if x, ok := m.GetValue().(*Const_Fval); ok {
		return x.Fval
	}
	return 0
}

func (m *Const) GetDateval() int32 {
	if x, ok := m.GetValue().(*Const_Dateval); ok {
		return x.Dateval
	}
	return 0
}

func (m *Const) GetTimeval() int64 {
	if x, ok := m.GetValue().(*Const_Timeval); ok {
		return x.Timeval
	}
	return 0
}

func (m *Const) GetDatetimeval() int64 {
	if x, ok := m.GetValue().(*Const_Datetimeval); ok {
		return x.Datetimeval
	}
	return 0
}

func (m *Const) GetDecimal64Val() *Decimal64 {
	if x, ok := m.GetValue().(*Const_Decimal64Val); ok {
		return x.Decimal64Val
	}
	return nil
}

func (m *Const) GetDecimal128Val() *Decimal128 {
	if x, ok := m.GetValue().(*Const_Decimal128Val); ok {
		return x.Decimal128Val
	}
	return nil
}

func (m *Const) GetTimestampval() int64 {
	if x, ok := m.GetValue().(*Const_Timestampval); ok {
		return x.Timestampval
	}
	return 0
}

func (m *Const) GetJsonval() string {
	if x, ok := m.GetValue().(*Const_Jsonval); ok {
		return x.Jsonval
	}
	return ""
}

func (m *Const) GetDefaultval() bool {
	if x, ok := m.GetValue().(*Const_Defaultval); ok {
		return x.Defaultval
	}
	return false
}

func (m *Const) GetUpdateVal() bool {
	if x, ok := m.GetValue().(*Const_UpdateVal); ok {
		return x.UpdateVal
	}
	return false
}

func (m *Const) GetIsBin() bool {
	if m != nil {
		return m.IsBin
	}
	return false
}

func (m *Const) GetSrc() *Expr {
	if m != nil {
		return m.Src
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Const) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Const_I8Val)(nil),
		(*Const_I16Val)(nil),
		(*Const_I32Val)(nil),
		(*Const_I64Val)(nil),
		(*Const_U8Val)(nil),
		(*Const_U16Val)(nil),
		(*Const_U32Val)(nil),
		(*Const_U64Val)(nil),
		(*Const_Dval)(nil),
		(*Const_Sval)(nil),
		(*Const_Bval)(nil),
		(*Const_Fval)(nil),
		(*Const_Dateval)(nil),
		(*Const_Timeval)(nil),
		(*Const_Datetimeval)(nil),
		(*Const_Decimal64Val)(nil),
		(*Const_Decimal128Val)(nil),
		(*Const_Timestampval)(nil),
		(*Const_Jsonval)(nil),
		(*Const_Defaultval)(nil),
		(*Const_UpdateVal)(nil),
	}
}

// Bounded param for prepared statement.  User fill on execution.
type ParamRef struct {
	Pos                  int32    `protobuf:"varint,1,opt,name=pos,proto3" json:"pos,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ParamRef) Reset()         { *m = ParamRef{} }
func (m *ParamRef) String() string { return proto.CompactTextString(m) }
func (*ParamRef) ProtoMessage()    {}
func (*ParamRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{2}
}
func (m *ParamRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParamRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParamRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParamRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParamRef.Merge(m, src)
}
func (m *ParamRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ParamRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ParamRef.DiscardUnknown(m)
}

var xxx_messageInfo_ParamRef proto.InternalMessageInfo

func (m *ParamRef) GetPos() int32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

// Session variable ref, compiler should fold.
type VarRef struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	System               bool     `protobuf:"varint,2,opt,name=system,proto3" json:"system,omitempty"`
	Global               bool     `protobuf:"varint,3,opt,name=global,proto3" json:"global,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VarRef) Reset()         { *m = VarRef{} }
func (m *VarRef) String() string { return proto.CompactTextString(m) }
func (*VarRef) ProtoMessage()    {}
func (*VarRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{3}
}
func (m *VarRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VarRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VarRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VarRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VarRef.Merge(m, src)
}
func (m *VarRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *VarRef) XXX_DiscardUnknown() {
	xxx_messageInfo_VarRef.DiscardUnknown(m)
}

var xxx_messageInfo_VarRef proto.InternalMessageInfo

func (m *VarRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VarRef) GetSystem() bool {
	if m != nil {
		return m.System
	}
	return false
}

func (m *VarRef) GetGlobal() bool {
	if m != nil {
		return m.Global
	}
	return false
}

// Reference a column in the proj list of a node.
type ColRef struct {
	RelPos               int32    `protobuf:"varint,1,opt,name=rel_pos,json=relPos,proto3" json:"rel_pos,omitempty"`
	ColPos               int32    `protobuf:"varint,2,opt,name=col_pos,json=colPos,proto3" json:"col_pos,omitempty"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ColRef) Reset()         { *m = ColRef{} }
func (m *ColRef) String() string { return proto.CompactTextString(m) }
func (*ColRef) ProtoMessage()    {}
func (*ColRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{4}
}
func (m *ColRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColRef.Merge(m, src)
}
func (m *ColRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ColRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ColRef.DiscardUnknown(m)
}

var xxx_messageInfo_ColRef proto.InternalMessageInfo

func (m *ColRef) GetRelPos() int32 {
	if m != nil {
		return m.RelPos
	}
	return 0
}

func (m *ColRef) GetColPos() int32 {
	if m != nil {
		return m.ColPos
	}
	return 0
}

func (m *ColRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Reference a column by its internal table id and column id
type RawColRef struct {
	TblId                uint64   `protobuf:"varint,1,opt,name=tbl_id,json=tblId,proto3" json:"tbl_id,omitempty"`
	ColId                uint64   `protobuf:"varint,2,opt,name=col_id,json=colId,proto3" json:"col_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RawColRef) Reset()         { *m = RawColRef{} }
func (m *RawColRef) String() string { return proto.CompactTextString(m) }
func (*RawColRef) ProtoMessage()    {}
func (*RawColRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{5}
}
func (m *RawColRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawColRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawColRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawColRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawColRef.Merge(m, src)
}
func (m *RawColRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RawColRef) XXX_DiscardUnknown() {
	xxx_messageInfo_RawColRef.DiscardUnknown(m)
}

var xxx_messageInfo_RawColRef proto.InternalMessageInfo

func (m *RawColRef) GetTblId() uint64 {
	if m != nil {
		return m.TblId
	}
	return 0
}

func (m *RawColRef) GetColId() uint64 {
	if m != nil {
		return m.ColId
	}
	return 0
}

// Reference a correlated column in the proj list of a node.
type CorrColRef struct {
	RelPos               int32    `protobuf:"varint,1,opt,name=rel_pos,json=relPos,proto3" json:"rel_pos,omitempty"`
	ColPos               int32    `protobuf:"varint,2,opt,name=col_pos,json=colPos,proto3" json:"col_pos,omitempty"`
	Depth                int32    `protobuf:"varint,3,opt,name=depth,proto3" json:"depth,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CorrColRef) Reset()         { *m = CorrColRef{} }
func (m *CorrColRef) String() string { return proto.CompactTextString(m) }
func (*CorrColRef) ProtoMessage()    {}
func (*CorrColRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{6}
}
func (m *CorrColRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CorrColRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CorrColRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CorrColRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CorrColRef.Merge(m, src)
}
func (m *CorrColRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CorrColRef) XXX_DiscardUnknown() {
	xxx_messageInfo_CorrColRef.DiscardUnknown(m)
}

var xxx_messageInfo_CorrColRef proto.InternalMessageInfo

func (m *CorrColRef) GetRelPos() int32 {
	if m != nil {
		return m.RelPos
	}
	return 0
}

func (m *CorrColRef) GetColPos() int32 {
	if m != nil {
		return m.ColPos
	}
	return 0
}

func (m *CorrColRef) GetDepth() int32 {
	if m != nil {
		return m.Depth
	}
	return 0
}

// ExprList is a type of Expr
type ExprList struct {
	List                 []*Expr  `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExprList) Reset()         { *m = ExprList{} }
func (m *ExprList) String() string { return proto.CompactTextString(m) }
func (*ExprList) ProtoMessage()    {}
func (*ExprList) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{7}
}
func (m *ExprList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExprList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExprList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExprList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExprList.Merge(m, src)
}
func (m *ExprList) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExprList) XXX_DiscardUnknown() {
	xxx_messageInfo_ExprList.DiscardUnknown(m)
}

var xxx_messageInfo_ExprList proto.InternalMessageInfo

func (m *ExprList) GetList() []*Expr {
	if m != nil {
		return m.List
	}
	return nil
}

type MaxValue struct {
	Value                string   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MaxValue) Reset()         { *m = MaxValue{} }
func (m *MaxValue) String() string { return proto.CompactTextString(m) }
func (*MaxValue) ProtoMessage()    {}
func (*MaxValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{8}
}
func (m *MaxValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaxValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaxValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaxValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaxValue.Merge(m, src)
}
func (m *MaxValue) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MaxValue) XXX_DiscardUnknown() {
	xxx_messageInfo_MaxValue.DiscardUnknown(m)
}

var xxx_messageInfo_MaxValue proto.InternalMessageInfo

func (m *MaxValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// TargetType used in cast function as target type
type TargetType struct {
	Typ                  *Type    `protobuf:"bytes,1,opt,name=typ,proto3" json:"typ,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TargetType) Reset()         { *m = TargetType{} }
func (m *TargetType) String() string { return proto.CompactTextString(m) }
func (*TargetType) ProtoMessage()    {}
func (*TargetType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{9}
}
func (m *TargetType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TargetType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TargetType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TargetType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TargetType.Merge(m, src)
}
func (m *TargetType) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TargetType) XXX_DiscardUnknown() {
	xxx_messageInfo_TargetType.DiscardUnknown(m)
}

var xxx_messageInfo_TargetType proto.InternalMessageInfo

func (m *TargetType) GetTyp() *Type {
	if m != nil {
		return m.Typ
	}
	return nil
}

// Reference a subquery
type SubqueryRef struct {
	Typ                  SubqueryRef_Type `protobuf:"varint,1,opt,name=typ,proto3,enum=plan.SubqueryRef_Type" json:"typ,omitempty"`
	NodeId               int32            `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Op                   string           `protobuf:"bytes,3,opt,name=op,proto3" json:"op,omitempty"`
	Child                *Expr            `protobuf:"bytes,4,opt,name=child,proto3" json:"child,omitempty"`
	RowSize              int32            `protobuf:"varint,5,opt,name=row_size,json=rowSize,proto3" json:"row_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SubqueryRef) Reset()         { *m = SubqueryRef{} }
func (m *SubqueryRef) String() string { return proto.CompactTextString(m) }
func (*SubqueryRef) ProtoMessage()    {}
func (*SubqueryRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{10}
}
func (m *SubqueryRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubqueryRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubqueryRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubqueryRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubqueryRef.Merge(m, src)
}
func (m *SubqueryRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SubqueryRef) XXX_DiscardUnknown() {
	xxx_messageInfo_SubqueryRef.DiscardUnknown(m)
}

var xxx_messageInfo_SubqueryRef proto.InternalMessageInfo

func (m *SubqueryRef) GetTyp() SubqueryRef_Type {
	if m != nil {
		return m.Typ
	}
	return SubqueryRef_SCALAR
}

func (m *SubqueryRef) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *SubqueryRef) GetOp() string {
	if m != nil {
		return m.Op
	}
	return ""
}

func (m *SubqueryRef) GetChild() *Expr {
	if m != nil {
		return m.Child
	}
	return nil
}

func (m *SubqueryRef) GetRowSize() int32 {
	if m != nil {
		return m.RowSize
	}
	return 0
}

// Object ref, reference a object in database, 4 part name.
type ObjectRef struct {
	Server               int64    `protobuf:"varint,1,opt,name=server,proto3" json:"server,omitempty"`
	Db                   int64    `protobuf:"varint,2,opt,name=db,proto3" json:"db,omitempty"`
	Schema               int64    `protobuf:"varint,3,opt,name=schema,proto3" json:"schema,omitempty"`
	Obj                  int64    `protobuf:"varint,4,opt,name=obj,proto3" json:"obj,omitempty"`
	ServerName           string   `protobuf:"bytes,5,opt,name=server_name,json=serverName,proto3" json:"server_name,omitempty"`
	DbName               string   `protobuf:"bytes,6,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	SchemaName           string   `protobuf:"bytes,7,opt,name=schema_name,json=schemaName,proto3" json:"schema_name,omitempty"`
	ObjName              string   `protobuf:"bytes,8,opt,name=obj_name,json=objName,proto3" json:"obj_name,omitempty"`
	SubscriptionName     string   `protobuf:"bytes,9,opt,name=subscription_name,json=subscriptionName,proto3" json:"subscription_name,omitempty"`
	PubAccountId         int32    `protobuf:"varint,10,opt,name=pub_account_id,json=pubAccountId,proto3" json:"pub_account_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectRef) Reset()         { *m = ObjectRef{} }
func (m *ObjectRef) String() string { return proto.CompactTextString(m) }
func (*ObjectRef) ProtoMessage()    {}
func (*ObjectRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{11}
}
func (m *ObjectRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectRef.Merge(m, src)
}
func (m *ObjectRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ObjectRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectRef.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectRef proto.InternalMessageInfo

func (m *ObjectRef) GetServer() int64 {
	if m != nil {
		return m.Server
	}
	return 0
}

func (m *ObjectRef) GetDb() int64 {
	if m != nil {
		return m.Db
	}
	return 0
}

func (m *ObjectRef) GetSchema() int64 {
	if m != nil {
		return m.Schema
	}
	return 0
}

func (m *ObjectRef) GetObj() int64 {
	if m != nil {
		return m.Obj
	}
	return 0
}

func (m *ObjectRef) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

func (m *ObjectRef) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *ObjectRef) GetSchemaName() string {
	if m != nil {
		return m.SchemaName
	}
	return ""
}

func (m *ObjectRef) GetObjName() string {
	if m != nil {
		return m.ObjName
	}
	return ""
}

func (m *ObjectRef) GetSubscriptionName() string {
	if m != nil {
		return m.SubscriptionName
	}
	return ""
}

func (m *ObjectRef) GetPubAccountId() int32 {
	if m != nil {
		return m.PubAccountId
	}
	return 0
}

type SubscriptionMeta struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	AccountId            int32    `protobuf:"varint,2,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
	DbName               string   `protobuf:"bytes,3,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	AccountName          string   `protobuf:"bytes,4,opt,name=account_name,json=accountName,proto3" json:"account_name,omitempty"`
	SubName              string   `protobuf:"bytes,5,opt,name=sub_name,json=subName,proto3" json:"sub_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscriptionMeta) Reset()         { *m = SubscriptionMeta{} }
func (m *SubscriptionMeta) String() string { return proto.CompactTextString(m) }
func (*SubscriptionMeta) ProtoMessage()    {}
func (*SubscriptionMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{12}
}
func (m *SubscriptionMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscriptionMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscriptionMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscriptionMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriptionMeta.Merge(m, src)
}
func (m *SubscriptionMeta) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SubscriptionMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriptionMeta.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriptionMeta proto.InternalMessageInfo

func (m *SubscriptionMeta) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SubscriptionMeta) GetAccountId() int32 {
	if m != nil {
		return m.AccountId
	}
	return 0
}

func (m *SubscriptionMeta) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *SubscriptionMeta) GetAccountName() string {
	if m != nil {
		return m.AccountName
	}
	return ""
}

func (m *SubscriptionMeta) GetSubName() string {
	if m != nil {
		return m.SubName
	}
	return ""
}

type Function struct {
	Func                 *ObjectRef `protobuf:"bytes,1,opt,name=func,proto3" json:"func,omitempty"`
	Args                 []*Expr    `protobuf:"bytes,2,rep,name=args,proto3" json:"args,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Function) Reset()         { *m = Function{} }
func (m *Function) String() string { return proto.CompactTextString(m) }
func (*Function) ProtoMessage()    {}
func (*Function) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{13}
}
func (m *Function) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Function) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Function.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Function) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Function.Merge(m, src)
}
func (m *Function) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Function) XXX_DiscardUnknown() {
	xxx_messageInfo_Function.DiscardUnknown(m)
}

var xxx_messageInfo_Function proto.InternalMessageInfo

func (m *Function) GetFunc() *ObjectRef {
	if m != nil {
		return m.Func
	}
	return nil
}

func (m *Function) GetArgs() []*Expr {
	if m != nil {
		return m.Args
	}
	return nil
}

type Expr struct {
	Typ *Type `protobuf:"bytes,1,opt,name=typ,proto3" json:"typ,omitempty"`
	// Types that are valid to be assigned to Expr:
	//
	//	*Expr_C
	//	*Expr_P
	//	*Expr_V
	//	*Expr_Col
	//	*Expr_Raw
	//	*Expr_F
	//	*Expr_Sub
	//	*Expr_Corr
	//	*Expr_T
	//	*Expr_List
	//	*Expr_Max
	Expr                 isExpr_Expr `protobuf_oneof:"expr"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Expr) Reset()         { *m = Expr{} }
func (m *Expr) String() string { return proto.CompactTextString(m) }
func (*Expr) ProtoMessage()    {}
func (*Expr) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{14}
}
func (m *Expr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Expr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Expr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Expr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Expr.Merge(m, src)
}
func (m *Expr) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Expr) XXX_DiscardUnknown() {
	xxx_messageInfo_Expr.DiscardUnknown(m)
}

var xxx_messageInfo_Expr proto.InternalMessageInfo

type isExpr_Expr interface {
	isExpr_Expr()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type Expr_C struct {
	C *Const `protobuf:"bytes,2,opt,name=c,proto3,oneof" json:"c,omitempty"`
}
type Expr_P struct {
	P *ParamRef `protobuf:"bytes,3,opt,name=p,proto3,oneof" json:"p,omitempty"`
}
type Expr_V struct {
	V *VarRef `protobuf:"bytes,4,opt,name=v,proto3,oneof" json:"v,omitempty"`
}
type Expr_Col struct {
	Col *ColRef `protobuf:"bytes,5,opt,name=col,proto3,oneof" json:"col,omitempty"`
}
type Expr_Raw struct {
	Raw *RawColRef `protobuf:"bytes,6,opt,name=raw,proto3,oneof" json:"raw,omitempty"`
}
type Expr_F struct {
	F *Function `protobuf:"bytes,7,opt,name=f,proto3,oneof" json:"f,omitempty"`
}
type Expr_Sub struct {
	Sub *SubqueryRef `protobuf:"bytes,8,opt,name=sub,proto3,oneof" json:"sub,omitempty"`
}
type Expr_Corr struct {
	Corr *CorrColRef `protobuf:"bytes,9,opt,name=corr,proto3,oneof" json:"corr,omitempty"`
}
type Expr_T struct {
	T *TargetType `protobuf:"bytes,10,opt,name=t,proto3,oneof" json:"t,omitempty"`
}
type Expr_List struct {
	List *ExprList `protobuf:"bytes,11,opt,name=list,proto3,oneof" json:"list,omitempty"`
}
type Expr_Max struct {
	Max *MaxValue `protobuf:"bytes,12,opt,name=max,proto3,oneof" json:"max,omitempty"`
}

func (*Expr_C) isExpr_Expr()    {}
func (*Expr_P) isExpr_Expr()    {}
func (*Expr_V) isExpr_Expr()    {}
func (*Expr_Col) isExpr_Expr()  {}
func (*Expr_Raw) isExpr_Expr()  {}
func (*Expr_F) isExpr_Expr()    {}
func (*Expr_Sub) isExpr_Expr()  {}
func (*Expr_Corr) isExpr_Expr() {}
func (*Expr_T) isExpr_Expr()    {}
func (*Expr_List) isExpr_Expr() {}
func (*Expr_Max) isExpr_Expr()  {}

func (m *Expr) GetExpr() isExpr_Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Expr) GetTyp() *Type {
	if m != nil {
		return m.Typ
	}
	return nil
}

func (m *Expr) GetC() *Const {
	if x, ok := m.GetExpr().(*Expr_C); ok {
		return x.C
	}
	return nil
}

func (m *Expr) GetP() *ParamRef {
	if x, ok := m.GetExpr().(*Expr_P); ok {
		return x.P
	}
	return nil
}

func (m *Expr) GetV() *VarRef {
	if x, ok := m.GetExpr().(*Expr_V); ok {
		return x.V
	}
	return nil
}

func (m *Expr) GetCol() *ColRef {
	if x, ok := m.GetExpr().(*Expr_Col); ok {
		return x.Col
	}
	return nil
}

func (m *Expr) GetRaw() *RawColRef {
	if x, ok := m.GetExpr().(*Expr_Raw); ok {
		return x.Raw
	}
	return nil
}

func (m *Expr) GetF() *Function {
	if x, ok := m.GetExpr().(*Expr_F); ok {
		return x.F
	}
	return nil
}

func (m *Expr) GetSub() *SubqueryRef {
	if x, ok := m.GetExpr().(*Expr_Sub); ok {
		return x.Sub
	}
	return nil
}

func (m *Expr) GetCorr() *CorrColRef {
	if x, ok := m.GetExpr().(*Expr_Corr); ok {
		return x.Corr
	}
	return nil
}

func (m *Expr) GetT() *TargetType {
	if x, ok := m.GetExpr().(*Expr_T); ok {
		return x.T
	}
	return nil
}

func (m *Expr) GetList() *ExprList {
	if x, ok := m.GetExpr().(*Expr_List); ok {
		return x.List
	}
	return nil
}

func (m *Expr) GetMax() *MaxValue {
	if x, ok := m.GetExpr().(*Expr_Max); ok {
		return x.Max
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Expr) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Expr_C)(nil),
		(*Expr_P)(nil),
		(*Expr_V)(nil),
		(*Expr_Col)(nil),
		(*Expr_Raw)(nil),
		(*Expr_F)(nil),
		(*Expr_Sub)(nil),
		(*Expr_Corr)(nil),
		(*Expr_T)(nil),
		(*Expr_List)(nil),
		(*Expr_Max)(nil),
	}
}

type Decimal64 struct {
	A                    int64    `protobuf:"varint,1,opt,name=a,proto3" json:"a,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Decimal64) Reset()         { *m = Decimal64{} }
func (m *Decimal64) String() string { return proto.CompactTextString(m) }
func (*Decimal64) ProtoMessage()    {}
func (*Decimal64) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{15}
}
func (m *Decimal64) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Decimal64) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Decimal64.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Decimal64) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Decimal64.Merge(m, src)
}
func (m *Decimal64) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Decimal64) XXX_DiscardUnknown() {
	xxx_messageInfo_Decimal64.DiscardUnknown(m)
}

var xxx_messageInfo_Decimal64 proto.InternalMessageInfo

func (m *Decimal64) GetA() int64 {
	if m != nil {
		return m.A
	}
	return 0
}

type Decimal128 struct {
	A                    int64    `protobuf:"varint,1,opt,name=a,proto3" json:"a,omitempty"`
	B                    int64    `protobuf:"varint,2,opt,name=b,proto3" json:"b,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Decimal128) Reset()         { *m = Decimal128{} }
func (m *Decimal128) String() string { return proto.CompactTextString(m) }
func (*Decimal128) ProtoMessage()    {}
func (*Decimal128) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{16}
}
func (m *Decimal128) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Decimal128) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Decimal128.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Decimal128) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Decimal128.Merge(m, src)
}
func (m *Decimal128) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Decimal128) XXX_DiscardUnknown() {
	xxx_messageInfo_Decimal128.DiscardUnknown(m)
}

var xxx_messageInfo_Decimal128 proto.InternalMessageInfo

func (m *Decimal128) GetA() int64 {
	if m != nil {
		return m.A
	}
	return 0
}

func (m *Decimal128) GetB() int64 {
	if m != nil {
		return m.B
	}
	return 0
}

type ResultColDef struct {
	ResultCols           []*ColDef `protobuf:"bytes,1,rep,name=ResultCols,proto3" json:"ResultCols,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ResultColDef) Reset()         { *m = ResultColDef{} }
func (m *ResultColDef) String() string { return proto.CompactTextString(m) }
func (*ResultColDef) ProtoMessage()    {}
func (*ResultColDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{17}
}
func (m *ResultColDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultColDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultColDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultColDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultColDef.Merge(m, src)
}
func (m *ResultColDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ResultColDef) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultColDef.DiscardUnknown(m)
}

var xxx_messageInfo_ResultColDef proto.InternalMessageInfo

func (m *ResultColDef) GetResultCols() []*ColDef {
	if m != nil {
		return m.ResultCols
	}
	return nil
}

type ColDef struct {
	ColId    uint64       `protobuf:"varint,1,opt,name=col_id,json=colId,proto3" json:"col_id,omitempty"`
	Name     string       `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Hidden   bool         `protobuf:"varint,3,opt,name=hidden,proto3" json:"hidden,omitempty"`
	Alg      CompressType `protobuf:"varint,4,opt,name=alg,proto3,enum=plan.CompressType" json:"alg,omitempty"`
	Typ      *Type        `protobuf:"bytes,5,opt,name=typ,proto3" json:"typ,omitempty"`
	NotNull  bool         `protobuf:"varint,6,opt,name=not_null,json=notNull,proto3" json:"not_null,omitempty"`
	Default  *Default     `protobuf:"bytes,7,opt,name=default,proto3" json:"default,omitempty"`
	Comment  string       `protobuf:"bytes,8,opt,name=comment,proto3" json:"comment,omitempty"`
	OnUpdate *OnUpdate    `protobuf:"bytes,9,opt,name=on_update,json=onUpdate,proto3" json:"on_update,omitempty"`
	LowCard  bool         `protobuf:"varint,10,opt,name=low_card,json=lowCard,proto3" json:"low_card,omitempty"`
	Seqnum   uint32       `protobuf:"varint,14,opt,name=seqnum,proto3" json:"seqnum,omitempty"`
	// XXX: Deprecated and to be removed soon.
	ClusterBy            bool     `protobuf:"varint,11,opt,name=clusterBy,proto3" json:"clusterBy,omitempty"`
	Primary              bool     `protobuf:"varint,12,opt,name=primary,proto3" json:"primary,omitempty"`
	Pkidx                int32    `protobuf:"varint,13,opt,name=pkidx,proto3" json:"pkidx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ColDef) Reset()         { *m = ColDef{} }
func (m *ColDef) String() string { return proto.CompactTextString(m) }
func (*ColDef) ProtoMessage()    {}
func (*ColDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{18}
}
func (m *ColDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColDef.Merge(m, src)
}
func (m *ColDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ColDef) XXX_DiscardUnknown() {
	xxx_messageInfo_ColDef.DiscardUnknown(m)
}

var xxx_messageInfo_ColDef proto.InternalMessageInfo

func (m *ColDef) GetColId() uint64 {
	if m != nil {
		return m.ColId
	}
	return 0
}

func (m *ColDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ColDef) GetHidden() bool {
	if m != nil {
		return m.Hidden
	}
	return false
}

func (m *ColDef) GetAlg() CompressType {
	if m != nil {
		return m.Alg
	}
	return CompressType_None
}

func (m *ColDef) GetTyp() *Type {
	if m != nil {
		return m.Typ
	}
	return nil
}

func (m *ColDef) GetNotNull() bool {
	if m != nil {
		return m.NotNull
	}
	return false
}

func (m *ColDef) GetDefault() *Default {
	if m != nil {
		return m.Default
	}
	return nil
}

func (m *ColDef) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *ColDef) GetOnUpdate() *OnUpdate {
	if m != nil {
		return m.OnUpdate
	}
	return nil
}

func (m *ColDef) GetLowCard() bool {
	if m != nil {
		return m.LowCard
	}
	return false
}

func (m *ColDef) GetSeqnum() uint32 {
	if m != nil {
		return m.Seqnum
	}
	return 0
}

func (m *ColDef) GetClusterBy() bool {
	if m != nil {
		return m.ClusterBy
	}
	return false
}

func (m *ColDef) GetPrimary() bool {
	if m != nil {
		return m.Primary
	}
	return false
}

func (m *ColDef) GetPkidx() int32 {
	if m != nil {
		return m.Pkidx
	}
	return 0
}

type Default struct {
	Expr         *Expr  `protobuf:"bytes,1,opt,name=expr,proto3" json:"expr,omitempty"`
	OriginString string `protobuf:"bytes,2,opt,name=origin_string,json=originString,proto3" json:"origin_string,omitempty"`
	// XXX: Deprecated and to be removed soon.
	NullAbility          bool     `protobuf:"varint,3,opt,name=null_ability,json=nullAbility,proto3" json:"null_ability,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Default) Reset()         { *m = Default{} }
func (m *Default) String() string { return proto.CompactTextString(m) }
func (*Default) ProtoMessage()    {}
func (*Default) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{19}
}
func (m *Default) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Default) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Default.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Default) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Default.Merge(m, src)
}
func (m *Default) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Default) XXX_DiscardUnknown() {
	xxx_messageInfo_Default.DiscardUnknown(m)
}

var xxx_messageInfo_Default proto.InternalMessageInfo

func (m *Default) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Default) GetOriginString() string {
	if m != nil {
		return m.OriginString
	}
	return ""
}

func (m *Default) GetNullAbility() bool {
	if m != nil {
		return m.NullAbility
	}
	return false
}

type OnUpdate struct {
	Expr                 *Expr    `protobuf:"bytes,1,opt,name=expr,proto3" json:"expr,omitempty"`
	OriginString         string   `protobuf:"bytes,2,opt,name=origin_string,json=originString,proto3" json:"origin_string,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OnUpdate) Reset()         { *m = OnUpdate{} }
func (m *OnUpdate) String() string { return proto.CompactTextString(m) }
func (*OnUpdate) ProtoMessage()    {}
func (*OnUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{20}
}
func (m *OnUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OnUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OnUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OnUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnUpdate.Merge(m, src)
}
func (m *OnUpdate) XXX_Size() int {
	return m.ProtoSize()
}
func (m *OnUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_OnUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_OnUpdate proto.InternalMessageInfo

func (m *OnUpdate) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *OnUpdate) GetOriginString() string {
	if m != nil {
		return m.OriginString
	}
	return ""
}

type IndexOption struct {
	CreateExtraTable     bool     `protobuf:"varint,1,opt,name=create_extra_table,json=createExtraTable,proto3" json:"create_extra_table,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IndexOption) Reset()         { *m = IndexOption{} }
func (m *IndexOption) String() string { return proto.CompactTextString(m) }
func (*IndexOption) ProtoMessage()    {}
func (*IndexOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{21}
}
func (m *IndexOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexOption.Merge(m, src)
}
func (m *IndexOption) XXX_Size() int {
	return m.ProtoSize()
}
func (m *IndexOption) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexOption.DiscardUnknown(m)
}

var xxx_messageInfo_IndexOption proto.InternalMessageInfo

func (m *IndexOption) GetCreateExtraTable() bool {
	if m != nil {
		return m.CreateExtraTable
	}
	return false
}

type PrimaryKeyDef struct {
	// currently not used
	Cols []uint64 `protobuf:"varint,1,rep,packed,name=cols,proto3" json:"cols,omitempty"`
	// currently not used
	PkeyColId uint64 `protobuf:"varint,2,opt,name=pkey_col_id,json=pkeyColId,proto3" json:"pkey_col_id,omitempty"`
	// currently not used
	Option *IndexOption `protobuf:"bytes,3,opt,name=option,proto3" json:"option,omitempty"`
	// Composed primary key column name: __mo_cpkey
	PkeyColName string `protobuf:"bytes,4,opt,name=pkey_col_name,json=pkeyColName,proto3" json:"pkey_col_name,omitempty"`
	// XXX: Deprecated and to be removed soon.
	Names []string `protobuf:"bytes,5,rep,name=names,proto3" json:"names,omitempty"`
	// Composite primary key column definition
	CompPkeyCol          *ColDef  `protobuf:"bytes,6,opt,name=comp_pkey_col,json=compPkeyCol,proto3" json:"comp_pkey_col,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PrimaryKeyDef) Reset()         { *m = PrimaryKeyDef{} }
func (m *PrimaryKeyDef) String() string { return proto.CompactTextString(m) }
func (*PrimaryKeyDef) ProtoMessage()    {}
func (*PrimaryKeyDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{22}
}
func (m *PrimaryKeyDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrimaryKeyDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrimaryKeyDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrimaryKeyDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrimaryKeyDef.Merge(m, src)
}
func (m *PrimaryKeyDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PrimaryKeyDef) XXX_DiscardUnknown() {
	xxx_messageInfo_PrimaryKeyDef.DiscardUnknown(m)
}

var xxx_messageInfo_PrimaryKeyDef proto.InternalMessageInfo

func (m *PrimaryKeyDef) GetCols() []uint64 {
	if m != nil {
		return m.Cols
	}
	return nil
}

func (m *PrimaryKeyDef) GetPkeyColId() uint64 {
	if m != nil {
		return m.PkeyColId
	}
	return 0
}

func (m *PrimaryKeyDef) GetOption() *IndexOption {
	if m != nil {
		return m.Option
	}
	return nil
}

func (m *PrimaryKeyDef) GetPkeyColName() string {
	if m != nil {
		return m.PkeyColName
	}
	return ""
}

func (m *PrimaryKeyDef) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

func (m *PrimaryKeyDef) GetCompPkeyCol() *ColDef {
	if m != nil {
		return m.CompPkeyCol
	}
	return nil
}

type IndexDef struct {
	// Generate UUID for each index, currently not used
	IdxId     string `protobuf:"bytes,1,opt,name=idx_id,json=idxId,proto3" json:"idx_id,omitempty"`
	IndexName string `protobuf:"bytes,2,opt,name=index_name,json=indexName,proto3" json:"index_name,omitempty"`
	// The constituent columns of the index
	Parts          []string `protobuf:"bytes,3,rep,name=parts,proto3" json:"parts,omitempty"`
	Unique         bool     `protobuf:"varint,4,opt,name=unique,proto3" json:"unique,omitempty"`
	IndexTableName string   `protobuf:"bytes,5,opt,name=index_table_name,json=indexTableName,proto3" json:"index_table_name,omitempty"`
	TableExist     bool     `protobuf:"varint,6,opt,name=table_exist,json=tableExist,proto3" json:"table_exist,omitempty"`
	Comment        string   `protobuf:"bytes,7,opt,name=comment,proto3" json:"comment,omitempty"`
	Visible        bool     `protobuf:"varint,8,opt,name=visible,proto3" json:"visible,omitempty"`
	// currently not used
	Option               *IndexOption `protobuf:"bytes,9,opt,name=option,proto3" json:"option,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *IndexDef) Reset()         { *m = IndexDef{} }
func (m *IndexDef) String() string { return proto.CompactTextString(m) }
func (*IndexDef) ProtoMessage()    {}
func (*IndexDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{23}
}
func (m *IndexDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexDef.Merge(m, src)
}
func (m *IndexDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *IndexDef) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexDef.DiscardUnknown(m)
}

var xxx_messageInfo_IndexDef proto.InternalMessageInfo

func (m *IndexDef) GetIdxId() string {
	if m != nil {
		return m.IdxId
	}
	return ""
}

func (m *IndexDef) GetIndexName() string {
	if m != nil {
		return m.IndexName
	}
	return ""
}

func (m *IndexDef) GetParts() []string {
	if m != nil {
		return m.Parts
	}
	return nil
}

func (m *IndexDef) GetUnique() bool {
	if m != nil {
		return m.Unique
	}
	return false
}

func (m *IndexDef) GetIndexTableName() string {
	if m != nil {
		return m.IndexTableName
	}
	return ""
}

func (m *IndexDef) GetTableExist() bool {
	if m != nil {
		return m.TableExist
	}
	return false
}

func (m *IndexDef) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *IndexDef) GetVisible() bool {
	if m != nil {
		return m.Visible
	}
	return false
}

func (m *IndexDef) GetOption() *IndexOption {
	if m != nil {
		return m.Option
	}
	return nil
}

type ForeignKeyDef struct {
	Name                 string                  `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Cols                 []uint64                `protobuf:"varint,2,rep,packed,name=cols,proto3" json:"cols,omitempty"`
	ForeignTbl           uint64                  `protobuf:"varint,3,opt,name=foreign_tbl,json=foreignTbl,proto3" json:"foreign_tbl,omitempty"`
	ForeignCols          []uint64                `protobuf:"varint,4,rep,packed,name=foreign_cols,json=foreignCols,proto3" json:"foreign_cols,omitempty"`
	OnDelete             ForeignKeyDef_RefAction `protobuf:"varint,5,opt,name=on_delete,json=onDelete,proto3,enum=plan.ForeignKeyDef_RefAction" json:"on_delete,omitempty"`
	OnUpdate             ForeignKeyDef_RefAction `protobuf:"varint,6,opt,name=on_update,json=onUpdate,proto3,enum=plan.ForeignKeyDef_RefAction" json:"on_update,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *ForeignKeyDef) Reset()         { *m = ForeignKeyDef{} }
func (m *ForeignKeyDef) String() string { return proto.CompactTextString(m) }
func (*ForeignKeyDef) ProtoMessage()    {}
func (*ForeignKeyDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{24}
}
func (m *ForeignKeyDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForeignKeyDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ForeignKeyDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ForeignKeyDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForeignKeyDef.Merge(m, src)
}
func (m *ForeignKeyDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ForeignKeyDef) XXX_DiscardUnknown() {
	xxx_messageInfo_ForeignKeyDef.DiscardUnknown(m)
}

var xxx_messageInfo_ForeignKeyDef proto.InternalMessageInfo

func (m *ForeignKeyDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ForeignKeyDef) GetCols() []uint64 {
	if m != nil {
		return m.Cols
	}
	return nil
}

func (m *ForeignKeyDef) GetForeignTbl() uint64 {
	if m != nil {
		return m.ForeignTbl
	}
	return 0
}

func (m *ForeignKeyDef) GetForeignCols() []uint64 {
	if m != nil {
		return m.ForeignCols
	}
	return nil
}

func (m *ForeignKeyDef) GetOnDelete() ForeignKeyDef_RefAction {
	if m != nil {
		return m.OnDelete
	}
	return ForeignKeyDef_RESTRICT
}

func (m *ForeignKeyDef) GetOnUpdate() ForeignKeyDef_RefAction {
	if m != nil {
		return m.OnUpdate
	}
	return ForeignKeyDef_RESTRICT
}

type CheckDef struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Name for anonymous constraints, __mo_chk_[INDEX_ID]
	Check                *Expr    `protobuf:"bytes,2,opt,name=check,proto3" json:"check,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckDef) Reset()         { *m = CheckDef{} }
func (m *CheckDef) String() string { return proto.CompactTextString(m) }
func (*CheckDef) ProtoMessage()    {}
func (*CheckDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{25}
}
func (m *CheckDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckDef.Merge(m, src)
}
func (m *CheckDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CheckDef) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckDef.DiscardUnknown(m)
}

var xxx_messageInfo_CheckDef proto.InternalMessageInfo

func (m *CheckDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CheckDef) GetCheck() *Expr {
	if m != nil {
		return m.Check
	}
	return nil
}

type ClusterByDef struct {
	Parts []*Expr `protobuf:"bytes,1,rep,name=parts,proto3" json:"parts,omitempty"`
	// XXX: Deprecated and to be removed soon.
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterByDef) Reset()         { *m = ClusterByDef{} }
func (m *ClusterByDef) String() string { return proto.CompactTextString(m) }
func (*ClusterByDef) ProtoMessage()    {}
func (*ClusterByDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{26}
}
func (m *ClusterByDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterByDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterByDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterByDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterByDef.Merge(m, src)
}
func (m *ClusterByDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ClusterByDef) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterByDef.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterByDef proto.InternalMessageInfo

func (m *ClusterByDef) GetParts() []*Expr {
	if m != nil {
		return m.Parts
	}
	return nil
}

func (m *ClusterByDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type PropertyDef struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PropertyDef) Reset()         { *m = PropertyDef{} }
func (m *PropertyDef) String() string { return proto.CompactTextString(m) }
func (*PropertyDef) ProtoMessage()    {}
func (*PropertyDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{27}
}
func (m *PropertyDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropertyDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropertyDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropertyDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropertyDef.Merge(m, src)
}
func (m *PropertyDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PropertyDef) XXX_DiscardUnknown() {
	xxx_messageInfo_PropertyDef.DiscardUnknown(m)
}

var xxx_messageInfo_PropertyDef proto.InternalMessageInfo

func (m *PropertyDef) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *PropertyDef) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type Property struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Property) Reset()         { *m = Property{} }
func (m *Property) String() string { return proto.CompactTextString(m) }
func (*Property) ProtoMessage()    {}
func (*Property) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{28}
}
func (m *Property) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Property) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Property.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Property) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Property.Merge(m, src)
}
func (m *Property) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Property) XXX_DiscardUnknown() {
	xxx_messageInfo_Property.DiscardUnknown(m)
}

var xxx_messageInfo_Property proto.InternalMessageInfo

func (m *Property) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Property) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type PropertiesDef struct {
	Properties           []*Property `protobuf:"bytes,1,rep,name=properties,proto3" json:"properties,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *PropertiesDef) Reset()         { *m = PropertiesDef{} }
func (m *PropertiesDef) String() string { return proto.CompactTextString(m) }
func (*PropertiesDef) ProtoMessage()    {}
func (*PropertiesDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{29}
}
func (m *PropertiesDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropertiesDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropertiesDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropertiesDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropertiesDef.Merge(m, src)
}
func (m *PropertiesDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PropertiesDef) XXX_DiscardUnknown() {
	xxx_messageInfo_PropertiesDef.DiscardUnknown(m)
}

var xxx_messageInfo_PropertiesDef proto.InternalMessageInfo

func (m *PropertiesDef) GetProperties() []*Property {
	if m != nil {
		return m.Properties
	}
	return nil
}

type PartitionByDef struct {
	Type                 PartitionType     `protobuf:"varint,1,opt,name=type,proto3,enum=plan.PartitionType" json:"type,omitempty"`
	PartitionExpr        *PartitionExpr    `protobuf:"bytes,2,opt,name=partition_expr,json=partitionExpr,proto3" json:"partition_expr,omitempty"`
	PartitionExpression  *Expr             `protobuf:"bytes,3,opt,name=partition_expression,json=partitionExpression,proto3" json:"partition_expression,omitempty"`
	PartitionColumns     *PartitionColumns `protobuf:"bytes,4,opt,name=partition_columns,json=partitionColumns,proto3" json:"partition_columns,omitempty"`
	PartitionNum         uint64            `protobuf:"varint,5,opt,name=partitionNum,proto3" json:"partitionNum,omitempty"`
	Partitions           []*PartitionItem  `protobuf:"bytes,6,rep,name=partitions,proto3" json:"partitions,omitempty"`
	Algorithm            int64             `protobuf:"varint,7,opt,name=algorithm,proto3" json:"algorithm,omitempty"`
	IsSubPartition       bool              `protobuf:"varint,8,opt,name=is_sub_partition,json=isSubPartition,proto3" json:"is_sub_partition,omitempty"`
	PartitionMsg         string            `protobuf:"bytes,9,opt,name=partition_msg,json=partitionMsg,proto3" json:"partition_msg,omitempty"`
	PartitionTableNames  []string          `protobuf:"bytes,10,rep,name=partition_table_names,json=partitionTableNames,proto3" json:"partition_table_names,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *PartitionByDef) Reset()         { *m = PartitionByDef{} }
func (m *PartitionByDef) String() string { return proto.CompactTextString(m) }
func (*PartitionByDef) ProtoMessage()    {}
func (*PartitionByDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{30}
}
func (m *PartitionByDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionByDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionByDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionByDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionByDef.Merge(m, src)
}
func (m *PartitionByDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PartitionByDef) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionByDef.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionByDef proto.InternalMessageInfo

func (m *PartitionByDef) GetType() PartitionType {
	if m != nil {
		return m.Type
	}
	return PartitionType_KEY
}

func (m *PartitionByDef) GetPartitionExpr() *PartitionExpr {
	if m != nil {
		return m.PartitionExpr
	}
	return nil
}

func (m *PartitionByDef) GetPartitionExpression() *Expr {
	if m != nil {
		return m.PartitionExpression
	}
	return nil
}

func (m *PartitionByDef) GetPartitionColumns() *PartitionColumns {
	if m != nil {
		return m.PartitionColumns
	}
	return nil
}

func (m *PartitionByDef) GetPartitionNum() uint64 {
	if m != nil {
		return m.PartitionNum
	}
	return 0
}

func (m *PartitionByDef) GetPartitions() []*PartitionItem {
	if m != nil {
		return m.Partitions
	}
	return nil
}

func (m *PartitionByDef) GetAlgorithm() int64 {
	if m != nil {
		return m.Algorithm
	}
	return 0
}

func (m *PartitionByDef) GetIsSubPartition() bool {
	if m != nil {
		return m.IsSubPartition
	}
	return false
}

func (m *PartitionByDef) GetPartitionMsg() string {
	if m != nil {
		return m.PartitionMsg
	}
	return ""
}

func (m *PartitionByDef) GetPartitionTableNames() []string {
	if m != nil {
		return m.PartitionTableNames
	}
	return nil
}

type PartitionExpr struct {
	Expr                 *Expr    `protobuf:"bytes,1,opt,name=expr,proto3" json:"expr,omitempty"`
	ExprStr              string   `protobuf:"bytes,2,opt,name=expr_str,json=exprStr,proto3" json:"expr_str,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartitionExpr) Reset()         { *m = PartitionExpr{} }
func (m *PartitionExpr) String() string { return proto.CompactTextString(m) }
func (*PartitionExpr) ProtoMessage()    {}
func (*PartitionExpr) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{31}
}
func (m *PartitionExpr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionExpr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionExpr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionExpr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionExpr.Merge(m, src)
}
func (m *PartitionExpr) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PartitionExpr) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionExpr.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionExpr proto.InternalMessageInfo

func (m *PartitionExpr) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *PartitionExpr) GetExprStr() string {
	if m != nil {
		return m.ExprStr
	}
	return ""
}

type PartitionColumns struct {
	Columns              []*Expr  `protobuf:"bytes,1,rep,name=columns,proto3" json:"columns,omitempty"`
	PartitionColumns     []string `protobuf:"bytes,2,rep,name=partition_columns,json=partitionColumns,proto3" json:"partition_columns,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartitionColumns) Reset()         { *m = PartitionColumns{} }
func (m *PartitionColumns) String() string { return proto.CompactTextString(m) }
func (*PartitionColumns) ProtoMessage()    {}
func (*PartitionColumns) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{32}
}
func (m *PartitionColumns) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionColumns) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionColumns.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionColumns) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionColumns.Merge(m, src)
}
func (m *PartitionColumns) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PartitionColumns) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionColumns.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionColumns proto.InternalMessageInfo

func (m *PartitionColumns) GetColumns() []*Expr {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *PartitionColumns) GetPartitionColumns() []string {
	if m != nil {
		return m.PartitionColumns
	}
	return nil
}

type PartitionItem struct {
	PartitionName        string   `protobuf:"bytes,1,opt,name=partition_name,json=partitionName,proto3" json:"partition_name,omitempty"`
	OrdinalPosition      uint32   `protobuf:"varint,2,opt,name=ordinal_position,json=ordinalPosition,proto3" json:"ordinal_position,omitempty"`
	Description          string   `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Comment              string   `protobuf:"bytes,4,opt,name=comment,proto3" json:"comment,omitempty"`
	LessThan             []*Expr  `protobuf:"bytes,5,rep,name=less_than,json=lessThan,proto3" json:"less_than,omitempty"`
	InValues             []*Expr  `protobuf:"bytes,6,rep,name=in_values,json=inValues,proto3" json:"in_values,omitempty"`
	PartitionTableName   string   `protobuf:"bytes,7,opt,name=partition_table_name,json=partitionTableName,proto3" json:"partition_table_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartitionItem) Reset()         { *m = PartitionItem{} }
func (m *PartitionItem) String() string { return proto.CompactTextString(m) }
func (*PartitionItem) ProtoMessage()    {}
func (*PartitionItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{33}
}
func (m *PartitionItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionItem.Merge(m, src)
}
func (m *PartitionItem) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PartitionItem) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionItem.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionItem proto.InternalMessageInfo

func (m *PartitionItem) GetPartitionName() string {
	if m != nil {
		return m.PartitionName
	}
	return ""
}

func (m *PartitionItem) GetOrdinalPosition() uint32 {
	if m != nil {
		return m.OrdinalPosition
	}
	return 0
}

func (m *PartitionItem) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *PartitionItem) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *PartitionItem) GetLessThan() []*Expr {
	if m != nil {
		return m.LessThan
	}
	return nil
}

func (m *PartitionItem) GetInValues() []*Expr {
	if m != nil {
		return m.InValues
	}
	return nil
}

func (m *PartitionItem) GetPartitionTableName() string {
	if m != nil {
		return m.PartitionTableName
	}
	return ""
}

type ViewDef struct {
	View                 string   `protobuf:"bytes,1,opt,name=view,proto3" json:"view,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ViewDef) Reset()         { *m = ViewDef{} }
func (m *ViewDef) String() string { return proto.CompactTextString(m) }
func (*ViewDef) ProtoMessage()    {}
func (*ViewDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{34}
}
func (m *ViewDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewDef.Merge(m, src)
}
func (m *ViewDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ViewDef) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewDef.DiscardUnknown(m)
}

var xxx_messageInfo_ViewDef proto.InternalMessageInfo

func (m *ViewDef) GetView() string {
	if m != nil {
		return m.View
	}
	return ""
}

type TableDef struct {
	TblId        uint64           `protobuf:"varint,1,opt,name=tbl_id,json=tblId,proto3" json:"tbl_id,omitempty"`
	Name         string           `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Hidden       bool             `protobuf:"varint,3,opt,name=hidden,proto3" json:"hidden,omitempty"`
	Cols         []*ColDef        `protobuf:"bytes,4,rep,name=cols,proto3" json:"cols,omitempty"`
	TableType    string           `protobuf:"bytes,5,opt,name=table_type,json=tableType,proto3" json:"table_type,omitempty"`
	Createsql    string           `protobuf:"bytes,6,opt,name=createsql,proto3" json:"createsql,omitempty"`
	TblFunc      *TableFunction   `protobuf:"bytes,7,opt,name=tbl_func,json=tblFunc,proto3" json:"tbl_func,omitempty"`
	Version      uint32           `protobuf:"varint,8,opt,name=version,proto3" json:"version,omitempty"`
	Pkey         *PrimaryKeyDef   `protobuf:"bytes,11,opt,name=pkey,proto3" json:"pkey,omitempty"`
	Indexes      []*IndexDef      `protobuf:"bytes,12,rep,name=indexes,proto3" json:"indexes,omitempty"`
	Fkeys        []*ForeignKeyDef `protobuf:"bytes,13,rep,name=fkeys,proto3" json:"fkeys,omitempty"`
	RefChildTbls []uint64         `protobuf:"varint,14,rep,packed,name=ref_child_tbls,json=refChildTbls,proto3" json:"ref_child_tbls,omitempty"`
	Checks       []*CheckDef      `protobuf:"bytes,15,rep,name=checks,proto3" json:"checks,omitempty"`
	Partition    *PartitionByDef  `protobuf:"bytes,21,opt,name=partition,proto3" json:"partition,omitempty"`
	ClusterBy    *ClusterByDef    `protobuf:"bytes,22,opt,name=cluster_by,json=clusterBy,proto3" json:"cluster_by,omitempty"`
	Props        []*PropertyDef   `protobuf:"bytes,23,rep,name=props,proto3" json:"props,omitempty"`
	ViewSql      *ViewDef         `protobuf:"bytes,24,opt,name=view_sql,json=viewSql,proto3" json:"view_sql,omitempty"`
	// XXX: Deprecated and to be removed soon.
	Defs                 []*TableDef_DefType `protobuf:"bytes,25,rep,name=defs,proto3" json:"defs,omitempty"`
	Name2ColIndex        map[string]int32    `protobuf:"bytes,26,rep,name=name2col_index,json=name2colIndex,proto3" json:"name2col_index,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	IsLocked             bool                `protobuf:"varint,27,opt,name=isLocked,proto3" json:"isLocked,omitempty"`
	TableLockType        TableLockType       `protobuf:"varint,28,opt,name=tableLockType,proto3,enum=plan.TableLockType" json:"tableLockType,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TableDef) Reset()         { *m = TableDef{} }
func (m *TableDef) String() string { return proto.CompactTextString(m) }
func (*TableDef) ProtoMessage()    {}
func (*TableDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{35}
}
func (m *TableDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDef.Merge(m, src)
}
func (m *TableDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableDef) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDef.DiscardUnknown(m)
}

var xxx_messageInfo_TableDef proto.InternalMessageInfo

func (m *TableDef) GetTblId() uint64 {
	if m != nil {
		return m.TblId
	}
	return 0
}

func (m *TableDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TableDef) GetHidden() bool {
	if m != nil {
		return m.Hidden
	}
	return false
}

func (m *TableDef) GetCols() []*ColDef {
	if m != nil {
		return m.Cols
	}
	return nil
}

func (m *TableDef) GetTableType() string {
	if m != nil {
		return m.TableType
	}
	return ""
}

func (m *TableDef) GetCreatesql() string {
	if m != nil {
		return m.Createsql
	}
	return ""
}

func (m *TableDef) GetTblFunc() *TableFunction {
	if m != nil {
		return m.TblFunc
	}
	return nil
}

func (m *TableDef) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *TableDef) GetPkey() *PrimaryKeyDef {
	if m != nil {
		return m.Pkey
	}
	return nil
}

func (m *TableDef) GetIndexes() []*IndexDef {
	if m != nil {
		return m.Indexes
	}
	return nil
}

func (m *TableDef) GetFkeys() []*ForeignKeyDef {
	if m != nil {
		return m.Fkeys
	}
	return nil
}

func (m *TableDef) GetRefChildTbls() []uint64 {
	if m != nil {
		return m.RefChildTbls
	}
	return nil
}

func (m *TableDef) GetChecks() []*CheckDef {
	if m != nil {
		return m.Checks
	}
	return nil
}

func (m *TableDef) GetPartition() *PartitionByDef {
	if m != nil {
		return m.Partition
	}
	return nil
}

func (m *TableDef) GetClusterBy() *ClusterByDef {
	if m != nil {
		return m.ClusterBy
	}
	return nil
}

func (m *TableDef) GetProps() []*PropertyDef {
	if m != nil {
		return m.Props
	}
	return nil
}

func (m *TableDef) GetViewSql() *ViewDef {
	if m != nil {
		return m.ViewSql
	}
	return nil
}

func (m *TableDef) GetDefs() []*TableDef_DefType {
	if m != nil {
		return m.Defs
	}
	return nil
}

func (m *TableDef) GetName2ColIndex() map[string]int32 {
	if m != nil {
		return m.Name2ColIndex
	}
	return nil
}

func (m *TableDef) GetIsLocked() bool {
	if m != nil {
		return m.IsLocked
	}
	return false
}

func (m *TableDef) GetTableLockType() TableLockType {
	if m != nil {
		return m.TableLockType
	}
	return TableLockType_TableLockNone
}

// XXX: Deprecated and to be removed soon.
type TableDef_DefType struct {
	// Types that are valid to be assigned to Def:
	//
	//	*TableDef_DefType_Properties
	Def                  isTableDef_DefType_Def `protobuf_oneof:"def"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *TableDef_DefType) Reset()         { *m = TableDef_DefType{} }
func (m *TableDef_DefType) String() string { return proto.CompactTextString(m) }
func (*TableDef_DefType) ProtoMessage()    {}
func (*TableDef_DefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{35, 0}
}
func (m *TableDef_DefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDef_DefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableDef_DefType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableDef_DefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDef_DefType.Merge(m, src)
}
func (m *TableDef_DefType) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableDef_DefType) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDef_DefType.DiscardUnknown(m)
}

var xxx_messageInfo_TableDef_DefType proto.InternalMessageInfo

type isTableDef_DefType_Def interface {
	isTableDef_DefType_Def()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type TableDef_DefType_Properties struct {
	Properties *PropertiesDef `protobuf:"bytes,1,opt,name=properties,proto3,oneof" json:"properties,omitempty"`
}

func (*TableDef_DefType_Properties) isTableDef_DefType_Def() {}

func (m *TableDef_DefType) GetDef() isTableDef_DefType_Def {
	if m != nil {
		return m.Def
	}
	return nil
}

func (m *TableDef_DefType) GetProperties() *PropertiesDef {
	if x, ok := m.GetDef().(*TableDef_DefType_Properties); ok {
		return x.Properties
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TableDef_DefType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TableDef_DefType_Properties)(nil),
	}
}

type TableFunction struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Param                []byte   `protobuf:"bytes,2,opt,name=param,proto3" json:"param,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TableFunction) Reset()         { *m = TableFunction{} }
func (m *TableFunction) String() string { return proto.CompactTextString(m) }
func (*TableFunction) ProtoMessage()    {}
func (*TableFunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{36}
}
func (m *TableFunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableFunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableFunction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableFunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableFunction.Merge(m, src)
}
func (m *TableFunction) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableFunction) XXX_DiscardUnknown() {
	xxx_messageInfo_TableFunction.DiscardUnknown(m)
}

var xxx_messageInfo_TableFunction proto.InternalMessageInfo

func (m *TableFunction) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TableFunction) GetParam() []byte {
	if m != nil {
		return m.Param
	}
	return nil
}

type Stats struct {
	// for scan, number of blocks to read from S3
	// for other nodes, it's meaningless
	BlockNum int32 `protobuf:"varint,1,opt,name=block_num,json=blockNum,proto3" json:"block_num,omitempty"`
	// for scan, cost of reading from S3, basically the read lines
	// for other nodes, it means the estimated cost of current node
	Cost float64 `protobuf:"fixed64,2,opt,name=cost,proto3" json:"cost,omitempty"`
	// number of output lines
	Outcnt float64 `protobuf:"fixed64,3,opt,name=outcnt,proto3" json:"outcnt,omitempty"`
	// average size of one row, currently not used
	Rowsize float64 `protobuf:"fixed64,4,opt,name=rowsize,proto3" json:"rowsize,omitempty"`
	// hashmap size for nodes which build a hashmap
	// for other nodes, it's meaningless
	HashmapSize float64 `protobuf:"fixed64,5,opt,name=hashmap_size,json=hashmapSize,proto3" json:"hashmap_size,omitempty"`
	// for scan, this means total count of all table, before filtering
	// for other nodes, this is meanlingless
	TableCnt float64 `protobuf:"fixed64,6,opt,name=table_cnt,json=tableCnt,proto3" json:"table_cnt,omitempty"`
	// for scan, selectivity means outcnt divide total count
	// for other node, currently be 0. will change in the future
	Selectivity          float64  `protobuf:"fixed64,7,opt,name=selectivity,proto3" json:"selectivity,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Stats) Reset()         { *m = Stats{} }
func (m *Stats) String() string { return proto.CompactTextString(m) }
func (*Stats) ProtoMessage()    {}
func (*Stats) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{37}
}
func (m *Stats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Stats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Stats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Stats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Stats.Merge(m, src)
}
func (m *Stats) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Stats) XXX_DiscardUnknown() {
	xxx_messageInfo_Stats.DiscardUnknown(m)
}

var xxx_messageInfo_Stats proto.InternalMessageInfo

func (m *Stats) GetBlockNum() int32 {
	if m != nil {
		return m.BlockNum
	}
	return 0
}

func (m *Stats) GetCost() float64 {
	if m != nil {
		return m.Cost
	}
	return 0
}

func (m *Stats) GetOutcnt() float64 {
	if m != nil {
		return m.Outcnt
	}
	return 0
}

func (m *Stats) GetRowsize() float64 {
	if m != nil {
		return m.Rowsize
	}
	return 0
}

func (m *Stats) GetHashmapSize() float64 {
	if m != nil {
		return m.HashmapSize
	}
	return 0
}

func (m *Stats) GetTableCnt() float64 {
	if m != nil {
		return m.TableCnt
	}
	return 0
}

func (m *Stats) GetSelectivity() float64 {
	if m != nil {
		return m.Selectivity
	}
	return 0
}

type ColData struct {
	Data                 []*Expr  `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ColData) Reset()         { *m = ColData{} }
func (m *ColData) String() string { return proto.CompactTextString(m) }
func (*ColData) ProtoMessage()    {}
func (*ColData) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{38}
}
func (m *ColData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColData.Merge(m, src)
}
func (m *ColData) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ColData) XXX_DiscardUnknown() {
	xxx_messageInfo_ColData.DiscardUnknown(m)
}

var xxx_messageInfo_ColData proto.InternalMessageInfo

func (m *ColData) GetData() []*Expr {
	if m != nil {
		return m.Data
	}
	return nil
}

type RowsetData struct {
	Cols                 []*ColData `protobuf:"bytes,1,rep,name=cols,proto3" json:"cols,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RowsetData) Reset()         { *m = RowsetData{} }
func (m *RowsetData) String() string { return proto.CompactTextString(m) }
func (*RowsetData) ProtoMessage()    {}
func (*RowsetData) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{39}
}
func (m *RowsetData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowsetData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RowsetData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RowsetData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowsetData.Merge(m, src)
}
func (m *RowsetData) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RowsetData) XXX_DiscardUnknown() {
	xxx_messageInfo_RowsetData.DiscardUnknown(m)
}

var xxx_messageInfo_RowsetData proto.InternalMessageInfo

func (m *RowsetData) GetCols() []*ColData {
	if m != nil {
		return m.Cols
	}
	return nil
}

type OrderBySpec struct {
	Expr                 *Expr                   `protobuf:"bytes,1,opt,name=expr,proto3" json:"expr,omitempty"`
	Collation            string                  `protobuf:"bytes,2,opt,name=collation,proto3" json:"collation,omitempty"`
	Flag                 OrderBySpec_OrderByFlag `protobuf:"varint,3,opt,name=flag,proto3,enum=plan.OrderBySpec_OrderByFlag" json:"flag,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *OrderBySpec) Reset()         { *m = OrderBySpec{} }
func (m *OrderBySpec) String() string { return proto.CompactTextString(m) }
func (*OrderBySpec) ProtoMessage()    {}
func (*OrderBySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{40}
}
func (m *OrderBySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderBySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderBySpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderBySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderBySpec.Merge(m, src)
}
func (m *OrderBySpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *OrderBySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderBySpec.DiscardUnknown(m)
}

var xxx_messageInfo_OrderBySpec proto.InternalMessageInfo

func (m *OrderBySpec) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *OrderBySpec) GetCollation() string {
	if m != nil {
		return m.Collation
	}
	return ""
}

func (m *OrderBySpec) GetFlag() OrderBySpec_OrderByFlag {
	if m != nil {
		return m.Flag
	}
	return OrderBySpec_INTERNAL
}

type WindowSpec struct {
	PartitionBy          []*Expr        `protobuf:"bytes,1,rep,name=partition_by,json=partitionBy,proto3" json:"partition_by,omitempty"`
	OrderBy              []*OrderBySpec `protobuf:"bytes,2,rep,name=order_by,json=orderBy,proto3" json:"order_by,omitempty"`
	Lead                 int32          `protobuf:"varint,3,opt,name=lead,proto3" json:"lead,omitempty"`
	Lag                  int32          `protobuf:"varint,4,opt,name=lag,proto3" json:"lag,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *WindowSpec) Reset()         { *m = WindowSpec{} }
func (m *WindowSpec) String() string { return proto.CompactTextString(m) }
func (*WindowSpec) ProtoMessage()    {}
func (*WindowSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{41}
}
func (m *WindowSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WindowSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WindowSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowSpec.Merge(m, src)
}
func (m *WindowSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *WindowSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowSpec.DiscardUnknown(m)
}

var xxx_messageInfo_WindowSpec proto.InternalMessageInfo

func (m *WindowSpec) GetPartitionBy() []*Expr {
	if m != nil {
		return m.PartitionBy
	}
	return nil
}

func (m *WindowSpec) GetOrderBy() []*OrderBySpec {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *WindowSpec) GetLead() int32 {
	if m != nil {
		return m.Lead
	}
	return 0
}

func (m *WindowSpec) GetLag() int32 {
	if m != nil {
		return m.Lag
	}
	return 0
}

type InsertCtx struct {
	Ref                  *ObjectRef       `protobuf:"bytes,1,opt,name=ref,proto3" json:"ref,omitempty"`
	TableDef             *TableDef        `protobuf:"bytes,2,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	OnDuplicateIdx       []int32          `protobuf:"varint,3,rep,packed,name=on_duplicate_idx,json=onDuplicateIdx,proto3" json:"on_duplicate_idx,omitempty"`
	OnDuplicateExpr      map[string]*Expr `protobuf:"bytes,4,rep,name=on_duplicate_expr,json=onDuplicateExpr,proto3" json:"on_duplicate_expr,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	IdxRef               []*ObjectRef     `protobuf:"bytes,5,rep,name=idx_ref,json=idxRef,proto3" json:"idx_ref,omitempty"`
	IdxIdx               []int32          `protobuf:"varint,6,rep,packed,name=idx_idx,json=idxIdx,proto3" json:"idx_idx,omitempty"`
	ParentIdx            map[string]int32 `protobuf:"bytes,7,rep,name=parent_idx,json=parentIdx,proto3" json:"parent_idx,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	ClusterTable         *ClusterTable    `protobuf:"bytes,8,opt,name=cluster_table,json=clusterTable,proto3" json:"cluster_table,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *InsertCtx) Reset()         { *m = InsertCtx{} }
func (m *InsertCtx) String() string { return proto.CompactTextString(m) }
func (*InsertCtx) ProtoMessage()    {}
func (*InsertCtx) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{42}
}
func (m *InsertCtx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InsertCtx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InsertCtx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InsertCtx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InsertCtx.Merge(m, src)
}
func (m *InsertCtx) XXX_Size() int {
	return m.ProtoSize()
}
func (m *InsertCtx) XXX_DiscardUnknown() {
	xxx_messageInfo_InsertCtx.DiscardUnknown(m)
}

var xxx_messageInfo_InsertCtx proto.InternalMessageInfo

func (m *InsertCtx) GetRef() *ObjectRef {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *InsertCtx) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *InsertCtx) GetOnDuplicateIdx() []int32 {
	if m != nil {
		return m.OnDuplicateIdx
	}
	return nil
}

func (m *InsertCtx) GetOnDuplicateExpr() map[string]*Expr {
	if m != nil {
		return m.OnDuplicateExpr
	}
	return nil
}

func (m *InsertCtx) GetIdxRef() []*ObjectRef {
	if m != nil {
		return m.IdxRef
	}
	return nil
}

func (m *InsertCtx) GetIdxIdx() []int32 {
	if m != nil {
		return m.IdxIdx
	}
	return nil
}

func (m *InsertCtx) GetParentIdx() map[string]int32 {
	if m != nil {
		return m.ParentIdx
	}
	return nil
}

func (m *InsertCtx) GetClusterTable() *ClusterTable {
	if m != nil {
		return m.ClusterTable
	}
	return nil
}

type UpdateCtx struct {
	Ref                  []*ObjectRef `protobuf:"bytes,1,rep,name=ref,proto3" json:"ref,omitempty"`
	Idx                  []*IdList    `protobuf:"bytes,2,rep,name=idx,proto3" json:"idx,omitempty"`
	TableDefs            []*TableDef  `protobuf:"bytes,3,rep,name=tableDefs,proto3" json:"tableDefs,omitempty"`
	UpdateCol            []*ColPosMap `protobuf:"bytes,4,rep,name=update_col,json=updateCol,proto3" json:"update_col,omitempty"`
	IdxRef               []*ObjectRef `protobuf:"bytes,5,rep,name=idx_ref,json=idxRef,proto3" json:"idx_ref,omitempty"`
	IdxIdx               []int32      `protobuf:"varint,6,rep,packed,name=idx_idx,json=idxIdx,proto3" json:"idx_idx,omitempty"`
	OnRestrictRef        []*ObjectRef `protobuf:"bytes,7,rep,name=on_restrict_ref,json=onRestrictRef,proto3" json:"on_restrict_ref,omitempty"`
	OnRestrictIdx        []int32      `protobuf:"varint,8,rep,packed,name=on_restrict_idx,json=onRestrictIdx,proto3" json:"on_restrict_idx,omitempty"`
	OnCascadeRef         []*ObjectRef `protobuf:"bytes,9,rep,name=on_cascade_ref,json=onCascadeRef,proto3" json:"on_cascade_ref,omitempty"`
	OnCascadeIdx         []*IdList    `protobuf:"bytes,10,rep,name=on_cascade_idx,json=onCascadeIdx,proto3" json:"on_cascade_idx,omitempty"`
	OnCascadeDef         []*TableDef  `protobuf:"bytes,11,rep,name=on_cascade_def,json=onCascadeDef,proto3" json:"on_cascade_def,omitempty"`
	OnCascadeUpdateCol   []*ColPosMap `protobuf:"bytes,12,rep,name=on_cascade_update_col,json=onCascadeUpdateCol,proto3" json:"on_cascade_update_col,omitempty"`
	OnSetRef             []*ObjectRef `protobuf:"bytes,13,rep,name=on_set_ref,json=onSetRef,proto3" json:"on_set_ref,omitempty"`
	OnSetIdx             []*IdList    `protobuf:"bytes,14,rep,name=on_set_idx,json=onSetIdx,proto3" json:"on_set_idx,omitempty"`
	OnSetDef             []*TableDef  `protobuf:"bytes,15,rep,name=on_set_def,json=onSetDef,proto3" json:"on_set_def,omitempty"`
	OnSetUpdateCol       []*ColPosMap `protobuf:"bytes,16,rep,name=on_set_update_col,json=onSetUpdateCol,proto3" json:"on_set_update_col,omitempty"`
	ParentIdx            []*ColPosMap `protobuf:"bytes,17,rep,name=parent_idx,json=parentIdx,proto3" json:"parent_idx,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *UpdateCtx) Reset()         { *m = UpdateCtx{} }
func (m *UpdateCtx) String() string { return proto.CompactTextString(m) }
func (*UpdateCtx) ProtoMessage()    {}
func (*UpdateCtx) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{43}
}
func (m *UpdateCtx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateCtx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateCtx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateCtx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateCtx.Merge(m, src)
}
func (m *UpdateCtx) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UpdateCtx) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateCtx.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateCtx proto.InternalMessageInfo

func (m *UpdateCtx) GetRef() []*ObjectRef {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *UpdateCtx) GetIdx() []*IdList {
	if m != nil {
		return m.Idx
	}
	return nil
}

func (m *UpdateCtx) GetTableDefs() []*TableDef {
	if m != nil {
		return m.TableDefs
	}
	return nil
}

func (m *UpdateCtx) GetUpdateCol() []*ColPosMap {
	if m != nil {
		return m.UpdateCol
	}
	return nil
}

func (m *UpdateCtx) GetIdxRef() []*ObjectRef {
	if m != nil {
		return m.IdxRef
	}
	return nil
}

func (m *UpdateCtx) GetIdxIdx() []int32 {
	if m != nil {
		return m.IdxIdx
	}
	return nil
}

func (m *UpdateCtx) GetOnRestrictRef() []*ObjectRef {
	if m != nil {
		return m.OnRestrictRef
	}
	return nil
}

func (m *UpdateCtx) GetOnRestrictIdx() []int32 {
	if m != nil {
		return m.OnRestrictIdx
	}
	return nil
}

func (m *UpdateCtx) GetOnCascadeRef() []*ObjectRef {
	if m != nil {
		return m.OnCascadeRef
	}
	return nil
}

func (m *UpdateCtx) GetOnCascadeIdx() []*IdList {
	if m != nil {
		return m.OnCascadeIdx
	}
	return nil
}

func (m *UpdateCtx) GetOnCascadeDef() []*TableDef {
	if m != nil {
		return m.OnCascadeDef
	}
	return nil
}

func (m *UpdateCtx) GetOnCascadeUpdateCol() []*ColPosMap {
	if m != nil {
		return m.OnCascadeUpdateCol
	}
	return nil
}

func (m *UpdateCtx) GetOnSetRef() []*ObjectRef {
	if m != nil {
		return m.OnSetRef
	}
	return nil
}

func (m *UpdateCtx) GetOnSetIdx() []*IdList {
	if m != nil {
		return m.OnSetIdx
	}
	return nil
}

func (m *UpdateCtx) GetOnSetDef() []*TableDef {
	if m != nil {
		return m.OnSetDef
	}
	return nil
}

func (m *UpdateCtx) GetOnSetUpdateCol() []*ColPosMap {
	if m != nil {
		return m.OnSetUpdateCol
	}
	return nil
}

func (m *UpdateCtx) GetParentIdx() []*ColPosMap {
	if m != nil {
		return m.ParentIdx
	}
	return nil
}

type AnalyzeInfo struct {
	InputRows            int64    `protobuf:"varint,1,opt,name=input_rows,json=inputRows,proto3" json:"input_rows,omitempty"`
	OutputRows           int64    `protobuf:"varint,2,opt,name=output_rows,json=outputRows,proto3" json:"output_rows,omitempty"`
	InputSize            int64    `protobuf:"varint,3,opt,name=input_size,json=inputSize,proto3" json:"input_size,omitempty"`
	OutputSize           int64    `protobuf:"varint,4,opt,name=output_size,json=outputSize,proto3" json:"output_size,omitempty"`
	TimeConsumed         int64    `protobuf:"varint,5,opt,name=time_consumed,json=timeConsumed,proto3" json:"time_consumed,omitempty"`
	MemorySize           int64    `protobuf:"varint,6,opt,name=memory_size,json=memorySize,proto3" json:"memory_size,omitempty"`
	WaitTimeConsumed     int64    `protobuf:"varint,7,opt,name=wait_time_consumed,json=waitTimeConsumed,proto3" json:"wait_time_consumed,omitempty"`
	DiskIO               int64    `protobuf:"varint,8,opt,name=diskIO,proto3" json:"diskIO,omitempty"`
	S3IOByte             int64    `protobuf:"varint,9,opt,name=s3IO_byte,json=s3IOByte,proto3" json:"s3IO_byte,omitempty"`
	S3IOInputCount       int64    `protobuf:"varint,10,opt,name=s3IO_input_count,json=s3IOInputCount,proto3" json:"s3IO_input_count,omitempty"`
	S3IOOutputCount      int64    `protobuf:"varint,11,opt,name=s3IO_output_count,json=s3IOOutputCount,proto3" json:"s3IO_output_count,omitempty"`
	NetworkIO            int64    `protobuf:"varint,12,opt,name=networkIO,proto3" json:"networkIO,omitempty"`
	ScanTime             int64    `protobuf:"varint,13,opt,name=scanTime,proto3" json:"scanTime,omitempty"`
	InsertTime           int64    `protobuf:"varint,14,opt,name=insertTime,proto3" json:"insertTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AnalyzeInfo) Reset()         { *m = AnalyzeInfo{} }
func (m *AnalyzeInfo) String() string { return proto.CompactTextString(m) }
func (*AnalyzeInfo) ProtoMessage()    {}
func (*AnalyzeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{44}
}
func (m *AnalyzeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnalyzeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnalyzeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AnalyzeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnalyzeInfo.Merge(m, src)
}
func (m *AnalyzeInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AnalyzeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AnalyzeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AnalyzeInfo proto.InternalMessageInfo

func (m *AnalyzeInfo) GetInputRows() int64 {
	if m != nil {
		return m.InputRows
	}
	return 0
}

func (m *AnalyzeInfo) GetOutputRows() int64 {
	if m != nil {
		return m.OutputRows
	}
	return 0
}

func (m *AnalyzeInfo) GetInputSize() int64 {
	if m != nil {
		return m.InputSize
	}
	return 0
}

func (m *AnalyzeInfo) GetOutputSize() int64 {
	if m != nil {
		return m.OutputSize
	}
	return 0
}

func (m *AnalyzeInfo) GetTimeConsumed() int64 {
	if m != nil {
		return m.TimeConsumed
	}
	return 0
}

func (m *AnalyzeInfo) GetMemorySize() int64 {
	if m != nil {
		return m.MemorySize
	}
	return 0
}

func (m *AnalyzeInfo) GetWaitTimeConsumed() int64 {
	if m != nil {
		return m.WaitTimeConsumed
	}
	return 0
}

func (m *AnalyzeInfo) GetDiskIO() int64 {
	if m != nil {
		return m.DiskIO
	}
	return 0
}

func (m *AnalyzeInfo) GetS3IOByte() int64 {
	if m != nil {
		return m.S3IOByte
	}
	return 0
}

func (m *AnalyzeInfo) GetS3IOInputCount() int64 {
	if m != nil {
		return m.S3IOInputCount
	}
	return 0
}

func (m *AnalyzeInfo) GetS3IOOutputCount() int64 {
	if m != nil {
		return m.S3IOOutputCount
	}
	return 0
}

func (m *AnalyzeInfo) GetNetworkIO() int64 {
	if m != nil {
		return m.NetworkIO
	}
	return 0
}

func (m *AnalyzeInfo) GetScanTime() int64 {
	if m != nil {
		return m.ScanTime
	}
	return 0
}

func (m *AnalyzeInfo) GetInsertTime() int64 {
	if m != nil {
		return m.InsertTime
	}
	return 0
}

type Node struct {
	NodeType Node_NodeType `protobuf:"varint,1,opt,name=node_type,json=nodeType,proto3,enum=plan.Node_NodeType" json:"node_type,omitempty"`
	NodeId   int32         `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Stats    *Stats        `protobuf:"bytes,3,opt,name=stats,proto3" json:"stats,omitempty"`
	Children []int32       `protobuf:"varint,4,rep,packed,name=children,proto3" json:"children,omitempty"`
	// PROJECT
	ProjectList []*Expr `protobuf:"bytes,5,rep,name=project_list,json=projectList,proto3" json:"project_list,omitempty"`
	// JOIN
	JoinType    Node_JoinType `protobuf:"varint,6,opt,name=join_type,json=joinType,proto3,enum=plan.Node_JoinType" json:"join_type,omitempty"`
	OnList      []*Expr       `protobuf:"bytes,7,rep,name=on_list,json=onList,proto3" json:"on_list,omitempty"`
	BuildOnLeft bool          `protobuf:"varint,8,opt,name=build_on_left,json=buildOnLeft,proto3" json:"build_on_left,omitempty"`
	// FILTER
	FilterList []*Expr `protobuf:"bytes,9,rep,name=filter_list,json=filterList,proto3" json:"filter_list,omitempty"`
	// AGG
	GroupBy     []*Expr `protobuf:"bytes,10,rep,name=group_by,json=groupBy,proto3" json:"group_by,omitempty"`
	GroupingSet []*Expr `protobuf:"bytes,11,rep,name=grouping_set,json=groupingSet,proto3" json:"grouping_set,omitempty"`
	AggList     []*Expr `protobuf:"bytes,12,rep,name=agg_list,json=aggList,proto3" json:"agg_list,omitempty"`
	// WINDOW
	WinSpec *WindowSpec `protobuf:"bytes,13,opt,name=win_spec,json=winSpec,proto3" json:"win_spec,omitempty"`
	// SORT
	OrderBy []*OrderBySpec `protobuf:"bytes,14,rep,name=order_by,json=orderBy,proto3" json:"order_by,omitempty"`
	// LIMIT
	Limit           *Expr        `protobuf:"bytes,15,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset          *Expr        `protobuf:"bytes,16,opt,name=offset,proto3" json:"offset,omitempty"`
	UpdateCtx       *UpdateCtx   `protobuf:"bytes,17,opt,name=update_ctx,json=updateCtx,proto3" json:"update_ctx,omitempty"`
	TableDef        *TableDef    `protobuf:"bytes,18,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	TableDefVec     []*TableDef  `protobuf:"bytes,19,rep,name=table_def_vec,json=tableDefVec,proto3" json:"table_def_vec,omitempty"`
	ObjRef          *ObjectRef   `protobuf:"bytes,20,opt,name=obj_ref,json=objRef,proto3" json:"obj_ref,omitempty"`
	RowsetData      *RowsetData  `protobuf:"bytes,21,opt,name=rowset_data,json=rowsetData,proto3" json:"rowset_data,omitempty"`
	ExtraOptions    string       `protobuf:"bytes,22,opt,name=extra_options,json=extraOptions,proto3" json:"extra_options,omitempty"`
	DeleteCtx       *DeleteCtx   `protobuf:"bytes,23,opt,name=delete_ctx,json=deleteCtx,proto3" json:"delete_ctx,omitempty"`
	BindingTags     []int32      `protobuf:"varint,24,rep,packed,name=binding_tags,json=bindingTags,proto3" json:"binding_tags,omitempty"`
	AnalyzeInfo     *AnalyzeInfo `protobuf:"bytes,25,opt,name=analyze_info,json=analyzeInfo,proto3" json:"analyze_info,omitempty"`
	TblFuncExprList []*Expr      `protobuf:"bytes,26,rep,name=tbl_func_expr_list,json=tblFuncExprList,proto3" json:"tbl_func_expr_list,omitempty"`
	// The pipeline will determine the parallelism by traversing the plan
	// when it is received. Then the build is built based on this information.
	Parallelism  int32         `protobuf:"varint,27,opt,name=parallelism,proto3" json:"parallelism,omitempty"`
	ClusterTable *ClusterTable `protobuf:"bytes,28,opt,name=cluster_table,json=clusterTable,proto3" json:"cluster_table,omitempty"`
	NotCacheable bool          `protobuf:"varint,29,opt,name=not_cacheable,json=notCacheable,proto3" json:"not_cacheable,omitempty"`
	InsertCtx    *InsertCtx    `protobuf:"bytes,30,opt,name=insert_ctx,json=insertCtx,proto3" json:"insert_ctx,omitempty"`
	// used to connect two plans[steps]
	CurrentStep          int32    `protobuf:"varint,31,opt,name=current_step,json=currentStep,proto3" json:"current_step,omitempty"`
	SourceStep           int32    `protobuf:"varint,32,opt,name=source_step,json=sourceStep,proto3" json:"source_step,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{45}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetNodeType() Node_NodeType {
	if m != nil {
		return m.NodeType
	}
	return Node_UNKNOWN
}

func (m *Node) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *Node) GetStats() *Stats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *Node) GetChildren() []int32 {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *Node) GetProjectList() []*Expr {
	if m != nil {
		return m.ProjectList
	}
	return nil
}

func (m *Node) GetJoinType() Node_JoinType {
	if m != nil {
		return m.JoinType
	}
	return Node_INNER
}

func (m *Node) GetOnList() []*Expr {
	if m != nil {
		return m.OnList
	}
	return nil
}

func (m *Node) GetBuildOnLeft() bool {
	if m != nil {
		return m.BuildOnLeft
	}
	return false
}

func (m *Node) GetFilterList() []*Expr {
	if m != nil {
		return m.FilterList
	}
	return nil
}

func (m *Node) GetGroupBy() []*Expr {
	if m != nil {
		return m.GroupBy
	}
	return nil
}

func (m *Node) GetGroupingSet() []*Expr {
	if m != nil {
		return m.GroupingSet
	}
	return nil
}

func (m *Node) GetAggList() []*Expr {
	if m != nil {
		return m.AggList
	}
	return nil
}

func (m *Node) GetWinSpec() *WindowSpec {
	if m != nil {
		return m.WinSpec
	}
	return nil
}

func (m *Node) GetOrderBy() []*OrderBySpec {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *Node) GetLimit() *Expr {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *Node) GetOffset() *Expr {
	if m != nil {
		return m.Offset
	}
	return nil
}

func (m *Node) GetUpdateCtx() *UpdateCtx {
	if m != nil {
		return m.UpdateCtx
	}
	return nil
}

func (m *Node) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *Node) GetTableDefVec() []*TableDef {
	if m != nil {
		return m.TableDefVec
	}
	return nil
}

func (m *Node) GetObjRef() *ObjectRef {
	if m != nil {
		return m.ObjRef
	}
	return nil
}

func (m *Node) GetRowsetData() *RowsetData {
	if m != nil {
		return m.RowsetData
	}
	return nil
}

func (m *Node) GetExtraOptions() string {
	if m != nil {
		return m.ExtraOptions
	}
	return ""
}

func (m *Node) GetDeleteCtx() *DeleteCtx {
	if m != nil {
		return m.DeleteCtx
	}
	return nil
}

func (m *Node) GetBindingTags() []int32 {
	if m != nil {
		return m.BindingTags
	}
	return nil
}

func (m *Node) GetAnalyzeInfo() *AnalyzeInfo {
	if m != nil {
		return m.AnalyzeInfo
	}
	return nil
}

func (m *Node) GetTblFuncExprList() []*Expr {
	if m != nil {
		return m.TblFuncExprList
	}
	return nil
}

func (m *Node) GetParallelism() int32 {
	if m != nil {
		return m.Parallelism
	}
	return 0
}

func (m *Node) GetClusterTable() *ClusterTable {
	if m != nil {
		return m.ClusterTable
	}
	return nil
}

func (m *Node) GetNotCacheable() bool {
	if m != nil {
		return m.NotCacheable
	}
	return false
}

func (m *Node) GetInsertCtx() *InsertCtx {
	if m != nil {
		return m.InsertCtx
	}
	return nil
}

func (m *Node) GetCurrentStep() int32 {
	if m != nil {
		return m.CurrentStep
	}
	return 0
}

func (m *Node) GetSourceStep() int32 {
	if m != nil {
		return m.SourceStep
	}
	return 0
}

type IdList struct {
	List                 []int64  `protobuf:"varint,1,rep,packed,name=list,proto3" json:"list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IdList) Reset()         { *m = IdList{} }
func (m *IdList) String() string { return proto.CompactTextString(m) }
func (*IdList) ProtoMessage()    {}
func (*IdList) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{46}
}
func (m *IdList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IdList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IdList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IdList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IdList.Merge(m, src)
}
func (m *IdList) XXX_Size() int {
	return m.ProtoSize()
}
func (m *IdList) XXX_DiscardUnknown() {
	xxx_messageInfo_IdList.DiscardUnknown(m)
}

var xxx_messageInfo_IdList proto.InternalMessageInfo

func (m *IdList) GetList() []int64 {
	if m != nil {
		return m.List
	}
	return nil
}

type ColPosMap struct {
	Map                  map[string]int32 `protobuf:"bytes,1,rep,name=map,proto3" json:"map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ColPosMap) Reset()         { *m = ColPosMap{} }
func (m *ColPosMap) String() string { return proto.CompactTextString(m) }
func (*ColPosMap) ProtoMessage()    {}
func (*ColPosMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{47}
}
func (m *ColPosMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColPosMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColPosMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColPosMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColPosMap.Merge(m, src)
}
func (m *ColPosMap) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ColPosMap) XXX_DiscardUnknown() {
	xxx_messageInfo_ColPosMap.DiscardUnknown(m)
}

var xxx_messageInfo_ColPosMap proto.InternalMessageInfo

func (m *ColPosMap) GetMap() map[string]int32 {
	if m != nil {
		return m.Map
	}
	return nil
}

type DeleteCtx struct {
	Ref                  []*ObjectRef `protobuf:"bytes,1,rep,name=ref,proto3" json:"ref,omitempty"`
	Idx                  []*IdList    `protobuf:"bytes,2,rep,name=idx,proto3" json:"idx,omitempty"`
	IdxRef               []*ObjectRef `protobuf:"bytes,3,rep,name=idx_ref,json=idxRef,proto3" json:"idx_ref,omitempty"`
	IdxIdx               []int32      `protobuf:"varint,4,rep,packed,name=idx_idx,json=idxIdx,proto3" json:"idx_idx,omitempty"`
	OnRestrictRef        []*ObjectRef `protobuf:"bytes,5,rep,name=on_restrict_ref,json=onRestrictRef,proto3" json:"on_restrict_ref,omitempty"`
	OnRestrictIdx        []int32      `protobuf:"varint,6,rep,packed,name=on_restrict_idx,json=onRestrictIdx,proto3" json:"on_restrict_idx,omitempty"`
	OnCascadeRef         []*ObjectRef `protobuf:"bytes,7,rep,name=on_cascade_ref,json=onCascadeRef,proto3" json:"on_cascade_ref,omitempty"`
	OnCascadeIdx         []int32      `protobuf:"varint,8,rep,packed,name=on_cascade_idx,json=onCascadeIdx,proto3" json:"on_cascade_idx,omitempty"`
	OnSetRef             []*ObjectRef `protobuf:"bytes,9,rep,name=on_set_ref,json=onSetRef,proto3" json:"on_set_ref,omitempty"`
	OnSetDef             []*TableDef  `protobuf:"bytes,10,rep,name=on_set_def,json=onSetDef,proto3" json:"on_set_def,omitempty"`
	OnSetIdx             []*IdList    `protobuf:"bytes,11,rep,name=on_set_idx,json=onSetIdx,proto3" json:"on_set_idx,omitempty"`
	OnSetUpdateCol       []*ColPosMap `protobuf:"bytes,12,rep,name=on_set_update_col,json=onSetUpdateCol,proto3" json:"on_set_update_col,omitempty"`
	CanTruncate          bool         `protobuf:"varint,13,opt,name=can_truncate,json=canTruncate,proto3" json:"can_truncate,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *DeleteCtx) Reset()         { *m = DeleteCtx{} }
func (m *DeleteCtx) String() string { return proto.CompactTextString(m) }
func (*DeleteCtx) ProtoMessage()    {}
func (*DeleteCtx) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{48}
}
func (m *DeleteCtx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteCtx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteCtx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteCtx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteCtx.Merge(m, src)
}
func (m *DeleteCtx) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeleteCtx) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteCtx.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteCtx proto.InternalMessageInfo

func (m *DeleteCtx) GetRef() []*ObjectRef {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *DeleteCtx) GetIdx() []*IdList {
	if m != nil {
		return m.Idx
	}
	return nil
}

func (m *DeleteCtx) GetIdxRef() []*ObjectRef {
	if m != nil {
		return m.IdxRef
	}
	return nil
}

func (m *DeleteCtx) GetIdxIdx() []int32 {
	if m != nil {
		return m.IdxIdx
	}
	return nil
}

func (m *DeleteCtx) GetOnRestrictRef() []*ObjectRef {
	if m != nil {
		return m.OnRestrictRef
	}
	return nil
}

func (m *DeleteCtx) GetOnRestrictIdx() []int32 {
	if m != nil {
		return m.OnRestrictIdx
	}
	return nil
}

func (m *DeleteCtx) GetOnCascadeRef() []*ObjectRef {
	if m != nil {
		return m.OnCascadeRef
	}
	return nil
}

func (m *DeleteCtx) GetOnCascadeIdx() []int32 {
	if m != nil {
		return m.OnCascadeIdx
	}
	return nil
}

func (m *DeleteCtx) GetOnSetRef() []*ObjectRef {
	if m != nil {
		return m.OnSetRef
	}
	return nil
}

func (m *DeleteCtx) GetOnSetDef() []*TableDef {
	if m != nil {
		return m.OnSetDef
	}
	return nil
}

func (m *DeleteCtx) GetOnSetIdx() []*IdList {
	if m != nil {
		return m.OnSetIdx
	}
	return nil
}

func (m *DeleteCtx) GetOnSetUpdateCol() []*ColPosMap {
	if m != nil {
		return m.OnSetUpdateCol
	}
	return nil
}

func (m *DeleteCtx) GetCanTruncate() bool {
	if m != nil {
		return m.CanTruncate
	}
	return false
}

type Query struct {
	StmtType Query_StatementType `protobuf:"varint,1,opt,name=stmt_type,json=stmtType,proto3,enum=plan.Query_StatementType" json:"stmt_type,omitempty"`
	// Each step is simply a root node.  Root node refers to other
	// node as children and the whole step is a DAG.
	Steps []int32 `protobuf:"varint,2,rep,packed,name=steps,proto3" json:"steps,omitempty"`
	// All the nodes.  It is OK to have dangle nodes, we only excute nodes
	// reachable from step roots.
	Nodes []*Node `protobuf:"bytes,3,rep,name=nodes,proto3" json:"nodes,omitempty"`
	// Bound Parameter for the query.
	Params []*Expr `protobuf:"bytes,4,rep,name=params,proto3" json:"params,omitempty"`
	// return head
	Headings []string `protobuf:"bytes,5,rep,name=headings,proto3" json:"headings,omitempty"`
	// load Tag
	LoadTag              bool     `protobuf:"varint,6,opt,name=loadTag,proto3" json:"loadTag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Query) Reset()         { *m = Query{} }
func (m *Query) String() string { return proto.CompactTextString(m) }
func (*Query) ProtoMessage()    {}
func (*Query) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{49}
}
func (m *Query) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Query) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Query.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Query) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Query.Merge(m, src)
}
func (m *Query) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Query) XXX_DiscardUnknown() {
	xxx_messageInfo_Query.DiscardUnknown(m)
}

var xxx_messageInfo_Query proto.InternalMessageInfo

func (m *Query) GetStmtType() Query_StatementType {
	if m != nil {
		return m.StmtType
	}
	return Query_UNKNOWN
}

func (m *Query) GetSteps() []int32 {
	if m != nil {
		return m.Steps
	}
	return nil
}

func (m *Query) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *Query) GetParams() []*Expr {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *Query) GetHeadings() []string {
	if m != nil {
		return m.Headings
	}
	return nil
}

func (m *Query) GetLoadTag() bool {
	if m != nil {
		return m.LoadTag
	}
	return false
}

type TransationControl struct {
	// TransationControl type
	TclType TransationControl_TclType `protobuf:"varint,1,opt,name=tcl_type,json=tclType,proto3,enum=plan.TransationControl_TclType" json:"tcl_type,omitempty"`
	// Types that are valid to be assigned to Action:
	//
	//	*TransationControl_Begin
	//	*TransationControl_Commit
	//	*TransationControl_Rollback
	Action               isTransationControl_Action `protobuf_oneof:"action"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *TransationControl) Reset()         { *m = TransationControl{} }
func (m *TransationControl) String() string { return proto.CompactTextString(m) }
func (*TransationControl) ProtoMessage()    {}
func (*TransationControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{50}
}
func (m *TransationControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransationControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransationControl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransationControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransationControl.Merge(m, src)
}
func (m *TransationControl) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransationControl) XXX_DiscardUnknown() {
	xxx_messageInfo_TransationControl.DiscardUnknown(m)
}

var xxx_messageInfo_TransationControl proto.InternalMessageInfo

type isTransationControl_Action interface {
	isTransationControl_Action()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type TransationControl_Begin struct {
	Begin *TransationBegin `protobuf:"bytes,2,opt,name=begin,proto3,oneof" json:"begin,omitempty"`
}
type TransationControl_Commit struct {
	Commit *TransationCommit `protobuf:"bytes,3,opt,name=commit,proto3,oneof" json:"commit,omitempty"`
}
type TransationControl_Rollback struct {
	Rollback *TransationRollback `protobuf:"bytes,4,opt,name=rollback,proto3,oneof" json:"rollback,omitempty"`
}

func (*TransationControl_Begin) isTransationControl_Action()    {}
func (*TransationControl_Commit) isTransationControl_Action()   {}
func (*TransationControl_Rollback) isTransationControl_Action() {}

func (m *TransationControl) GetAction() isTransationControl_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *TransationControl) GetTclType() TransationControl_TclType {
	if m != nil {
		return m.TclType
	}
	return TransationControl_BEGIN
}

func (m *TransationControl) GetBegin() *TransationBegin {
	if x, ok := m.GetAction().(*TransationControl_Begin); ok {
		return x.Begin
	}
	return nil
}

func (m *TransationControl) GetCommit() *TransationCommit {
	if x, ok := m.GetAction().(*TransationControl_Commit); ok {
		return x.Commit
	}
	return nil
}

func (m *TransationControl) GetRollback() *TransationRollback {
	if x, ok := m.GetAction().(*TransationControl_Rollback); ok {
		return x.Rollback
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TransationControl) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TransationControl_Begin)(nil),
		(*TransationControl_Commit)(nil),
		(*TransationControl_Rollback)(nil),
	}
}

type TransationBegin struct {
	Mode                 TransationBegin_TransationMode `protobuf:"varint,1,opt,name=mode,proto3,enum=plan.TransationBegin_TransationMode" json:"mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *TransationBegin) Reset()         { *m = TransationBegin{} }
func (m *TransationBegin) String() string { return proto.CompactTextString(m) }
func (*TransationBegin) ProtoMessage()    {}
func (*TransationBegin) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{51}
}
func (m *TransationBegin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransationBegin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransationBegin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransationBegin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransationBegin.Merge(m, src)
}
func (m *TransationBegin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransationBegin) XXX_DiscardUnknown() {
	xxx_messageInfo_TransationBegin.DiscardUnknown(m)
}

var xxx_messageInfo_TransationBegin proto.InternalMessageInfo

func (m *TransationBegin) GetMode() TransationBegin_TransationMode {
	if m != nil {
		return m.Mode
	}
	return TransationBegin_NONE
}

type TransationCommit struct {
	CompletionType       TransationCompletionType `protobuf:"varint,1,opt,name=completion_type,json=completionType,proto3,enum=plan.TransationCompletionType" json:"completion_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *TransationCommit) Reset()         { *m = TransationCommit{} }
func (m *TransationCommit) String() string { return proto.CompactTextString(m) }
func (*TransationCommit) ProtoMessage()    {}
func (*TransationCommit) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{52}
}
func (m *TransationCommit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransationCommit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransationCommit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransationCommit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransationCommit.Merge(m, src)
}
func (m *TransationCommit) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransationCommit) XXX_DiscardUnknown() {
	xxx_messageInfo_TransationCommit.DiscardUnknown(m)
}

var xxx_messageInfo_TransationCommit proto.InternalMessageInfo

func (m *TransationCommit) GetCompletionType() TransationCompletionType {
	if m != nil {
		return m.CompletionType
	}
	return TransationCompletionType_CHAIN
}

type TransationRollback struct {
	CompletionType       TransationCompletionType `protobuf:"varint,1,opt,name=completion_type,json=completionType,proto3,enum=plan.TransationCompletionType" json:"completion_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *TransationRollback) Reset()         { *m = TransationRollback{} }
func (m *TransationRollback) String() string { return proto.CompactTextString(m) }
func (*TransationRollback) ProtoMessage()    {}
func (*TransationRollback) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{53}
}
func (m *TransationRollback) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransationRollback) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransationRollback.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransationRollback) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransationRollback.Merge(m, src)
}
func (m *TransationRollback) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransationRollback) XXX_DiscardUnknown() {
	xxx_messageInfo_TransationRollback.DiscardUnknown(m)
}

var xxx_messageInfo_TransationRollback proto.InternalMessageInfo

func (m *TransationRollback) GetCompletionType() TransationCompletionType {
	if m != nil {
		return m.CompletionType
	}
	return TransationCompletionType_CHAIN
}

type Plan struct {
	// Types that are valid to be assigned to Plan:
	//
	//	*Plan_Query
	//	*Plan_Tcl
	//	*Plan_Ddl
	//	*Plan_Dcl
	Plan isPlan_Plan `protobuf_oneof:"plan"`
	// AttachedPlan for the ddl statements, Attached Plan is used to modify related metadata
	AttachedPlan         *Plan    `protobuf:"bytes,5,opt,name=AttachedPlan,proto3" json:"AttachedPlan,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Plan) Reset()         { *m = Plan{} }
func (m *Plan) String() string { return proto.CompactTextString(m) }
func (*Plan) ProtoMessage()    {}
func (*Plan) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{54}
}
func (m *Plan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Plan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Plan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Plan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Plan.Merge(m, src)
}
func (m *Plan) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Plan) XXX_DiscardUnknown() {
	xxx_messageInfo_Plan.DiscardUnknown(m)
}

var xxx_messageInfo_Plan proto.InternalMessageInfo

type isPlan_Plan interface {
	isPlan_Plan()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type Plan_Query struct {
	Query *Query `protobuf:"bytes,1,opt,name=query,proto3,oneof" json:"query,omitempty"`
}
type Plan_Tcl struct {
	Tcl *TransationControl `protobuf:"bytes,2,opt,name=tcl,proto3,oneof" json:"tcl,omitempty"`
}
type Plan_Ddl struct {
	Ddl *DataDefinition `protobuf:"bytes,3,opt,name=ddl,proto3,oneof" json:"ddl,omitempty"`
}
type Plan_Dcl struct {
	Dcl *DataControl `protobuf:"bytes,4,opt,name=dcl,proto3,oneof" json:"dcl,omitempty"`
}

func (*Plan_Query) isPlan_Plan() {}
func (*Plan_Tcl) isPlan_Plan()   {}
func (*Plan_Ddl) isPlan_Plan()   {}
func (*Plan_Dcl) isPlan_Plan()   {}

func (m *Plan) GetPlan() isPlan_Plan {
	if m != nil {
		return m.Plan
	}
	return nil
}

func (m *Plan) GetQuery() *Query {
	if x, ok := m.GetPlan().(*Plan_Query); ok {
		return x.Query
	}
	return nil
}

func (m *Plan) GetTcl() *TransationControl {
	if x, ok := m.GetPlan().(*Plan_Tcl); ok {
		return x.Tcl
	}
	return nil
}

func (m *Plan) GetDdl() *DataDefinition {
	if x, ok := m.GetPlan().(*Plan_Ddl); ok {
		return x.Ddl
	}
	return nil
}

func (m *Plan) GetDcl() *DataControl {
	if x, ok := m.GetPlan().(*Plan_Dcl); ok {
		return x.Dcl
	}
	return nil
}

func (m *Plan) GetAttachedPlan() *Plan {
	if m != nil {
		return m.AttachedPlan
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Plan) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Plan_Query)(nil),
		(*Plan_Tcl)(nil),
		(*Plan_Ddl)(nil),
		(*Plan_Dcl)(nil),
	}
}

type Column struct {
	Column               []*Expr  `protobuf:"bytes,1,rep,name=column,proto3" json:"column,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Column) Reset()         { *m = Column{} }
func (m *Column) String() string { return proto.CompactTextString(m) }
func (*Column) ProtoMessage()    {}
func (*Column) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{55}
}
func (m *Column) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Column) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Column.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Column) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Column.Merge(m, src)
}
func (m *Column) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Column) XXX_DiscardUnknown() {
	xxx_messageInfo_Column.DiscardUnknown(m)
}

var xxx_messageInfo_Column proto.InternalMessageInfo

func (m *Column) GetColumn() []*Expr {
	if m != nil {
		return m.Column
	}
	return nil
}

type DataControl struct {
	// DataDefinition type
	DclType DataControl_DclType `protobuf:"varint,1,opt,name=dcl_type,json=dclType,proto3,enum=plan.DataControl_DclType" json:"dcl_type,omitempty"`
	// Types that are valid to be assigned to Control:
	//
	//	*DataControl_SetVariables
	//	*DataControl_Prepare
	//	*DataControl_Execute
	//	*DataControl_Deallocate
	Control              isDataControl_Control `protobuf_oneof:"control"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *DataControl) Reset()         { *m = DataControl{} }
func (m *DataControl) String() string { return proto.CompactTextString(m) }
func (*DataControl) ProtoMessage()    {}
func (*DataControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{56}
}
func (m *DataControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataControl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataControl.Merge(m, src)
}
func (m *DataControl) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DataControl) XXX_DiscardUnknown() {
	xxx_messageInfo_DataControl.DiscardUnknown(m)
}

var xxx_messageInfo_DataControl proto.InternalMessageInfo

type isDataControl_Control interface {
	isDataControl_Control()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type DataControl_SetVariables struct {
	SetVariables *SetVariables `protobuf:"bytes,2,opt,name=set_variables,json=setVariables,proto3,oneof" json:"set_variables,omitempty"`
}
type DataControl_Prepare struct {
	Prepare *Prepare `protobuf:"bytes,3,opt,name=prepare,proto3,oneof" json:"prepare,omitempty"`
}
type DataControl_Execute struct {
	Execute *Execute `protobuf:"bytes,4,opt,name=execute,proto3,oneof" json:"execute,omitempty"`
}
type DataControl_Deallocate struct {
	Deallocate *Deallocate `protobuf:"bytes,5,opt,name=deallocate,proto3,oneof" json:"deallocate,omitempty"`
}

func (*DataControl_SetVariables) isDataControl_Control() {}
func (*DataControl_Prepare) isDataControl_Control()      {}
func (*DataControl_Execute) isDataControl_Control()      {}
func (*DataControl_Deallocate) isDataControl_Control()   {}

func (m *DataControl) GetControl() isDataControl_Control {
	if m != nil {
		return m.Control
	}
	return nil
}

func (m *DataControl) GetDclType() DataControl_DclType {
	if m != nil {
		return m.DclType
	}
	return DataControl_SET_VARIABLES
}

func (m *DataControl) GetSetVariables() *SetVariables {
	if x, ok := m.GetControl().(*DataControl_SetVariables); ok {
		return x.SetVariables
	}
	return nil
}

func (m *DataControl) GetPrepare() *Prepare {
	if x, ok := m.GetControl().(*DataControl_Prepare); ok {
		return x.Prepare
	}
	return nil
}

func (m *DataControl) GetExecute() *Execute {
	if x, ok := m.GetControl().(*DataControl_Execute); ok {
		return x.Execute
	}
	return nil
}

func (m *DataControl) GetDeallocate() *Deallocate {
	if x, ok := m.GetControl().(*DataControl_Deallocate); ok {
		return x.Deallocate
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DataControl) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DataControl_SetVariables)(nil),
		(*DataControl_Prepare)(nil),
		(*DataControl_Execute)(nil),
		(*DataControl_Deallocate)(nil),
	}
}

type DataDefinition struct {
	// DataDefinition type
	DdlType DataDefinition_DdlType `protobuf:"varint,1,opt,name=ddl_type,json=ddlType,proto3,enum=plan.DataDefinition_DdlType" json:"ddl_type,omitempty"`
	// other show statement we will rewrite to a select statement
	// then we will get a Query
	// eg: 'show databases' will rewrite to 'select md.datname as `Database` from mo_database md'
	Query *Query `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// Types that are valid to be assigned to Definition:
	//
	//	*DataDefinition_CreateDatabase
	//	*DataDefinition_AlterDatabase
	//	*DataDefinition_DropDatabase
	//	*DataDefinition_CreateTable
	//	*DataDefinition_AlterTable
	//	*DataDefinition_DropTable
	//	*DataDefinition_CreateIndex
	//	*DataDefinition_AlterIndex
	//	*DataDefinition_DropIndex
	//	*DataDefinition_TruncateTable
	//	*DataDefinition_ShowVariables
	//	*DataDefinition_AlterView
	//	*DataDefinition_LockTables
	//	*DataDefinition_UnlockTables
	//	*DataDefinition_CreateSequence
	//	*DataDefinition_DropSequence
	//	*DataDefinition_AlterSequence
	Definition           isDataDefinition_Definition `protobuf_oneof:"definition"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *DataDefinition) Reset()         { *m = DataDefinition{} }
func (m *DataDefinition) String() string { return proto.CompactTextString(m) }
func (*DataDefinition) ProtoMessage()    {}
func (*DataDefinition) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{57}
}
func (m *DataDefinition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataDefinition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataDefinition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataDefinition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataDefinition.Merge(m, src)
}
func (m *DataDefinition) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DataDefinition) XXX_DiscardUnknown() {
	xxx_messageInfo_DataDefinition.DiscardUnknown(m)
}

var xxx_messageInfo_DataDefinition proto.InternalMessageInfo

type isDataDefinition_Definition interface {
	isDataDefinition_Definition()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type DataDefinition_CreateDatabase struct {
	CreateDatabase *CreateDatabase `protobuf:"bytes,3,opt,name=create_database,json=createDatabase,proto3,oneof" json:"create_database,omitempty"`
}
type DataDefinition_AlterDatabase struct {
	AlterDatabase *AlterDatabase `protobuf:"bytes,4,opt,name=alter_database,json=alterDatabase,proto3,oneof" json:"alter_database,omitempty"`
}
type DataDefinition_DropDatabase struct {
	DropDatabase *DropDatabase `protobuf:"bytes,5,opt,name=drop_database,json=dropDatabase,proto3,oneof" json:"drop_database,omitempty"`
}
type DataDefinition_CreateTable struct {
	CreateTable *CreateTable `protobuf:"bytes,6,opt,name=create_table,json=createTable,proto3,oneof" json:"create_table,omitempty"`
}
type DataDefinition_AlterTable struct {
	AlterTable *AlterTable `protobuf:"bytes,7,opt,name=alter_table,json=alterTable,proto3,oneof" json:"alter_table,omitempty"`
}
type DataDefinition_DropTable struct {
	DropTable *DropTable `protobuf:"bytes,8,opt,name=drop_table,json=dropTable,proto3,oneof" json:"drop_table,omitempty"`
}
type DataDefinition_CreateIndex struct {
	CreateIndex *CreateIndex `protobuf:"bytes,9,opt,name=create_index,json=createIndex,proto3,oneof" json:"create_index,omitempty"`
}
type DataDefinition_AlterIndex struct {
	AlterIndex *AlterIndex `protobuf:"bytes,10,opt,name=alter_index,json=alterIndex,proto3,oneof" json:"alter_index,omitempty"`
}
type DataDefinition_DropIndex struct {
	DropIndex *DropIndex `protobuf:"bytes,11,opt,name=drop_index,json=dropIndex,proto3,oneof" json:"drop_index,omitempty"`
}
type DataDefinition_TruncateTable struct {
	TruncateTable *TruncateTable `protobuf:"bytes,12,opt,name=truncate_table,json=truncateTable,proto3,oneof" json:"truncate_table,omitempty"`
}
type DataDefinition_ShowVariables struct {
	ShowVariables *ShowVariables `protobuf:"bytes,13,opt,name=show_variables,json=showVariables,proto3,oneof" json:"show_variables,omitempty"`
}
type DataDefinition_AlterView struct {
	AlterView *AlterView `protobuf:"bytes,14,opt,name=alter_view,json=alterView,proto3,oneof" json:"alter_view,omitempty"`
}
type DataDefinition_LockTables struct {
	LockTables *LockTables `protobuf:"bytes,15,opt,name=lock_tables,json=lockTables,proto3,oneof" json:"lock_tables,omitempty"`
}
type DataDefinition_UnlockTables struct {
	UnlockTables *UnLockTables `protobuf:"bytes,16,opt,name=unlock_tables,json=unlockTables,proto3,oneof" json:"unlock_tables,omitempty"`
}
type DataDefinition_CreateSequence struct {
	CreateSequence *CreateSequence `protobuf:"bytes,17,opt,name=create_sequence,json=createSequence,proto3,oneof" json:"create_sequence,omitempty"`
}
type DataDefinition_DropSequence struct {
	DropSequence *DropSequence `protobuf:"bytes,18,opt,name=drop_sequence,json=dropSequence,proto3,oneof" json:"drop_sequence,omitempty"`
}
type DataDefinition_AlterSequence struct {
	AlterSequence *AlterSequence `protobuf:"bytes,19,opt,name=alter_sequence,json=alterSequence,proto3,oneof" json:"alter_sequence,omitempty"`
}

func (*DataDefinition_CreateDatabase) isDataDefinition_Definition() {}
func (*DataDefinition_AlterDatabase) isDataDefinition_Definition()  {}
func (*DataDefinition_DropDatabase) isDataDefinition_Definition()   {}
func (*DataDefinition_CreateTable) isDataDefinition_Definition()    {}
func (*DataDefinition_AlterTable) isDataDefinition_Definition()     {}
func (*DataDefinition_DropTable) isDataDefinition_Definition()      {}
func (*DataDefinition_CreateIndex) isDataDefinition_Definition()    {}
func (*DataDefinition_AlterIndex) isDataDefinition_Definition()     {}
func (*DataDefinition_DropIndex) isDataDefinition_Definition()      {}
func (*DataDefinition_TruncateTable) isDataDefinition_Definition()  {}
func (*DataDefinition_ShowVariables) isDataDefinition_Definition()  {}
func (*DataDefinition_AlterView) isDataDefinition_Definition()      {}
func (*DataDefinition_LockTables) isDataDefinition_Definition()     {}
func (*DataDefinition_UnlockTables) isDataDefinition_Definition()   {}
func (*DataDefinition_CreateSequence) isDataDefinition_Definition() {}
func (*DataDefinition_DropSequence) isDataDefinition_Definition()   {}
func (*DataDefinition_AlterSequence) isDataDefinition_Definition()  {}

func (m *DataDefinition) GetDefinition() isDataDefinition_Definition {
	if m != nil {
		return m.Definition
	}
	return nil
}

func (m *DataDefinition) GetDdlType() DataDefinition_DdlType {
	if m != nil {
		return m.DdlType
	}
	return DataDefinition_CREATE_DATABASE
}

func (m *DataDefinition) GetQuery() *Query {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *DataDefinition) GetCreateDatabase() *CreateDatabase {
	if x, ok := m.GetDefinition().(*DataDefinition_CreateDatabase); ok {
		return x.CreateDatabase
	}
	return nil
}

func (m *DataDefinition) GetAlterDatabase() *AlterDatabase {
	if x, ok := m.GetDefinition().(*DataDefinition_AlterDatabase); ok {
		return x.AlterDatabase
	}
	return nil
}

func (m *DataDefinition) GetDropDatabase() *DropDatabase {
	if x, ok := m.GetDefinition().(*DataDefinition_DropDatabase); ok {
		return x.DropDatabase
	}
	return nil
}

func (m *DataDefinition) GetCreateTable() *CreateTable {
	if x, ok := m.GetDefinition().(*DataDefinition_CreateTable); ok {
		return x.CreateTable
	}
	return nil
}

func (m *DataDefinition) GetAlterTable() *AlterTable {
	if x, ok := m.GetDefinition().(*DataDefinition_AlterTable); ok {
		return x.AlterTable
	}
	return nil
}

func (m *DataDefinition) GetDropTable() *DropTable {
	if x, ok := m.GetDefinition().(*DataDefinition_DropTable); ok {
		return x.DropTable
	}
	return nil
}

func (m *DataDefinition) GetCreateIndex() *CreateIndex {
	if x, ok := m.GetDefinition().(*DataDefinition_CreateIndex); ok {
		return x.CreateIndex
	}
	return nil
}

func (m *DataDefinition) GetAlterIndex() *AlterIndex {
	if x, ok := m.GetDefinition().(*DataDefinition_AlterIndex); ok {
		return x.AlterIndex
	}
	return nil
}

func (m *DataDefinition) GetDropIndex() *DropIndex {
	if x, ok := m.GetDefinition().(*DataDefinition_DropIndex); ok {
		return x.DropIndex
	}
	return nil
}

func (m *DataDefinition) GetTruncateTable() *TruncateTable {
	if x, ok := m.GetDefinition().(*DataDefinition_TruncateTable); ok {
		return x.TruncateTable
	}
	return nil
}

func (m *DataDefinition) GetShowVariables() *ShowVariables {
	if x, ok := m.GetDefinition().(*DataDefinition_ShowVariables); ok {
		return x.ShowVariables
	}
	return nil
}

func (m *DataDefinition) GetAlterView() *AlterView {
	if x, ok := m.GetDefinition().(*DataDefinition_AlterView); ok {
		return x.AlterView
	}
	return nil
}

func (m *DataDefinition) GetLockTables() *LockTables {
	if x, ok := m.GetDefinition().(*DataDefinition_LockTables); ok {
		return x.LockTables
	}
	return nil
}

func (m *DataDefinition) GetUnlockTables() *UnLockTables {
	if x, ok := m.GetDefinition().(*DataDefinition_UnlockTables); ok {
		return x.UnlockTables
	}
	return nil
}

func (m *DataDefinition) GetCreateSequence() *CreateSequence {
	if x, ok := m.GetDefinition().(*DataDefinition_CreateSequence); ok {
		return x.CreateSequence
	}
	return nil
}

func (m *DataDefinition) GetDropSequence() *DropSequence {
	if x, ok := m.GetDefinition().(*DataDefinition_DropSequence); ok {
		return x.DropSequence
	}
	return nil
}

func (m *DataDefinition) GetAlterSequence() *AlterSequence {
	if x, ok := m.GetDefinition().(*DataDefinition_AlterSequence); ok {
		return x.AlterSequence
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DataDefinition) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DataDefinition_CreateDatabase)(nil),
		(*DataDefinition_AlterDatabase)(nil),
		(*DataDefinition_DropDatabase)(nil),
		(*DataDefinition_CreateTable)(nil),
		(*DataDefinition_AlterTable)(nil),
		(*DataDefinition_DropTable)(nil),
		(*DataDefinition_CreateIndex)(nil),
		(*DataDefinition_AlterIndex)(nil),
		(*DataDefinition_DropIndex)(nil),
		(*DataDefinition_TruncateTable)(nil),
		(*DataDefinition_ShowVariables)(nil),
		(*DataDefinition_AlterView)(nil),
		(*DataDefinition_LockTables)(nil),
		(*DataDefinition_UnlockTables)(nil),
		(*DataDefinition_CreateSequence)(nil),
		(*DataDefinition_DropSequence)(nil),
		(*DataDefinition_AlterSequence)(nil),
	}
}

type SubscriptionOption struct {
	From                 string   `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	Publication          string   `protobuf:"bytes,2,opt,name=publication,proto3" json:"publication,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscriptionOption) Reset()         { *m = SubscriptionOption{} }
func (m *SubscriptionOption) String() string { return proto.CompactTextString(m) }
func (*SubscriptionOption) ProtoMessage()    {}
func (*SubscriptionOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{58}
}
func (m *SubscriptionOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscriptionOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscriptionOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscriptionOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriptionOption.Merge(m, src)
}
func (m *SubscriptionOption) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SubscriptionOption) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriptionOption.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriptionOption proto.InternalMessageInfo

func (m *SubscriptionOption) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *SubscriptionOption) GetPublication() string {
	if m != nil {
		return m.Publication
	}
	return ""
}

type CreateDatabase struct {
	IfNotExists          bool                `protobuf:"varint,1,opt,name=if_not_exists,json=ifNotExists,proto3" json:"if_not_exists,omitempty"`
	Database             string              `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	SubscriptionOption   *SubscriptionOption `protobuf:"bytes,3,opt,name=subscription_option,json=subscriptionOption,proto3" json:"subscription_option,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *CreateDatabase) Reset()         { *m = CreateDatabase{} }
func (m *CreateDatabase) String() string { return proto.CompactTextString(m) }
func (*CreateDatabase) ProtoMessage()    {}
func (*CreateDatabase) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{59}
}
func (m *CreateDatabase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateDatabase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateDatabase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateDatabase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateDatabase.Merge(m, src)
}
func (m *CreateDatabase) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CreateDatabase) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateDatabase.DiscardUnknown(m)
}

var xxx_messageInfo_CreateDatabase proto.InternalMessageInfo

func (m *CreateDatabase) GetIfNotExists() bool {
	if m != nil {
		return m.IfNotExists
	}
	return false
}

func (m *CreateDatabase) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *CreateDatabase) GetSubscriptionOption() *SubscriptionOption {
	if m != nil {
		return m.SubscriptionOption
	}
	return nil
}

type AlterDatabase struct {
	IfExists             bool     `protobuf:"varint,1,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	Database             string   `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterDatabase) Reset()         { *m = AlterDatabase{} }
func (m *AlterDatabase) String() string { return proto.CompactTextString(m) }
func (*AlterDatabase) ProtoMessage()    {}
func (*AlterDatabase) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{60}
}
func (m *AlterDatabase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterDatabase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterDatabase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterDatabase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterDatabase.Merge(m, src)
}
func (m *AlterDatabase) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterDatabase) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterDatabase.DiscardUnknown(m)
}

var xxx_messageInfo_AlterDatabase proto.InternalMessageInfo

func (m *AlterDatabase) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

func (m *AlterDatabase) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

type DropDatabase struct {
	IfExists             bool     `protobuf:"varint,1,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	Database             string   `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DropDatabase) Reset()         { *m = DropDatabase{} }
func (m *DropDatabase) String() string { return proto.CompactTextString(m) }
func (*DropDatabase) ProtoMessage()    {}
func (*DropDatabase) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{61}
}
func (m *DropDatabase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropDatabase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropDatabase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropDatabase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropDatabase.Merge(m, src)
}
func (m *DropDatabase) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DropDatabase) XXX_DiscardUnknown() {
	xxx_messageInfo_DropDatabase.DiscardUnknown(m)
}

var xxx_messageInfo_DropDatabase proto.InternalMessageInfo

func (m *DropDatabase) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

func (m *DropDatabase) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

type FkColName struct {
	Cols                 []string `protobuf:"bytes,1,rep,name=cols,proto3" json:"cols,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FkColName) Reset()         { *m = FkColName{} }
func (m *FkColName) String() string { return proto.CompactTextString(m) }
func (*FkColName) ProtoMessage()    {}
func (*FkColName) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{62}
}
func (m *FkColName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FkColName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FkColName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FkColName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FkColName.Merge(m, src)
}
func (m *FkColName) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FkColName) XXX_DiscardUnknown() {
	xxx_messageInfo_FkColName.DiscardUnknown(m)
}

var xxx_messageInfo_FkColName proto.InternalMessageInfo

func (m *FkColName) GetCols() []string {
	if m != nil {
		return m.Cols
	}
	return nil
}

type CreateTable struct {
	IfNotExists bool        `protobuf:"varint,1,opt,name=if_not_exists,json=ifNotExists,proto3" json:"if_not_exists,omitempty"`
	Temporary   bool        `protobuf:"varint,2,opt,name=temporary,proto3" json:"temporary,omitempty"`
	Database    string      `protobuf:"bytes,3,opt,name=database,proto3" json:"database,omitempty"`
	TableDef    *TableDef   `protobuf:"bytes,4,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	IndexTables []*TableDef `protobuf:"bytes,5,rep,name=index_tables,json=indexTables,proto3" json:"index_tables,omitempty"`
	// we need the db/table name of foreign key when create table. but we don't need it in ForeignKeyDef
	FkDbs    []string `protobuf:"bytes,6,rep,name=fk_dbs,json=fkDbs,proto3" json:"fk_dbs,omitempty"`
	FkTables []string `protobuf:"bytes,7,rep,name=fk_tables,json=fkTables,proto3" json:"fk_tables,omitempty"`
	// we need column name when create table, but not in ForeignKeyDef
	FkCols               []*FkColName `protobuf:"bytes,8,rep,name=fk_cols,json=fkCols,proto3" json:"fk_cols,omitempty"`
	PartitionTables      []*TableDef  `protobuf:"bytes,9,rep,name=partition_tables,json=partitionTables,proto3" json:"partition_tables,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *CreateTable) Reset()         { *m = CreateTable{} }
func (m *CreateTable) String() string { return proto.CompactTextString(m) }
func (*CreateTable) ProtoMessage()    {}
func (*CreateTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{63}
}
func (m *CreateTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateTable.Merge(m, src)
}
func (m *CreateTable) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CreateTable) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateTable.DiscardUnknown(m)
}

var xxx_messageInfo_CreateTable proto.InternalMessageInfo

func (m *CreateTable) GetIfNotExists() bool {
	if m != nil {
		return m.IfNotExists
	}
	return false
}

func (m *CreateTable) GetTemporary() bool {
	if m != nil {
		return m.Temporary
	}
	return false
}

func (m *CreateTable) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *CreateTable) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *CreateTable) GetIndexTables() []*TableDef {
	if m != nil {
		return m.IndexTables
	}
	return nil
}

func (m *CreateTable) GetFkDbs() []string {
	if m != nil {
		return m.FkDbs
	}
	return nil
}

func (m *CreateTable) GetFkTables() []string {
	if m != nil {
		return m.FkTables
	}
	return nil
}

func (m *CreateTable) GetFkCols() []*FkColName {
	if m != nil {
		return m.FkCols
	}
	return nil
}

func (m *CreateTable) GetPartitionTables() []*TableDef {
	if m != nil {
		return m.PartitionTables
	}
	return nil
}

type AlterTableDrop struct {
	Typ                  AlterTableDrop_Typ `protobuf:"varint,1,opt,name=typ,proto3,enum=plan.AlterTableDrop_Typ" json:"typ,omitempty"`
	Name                 string             `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	IndexTableName       string             `protobuf:"bytes,3,opt,name=index_table_name,json=indexTableName,proto3" json:"index_table_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *AlterTableDrop) Reset()         { *m = AlterTableDrop{} }
func (m *AlterTableDrop) String() string { return proto.CompactTextString(m) }
func (*AlterTableDrop) ProtoMessage()    {}
func (*AlterTableDrop) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{64}
}
func (m *AlterTableDrop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTableDrop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTableDrop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTableDrop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTableDrop.Merge(m, src)
}
func (m *AlterTableDrop) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTableDrop) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTableDrop.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTableDrop proto.InternalMessageInfo

func (m *AlterTableDrop) GetTyp() AlterTableDrop_Typ {
	if m != nil {
		return m.Typ
	}
	return AlterTableDrop_COLUMN
}

func (m *AlterTableDrop) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AlterTableDrop) GetIndexTableName() string {
	if m != nil {
		return m.IndexTableName
	}
	return ""
}

type AlterTableAddFk struct {
	DbName               string         `protobuf:"bytes,1,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	TableName            string         `protobuf:"bytes,2,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	Cols                 []string       `protobuf:"bytes,3,rep,name=cols,proto3" json:"cols,omitempty"`
	Fkey                 *ForeignKeyDef `protobuf:"bytes,4,opt,name=fkey,proto3" json:"fkey,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *AlterTableAddFk) Reset()         { *m = AlterTableAddFk{} }
func (m *AlterTableAddFk) String() string { return proto.CompactTextString(m) }
func (*AlterTableAddFk) ProtoMessage()    {}
func (*AlterTableAddFk) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{65}
}
func (m *AlterTableAddFk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTableAddFk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTableAddFk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTableAddFk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTableAddFk.Merge(m, src)
}
func (m *AlterTableAddFk) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTableAddFk) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTableAddFk.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTableAddFk proto.InternalMessageInfo

func (m *AlterTableAddFk) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *AlterTableAddFk) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *AlterTableAddFk) GetCols() []string {
	if m != nil {
		return m.Cols
	}
	return nil
}

func (m *AlterTableAddFk) GetFkey() *ForeignKeyDef {
	if m != nil {
		return m.Fkey
	}
	return nil
}

type AlterTableAddIndex struct {
	DbName                string       `protobuf:"bytes,1,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	TableName             string       `protobuf:"bytes,2,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	OriginTablePrimaryKey string       `protobuf:"bytes,3,opt,name=origin_table_primary_key,json=originTablePrimaryKey,proto3" json:"origin_table_primary_key,omitempty"`
	IndexInfo             *CreateTable `protobuf:"bytes,4,opt,name=indexInfo,proto3" json:"indexInfo,omitempty"`
	IndexTableExist       bool         `protobuf:"varint,5,opt,name=index_table_exist,json=indexTableExist,proto3" json:"index_table_exist,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}     `json:"-"`
	XXX_unrecognized      []byte       `json:"-"`
	XXX_sizecache         int32        `json:"-"`
}

func (m *AlterTableAddIndex) Reset()         { *m = AlterTableAddIndex{} }
func (m *AlterTableAddIndex) String() string { return proto.CompactTextString(m) }
func (*AlterTableAddIndex) ProtoMessage()    {}
func (*AlterTableAddIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{66}
}
func (m *AlterTableAddIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTableAddIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTableAddIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTableAddIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTableAddIndex.Merge(m, src)
}
func (m *AlterTableAddIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTableAddIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTableAddIndex.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTableAddIndex proto.InternalMessageInfo

func (m *AlterTableAddIndex) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *AlterTableAddIndex) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *AlterTableAddIndex) GetOriginTablePrimaryKey() string {
	if m != nil {
		return m.OriginTablePrimaryKey
	}
	return ""
}

func (m *AlterTableAddIndex) GetIndexInfo() *CreateTable {
	if m != nil {
		return m.IndexInfo
	}
	return nil
}

func (m *AlterTableAddIndex) GetIndexTableExist() bool {
	if m != nil {
		return m.IndexTableExist
	}
	return false
}

type AlterTableDropIndex struct {
	DbName               string   `protobuf:"bytes,1,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	TableName            string   `protobuf:"bytes,2,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	IndexName            string   `protobuf:"bytes,3,opt,name=index_name,json=indexName,proto3" json:"index_name,omitempty"`
	IndexTableName       string   `protobuf:"bytes,4,opt,name=index_table_name,json=indexTableName,proto3" json:"index_table_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterTableDropIndex) Reset()         { *m = AlterTableDropIndex{} }
func (m *AlterTableDropIndex) String() string { return proto.CompactTextString(m) }
func (*AlterTableDropIndex) ProtoMessage()    {}
func (*AlterTableDropIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{67}
}
func (m *AlterTableDropIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTableDropIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTableDropIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTableDropIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTableDropIndex.Merge(m, src)
}
func (m *AlterTableDropIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTableDropIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTableDropIndex.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTableDropIndex proto.InternalMessageInfo

func (m *AlterTableDropIndex) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *AlterTableDropIndex) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *AlterTableDropIndex) GetIndexName() string {
	if m != nil {
		return m.IndexName
	}
	return ""
}

func (m *AlterTableDropIndex) GetIndexTableName() string {
	if m != nil {
		return m.IndexTableName
	}
	return ""
}

type AlterTableAlterIndex struct {
	DbName               string   `protobuf:"bytes,1,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	TableName            string   `protobuf:"bytes,2,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	IndexName            string   `protobuf:"bytes,3,opt,name=index_name,json=indexName,proto3" json:"index_name,omitempty"`
	Visible              bool     `protobuf:"varint,4,opt,name=visible,proto3" json:"visible,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterTableAlterIndex) Reset()         { *m = AlterTableAlterIndex{} }
func (m *AlterTableAlterIndex) String() string { return proto.CompactTextString(m) }
func (*AlterTableAlterIndex) ProtoMessage()    {}
func (*AlterTableAlterIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{68}
}
func (m *AlterTableAlterIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTableAlterIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTableAlterIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTableAlterIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTableAlterIndex.Merge(m, src)
}
func (m *AlterTableAlterIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTableAlterIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTableAlterIndex.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTableAlterIndex proto.InternalMessageInfo

func (m *AlterTableAlterIndex) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *AlterTableAlterIndex) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *AlterTableAlterIndex) GetIndexName() string {
	if m != nil {
		return m.IndexName
	}
	return ""
}

func (m *AlterTableAlterIndex) GetVisible() bool {
	if m != nil {
		return m.Visible
	}
	return false
}

type AlterTable struct {
	Database             string               `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	TableDef             *TableDef            `protobuf:"bytes,2,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	IsClusterTable       bool                 `protobuf:"varint,3,opt,name=is_cluster_table,json=isClusterTable,proto3" json:"is_cluster_table,omitempty"`
	Actions              []*AlterTable_Action `protobuf:"bytes,4,rep,name=actions,proto3" json:"actions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *AlterTable) Reset()         { *m = AlterTable{} }
func (m *AlterTable) String() string { return proto.CompactTextString(m) }
func (*AlterTable) ProtoMessage()    {}
func (*AlterTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{69}
}
func (m *AlterTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTable.Merge(m, src)
}
func (m *AlterTable) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTable) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTable.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTable proto.InternalMessageInfo

func (m *AlterTable) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *AlterTable) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *AlterTable) GetIsClusterTable() bool {
	if m != nil {
		return m.IsClusterTable
	}
	return false
}

func (m *AlterTable) GetActions() []*AlterTable_Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

type AlterTable_Action struct {
	// Types that are valid to be assigned to Action:
	//
	//	*AlterTable_Action_Drop
	//	*AlterTable_Action_AddFk
	//	*AlterTable_Action_AddIndex
	//	*AlterTable_Action_AlterIndex
	Action               isAlterTable_Action_Action `protobuf_oneof:"action"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *AlterTable_Action) Reset()         { *m = AlterTable_Action{} }
func (m *AlterTable_Action) String() string { return proto.CompactTextString(m) }
func (*AlterTable_Action) ProtoMessage()    {}
func (*AlterTable_Action) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{69, 0}
}
func (m *AlterTable_Action) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTable_Action) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTable_Action.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTable_Action) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTable_Action.Merge(m, src)
}
func (m *AlterTable_Action) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTable_Action) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTable_Action.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTable_Action proto.InternalMessageInfo

type isAlterTable_Action_Action interface {
	isAlterTable_Action_Action()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type AlterTable_Action_Drop struct {
	Drop *AlterTableDrop `protobuf:"bytes,1,opt,name=drop,proto3,oneof" json:"drop,omitempty"`
}
type AlterTable_Action_AddFk struct {
	AddFk *AlterTableAddFk `protobuf:"bytes,2,opt,name=add_fk,json=addFk,proto3,oneof" json:"add_fk,omitempty"`
}
type AlterTable_Action_AddIndex struct {
	AddIndex *AlterTableAddIndex `protobuf:"bytes,3,opt,name=add_index,json=addIndex,proto3,oneof" json:"add_index,omitempty"`
}
type AlterTable_Action_AlterIndex struct {
	AlterIndex *AlterTableAlterIndex `protobuf:"bytes,4,opt,name=alter_index,json=alterIndex,proto3,oneof" json:"alter_index,omitempty"`
}

func (*AlterTable_Action_Drop) isAlterTable_Action_Action()       {}
func (*AlterTable_Action_AddFk) isAlterTable_Action_Action()      {}
func (*AlterTable_Action_AddIndex) isAlterTable_Action_Action()   {}
func (*AlterTable_Action_AlterIndex) isAlterTable_Action_Action() {}

func (m *AlterTable_Action) GetAction() isAlterTable_Action_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *AlterTable_Action) GetDrop() *AlterTableDrop {
	if x, ok := m.GetAction().(*AlterTable_Action_Drop); ok {
		return x.Drop
	}
	return nil
}

func (m *AlterTable_Action) GetAddFk() *AlterTableAddFk {
	if x, ok := m.GetAction().(*AlterTable_Action_AddFk); ok {
		return x.AddFk
	}
	return nil
}

func (m *AlterTable_Action) GetAddIndex() *AlterTableAddIndex {
	if x, ok := m.GetAction().(*AlterTable_Action_AddIndex); ok {
		return x.AddIndex
	}
	return nil
}

func (m *AlterTable_Action) GetAlterIndex() *AlterTableAlterIndex {
	if x, ok := m.GetAction().(*AlterTable_Action_AlterIndex); ok {
		return x.AlterIndex
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AlterTable_Action) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AlterTable_Action_Drop)(nil),
		(*AlterTable_Action_AddFk)(nil),
		(*AlterTable_Action_AddIndex)(nil),
		(*AlterTable_Action_AlterIndex)(nil),
	}
}

type DropTable struct {
	IfExists             bool          `protobuf:"varint,1,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	Database             string        `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	Table                string        `protobuf:"bytes,3,opt,name=table,proto3" json:"table,omitempty"`
	IndexTableNames      []string      `protobuf:"bytes,4,rep,name=index_table_names,json=indexTableNames,proto3" json:"index_table_names,omitempty"`
	ClusterTable         *ClusterTable `protobuf:"bytes,5,opt,name=cluster_table,json=clusterTable,proto3" json:"cluster_table,omitempty"`
	TableId              uint64        `protobuf:"varint,6,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	ForeignTbl           []uint64      `protobuf:"varint,7,rep,packed,name=foreign_tbl,json=foreignTbl,proto3" json:"foreign_tbl,omitempty"`
	PartitionTableNames  []string      `protobuf:"bytes,8,rep,name=partition_table_names,json=partitionTableNames,proto3" json:"partition_table_names,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *DropTable) Reset()         { *m = DropTable{} }
func (m *DropTable) String() string { return proto.CompactTextString(m) }
func (*DropTable) ProtoMessage()    {}
func (*DropTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{70}
}
func (m *DropTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropTable.Merge(m, src)
}
func (m *DropTable) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DropTable) XXX_DiscardUnknown() {
	xxx_messageInfo_DropTable.DiscardUnknown(m)
}

var xxx_messageInfo_DropTable proto.InternalMessageInfo

func (m *DropTable) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

func (m *DropTable) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *DropTable) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *DropTable) GetIndexTableNames() []string {
	if m != nil {
		return m.IndexTableNames
	}
	return nil
}

func (m *DropTable) GetClusterTable() *ClusterTable {
	if m != nil {
		return m.ClusterTable
	}
	return nil
}

func (m *DropTable) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *DropTable) GetForeignTbl() []uint64 {
	if m != nil {
		return m.ForeignTbl
	}
	return nil
}

func (m *DropTable) GetPartitionTableNames() []string {
	if m != nil {
		return m.PartitionTableNames
	}
	return nil
}

type AlterView struct {
	IfExists             bool      `protobuf:"varint,1,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	Database             string    `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	TableDef             *TableDef `protobuf:"bytes,4,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *AlterView) Reset()         { *m = AlterView{} }
func (m *AlterView) String() string { return proto.CompactTextString(m) }
func (*AlterView) ProtoMessage()    {}
func (*AlterView) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{71}
}
func (m *AlterView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterView.Merge(m, src)
}
func (m *AlterView) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterView) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterView.DiscardUnknown(m)
}

var xxx_messageInfo_AlterView proto.InternalMessageInfo

func (m *AlterView) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

func (m *AlterView) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *AlterView) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

type CreateSequence struct {
	IfNotExists          bool      `protobuf:"varint,1,opt,name=if_not_exists,json=ifNotExists,proto3" json:"if_not_exists,omitempty"`
	Database             string    `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	TableDef             *TableDef `protobuf:"bytes,3,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *CreateSequence) Reset()         { *m = CreateSequence{} }
func (m *CreateSequence) String() string { return proto.CompactTextString(m) }
func (*CreateSequence) ProtoMessage()    {}
func (*CreateSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{72}
}
func (m *CreateSequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateSequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSequence.Merge(m, src)
}
func (m *CreateSequence) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CreateSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSequence.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSequence proto.InternalMessageInfo

func (m *CreateSequence) GetIfNotExists() bool {
	if m != nil {
		return m.IfNotExists
	}
	return false
}

func (m *CreateSequence) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *CreateSequence) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

type DropSequence struct {
	IfExists             bool     `protobuf:"varint,1,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	Database             string   `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	Table                string   `protobuf:"bytes,3,opt,name=table,proto3" json:"table,omitempty"`
	TableId              uint64   `protobuf:"varint,4,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DropSequence) Reset()         { *m = DropSequence{} }
func (m *DropSequence) String() string { return proto.CompactTextString(m) }
func (*DropSequence) ProtoMessage()    {}
func (*DropSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{73}
}
func (m *DropSequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropSequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropSequence.Merge(m, src)
}
func (m *DropSequence) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DropSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_DropSequence.DiscardUnknown(m)
}

var xxx_messageInfo_DropSequence proto.InternalMessageInfo

func (m *DropSequence) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

func (m *DropSequence) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *DropSequence) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *DropSequence) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

type AlterSequence struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterSequence) Reset()         { *m = AlterSequence{} }
func (m *AlterSequence) String() string { return proto.CompactTextString(m) }
func (*AlterSequence) ProtoMessage()    {}
func (*AlterSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{74}
}
func (m *AlterSequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterSequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterSequence.Merge(m, src)
}
func (m *AlterSequence) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterSequence.DiscardUnknown(m)
}

var xxx_messageInfo_AlterSequence proto.InternalMessageInfo

type CreateIndex struct {
	Database              string       `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	Table                 string       `protobuf:"bytes,2,opt,name=table,proto3" json:"table,omitempty"`
	OriginTablePrimaryKey string       `protobuf:"bytes,3,opt,name=origin_table_primary_key,json=originTablePrimaryKey,proto3" json:"origin_table_primary_key,omitempty"`
	Index                 *CreateTable `protobuf:"bytes,4,opt,name=index,proto3" json:"index,omitempty"`
	TableExist            bool         `protobuf:"varint,5,opt,name=table_exist,json=tableExist,proto3" json:"table_exist,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}     `json:"-"`
	XXX_unrecognized      []byte       `json:"-"`
	XXX_sizecache         int32        `json:"-"`
}

func (m *CreateIndex) Reset()         { *m = CreateIndex{} }
func (m *CreateIndex) String() string { return proto.CompactTextString(m) }
func (*CreateIndex) ProtoMessage()    {}
func (*CreateIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{75}
}
func (m *CreateIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateIndex.Merge(m, src)
}
func (m *CreateIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CreateIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateIndex.DiscardUnknown(m)
}

var xxx_messageInfo_CreateIndex proto.InternalMessageInfo

func (m *CreateIndex) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *CreateIndex) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *CreateIndex) GetOriginTablePrimaryKey() string {
	if m != nil {
		return m.OriginTablePrimaryKey
	}
	return ""
}

func (m *CreateIndex) GetIndex() *CreateTable {
	if m != nil {
		return m.Index
	}
	return nil
}

func (m *CreateIndex) GetTableExist() bool {
	if m != nil {
		return m.TableExist
	}
	return false
}

type AlterIndex struct {
	Index                string   `protobuf:"bytes,1,opt,name=index,proto3" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterIndex) Reset()         { *m = AlterIndex{} }
func (m *AlterIndex) String() string { return proto.CompactTextString(m) }
func (*AlterIndex) ProtoMessage()    {}
func (*AlterIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{76}
}
func (m *AlterIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterIndex.Merge(m, src)
}
func (m *AlterIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterIndex.DiscardUnknown(m)
}

var xxx_messageInfo_AlterIndex proto.InternalMessageInfo

func (m *AlterIndex) GetIndex() string {
	if m != nil {
		return m.Index
	}
	return ""
}

type DropIndex struct {
	Database             string   `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	Table                string   `protobuf:"bytes,2,opt,name=table,proto3" json:"table,omitempty"`
	IndexName            string   `protobuf:"bytes,3,opt,name=index_name,json=indexName,proto3" json:"index_name,omitempty"`
	IndexTableName       string   `protobuf:"bytes,4,opt,name=index_table_name,json=indexTableName,proto3" json:"index_table_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DropIndex) Reset()         { *m = DropIndex{} }
func (m *DropIndex) String() string { return proto.CompactTextString(m) }
func (*DropIndex) ProtoMessage()    {}
func (*DropIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{77}
}
func (m *DropIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropIndex.Merge(m, src)
}
func (m *DropIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DropIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_DropIndex.DiscardUnknown(m)
}

var xxx_messageInfo_DropIndex proto.InternalMessageInfo

func (m *DropIndex) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *DropIndex) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *DropIndex) GetIndexName() string {
	if m != nil {
		return m.IndexName
	}
	return ""
}

func (m *DropIndex) GetIndexTableName() string {
	if m != nil {
		return m.IndexTableName
	}
	return ""
}

type TruncateTable struct {
	Database             string        `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	Table                string        `protobuf:"bytes,2,opt,name=table,proto3" json:"table,omitempty"`
	IndexTableNames      []string      `protobuf:"bytes,3,rep,name=index_table_names,json=indexTableNames,proto3" json:"index_table_names,omitempty"`
	ClusterTable         *ClusterTable `protobuf:"bytes,4,opt,name=cluster_table,json=clusterTable,proto3" json:"cluster_table,omitempty"`
	TableId              uint64        `protobuf:"varint,5,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	ForeignTbl           []uint64      `protobuf:"varint,6,rep,packed,name=foreign_tbl,json=foreignTbl,proto3" json:"foreign_tbl,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TruncateTable) Reset()         { *m = TruncateTable{} }
func (m *TruncateTable) String() string { return proto.CompactTextString(m) }
func (*TruncateTable) ProtoMessage()    {}
func (*TruncateTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{78}
}
func (m *TruncateTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TruncateTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TruncateTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TruncateTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TruncateTable.Merge(m, src)
}
func (m *TruncateTable) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TruncateTable) XXX_DiscardUnknown() {
	xxx_messageInfo_TruncateTable.DiscardUnknown(m)
}

var xxx_messageInfo_TruncateTable proto.InternalMessageInfo

func (m *TruncateTable) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *TruncateTable) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *TruncateTable) GetIndexTableNames() []string {
	if m != nil {
		return m.IndexTableNames
	}
	return nil
}

func (m *TruncateTable) GetClusterTable() *ClusterTable {
	if m != nil {
		return m.ClusterTable
	}
	return nil
}

func (m *TruncateTable) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *TruncateTable) GetForeignTbl() []uint64 {
	if m != nil {
		return m.ForeignTbl
	}
	return nil
}

type ClusterTable struct {
	IsClusterTable         bool     `protobuf:"varint,1,opt,name=is_cluster_table,json=isClusterTable,proto3" json:"is_cluster_table,omitempty"`
	AccountIDs             []uint32 `protobuf:"varint,2,rep,packed,name=accountIDs,proto3" json:"accountIDs,omitempty"`
	ColumnIndexOfAccountId int32    `protobuf:"varint,3,opt,name=column_index_of_accountId,json=columnIndexOfAccountId,proto3" json:"column_index_of_accountId,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *ClusterTable) Reset()         { *m = ClusterTable{} }
func (m *ClusterTable) String() string { return proto.CompactTextString(m) }
func (*ClusterTable) ProtoMessage()    {}
func (*ClusterTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{79}
}
func (m *ClusterTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterTable.Merge(m, src)
}
func (m *ClusterTable) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ClusterTable) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterTable.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterTable proto.InternalMessageInfo

func (m *ClusterTable) GetIsClusterTable() bool {
	if m != nil {
		return m.IsClusterTable
	}
	return false
}

func (m *ClusterTable) GetAccountIDs() []uint32 {
	if m != nil {
		return m.AccountIDs
	}
	return nil
}

func (m *ClusterTable) GetColumnIndexOfAccountId() int32 {
	if m != nil {
		return m.ColumnIndexOfAccountId
	}
	return 0
}

type ShowVariables struct {
	Global               bool     `protobuf:"varint,1,opt,name=global,proto3" json:"global,omitempty"`
	Where                []*Expr  `protobuf:"bytes,2,rep,name=where,proto3" json:"where,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShowVariables) Reset()         { *m = ShowVariables{} }
func (m *ShowVariables) String() string { return proto.CompactTextString(m) }
func (*ShowVariables) ProtoMessage()    {}
func (*ShowVariables) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{80}
}
func (m *ShowVariables) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowVariables) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowVariables.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowVariables) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowVariables.Merge(m, src)
}
func (m *ShowVariables) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ShowVariables) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowVariables.DiscardUnknown(m)
}

var xxx_messageInfo_ShowVariables proto.InternalMessageInfo

func (m *ShowVariables) GetGlobal() bool {
	if m != nil {
		return m.Global
	}
	return false
}

func (m *ShowVariables) GetWhere() []*Expr {
	if m != nil {
		return m.Where
	}
	return nil
}

type SetVariables struct {
	Items                []*SetVariablesItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *SetVariables) Reset()         { *m = SetVariables{} }
func (m *SetVariables) String() string { return proto.CompactTextString(m) }
func (*SetVariables) ProtoMessage()    {}
func (*SetVariables) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{81}
}
func (m *SetVariables) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetVariables) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetVariables.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetVariables) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetVariables.Merge(m, src)
}
func (m *SetVariables) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SetVariables) XXX_DiscardUnknown() {
	xxx_messageInfo_SetVariables.DiscardUnknown(m)
}

var xxx_messageInfo_SetVariables proto.InternalMessageInfo

func (m *SetVariables) GetItems() []*SetVariablesItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type SetVariablesItem struct {
	System               bool     `protobuf:"varint,1,opt,name=system,proto3" json:"system,omitempty"`
	Global               bool     `protobuf:"varint,2,opt,name=global,proto3" json:"global,omitempty"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Value                *Expr    `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`
	Reserved             *Expr    `protobuf:"bytes,5,opt,name=reserved,proto3" json:"reserved,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetVariablesItem) Reset()         { *m = SetVariablesItem{} }
func (m *SetVariablesItem) String() string { return proto.CompactTextString(m) }
func (*SetVariablesItem) ProtoMessage()    {}
func (*SetVariablesItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{82}
}
func (m *SetVariablesItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetVariablesItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetVariablesItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetVariablesItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetVariablesItem.Merge(m, src)
}
func (m *SetVariablesItem) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SetVariablesItem) XXX_DiscardUnknown() {
	xxx_messageInfo_SetVariablesItem.DiscardUnknown(m)
}

var xxx_messageInfo_SetVariablesItem proto.InternalMessageInfo

func (m *SetVariablesItem) GetSystem() bool {
	if m != nil {
		return m.System
	}
	return false
}

func (m *SetVariablesItem) GetGlobal() bool {
	if m != nil {
		return m.Global
	}
	return false
}

func (m *SetVariablesItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SetVariablesItem) GetValue() *Expr {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *SetVariablesItem) GetReserved() *Expr {
	if m != nil {
		return m.Reserved
	}
	return nil
}

type Prepare struct {
	Name                 string       `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Schemas              []*ObjectRef `protobuf:"bytes,2,rep,name=schemas,proto3" json:"schemas,omitempty"`
	Plan                 *Plan        `protobuf:"bytes,3,opt,name=plan,proto3" json:"plan,omitempty"`
	ParamTypes           []int32      `protobuf:"varint,4,rep,packed,name=param_types,json=paramTypes,proto3" json:"param_types,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Prepare) Reset()         { *m = Prepare{} }
func (m *Prepare) String() string { return proto.CompactTextString(m) }
func (*Prepare) ProtoMessage()    {}
func (*Prepare) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{83}
}
func (m *Prepare) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Prepare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Prepare.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Prepare) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Prepare.Merge(m, src)
}
func (m *Prepare) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Prepare) XXX_DiscardUnknown() {
	xxx_messageInfo_Prepare.DiscardUnknown(m)
}

var xxx_messageInfo_Prepare proto.InternalMessageInfo

func (m *Prepare) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Prepare) GetSchemas() []*ObjectRef {
	if m != nil {
		return m.Schemas
	}
	return nil
}

func (m *Prepare) GetPlan() *Plan {
	if m != nil {
		return m.Plan
	}
	return nil
}

func (m *Prepare) GetParamTypes() []int32 {
	if m != nil {
		return m.ParamTypes
	}
	return nil
}

type Execute struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Args                 []*Expr  `protobuf:"bytes,2,rep,name=args,proto3" json:"args,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Execute) Reset()         { *m = Execute{} }
func (m *Execute) String() string { return proto.CompactTextString(m) }
func (*Execute) ProtoMessage()    {}
func (*Execute) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{84}
}
func (m *Execute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Execute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Execute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Execute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Execute.Merge(m, src)
}
func (m *Execute) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Execute) XXX_DiscardUnknown() {
	xxx_messageInfo_Execute.DiscardUnknown(m)
}

var xxx_messageInfo_Execute proto.InternalMessageInfo

func (m *Execute) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Execute) GetArgs() []*Expr {
	if m != nil {
		return m.Args
	}
	return nil
}

type Deallocate struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Deallocate) Reset()         { *m = Deallocate{} }
func (m *Deallocate) String() string { return proto.CompactTextString(m) }
func (*Deallocate) ProtoMessage()    {}
func (*Deallocate) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{85}
}
func (m *Deallocate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deallocate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deallocate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deallocate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deallocate.Merge(m, src)
}
func (m *Deallocate) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Deallocate) XXX_DiscardUnknown() {
	xxx_messageInfo_Deallocate.DiscardUnknown(m)
}

var xxx_messageInfo_Deallocate proto.InternalMessageInfo

func (m *Deallocate) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type TableLockInfo struct {
	LockType             TableLockType `protobuf:"varint,1,opt,name=lockType,proto3,enum=plan.TableLockType" json:"lockType,omitempty"`
	TableDef             *TableDef     `protobuf:"bytes,2,opt,name=tableDef,proto3" json:"tableDef,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TableLockInfo) Reset()         { *m = TableLockInfo{} }
func (m *TableLockInfo) String() string { return proto.CompactTextString(m) }
func (*TableLockInfo) ProtoMessage()    {}
func (*TableLockInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{86}
}
func (m *TableLockInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableLockInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableLockInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableLockInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableLockInfo.Merge(m, src)
}
func (m *TableLockInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableLockInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TableLockInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TableLockInfo proto.InternalMessageInfo

func (m *TableLockInfo) GetLockType() TableLockType {
	if m != nil {
		return m.LockType
	}
	return TableLockType_TableLockNone
}

func (m *TableLockInfo) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

type LockTables struct {
	TableLocks           []*TableLockInfo `protobuf:"bytes,1,rep,name=tableLocks,proto3" json:"tableLocks,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *LockTables) Reset()         { *m = LockTables{} }
func (m *LockTables) String() string { return proto.CompactTextString(m) }
func (*LockTables) ProtoMessage()    {}
func (*LockTables) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{87}
}
func (m *LockTables) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockTables) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockTables.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LockTables) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockTables.Merge(m, src)
}
func (m *LockTables) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LockTables) XXX_DiscardUnknown() {
	xxx_messageInfo_LockTables.DiscardUnknown(m)
}

var xxx_messageInfo_LockTables proto.InternalMessageInfo

func (m *LockTables) GetTableLocks() []*TableLockInfo {
	if m != nil {
		return m.TableLocks
	}
	return nil
}

type UnLockTables struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnLockTables) Reset()         { *m = UnLockTables{} }
func (m *UnLockTables) String() string { return proto.CompactTextString(m) }
func (*UnLockTables) ProtoMessage()    {}
func (*UnLockTables) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{88}
}
func (m *UnLockTables) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnLockTables) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnLockTables.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnLockTables) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnLockTables.Merge(m, src)
}
func (m *UnLockTables) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnLockTables) XXX_DiscardUnknown() {
	xxx_messageInfo_UnLockTables.DiscardUnknown(m)
}

var xxx_messageInfo_UnLockTables proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("plan.CompressType", CompressType_name, CompressType_value)
	proto.RegisterEnum("plan.PartitionType", PartitionType_name, PartitionType_value)
	proto.RegisterEnum("plan.TransationCompletionType", TransationCompletionType_name, TransationCompletionType_value)
	proto.RegisterEnum("plan.TableLockType", TableLockType_name, TableLockType_value)
	proto.RegisterEnum("plan.SubqueryRef_Type", SubqueryRef_Type_name, SubqueryRef_Type_value)
	proto.RegisterEnum("plan.Function_FuncFlag", Function_FuncFlag_name, Function_FuncFlag_value)
	proto.RegisterEnum("plan.ForeignKeyDef_RefAction", ForeignKeyDef_RefAction_name, ForeignKeyDef_RefAction_value)
	proto.RegisterEnum("plan.OrderBySpec_OrderByFlag", OrderBySpec_OrderByFlag_name, OrderBySpec_OrderByFlag_value)
	proto.RegisterEnum("plan.Node_NodeType", Node_NodeType_name, Node_NodeType_value)
	proto.RegisterEnum("plan.Node_JoinType", Node_JoinType_name, Node_JoinType_value)
	proto.RegisterEnum("plan.Node_AggMode", Node_AggMode_name, Node_AggMode_value)
	proto.RegisterEnum("plan.Query_StatementType", Query_StatementType_name, Query_StatementType_value)
	proto.RegisterEnum("plan.TransationControl_TclType", TransationControl_TclType_name, TransationControl_TclType_value)
	proto.RegisterEnum("plan.TransationBegin_TransationMode", TransationBegin_TransationMode_name, TransationBegin_TransationMode_value)
	proto.RegisterEnum("plan.DataControl_DclType", DataControl_DclType_name, DataControl_DclType_value)
	proto.RegisterEnum("plan.DataDefinition_DdlType", DataDefinition_DdlType_name, DataDefinition_DdlType_value)
	proto.RegisterEnum("plan.AlterTableDrop_Typ", AlterTableDrop_Typ_name, AlterTableDrop_Typ_value)
	proto.RegisterType((*Type)(nil), "plan.Type")
	proto.RegisterType((*Const)(nil), "plan.Const")
	proto.RegisterType((*ParamRef)(nil), "plan.ParamRef")
	proto.RegisterType((*VarRef)(nil), "plan.VarRef")
	proto.RegisterType((*ColRef)(nil), "plan.ColRef")
	proto.RegisterType((*RawColRef)(nil), "plan.RawColRef")
	proto.RegisterType((*CorrColRef)(nil), "plan.CorrColRef")
	proto.RegisterType((*ExprList)(nil), "plan.ExprList")
	proto.RegisterType((*MaxValue)(nil), "plan.MaxValue")
	proto.RegisterType((*TargetType)(nil), "plan.TargetType")
	proto.RegisterType((*SubqueryRef)(nil), "plan.SubqueryRef")
	proto.RegisterType((*ObjectRef)(nil), "plan.ObjectRef")
	proto.RegisterType((*SubscriptionMeta)(nil), "plan.SubscriptionMeta")
	proto.RegisterType((*Function)(nil), "plan.Function")
	proto.RegisterType((*Expr)(nil), "plan.Expr")
	proto.RegisterType((*Decimal64)(nil), "plan.decimal64")
	proto.RegisterType((*Decimal128)(nil), "plan.decimal128")
	proto.RegisterType((*ResultColDef)(nil), "plan.ResultColDef")
	proto.RegisterType((*ColDef)(nil), "plan.ColDef")
	proto.RegisterType((*Default)(nil), "plan.Default")
	proto.RegisterType((*OnUpdate)(nil), "plan.OnUpdate")
	proto.RegisterType((*IndexOption)(nil), "plan.IndexOption")
	proto.RegisterType((*PrimaryKeyDef)(nil), "plan.PrimaryKeyDef")
	proto.RegisterType((*IndexDef)(nil), "plan.IndexDef")
	proto.RegisterType((*ForeignKeyDef)(nil), "plan.ForeignKeyDef")
	proto.RegisterType((*CheckDef)(nil), "plan.CheckDef")
	proto.RegisterType((*ClusterByDef)(nil), "plan.ClusterByDef")
	proto.RegisterType((*PropertyDef)(nil), "plan.PropertyDef")
	proto.RegisterType((*Property)(nil), "plan.Property")
	proto.RegisterType((*PropertiesDef)(nil), "plan.PropertiesDef")
	proto.RegisterType((*PartitionByDef)(nil), "plan.PartitionByDef")
	proto.RegisterType((*PartitionExpr)(nil), "plan.PartitionExpr")
	proto.RegisterType((*PartitionColumns)(nil), "plan.PartitionColumns")
	proto.RegisterType((*PartitionItem)(nil), "plan.PartitionItem")
	proto.RegisterType((*ViewDef)(nil), "plan.ViewDef")
	proto.RegisterType((*TableDef)(nil), "plan.TableDef")
	proto.RegisterMapType((map[string]int32)(nil), "plan.TableDef.Name2colIndexEntry")
	proto.RegisterType((*TableDef_DefType)(nil), "plan.TableDef.DefType")
	proto.RegisterType((*TableFunction)(nil), "plan.TableFunction")
	proto.RegisterType((*Stats)(nil), "plan.Stats")
	proto.RegisterType((*ColData)(nil), "plan.ColData")
	proto.RegisterType((*RowsetData)(nil), "plan.RowsetData")
	proto.RegisterType((*OrderBySpec)(nil), "plan.OrderBySpec")
	proto.RegisterType((*WindowSpec)(nil), "plan.WindowSpec")
	proto.RegisterType((*InsertCtx)(nil), "plan.InsertCtx")
	proto.RegisterMapType((map[string]*Expr)(nil), "plan.InsertCtx.OnDuplicateExprEntry")
	proto.RegisterMapType((map[string]int32)(nil), "plan.InsertCtx.ParentIdxEntry")
	proto.RegisterType((*UpdateCtx)(nil), "plan.UpdateCtx")
	proto.RegisterType((*AnalyzeInfo)(nil), "plan.AnalyzeInfo")
	proto.RegisterType((*Node)(nil), "plan.Node")
	proto.RegisterType((*IdList)(nil), "plan.IdList")
	proto.RegisterType((*ColPosMap)(nil), "plan.ColPosMap")
	proto.RegisterMapType((map[string]int32)(nil), "plan.ColPosMap.MapEntry")
	proto.RegisterType((*DeleteCtx)(nil), "plan.DeleteCtx")
	proto.RegisterType((*Query)(nil), "plan.Query")
	proto.RegisterType((*TransationControl)(nil), "plan.TransationControl")
	proto.RegisterType((*TransationBegin)(nil), "plan.TransationBegin")
	proto.RegisterType((*TransationCommit)(nil), "plan.TransationCommit")
	proto.RegisterType((*TransationRollback)(nil), "plan.TransationRollback")
	proto.RegisterType((*Plan)(nil), "plan.Plan")
	proto.RegisterType((*Column)(nil), "plan.column")
	proto.RegisterType((*DataControl)(nil), "plan.DataControl")
	proto.RegisterType((*DataDefinition)(nil), "plan.DataDefinition")
	proto.RegisterType((*SubscriptionOption)(nil), "plan.SubscriptionOption")
	proto.RegisterType((*CreateDatabase)(nil), "plan.CreateDatabase")
	proto.RegisterType((*AlterDatabase)(nil), "plan.AlterDatabase")
	proto.RegisterType((*DropDatabase)(nil), "plan.DropDatabase")
	proto.RegisterType((*FkColName)(nil), "plan.FkColName")
	proto.RegisterType((*CreateTable)(nil), "plan.CreateTable")
	proto.RegisterType((*AlterTableDrop)(nil), "plan.AlterTableDrop")
	proto.RegisterType((*AlterTableAddFk)(nil), "plan.AlterTableAddFk")
	proto.RegisterType((*AlterTableAddIndex)(nil), "plan.AlterTableAddIndex")
	proto.RegisterType((*AlterTableDropIndex)(nil), "plan.AlterTableDropIndex")
	proto.RegisterType((*AlterTableAlterIndex)(nil), "plan.AlterTableAlterIndex")
	proto.RegisterType((*AlterTable)(nil), "plan.AlterTable")
	proto.RegisterType((*AlterTable_Action)(nil), "plan.AlterTable.Action")
	proto.RegisterType((*DropTable)(nil), "plan.DropTable")
	proto.RegisterType((*AlterView)(nil), "plan.AlterView")
	proto.RegisterType((*CreateSequence)(nil), "plan.CreateSequence")
	proto.RegisterType((*DropSequence)(nil), "plan.DropSequence")
	proto.RegisterType((*AlterSequence)(nil), "plan.AlterSequence")
	proto.RegisterType((*CreateIndex)(nil), "plan.CreateIndex")
	proto.RegisterType((*AlterIndex)(nil), "plan.AlterIndex")
	proto.RegisterType((*DropIndex)(nil), "plan.DropIndex")
	proto.RegisterType((*TruncateTable)(nil), "plan.TruncateTable")
	proto.RegisterType((*ClusterTable)(nil), "plan.ClusterTable")
	proto.RegisterType((*ShowVariables)(nil), "plan.ShowVariables")
	proto.RegisterType((*SetVariables)(nil), "plan.SetVariables")
	proto.RegisterType((*SetVariablesItem)(nil), "plan.SetVariablesItem")
	proto.RegisterType((*Prepare)(nil), "plan.Prepare")
	proto.RegisterType((*Execute)(nil), "plan.Execute")
	proto.RegisterType((*Deallocate)(nil), "plan.Deallocate")
	proto.RegisterType((*TableLockInfo)(nil), "plan.TableLockInfo")
	proto.RegisterType((*LockTables)(nil), "plan.LockTables")
	proto.RegisterType((*UnLockTables)(nil), "plan.UnLockTables")
}

func init() { proto.RegisterFile("plan.proto", fileDescriptor_2d655ab2f7683c23) }

var fileDescriptor_2d655ab2f7683c23 = []byte{
	// 7436 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x7c, 0x4b, 0x8c, 0x1b, 0x47,
	0xda, 0xd8, 0xf0, 0x4d, 0x7e, 0x7c, 0x4c, 0xab, 0xf4, 0xa2, 0x64, 0x59, 0x1e, 0xb7, 0xb5, 0xb6,
	0x2c, 0x7b, 0x65, 0x7b, 0xfc, 0x76, 0xbc, 0xd8, 0xe5, 0x90, 0xd4, 0x0c, 0x6d, 0x8a, 0x9c, 0x2d,
	0x72, 0xa4, 0x75, 0x7e, 0x04, 0x44, 0x93, 0xdd, 0x1c, 0xb5, 0xa6, 0xd9, 0x4d, 0x77, 0x37, 0x35,
	0x33, 0x0b, 0xfc, 0xc0, 0x9e, 0x12, 0xe4, 0x94, 0x43, 0x80, 0x24, 0xc0, 0x06, 0xc8, 0x26, 0x87,
	0x00, 0xf9, 0x2f, 0x39, 0xe6, 0x92, 0x4b, 0x92, 0x4b, 0x02, 0xe4, 0x90, 0x00, 0xc9, 0x25, 0xb9,
	0x24, 0x4e, 0xf0, 0xdf, 0x83, 0x3f, 0xc7, 0x1c, 0x82, 0xef, 0xab, 0xea, 0xee, 0x6a, 0x0e, 0xb5,
	0x92, 0xb5, 0xfe, 0x2f, 0x33, 0x5d, 0xdf, 0xa3, 0xea, 0xab, 0xaa, 0xaf, 0xbe, 0x47, 0x3d, 0x08,
	0xb0, 0x74, 0x0c, 0xf7, 0xfe, 0xd2, 0xf7, 0x42, 0x8f, 0xe5, 0xf1, 0xfb, 0xe6, 0xcf, 0x8f, 0xed,
	0xf0, 0xc9, 0x6a, 0x7a, 0x7f, 0xe6, 0x2d, 0x3e, 0x38, 0xf6, 0x8e, 0xbd, 0x0f, 0x08, 0x39, 0x5d,
	0xcd, 0xa9, 0x44, 0x05, 0xfa, 0x12, 0x4c, 0xfa, 0x3f, 0xcc, 0x40, 0x7e, 0x7c, 0xbe, 0xb4, 0x58,
	0x03, 0xb2, 0xb6, 0xd9, 0xcc, 0xec, 0x64, 0xee, 0x16, 0x78, 0xd6, 0x36, 0xd9, 0x0e, 0x54, 0x5d,
	0x2f, 0x1c, 0xac, 0x1c, 0xc7, 0x98, 0x3a, 0x56, 0x33, 0xbb, 0x93, 0xb9, 0x5b, 0xe6, 0x2a, 0x88,
	0xbd, 0x06, 0x15, 0x63, 0x15, 0x7a, 0x13, 0xdb, 0x9d, 0xf9, 0xcd, 0x1c, 0xe1, 0xcb, 0x08, 0xe8,
	0xb9, 0x33, 0x9f, 0x5d, 0x81, 0xc2, 0xa9, 0x6d, 0x86, 0x4f, 0x9a, 0x79, 0xaa, 0x51, 0x14, 0x10,
	0x1a, 0xcc, 0x0c, 0xc7, 0x6a, 0x16, 0x04, 0x94, 0x0a, 0x08, 0x0d, 0xa9, 0x91, 0xe2, 0x4e, 0xe6,
	0x6e, 0x85, 0x8b, 0x82, 0xfe, 0x9f, 0x0b, 0x50, 0x68, 0x7b, 0x6e, 0x10, 0xb2, 0x6b, 0x50, 0xb4,
	0x03, 0x77, 0xe5, 0x38, 0x24, 0x5e, 0x99, 0xcb, 0x12, 0xbb, 0x06, 0x05, 0xfb, 0x8b, 0x67, 0x86,
	0x43, 0xc2, 0x15, 0x0e, 0xb6, 0xb8, 0x28, 0xb2, 0x26, 0x14, 0xed, 0x8f, 0x3e, 0x43, 0x44, 0x4e,
	0x22, 0x64, 0x99, 0x30, 0x1f, 0xef, 0x22, 0x26, 0x1f, 0x63, 0xa8, 0x4c, 0x98, 0xcf, 0x3e, 0x41,
	0x0c, 0x8a, 0x96, 0x23, 0x0c, 0x95, 0xb1, 0x95, 0x15, 0xb5, 0x82, 0xd2, 0xd5, 0xb1, 0x95, 0x55,
	0xd4, 0xca, 0x4a, 0xb4, 0x52, 0x92, 0x08, 0x59, 0x26, 0x8c, 0x68, 0xa5, 0x1c, 0x63, 0xe2, 0x56,
	0x56, 0xa2, 0x95, 0xca, 0x4e, 0xe6, 0x6e, 0x9e, 0x30, 0xa2, 0x95, 0x2b, 0x90, 0x37, 0x11, 0x0e,
	0x3b, 0x99, 0xbb, 0x99, 0x83, 0x2d, 0x4e, 0x25, 0x84, 0x06, 0x08, 0xad, 0xe2, 0xc0, 0x20, 0x34,
	0x90, 0xd0, 0x29, 0x42, 0x6b, 0x38, 0x1a, 0x08, 0x9d, 0x4a, 0xe8, 0x1c, 0xa1, 0xf5, 0x9d, 0xcc,
	0xdd, 0x2c, 0x42, 0xb1, 0xc4, 0x6e, 0x42, 0xc9, 0x34, 0x42, 0x0b, 0x11, 0x0d, 0xd9, 0xe5, 0x08,
	0x80, 0xb8, 0xd0, 0x5e, 0x10, 0x6e, 0x5b, 0x76, 0x3a, 0x02, 0x30, 0x1d, 0xaa, 0x48, 0x16, 0xe1,
	0x35, 0x89, 0x57, 0x81, 0xec, 0x53, 0xa8, 0x99, 0xd6, 0xcc, 0x5e, 0x18, 0x8e, 0xe8, 0xd3, 0xa5,
	0x9d, 0xcc, 0xdd, 0xea, 0xee, 0xf6, 0x7d, 0xd2, 0xc9, 0x18, 0x73, 0xb0, 0xc5, 0x53, 0x64, 0xec,
	0x0b, 0xa8, 0xcb, 0xf2, 0x47, 0xbb, 0x34, 0xb0, 0x8c, 0xf8, 0xb4, 0x14, 0xdf, 0x47, 0xbb, 0x5f,
	0x1c, 0x6c, 0xf1, 0x34, 0x21, 0xbb, 0x03, 0x35, 0x6c, 0x3b, 0x08, 0x8d, 0xc5, 0x12, 0x19, 0x2f,
	0x4b, 0xa9, 0x52, 0x50, 0xec, 0xd6, 0xd3, 0xc0, 0x73, 0x91, 0xe0, 0x8a, 0x1c, 0xb7, 0x08, 0xc0,
	0x76, 0x00, 0x4c, 0x6b, 0x6e, 0xac, 0x9c, 0x10, 0xd1, 0x57, 0xe5, 0x00, 0x2a, 0x30, 0x76, 0x1b,
	0x2a, 0xab, 0x25, 0xf6, 0xf2, 0x91, 0xe1, 0x34, 0xaf, 0x49, 0x82, 0x04, 0x84, 0xca, 0x6a, 0x07,
	0x7b, 0xb6, 0xdb, 0xbc, 0x4e, 0xba, 0x28, 0x0a, 0xec, 0x16, 0xe4, 0x02, 0x7f, 0xd6, 0x6c, 0x52,
	0x4f, 0x40, 0xf4, 0xa4, 0x7b, 0xb6, 0xf4, 0x39, 0x82, 0xf7, 0x4a, 0x50, 0x78, 0x66, 0x38, 0x2b,
	0x4b, 0xbf, 0x05, 0xe5, 0x43, 0xc3, 0x37, 0x16, 0xdc, 0x9a, 0x33, 0x0d, 0x72, 0x4b, 0x2f, 0x90,
	0x2b, 0x0e, 0x3f, 0xf5, 0x3e, 0x14, 0x1f, 0x19, 0x3e, 0xe2, 0x18, 0xe4, 0x5d, 0x63, 0x61, 0x11,
	0xb2, 0xc2, 0xe9, 0x1b, 0x57, 0x41, 0x70, 0x1e, 0x84, 0xd6, 0x42, 0xae, 0x45, 0x59, 0x42, 0xf8,
	0xb1, 0xe3, 0x4d, 0xa5, 0xb6, 0x97, 0xb9, 0x2c, 0xe9, 0x03, 0x28, 0xb6, 0x3d, 0x07, 0x6b, 0xbb,
	0x0e, 0x25, 0xdf, 0x72, 0x26, 0x49, 0x6b, 0x45, 0xdf, 0x72, 0x0e, 0xbd, 0x00, 0x11, 0x33, 0x4f,
	0x20, 0xb2, 0x02, 0x31, 0xf3, 0x08, 0x11, 0xb5, 0x9f, 0x4b, 0xda, 0xd7, 0xbf, 0x84, 0x0a, 0x37,
	0x4e, 0x65, 0x95, 0x57, 0xa1, 0x18, 0x4e, 0x9d, 0x89, 0xb4, 0x18, 0x79, 0x5e, 0x08, 0xa7, 0x4e,
	0xcf, 0x44, 0x30, 0x56, 0x68, 0x9b, 0x54, 0x5f, 0x9e, 0x17, 0x66, 0x9e, 0xd3, 0x33, 0xf5, 0x31,
	0x40, 0xdb, 0xf3, 0xfd, 0x57, 0x16, 0xe7, 0x0a, 0x14, 0x4c, 0x6b, 0x19, 0x3e, 0x11, 0xeb, 0x99,
	0x8b, 0x82, 0x7e, 0x0f, 0xca, 0x38, 0xc4, 0x7d, 0x3b, 0x08, 0xd9, 0x6d, 0xc8, 0x3b, 0x76, 0x10,
	0x36, 0x33, 0x3b, 0xb9, 0xb5, 0x09, 0x20, 0xb8, 0xbe, 0x03, 0xe5, 0x87, 0xc6, 0xd9, 0x23, 0x9c,
	0x04, 0xac, 0x8d, 0x66, 0x43, 0x8e, 0xae, 0x9c, 0x9a, 0x7b, 0x00, 0x63, 0xc3, 0x3f, 0xb6, 0x42,
	0xb2, 0x86, 0xb7, 0x20, 0x17, 0x9e, 0x2f, 0x89, 0x22, 0xae, 0x0e, 0x11, 0x1c, 0xc1, 0xfa, 0x5f,
	0x65, 0xa0, 0x3a, 0x5a, 0x4d, 0xbf, 0x5f, 0x59, 0xfe, 0x39, 0xf6, 0xe8, 0x6e, 0x42, 0xdd, 0xd8,
	0xbd, 0x26, 0xa8, 0x15, 0x7c, 0xc2, 0x89, 0x5d, 0x74, 0x3d, 0xd3, 0x8a, 0x46, 0xa8, 0xc0, 0x8b,
	0x58, 0xec, 0x99, 0x68, 0x7e, 0xbd, 0xa5, 0x1c, 0xef, 0xac, 0xb7, 0x64, 0x3b, 0x50, 0x98, 0x3d,
	0xb1, 0x1d, 0x93, 0x0c, 0x55, 0xba, 0x47, 0x02, 0xc1, 0x6e, 0x40, 0xd9, 0xf7, 0x4e, 0x27, 0x81,
	0xfd, 0xdb, 0xc8, 0x9c, 0x96, 0x7c, 0xef, 0x74, 0x64, 0xff, 0xd6, 0xd2, 0xc7, 0xd2, 0xa6, 0x03,
	0x14, 0x47, 0xed, 0x56, 0xbf, 0xc5, 0xb5, 0x2d, 0xfc, 0xee, 0xfe, 0xa6, 0x37, 0x1a, 0x8f, 0xb4,
	0x0c, 0x6b, 0x00, 0x0c, 0x86, 0xe3, 0x89, 0x2c, 0x67, 0x59, 0x11, 0xb2, 0xbd, 0x81, 0x96, 0x43,
	0x1a, 0x84, 0xf7, 0x06, 0x5a, 0x9e, 0x95, 0x20, 0xd7, 0x1a, 0x7c, 0xa7, 0x15, 0xe8, 0xa3, 0xdf,
	0xd7, 0x8a, 0xfa, 0x3f, 0xcf, 0x42, 0x65, 0x38, 0x7d, 0x6a, 0xcd, 0x42, 0xec, 0x33, 0xaa, 0xa3,
	0xe5, 0x3f, 0xb3, 0x7c, 0xea, 0x76, 0x8e, 0xcb, 0x12, 0x76, 0xc4, 0x9c, 0x52, 0xe7, 0x72, 0x3c,
	0x6b, 0x4e, 0x89, 0x6e, 0xf6, 0xc4, 0x5a, 0x18, 0xd4, 0x39, 0xa4, 0xa3, 0x12, 0xaa, 0xbf, 0x37,
	0x7d, 0x4a, 0xdd, 0xcb, 0x71, 0xfc, 0x64, 0x6f, 0x40, 0x55, 0xd4, 0x31, 0x21, 0xdd, 0x2b, 0xd0,
	0x58, 0x80, 0x00, 0x0d, 0x70, 0x05, 0x5c, 0x87, 0x92, 0x39, 0x15, 0x48, 0xe1, 0x29, 0x8a, 0xe6,
	0x94, 0x10, 0xc8, 0x49, 0xb5, 0x0a, 0x64, 0x49, 0x72, 0x12, 0x88, 0x08, 0x6e, 0x40, 0xd9, 0x9b,
	0x3e, 0x15, 0xd8, 0x32, 0x61, 0x4b, 0xde, 0xf4, 0x29, 0xa1, 0xde, 0x83, 0x4b, 0xc1, 0x6a, 0x1a,
	0xcc, 0x7c, 0x7b, 0x19, 0xda, 0x9e, 0x2b, 0x68, 0x2a, 0x44, 0xa3, 0xa9, 0x08, 0x22, 0xbe, 0x03,
	0x8d, 0xe5, 0x6a, 0x3a, 0x31, 0x66, 0x33, 0x6f, 0xe5, 0x86, 0x38, 0x8b, 0x40, 0x23, 0x5f, 0x5b,
	0xae, 0xa6, 0x2d, 0x01, 0xec, 0x99, 0xfa, 0x3f, 0xce, 0x80, 0x36, 0x52, 0x58, 0x1f, 0x5a, 0xa1,
	0xb1, 0x71, 0x49, 0xbf, 0x0e, 0xa0, 0x54, 0x25, 0x14, 0xa2, 0x62, 0x44, 0xf5, 0xa8, 0xfd, 0xcd,
	0xa5, 0xfa, 0xfb, 0x26, 0xd4, 0x22, 0x3e, 0xc2, 0xe6, 0x09, 0x5b, 0x95, 0xb0, 0xa8, 0xc7, 0xc1,
	0x6a, 0xaa, 0x8e, 0x64, 0x29, 0x58, 0x11, 0xb7, 0xfe, 0x7f, 0x32, 0x50, 0x7e, 0xb0, 0x72, 0x67,
	0x28, 0x1a, 0x7b, 0x0b, 0xf2, 0xf3, 0x95, 0x3b, 0x93, 0x9a, 0x2e, 0x6d, 0x77, 0x3c, 0xcb, 0x9c,
	0x90, 0xb8, 0xba, 0x0c, 0xff, 0x18, 0x57, 0xe5, 0x85, 0xd5, 0x85, 0x70, 0xfd, 0x9f, 0xc8, 0x1a,
	0x1f, 0x38, 0xc6, 0x31, 0x2b, 0x43, 0x7e, 0x30, 0x1c, 0x74, 0xb5, 0x2d, 0x56, 0x83, 0x72, 0x6f,
	0x30, 0xee, 0xf2, 0x41, 0xab, 0xaf, 0x65, 0x48, 0x19, 0xc7, 0xad, 0xbd, 0x7e, 0x57, 0xcb, 0x22,
	0xe6, 0xd1, 0xb0, 0xdf, 0x1a, 0xf7, 0xfa, 0x5d, 0x2d, 0x2f, 0x30, 0xbc, 0xd7, 0x1e, 0x6b, 0x65,
	0xa6, 0x41, 0xed, 0x90, 0x0f, 0x3b, 0x47, 0xed, 0xee, 0x64, 0x70, 0xd4, 0xef, 0x6b, 0x1a, 0xbb,
	0x0c, 0xdb, 0x31, 0x64, 0x28, 0x80, 0x3b, 0xc8, 0xf2, 0xa8, 0xc5, 0x5b, 0x7c, 0x5f, 0xfb, 0x15,
	0x2b, 0x43, 0xae, 0xb5, 0xbf, 0xaf, 0xfd, 0x2e, 0x83, 0x5f, 0x8f, 0x7b, 0x03, 0xed, 0x77, 0x59,
	0xd6, 0x80, 0xca, 0xc3, 0xe1, 0x60, 0x38, 0x1e, 0x0e, 0x7a, 0x6d, 0xed, 0x77, 0x79, 0xfd, 0x5f,
	0xe4, 0x20, 0x8f, 0x02, 0xff, 0xf1, 0x85, 0xcd, 0x5e, 0x83, 0xcc, 0x8c, 0xe6, 0xa1, 0xba, 0x5b,
	0x15, 0x38, 0x8a, 0x40, 0x0e, 0xb6, 0x78, 0x06, 0x47, 0x21, 0x23, 0x56, 0x68, 0x75, 0xb7, 0x21,
	0x90, 0x91, 0x2d, 0x47, 0xfc, 0x92, 0xdd, 0x82, 0xcc, 0x33, 0xb9, 0x5c, 0x6b, 0x02, 0x2f, 0xac,
	0x39, 0x62, 0x9f, 0xb1, 0x1d, 0xc8, 0xcd, 0x3c, 0x11, 0x5d, 0xc4, 0x78, 0x61, 0x10, 0x0f, 0xb6,
	0x38, 0xa2, 0xd8, 0x5b, 0x90, 0xf3, 0x8d, 0x53, 0x52, 0xed, 0x78, 0x26, 0x62, 0x8b, 0x8b, 0x44,
	0xbe, 0x71, 0x8a, 0x42, 0xcc, 0x49, 0xc1, 0x63, 0x21, 0xa2, 0xa9, 0xc4, 0x66, 0xe6, 0xec, 0x67,
	0x90, 0x0b, 0x56, 0x53, 0x52, 0xf2, 0xea, 0xee, 0xa5, 0x0b, 0xa6, 0x08, 0xab, 0x09, 0x56, 0x53,
	0xf6, 0x36, 0xe4, 0x67, 0x9e, 0xef, 0x93, 0xa2, 0xc7, 0xae, 0x37, 0xb1, 0xd1, 0x18, 0x3e, 0x20,
	0x9e, 0xed, 0x40, 0x26, 0x24, 0x1d, 0x8f, 0x89, 0x12, 0x23, 0x89, 0x0d, 0x86, 0xec, 0x8e, 0xb4,
	0xbc, 0x55, 0x55, 0xa6, 0xc8, 0x2e, 0x63, 0x3d, 0x88, 0x65, 0x3a, 0xe4, 0x16, 0xc6, 0x19, 0x45,
	0x2c, 0x31, 0x51, 0x64, 0x90, 0x51, 0xa6, 0x85, 0x71, 0xb6, 0x57, 0x84, 0xbc, 0x75, 0xb6, 0xf4,
	0xf5, 0x1b, 0x50, 0x89, 0xe3, 0x05, 0x56, 0x83, 0x8c, 0x21, 0x2d, 0x4c, 0xc6, 0xd0, 0xef, 0xa2,
	0xfb, 0x8e, 0x22, 0x82, 0x34, 0x0e, 0x4b, 0x91, 0xdd, 0xc9, 0x4c, 0xf5, 0xaf, 0xa1, 0xc6, 0xad,
	0x60, 0xe5, 0x84, 0x6d, 0xcf, 0xe9, 0x58, 0x73, 0xf6, 0x3e, 0x40, 0x5c, 0x0e, 0xa4, 0x9b, 0x48,
	0x66, 0xa1, 0x63, 0xcd, 0xb9, 0x82, 0xd7, 0x7f, 0x9f, 0x23, 0xe7, 0xd9, 0x11, 0x9e, 0x4e, 0xba,
	0xb4, 0x8c, 0xe2, 0xd2, 0xe2, 0xe5, 0x9c, 0x4d, 0x7b, 0xe8, 0x27, 0xb6, 0x69, 0x5a, 0x6e, 0xe4,
	0x89, 0x45, 0x89, 0xdd, 0x81, 0x9c, 0xe1, 0x1c, 0x93, 0x6a, 0x34, 0x76, 0x59, 0xd4, 0xe8, 0x62,
	0xe9, 0x5b, 0x41, 0x20, 0x74, 0xcf, 0x70, 0x8e, 0x23, 0xcd, 0x2c, 0x6c, 0xd6, 0xcc, 0x1b, 0x50,
	0x76, 0xbd, 0x70, 0x42, 0x51, 0x70, 0x91, 0x6a, 0x2f, 0xc9, 0x58, 0x9c, 0xbd, 0x03, 0x25, 0x19,
	0xbf, 0x48, 0xc5, 0xa8, 0x0b, 0xe6, 0x8e, 0x00, 0xf2, 0x08, 0xcb, 0x9a, 0xe8, 0x5f, 0x17, 0x0b,
	0xcb, 0x0d, 0x23, 0x23, 0x28, 0x8b, 0xec, 0x3d, 0xa8, 0x78, 0xee, 0x44, 0x04, 0x39, 0x52, 0x27,
	0xe4, 0x24, 0x0d, 0xdd, 0x23, 0x82, 0xf2, 0xb2, 0x27, 0xbf, 0x50, 0x14, 0xc7, 0x3b, 0x9d, 0xcc,
	0x0c, 0x5f, 0x98, 0xbf, 0x32, 0x2f, 0x39, 0xde, 0x69, 0xdb, 0xf0, 0x4d, 0xe1, 0x14, 0xbe, 0x77,
	0x57, 0x0b, 0x0a, 0x36, 0xeb, 0x5c, 0x96, 0xd8, 0x2d, 0xa8, 0xcc, 0x9c, 0x55, 0x10, 0x5a, 0xfe,
	0xde, 0x39, 0x69, 0x4a, 0x99, 0x27, 0x00, 0x94, 0x6b, 0xe9, 0xdb, 0x0b, 0xc3, 0x3f, 0x17, 0x21,
	0x2d, 0x8f, 0x8a, 0xe8, 0xaa, 0x97, 0x27, 0xb6, 0x79, 0x46, 0x41, 0x6d, 0x81, 0x8b, 0x82, 0xfe,
	0x3d, 0x94, 0x64, 0xdf, 0xd0, 0x32, 0xa1, 0xce, 0xa4, 0xd7, 0xb3, 0xb0, 0x4c, 0x08, 0x67, 0x6f,
	0x41, 0xdd, 0xf3, 0xed, 0x63, 0xdb, 0x9d, 0x04, 0xa1, 0x6f, 0xbb, 0xc7, 0x72, 0xbe, 0x6a, 0x02,
	0x38, 0x22, 0x18, 0x9a, 0x53, 0x1c, 0xd7, 0x89, 0x31, 0xb5, 0x1d, 0x3b, 0x3c, 0x97, 0xb3, 0x57,
	0x45, 0x58, 0x4b, 0x80, 0xf4, 0x21, 0x94, 0xa3, 0x91, 0xf8, 0x49, 0xda, 0xd4, 0xff, 0x06, 0x54,
	0x7b, 0xae, 0x69, 0x9d, 0x0d, 0xc9, 0x43, 0xb0, 0xf7, 0x81, 0xcd, 0x7c, 0xcb, 0x08, 0xad, 0x89,
	0x75, 0x16, 0xfa, 0xc6, 0x44, 0xe4, 0x43, 0x22, 0xdd, 0xd1, 0x04, 0xa6, 0x8b, 0x88, 0x31, 0xa5,
	0x46, 0xff, 0x2d, 0x03, 0xf5, 0x43, 0x31, 0x44, 0xdf, 0x5a, 0xe7, 0x1d, 0x11, 0x30, 0xce, 0x22,
	0xc5, 0xce, 0x73, 0xfa, 0x66, 0xb7, 0xa1, 0xba, 0x3c, 0xb1, 0xce, 0x27, 0xa9, 0x88, 0xac, 0x82,
	0xa0, 0x36, 0xa9, 0xf0, 0xbb, 0x50, 0xf4, 0xa8, 0x75, 0x69, 0xd4, 0xa4, 0xb5, 0x50, 0xc4, 0xe2,
	0x92, 0x80, 0xe9, 0x50, 0x8f, 0xab, 0x52, 0x3d, 0x8e, 0xac, 0x8c, 0x3c, 0xce, 0x15, 0x28, 0x20,
	0x2a, 0x68, 0x16, 0x76, 0x72, 0x18, 0x56, 0x51, 0x81, 0x7d, 0x08, 0xf5, 0x99, 0xb7, 0x58, 0x4e,
	0x22, 0x76, 0x69, 0xde, 0xd2, 0x4b, 0xaf, 0x8a, 0x24, 0x87, 0xa2, 0x2e, 0xfd, 0x1f, 0x65, 0xa1,
	0x4c, 0x32, 0xc8, 0xd5, 0x67, 0x9b, 0x67, 0xd1, 0xea, 0xab, 0xf0, 0x82, 0x6d, 0x9e, 0xf5, 0x4c,
	0x74, 0x9c, 0x36, 0x92, 0x4c, 0x94, 0x35, 0x58, 0x21, 0x48, 0x24, 0xca, 0xd2, 0xf0, 0xc3, 0xa0,
	0x99, 0x13, 0xa2, 0x50, 0x01, 0x95, 0x73, 0xe5, 0xda, 0xdf, 0xaf, 0x84, 0xf4, 0x65, 0x2e, 0x4b,
	0xec, 0x2e, 0x68, 0xa2, 0x32, 0x1a, 0x74, 0xd5, 0x65, 0x36, 0x08, 0x4e, 0x63, 0x1e, 0xc5, 0x19,
	0x82, 0xc6, 0x3a, 0x43, 0x93, 0x27, 0xd6, 0x21, 0x10, 0xa8, 0x8b, 0x10, 0x75, 0x85, 0x95, 0xd2,
	0x2b, 0xac, 0x09, 0xa5, 0x67, 0x76, 0x60, 0xe3, 0xac, 0x96, 0x85, 0x8e, 0xcb, 0xa2, 0x32, 0x0d,
	0x95, 0x17, 0x4c, 0x83, 0xfe, 0x1f, 0xb2, 0x50, 0x7f, 0xe0, 0xf9, 0x96, 0x7d, 0xec, 0x26, 0xf3,
	0x7e, 0x21, 0xaa, 0x88, 0x74, 0x21, 0xab, 0xe8, 0xc2, 0x1b, 0x50, 0x9d, 0x0b, 0xc6, 0x49, 0x38,
	0x15, 0x99, 0x42, 0x9e, 0x83, 0x04, 0x8d, 0xa7, 0x0e, 0xae, 0x81, 0x88, 0x80, 0x98, 0xf3, 0xc4,
	0x1c, 0x31, 0xa1, 0x51, 0x64, 0x5f, 0x91, 0x91, 0x30, 0x2d, 0xc7, 0x0a, 0xc5, 0x00, 0x35, 0x76,
	0x5f, 0x97, 0x2e, 0x48, 0x95, 0xe9, 0x3e, 0xb7, 0xe6, 0x2d, 0xf2, 0x48, 0x68, 0x33, 0x3a, 0x44,
	0x2e, 0x79, 0xa5, 0x81, 0x29, 0xbe, 0x24, 0xaf, 0x58, 0x6f, 0xfa, 0x18, 0x2a, 0x31, 0x18, 0x23,
	0x07, 0xde, 0x95, 0xd1, 0xc2, 0x16, 0xab, 0x42, 0xa9, 0xdd, 0x1a, 0xb5, 0x5b, 0x9d, 0xae, 0x96,
	0x41, 0xd4, 0xa8, 0x3b, 0x16, 0x11, 0x42, 0x96, 0x6d, 0x43, 0x15, 0x4b, 0x9d, 0xee, 0x83, 0xd6,
	0x51, 0x7f, 0xac, 0xe5, 0x58, 0x1d, 0x2a, 0x83, 0xe1, 0xa4, 0xd5, 0x1e, 0xf7, 0x86, 0x03, 0x2d,
	0xaf, 0xff, 0x0a, 0xca, 0xed, 0x27, 0xd6, 0xec, 0xe4, 0x79, 0xa3, 0x48, 0x01, 0xb8, 0x35, 0x3b,
	0x91, 0xe1, 0xc0, 0x5a, 0x00, 0x6e, 0xcd, 0x4e, 0xf4, 0x0e, 0xd4, 0xda, 0x91, 0x0d, 0xc3, 0x5a,
	0x76, 0x22, 0xad, 0xbb, 0x98, 0x84, 0x48, 0x0d, 0xdc, 0xe0, 0x34, 0xf4, 0x4f, 0xa1, 0x7a, 0xe8,
	0x7b, 0x4b, 0xcb, 0x0f, 0xa9, 0x12, 0x0d, 0x72, 0x27, 0xd6, 0xb9, 0x94, 0x04, 0x3f, 0x93, 0x74,
	0x25, 0xab, 0xa6, 0x2b, 0xbb, 0x50, 0x8e, 0xd8, 0x5e, 0x9a, 0xe7, 0x97, 0x68, 0x35, 0x88, 0xc7,
	0xb6, 0x02, 0x6c, 0xec, 0x3e, 0xc0, 0x32, 0x06, 0x48, 0xb1, 0xa3, 0xd0, 0x46, 0x56, 0xce, 0x15,
	0x0a, 0xfd, 0xaf, 0x72, 0xd0, 0x38, 0x34, 0xfc, 0xd0, 0xc6, 0xa9, 0x10, 0x9d, 0x7e, 0x07, 0xf2,
	0xe1, 0xf9, 0xd2, 0x92, 0xb9, 0xcf, 0xe5, 0x38, 0x2e, 0x12, 0x34, 0xe4, 0xbf, 0x88, 0x80, 0x7d,
	0x05, 0x8d, 0x65, 0x04, 0x9e, 0x90, 0xfd, 0x14, 0x03, 0xbb, 0xce, 0x42, 0xe3, 0x55, 0x5f, 0xaa,
	0x45, 0xf6, 0x0b, 0xb8, 0x92, 0xe6, 0xb5, 0x82, 0x20, 0xb1, 0x5b, 0xea, 0x40, 0x5f, 0x4e, 0x31,
	0x0a, 0x32, 0xd6, 0x86, 0x4b, 0x09, 0xfb, 0xcc, 0x73, 0x56, 0x0b, 0x37, 0x90, 0x81, 0xda, 0xb5,
	0xb5, 0xd6, 0xdb, 0x02, 0xcb, 0xb5, 0xe5, 0x1a, 0x84, 0xe9, 0x50, 0x8b, 0x61, 0x83, 0xd5, 0x82,
	0x16, 0x40, 0x9e, 0xa7, 0x60, 0xec, 0x63, 0x80, 0xb8, 0x1c, 0x34, 0x8b, 0x34, 0x9e, 0xeb, 0xfd,
	0xeb, 0x85, 0xd6, 0x82, 0x2b, 0x64, 0xe8, 0x1b, 0x0d, 0xe7, 0xd8, 0xf3, 0xed, 0xf0, 0xc9, 0x82,
	0xac, 0x46, 0x8e, 0x27, 0x00, 0x32, 0x4e, 0xc1, 0x04, 0x43, 0xf9, 0x98, 0x45, 0x1a, 0x90, 0x86,
	0x1d, 0x8c, 0x56, 0xd3, 0xb8, 0x5e, 0x74, 0x3b, 0x49, 0x2f, 0x17, 0xc1, 0xb1, 0x4c, 0x62, 0x12,
	0x09, 0x1f, 0x06, 0xc7, 0x6c, 0x17, 0xae, 0x26, 0x44, 0x89, 0xbd, 0x0b, 0x9a, 0x40, 0x96, 0x32,
	0x19, 0xbe, 0xd8, 0xe8, 0x05, 0xfa, 0x37, 0x50, 0x4f, 0xcd, 0xce, 0x0b, 0x1d, 0xe0, 0x0d, 0x28,
	0xe3, 0x7f, 0x74, 0x7f, 0x52, 0x01, 0x4b, 0x58, 0x1e, 0x85, 0xbe, 0x6e, 0x81, 0xb6, 0x3e, 0xd6,
	0xec, 0x0e, 0xa5, 0xfd, 0x34, 0x29, 0x17, 0x57, 0x4e, 0x84, 0xc2, 0x3c, 0xed, 0xe2, 0x24, 0x66,
	0x49, 0xea, 0x0b, 0x93, 0xa5, 0xff, 0xd3, 0xac, 0x22, 0x33, 0x8e, 0x38, 0xfb, 0x99, 0xaa, 0x7e,
	0xca, 0x62, 0x4f, 0xc6, 0x8c, 0x2c, 0xfc, 0xbb, 0xa0, 0x79, 0xbe, 0x69, 0xbb, 0x06, 0x6d, 0x43,
	0x88, 0xe1, 0xce, 0x52, 0x28, 0xb3, 0x2d, 0xe1, 0x87, 0x12, 0xcc, 0x76, 0xa0, 0x6a, 0x5a, 0x71,
	0x8e, 0x27, 0x33, 0x34, 0x15, 0xa4, 0x7a, 0x83, 0x7c, 0xda, 0x1b, 0xbc, 0x03, 0x15, 0xc7, 0x0a,
	0x82, 0x49, 0xf8, 0xc4, 0x70, 0xc9, 0x5f, 0xa6, 0x3b, 0x5d, 0x46, 0xe4, 0xf8, 0x89, 0xe1, 0x22,
	0xa1, 0xed, 0x4e, 0x68, 0xf9, 0x46, 0x0a, 0x95, 0x22, 0xb4, 0x5d, 0x0a, 0xa1, 0xd1, 0xcf, 0x5e,
	0xd9, 0x34, 0xb1, 0xd2, 0x0d, 0xb1, 0x8b, 0xf3, 0xaa, 0xbf, 0x0e, 0xa5, 0x47, 0xb6, 0x75, 0x2a,
	0xed, 0xdf, 0x33, 0xdb, 0x3a, 0x8d, 0xec, 0x1f, 0x7e, 0xeb, 0xff, 0xa5, 0x04, 0x65, 0x22, 0xee,
	0x3c, 0x7f, 0xbb, 0xe7, 0xc7, 0x04, 0xc1, 0x3b, 0xd2, 0x2b, 0xe5, 0x37, 0x84, 0xde, 0xc2, 0x47,
	0xbd, 0x0e, 0xc2, 0x95, 0x4e, 0xc8, 0xa0, 0x08, 0x0f, 0x5c, 0x21, 0x88, 0xdc, 0x92, 0xa9, 0x88,
	0x40, 0x28, 0xf8, 0xde, 0x91, 0xf9, 0x7f, 0x02, 0x60, 0xf7, 0xa1, 0x8c, 0x12, 0x52, 0x2e, 0x5b,
	0x52, 0x0d, 0x0b, 0xf5, 0x21, 0xca, 0x91, 0x78, 0x29, 0x9c, 0x3a, 0x58, 0x20, 0x7f, 0x6c, 0xf9,
	0x41, 0xb4, 0x9c, 0xea, 0x3c, 0x2a, 0xa2, 0x45, 0xc3, 0x60, 0x45, 0x26, 0x34, 0xd1, 0xf2, 0x55,
	0xa3, 0x2d, 0x4e, 0x04, 0xec, 0x2e, 0x94, 0x28, 0x3e, 0xb0, 0x82, 0x66, 0x4d, 0x35, 0x9d, 0x51,
	0xf0, 0xc2, 0x23, 0x34, 0x7b, 0x17, 0x0a, 0xf3, 0x13, 0xeb, 0x3c, 0x68, 0xd6, 0x55, 0x93, 0x90,
	0xf2, 0x7c, 0x5c, 0x50, 0xb0, 0x3b, 0xd0, 0xf0, 0xad, 0xf9, 0x84, 0xb6, 0x78, 0xd0, 0x55, 0x07,
	0xcd, 0x06, 0x79, 0xe2, 0x9a, 0x6f, 0xcd, 0xdb, 0x08, 0x1c, 0x4f, 0x9d, 0x80, 0xbd, 0x0d, 0x45,
	0xf2, 0x41, 0x41, 0x73, 0x5b, 0x6d, 0x39, 0x72, 0x68, 0x5c, 0x62, 0xd9, 0x2e, 0x54, 0x12, 0xb3,
	0x71, 0x95, 0x3a, 0x74, 0x65, 0xcd, 0x1e, 0x91, 0x19, 0xe7, 0x09, 0x19, 0xfb, 0x08, 0x40, 0x86,
	0xe6, 0x93, 0xe9, 0x39, 0xed, 0x80, 0x56, 0xe3, 0xa4, 0x45, 0x71, 0x77, 0x6a, 0x00, 0xff, 0x0e,
	0x14, 0xd0, 0x4b, 0x04, 0xcd, 0xeb, 0x24, 0xcd, 0xa5, 0xb4, 0x0b, 0xa1, 0xde, 0x11, 0x9e, 0xdd,
	0x85, 0x32, 0x2a, 0xd7, 0x04, 0xa7, 0xb0, 0xa9, 0xe6, 0x2a, 0x52, 0x13, 0x31, 0x2a, 0xb2, 0x4e,
	0x47, 0xdf, 0x3b, 0xec, 0x1e, 0xe4, 0x4d, 0x6b, 0x1e, 0x34, 0x6f, 0x50, 0x8d, 0xd7, 0x94, 0xb9,
	0xc4, 0x30, 0xa1, 0x63, 0xcd, 0x85, 0x6b, 0x41, 0x1a, 0x76, 0x00, 0x0d, 0x54, 0xbd, 0x5d, 0x0a,
	0x74, 0x71, 0xc8, 0x9b, 0x37, 0x89, 0xeb, 0xcd, 0x35, 0xae, 0x81, 0x24, 0xa2, 0x09, 0xea, 0xba,
	0xa1, 0x7f, 0xce, 0xeb, 0xae, 0x0a, 0x63, 0x37, 0xa1, 0x6c, 0x07, 0x7d, 0x6f, 0x76, 0x62, 0x99,
	0xcd, 0xd7, 0xc4, 0x89, 0x46, 0x54, 0x66, 0x5f, 0x42, 0x9d, 0x94, 0x11, 0x8b, 0xd8, 0x78, 0xf3,
	0x96, 0xea, 0xf2, 0xc6, 0x2a, 0x8a, 0xa7, 0x29, 0x6f, 0xee, 0x53, 0xc2, 0x42, 0x5a, 0xfc, 0xe9,
	0x9a, 0xcb, 0x4d, 0xe9, 0x98, 0xe2, 0x9b, 0x0f, 0xb6, 0x54, 0xcf, 0xbb, 0x57, 0x80, 0x9c, 0x69,
	0xcd, 0x6f, 0xfe, 0x0a, 0xd8, 0xc5, 0x4e, 0xbc, 0xc8, 0xff, 0x17, 0xa4, 0xff, 0xff, 0x2a, 0xfb,
	0x45, 0x46, 0xff, 0x12, 0xea, 0xa9, 0x15, 0xb1, 0x31, 0xf6, 0x11, 0xf1, 0xb3, 0x21, 0x76, 0x9a,
	0x6b, 0x5c, 0x14, 0xf4, 0xff, 0x98, 0x81, 0xc2, 0x28, 0x34, 0xc2, 0x80, 0xbd, 0x06, 0x95, 0xa9,
	0xe3, 0xcd, 0x4e, 0x26, 0x98, 0xe9, 0x89, 0x3d, 0xdc, 0x32, 0x01, 0xd0, 0x09, 0x52, 0xf8, 0x19,
	0x84, 0xc4, 0x9b, 0xe1, 0xf4, 0x8d, 0x46, 0xc1, 0x5b, 0x85, 0x33, 0x37, 0x24, 0xa3, 0x90, 0xe1,
	0xb2, 0x84, 0xab, 0xd0, 0xf7, 0x4e, 0x69, 0x0b, 0x33, 0x4f, 0x88, 0xa8, 0x88, 0xf1, 0xe8, 0x13,
	0x23, 0x78, 0xb2, 0x30, 0x96, 0xc9, 0x0e, 0x67, 0x86, 0x57, 0x25, 0x6c, 0x84, 0x24, 0xaf, 0x81,
	0xb0, 0x0e, 0x13, 0xac, 0xb7, 0x48, 0xf8, 0x32, 0x01, 0xda, 0x6e, 0x88, 0xd6, 0x39, 0xb0, 0x1c,
	0x6b, 0x16, 0xda, 0xcf, 0x30, 0xa5, 0x2b, 0x09, 0x76, 0x05, 0xa4, 0xbf, 0x0b, 0x25, 0x34, 0x3f,
	0x46, 0x68, 0xa0, 0x43, 0x33, 0x8d, 0xd0, 0xd8, 0xb4, 0x7b, 0x8c, 0x70, 0xfd, 0x03, 0x00, 0xee,
	0x9d, 0x06, 0x56, 0x48, 0xd4, 0x6f, 0x2a, 0xb9, 0x56, 0xac, 0xc0, 0xb2, 0x2a, 0x61, 0xca, 0xf4,
	0xff, 0x9e, 0x81, 0xea, 0xd0, 0x37, 0x71, 0x71, 0x8c, 0x96, 0xd6, 0xec, 0x85, 0x1e, 0x13, 0x6d,
	0x9b, 0xe7, 0x38, 0x46, 0xec, 0x6f, 0xd0, 0xb6, 0x45, 0x00, 0xf6, 0x11, 0xe4, 0xe7, 0x8e, 0x71,
	0x4c, 0x63, 0x17, 0xc7, 0xcd, 0x4a, 0xf5, 0xd1, 0xf7, 0x03, 0xc7, 0x38, 0xe6, 0x44, 0xaa, 0xff,
	0x59, 0xdc, 0x3e, 0xed, 0xc9, 0xa9, 0x3b, 0x71, 0x5b, 0xb4, 0xa3, 0x3b, 0x6a, 0x6b, 0x19, 0x56,
	0x86, 0x7c, 0xa7, 0x3b, 0x6a, 0x8b, 0x68, 0x19, 0xe3, 0xe6, 0xd1, 0xe4, 0x41, 0x8f, 0x8f, 0xc6,
	0x5a, 0x9e, 0xb6, 0x88, 0x09, 0xd0, 0x6f, 0x8d, 0xc6, 0x5a, 0x99, 0x01, 0x14, 0x8f, 0x06, 0xbd,
	0x5f, 0x1f, 0x75, 0x35, 0x4d, 0xff, 0x7b, 0x19, 0x80, 0xc7, 0xb6, 0x6b, 0x7a, 0xa7, 0xd4, 0xb9,
	0x9f, 0x2b, 0x91, 0x11, 0x9a, 0x8c, 0x8b, 0xa3, 0x58, 0x5d, 0x26, 0xd6, 0x86, 0xbd, 0x0f, 0x65,
	0x0f, 0x45, 0x43, 0xd2, 0xac, 0x6a, 0x2f, 0x94, 0x1e, 0xf1, 0x92, 0x27, 0x0a, 0xa8, 0x4d, 0x8e,
	0x65, 0x98, 0x72, 0xe7, 0x9f, 0xbe, 0x51, 0xdf, 0x71, 0x38, 0xc4, 0xc9, 0x22, 0x7e, 0xea, 0x7f,
	0xc8, 0x43, 0xa5, 0xe7, 0x06, 0x96, 0x1f, 0xb6, 0xc3, 0x33, 0xf6, 0x26, 0xe4, 0x7c, 0x6b, 0xfe,
	0xbc, 0x2d, 0x4d, 0xc4, 0xb1, 0xf7, 0x22, 0xdd, 0x31, 0xad, 0xb9, 0x0c, 0x44, 0x1b, 0x69, 0x6b,
	0x21, 0x75, 0xa9, 0x43, 0xdb, 0xfb, 0x1a, 0x26, 0x3e, 0xab, 0xa5, 0x63, 0xcf, 0x30, 0x45, 0xb7,
	0xcd, 0x33, 0xca, 0x2c, 0x0b, 0xbc, 0xe1, 0xb9, 0x9d, 0x08, 0xdc, 0x33, 0xcf, 0xd8, 0x21, 0x5c,
	0x4a, 0x51, 0xd2, 0xa4, 0x0b, 0x8f, 0x77, 0x27, 0x72, 0x0e, 0x52, 0xca, 0xfb, 0xc3, 0x84, 0x15,
	0x07, 0x49, 0xd8, 0xa3, 0x6d, 0x2f, 0x0d, 0x25, 0x27, 0x63, 0x9e, 0x4d, 0xb0, 0x3f, 0x22, 0x4e,
	0xb8, 0xd0, 0x1f, 0x4c, 0x90, 0xe5, 0xb1, 0x8a, 0x48, 0x95, 0xcf, 0x28, 0x50, 0x28, 0x10, 0x02,
	0x85, 0xfa, 0x05, 0x45, 0xa5, 0x16, 0x6d, 0x32, 0x9f, 0x35, 0x4b, 0x54, 0xcb, 0xed, 0x75, 0x69,
	0x0e, 0x89, 0xa2, 0x67, 0x4a, 0xbb, 0x58, 0x59, 0x46, 0x65, 0xf6, 0x39, 0xd4, 0x23, 0x7f, 0x20,
	0x76, 0x25, 0xca, 0x1b, 0x5c, 0x02, 0x8d, 0x1a, 0xaf, 0xcd, 0x94, 0xd2, 0xcd, 0x01, 0x5c, 0xd9,
	0xd4, 0xc7, 0x0d, 0xe6, 0x6a, 0x47, 0x35, 0x57, 0x6b, 0x99, 0x53, 0x6c, 0xba, 0x6e, 0x7e, 0x4d,
	0xc9, 0x87, 0x22, 0xe5, 0x8f, 0x32, 0x7c, 0x7f, 0x51, 0x84, 0x8a, 0x48, 0x28, 0x53, 0x2a, 0x92,
	0x7b, 0xae, 0x8a, 0xdc, 0x86, 0x1c, 0x8e, 0x57, 0x56, 0x8d, 0x57, 0x7a, 0x66, 0xdf, 0x0e, 0x42,
	0x8e, 0x08, 0xf6, 0xbe, 0x54, 0xa1, 0x0e, 0xba, 0xa9, 0x9c, 0xea, 0x86, 0x63, 0x15, 0x4a, 0x08,
	0x30, 0xd5, 0x12, 0xd9, 0x2f, 0x6d, 0x82, 0xe4, 0xd5, 0x76, 0xdb, 0x74, 0xc8, 0xf5, 0xd0, 0x58,
	0x46, 0xc7, 0x8c, 0x6d, 0xcf, 0xf9, 0x29, 0xe6, 0xfd, 0x73, 0xd8, 0xf6, 0xdc, 0x89, 0x6f, 0x05,
	0xa1, 0x6f, 0xcf, 0x42, 0xaa, 0xaa, 0xb4, 0xb9, 0xaa, 0xba, 0xe7, 0x72, 0x49, 0x86, 0x35, 0xbe,
	0x9d, 0x66, 0xc4, 0x9a, 0xcb, 0x54, 0xb3, 0x42, 0x87, 0x0d, 0x7c, 0x0a, 0x0d, 0x8c, 0xc5, 0x8d,
	0x60, 0x66, 0x98, 0x16, 0xd5, 0x5f, 0xd9, 0x5c, 0x7f, 0xcd, 0x73, 0xdb, 0x82, 0x0a, 0xab, 0xdf,
	0x4d, 0xb1, 0x61, 0xed, 0xb0, 0x61, 0x8c, 0x13, 0x1e, 0x6c, 0xea, 0x93, 0x14, 0x0f, 0x2e, 0xda,
	0xea, 0xc6, 0x11, 0x4f, 0xb8, 0x70, 0xe1, 0xee, 0xc1, 0x55, 0x85, 0x4b, 0x19, 0xff, 0xda, 0xe6,
	0xf1, 0x67, 0x31, 0xf7, 0x51, 0x3c, 0x11, 0x3f, 0x07, 0xf0, 0xdc, 0x49, 0x60, 0x89, 0x01, 0xac,
	0x6f, 0xee, 0x60, 0xd9, 0x73, 0x47, 0x16, 0x8d, 0xdd, 0xbd, 0x98, 0x1c, 0x3b, 0xd6, 0xd8, 0xd0,
	0x31, 0x41, 0xdb, 0x23, 0x0d, 0x8a, 0x68, 0xb1, 0x43, 0xdb, 0x1b, 0x3b, 0x24, 0xa8, 0xb1, 0x33,
	0x5f, 0x91, 0x6d, 0x41, 0x6a, 0xa5, 0x23, 0xda, 0xe6, 0x8e, 0x34, 0x88, 0x2b, 0xe9, 0xc4, 0xfd,
	0x94, 0x09, 0xb8, 0xf4, 0x1c, 0xed, 0x8b, 0xd7, 0xbc, 0xfe, 0x97, 0x39, 0xa8, 0xb6, 0x5c, 0xc3,
	0x39, 0xff, 0xad, 0xd5, 0x73, 0xe7, 0x9e, 0xd8, 0x6f, 0x5b, 0xae, 0xc2, 0x09, 0xba, 0x67, 0xb9,
	0xe5, 0x5e, 0x21, 0x08, 0xfa, 0x45, 0xf6, 0x06, 0x54, 0xbd, 0x55, 0x18, 0xe3, 0xc5, 0x26, 0x3c,
	0x08, 0x10, 0x11, 0xc4, 0xfc, 0xe4, 0xcb, 0x73, 0x0a, 0x3f, 0x79, 0xf2, 0x84, 0x3f, 0x0e, 0x05,
	0x62, 0x7e, 0x22, 0x78, 0x0b, 0xea, 0xa1, 0xbd, 0xc0, 0x2e, 0xbb, 0xc1, 0x6a, 0x61, 0x99, 0xe2,
	0x92, 0x86, 0x38, 0xf7, 0x6f, 0x4b, 0x18, 0xd6, 0xb2, 0xb0, 0x16, 0x9e, 0x7f, 0x2e, 0x6a, 0x29,
	0x8a, 0x5a, 0x04, 0x88, 0x6a, 0x79, 0x1f, 0xd8, 0xa9, 0x61, 0x87, 0x93, 0x74, 0x55, 0x22, 0xe5,
	0xd6, 0x10, 0x33, 0x56, 0xab, 0xbb, 0x06, 0x45, 0xd3, 0x0e, 0x4e, 0x7a, 0x43, 0x32, 0x78, 0x39,
	0x2e, 0x4b, 0x18, 0x76, 0x04, 0x1f, 0xf7, 0x86, 0x93, 0xe9, 0xb9, 0xdc, 0x2b, 0xcf, 0xf1, 0x32,
	0x02, 0xf6, 0xce, 0x43, 0xda, 0x4b, 0x24, 0xa4, 0xe8, 0x2d, 0x1d, 0xc7, 0xd1, 0x1e, 0x79, 0x8e,
	0x37, 0x10, 0xde, 0x43, 0x70, 0x1b, 0xa1, 0xec, 0x1e, 0x5c, 0x22, 0x4a, 0xd9, 0x71, 0x41, 0x5a,
	0x25, 0xd2, 0x6d, 0x44, 0x0c, 0x09, 0x2e, 0x68, 0x6f, 0x41, 0xc5, 0xb5, 0xc2, 0x53, 0xcf, 0x47,
	0x69, 0x6a, 0x62, 0xf4, 0x62, 0x00, 0x06, 0xad, 0xc1, 0xcc, 0x70, 0x51, 0x78, 0xda, 0x27, 0x47,
	0x79, 0x64, 0x99, 0xdd, 0xc6, 0x81, 0x47, 0x1b, 0x4f, 0xd8, 0x86, 0x18, 0x92, 0x04, 0xa2, 0xff,
	0xeb, 0x6d, 0xc8, 0x0f, 0x3c, 0xd3, 0x62, 0x1f, 0x42, 0x85, 0x0e, 0xa6, 0x2f, 0x6e, 0xe6, 0x20,
	0x9a, 0xfe, 0x50, 0x64, 0x5b, 0x76, 0xe5, 0xd7, 0xf3, 0x8f, 0xb2, 0xdf, 0x84, 0x42, 0x80, 0x61,
	0xa2, 0xdc, 0x9e, 0x91, 0x07, 0x69, 0x14, 0x39, 0x72, 0x81, 0x41, 0x91, 0x29, 0xc3, 0xf1, 0x2d,
	0x97, 0x6c, 0x61, 0x81, 0xc7, 0x65, 0x0a, 0x27, 0x7c, 0x0f, 0x57, 0xd6, 0x84, 0x0e, 0x96, 0x0a,
	0x1b, 0xc2, 0x09, 0x81, 0xa7, 0x93, 0xff, 0x0f, 0xa1, 0xf2, 0xd4, 0xb3, 0x5d, 0x21, 0x78, 0xf1,
	0x82, 0xe0, 0xdf, 0x78, 0xb6, 0xd8, 0x85, 0x2a, 0x3f, 0x95, 0x5f, 0xec, 0x2d, 0x28, 0x79, 0xae,
	0xa8, 0xbb, 0x74, 0xa1, 0xee, 0xa2, 0xe7, 0xf6, 0xc5, 0x81, 0x55, 0x7d, 0xba, 0xc2, 0x1c, 0x0c,
	0x49, 0xad, 0x79, 0x28, 0x37, 0x5d, 0xaa, 0x04, 0x1c, 0xba, 0x7d, 0x6b, 0x1e, 0xb2, 0xf7, 0xa0,
	0x3a, 0xb7, 0x1d, 0x74, 0x8c, 0x54, 0x59, 0xe5, 0x42, 0x65, 0x20, 0xd0, 0x54, 0xe1, 0xcf, 0xa0,
	0x7c, 0xec, 0x7b, 0xab, 0x25, 0x86, 0x3d, 0x70, 0x71, 0x9b, 0x83, 0x70, 0x7b, 0xe7, 0xd8, 0x7b,
	0xfa, 0xb4, 0xdd, 0x63, 0x5c, 0xeb, 0xd2, 0xcc, 0xa5, 0x7a, 0x1f, 0xe1, 0x47, 0x16, 0xd5, 0x6a,
	0x1c, 0x1f, 0x8b, 0xf6, 0x6b, 0x17, 0x6b, 0x35, 0x8e, 0x8f, 0xa9, 0xf1, 0xf7, 0xa0, 0x7c, 0x6a,
	0xbb, 0x93, 0x60, 0x69, 0xcd, 0x48, 0x45, 0xe2, 0xd3, 0xbc, 0x24, 0x8c, 0xe3, 0xa5, 0x53, 0xdb,
	0xa5, 0x78, 0x4e, 0x0d, 0xd0, 0x1a, 0x2f, 0x0c, 0xd0, 0x76, 0xa0, 0xe0, 0xd8, 0x0b, 0x3b, 0xa4,
	0x2b, 0x44, 0x6b, 0xbe, 0x9b, 0x10, 0x4c, 0x87, 0xa2, 0x37, 0x9f, 0x63, 0x67, 0xb4, 0x0b, 0x24,
	0x12, 0xa3, 0xba, 0xc7, 0xf0, 0x2c, 0x7d, 0x91, 0x28, 0x76, 0xda, 0xb1, 0x7b, 0x0c, 0xcf, 0xd2,
	0xf1, 0x1b, 0x7b, 0x41, 0xfc, 0xb6, 0x2b, 0x33, 0x37, 0x24, 0x9e, 0x3c, 0xb3, 0x66, 0xcd, 0xcb,
	0x1b, 0x4d, 0x6d, 0x35, 0x62, 0x78, 0x64, 0xcd, 0xd0, 0xff, 0x7a, 0xd3, 0xa7, 0x64, 0xf3, 0xaf,
	0x6c, 0x8e, 0x23, 0x8b, 0xde, 0xf4, 0x29, 0x5a, 0xfc, 0x8f, 0xa0, 0xea, 0x53, 0x72, 0x30, 0xa1,
	0x1c, 0xe2, 0xaa, 0x3a, 0xbc, 0x49, 0xd6, 0xc0, 0xc1, 0x4f, 0x32, 0x88, 0xb7, 0xa0, 0x2e, 0x8e,
	0x79, 0xc4, 0xbe, 0x7e, 0x40, 0x59, 0x76, 0x85, 0xd7, 0x08, 0x28, 0xf6, 0xfc, 0x29, 0x62, 0x10,
	0x7b, 0xed, 0x34, 0x24, 0xd7, 0x55, 0x21, 0xc4, 0xa6, 0x3a, 0x0d, 0x89, 0x19, 0x7d, 0x62, 0xc6,
	0x34, 0xb5, 0x5d, 0x13, 0x15, 0x27, 0x34, 0x8e, 0x83, 0x66, 0x93, 0xd6, 0x55, 0x55, 0xc2, 0xc6,
	0xc6, 0x71, 0xc0, 0x3e, 0x81, 0x9a, 0x21, 0xac, 0xfa, 0xc4, 0x76, 0xe7, 0x5e, 0xf3, 0x86, 0x7a,
	0xe0, 0xa0, 0xd8, 0x7b, 0x5e, 0x35, 0x14, 0xe3, 0xff, 0x39, 0xb0, 0x68, 0x6b, 0x85, 0x02, 0x5a,
	0xa1, 0x6d, 0x37, 0x2f, 0x68, 0xdb, 0xb6, 0xdc, 0x5b, 0x89, 0x2f, 0xe5, 0xec, 0x00, 0x06, 0xfe,
	0x86, 0xe3, 0x58, 0x8e, 0x1d, 0x2c, 0x28, 0xa1, 0x2e, 0x70, 0x15, 0x74, 0x31, 0xb6, 0xbc, 0xf5,
	0x72, 0xb1, 0x25, 0x8e, 0xa0, 0xeb, 0x85, 0x93, 0x99, 0x31, 0x7b, 0x62, 0x11, 0xe3, 0xeb, 0xb4,
	0x3c, 0x6b, 0xae, 0x17, 0xb6, 0x23, 0x18, 0x8e, 0xa0, 0x30, 0x75, 0x34, 0x82, 0xb7, 0xd5, 0x11,
	0x8c, 0x03, 0x5f, 0x74, 0x43, 0x49, 0xde, 0x50, 0x9b, 0xad, 0x7c, 0x72, 0x93, 0x41, 0x68, 0x2d,
	0x9b, 0x6f, 0x08, 0x81, 0x25, 0x6c, 0x14, 0x5a, 0x4b, 0xba, 0x69, 0xe2, 0xad, 0xfc, 0x99, 0x25,
	0x28, 0x76, 0x88, 0x02, 0x04, 0x08, 0x09, 0xf4, 0xff, 0x9a, 0x83, 0x72, 0x64, 0x2c, 0x59, 0x15,
	0x4a, 0x47, 0x83, 0x6f, 0x07, 0xc3, 0xc7, 0x03, 0x6d, 0x0b, 0x33, 0xaa, 0x47, 0xad, 0xfe, 0x51,
	0x77, 0x32, 0x6a, 0xb7, 0x06, 0xe2, 0x12, 0x0e, 0x5d, 0x87, 0x10, 0xe5, 0x2c, 0xbb, 0x04, 0xf5,
	0x07, 0x47, 0x03, 0x3a, 0x9e, 0x10, 0xa0, 0x1c, 0x82, 0xba, 0xbf, 0x11, 0x69, 0x9b, 0x00, 0xe5,
	0x11, 0xf4, 0xb0, 0x35, 0xee, 0xf2, 0x5e, 0x04, 0x2a, 0x60, 0x2b, 0x87, 0x7c, 0xf8, 0x4d, 0xb7,
	0x3d, 0xd6, 0x80, 0x5d, 0x85, 0x4b, 0x31, 0x4b, 0x54, 0x9d, 0x56, 0xc5, 0x04, 0x30, 0x62, 0xd3,
	0xae, 0x60, 0x25, 0xbc, 0xdb, 0x3e, 0xe2, 0xa3, 0xde, 0xa3, 0xee, 0xa4, 0x3d, 0xee, 0x6a, 0x57,
	0x31, 0x15, 0x1c, 0xf5, 0x06, 0xdf, 0x6a, 0xd7, 0x58, 0x1d, 0x2a, 0xf8, 0x25, 0x6a, 0xbf, 0x4e,
	0xc9, 0xe2, 0xfe, 0xbe, 0x76, 0x1b, 0xab, 0xe8, 0xf4, 0x46, 0xe3, 0xde, 0xa0, 0x3d, 0xd6, 0xde,
	0xc0, 0x7c, 0xf0, 0x41, 0xaf, 0x3f, 0xee, 0x72, 0x6d, 0x07, 0x79, 0xbf, 0x19, 0xf6, 0x06, 0xda,
	0x9b, 0x74, 0x93, 0xa3, 0xf5, 0xf0, 0xb0, 0xdf, 0xd5, 0x74, 0xaa, 0x71, 0xc8, 0xc7, 0xda, 0x5b,
	0xac, 0x02, 0x85, 0xa3, 0x01, 0xca, 0x71, 0x07, 0x2b, 0xa7, 0xcf, 0x49, 0xab, 0xdf, 0xd7, 0x7e,
	0xa6, 0x64, 0x95, 0x6f, 0xe3, 0xf7, 0xe3, 0xde, 0xa0, 0x33, 0x7c, 0xac, 0xbd, 0x83, 0x64, 0x7b,
	0x7c, 0xd8, 0xea, 0xb4, 0x31, 0xf9, 0xbc, 0x8b, 0x15, 0x8c, 0x0e, 0xfb, 0xbd, 0xb1, 0xf6, 0x2e,
	0x52, 0xed, 0xb7, 0xc6, 0x07, 0x5d, 0xae, 0xdd, 0xc3, 0xef, 0xd6, 0x68, 0xd4, 0xe5, 0x63, 0x6d,
	0x17, 0xbf, 0x7b, 0x03, 0xfa, 0xfe, 0x98, 0x6a, 0x3d, 0xec, 0xb4, 0xc6, 0x5d, 0xed, 0x13, 0xfc,
	0xee, 0x74, 0xfb, 0xdd, 0x71, 0x57, 0xfb, 0x14, 0x6b, 0xa5, 0x2c, 0x78, 0x84, 0x43, 0xf5, 0x19,
	0x8e, 0x42, 0x5c, 0x24, 0x79, 0x3e, 0xc7, 0x86, 0x1e, 0xf6, 0x06, 0x47, 0x23, 0xed, 0x0b, 0x24,
	0xa6, 0x4f, 0xc2, 0x7c, 0xa9, 0x3f, 0x85, 0x72, 0xe4, 0x4a, 0x90, 0xaa, 0x37, 0x18, 0x74, 0xb9,
	0xb6, 0x85, 0x9d, 0xec, 0x77, 0x1f, 0x8c, 0xb5, 0x0c, 0x02, 0x79, 0x6f, 0xff, 0x60, 0xac, 0x65,
	0xf1, 0x73, 0x78, 0x84, 0x43, 0x93, 0xa3, 0x41, 0xe8, 0x3e, 0xec, 0x69, 0x79, 0xfc, 0x6a, 0x0d,
	0xc6, 0x3d, 0xad, 0x40, 0x83, 0xd4, 0x1b, 0xec, 0xf7, 0xbb, 0x5a, 0x11, 0xa1, 0x0f, 0x5b, 0xfc,
	0x5b, 0xad, 0x84, 0x4c, 0xad, 0xc3, 0xc3, 0xfe, 0x77, 0x5a, 0x59, 0xbf, 0x0b, 0xa5, 0xd6, 0xf1,
	0xf1, 0x43, 0x74, 0xcb, 0x65, 0xc8, 0x3f, 0x38, 0xea, 0xf7, 0xc5, 0xfd, 0xad, 0xbd, 0xe1, 0x78,
	0x3c, 0x7c, 0xa8, 0x65, 0x70, 0x4e, 0xc6, 0xc3, 0x43, 0x2d, 0xab, 0xdf, 0x82, 0xa2, 0x88, 0x2a,
	0x29, 0x4f, 0x8e, 0x2e, 0xc0, 0xe5, 0xe4, 0xa5, 0x37, 0x0f, 0x2a, 0x71, 0x74, 0xc7, 0xee, 0x41,
	0x6e, 0x61, 0x2c, 0x65, 0xc6, 0xd3, 0x5c, 0x8b, 0xfd, 0xee, 0x3f, 0x34, 0x96, 0x22, 0xf1, 0x43,
	0xa2, 0x9b, 0x9f, 0x41, 0x39, 0x02, 0xfc, 0xa8, 0x1c, 0xeb, 0x5f, 0xe5, 0xa1, 0xd2, 0x51, 0x0c,
	0xd2, 0x9f, 0x9c, 0x63, 0x29, 0x59, 0x50, 0xee, 0xa5, 0xb3, 0xa0, 0xfc, 0x8b, 0xb2, 0xa0, 0xc2,
	0xab, 0x66, 0x41, 0xc5, 0x97, 0xcb, 0x82, 0x4a, 0x2f, 0x93, 0x05, 0xdd, 0xb9, 0x90, 0x05, 0x89,
	0x1c, 0x2b, 0x9d, 0xf7, 0xa4, 0xb3, 0x8f, 0xca, 0x8b, 0xb2, 0x8f, 0x74, 0x46, 0x01, 0x2f, 0xc8,
	0x28, 0xd2, 0xb9, 0x4a, 0xf5, 0x8f, 0xe6, 0x2a, 0x1b, 0xb3, 0x8f, 0xda, 0xcb, 0x65, 0x1f, 0x68,
	0x57, 0x0d, 0x77, 0x12, 0xfa, 0x2b, 0x77, 0x66, 0x84, 0x22, 0x48, 0x2d, 0xf3, 0x2a, 0xc6, 0xa8,
	0x12, 0xa4, 0xff, 0x45, 0x16, 0x0a, 0xbf, 0x5e, 0x59, 0xfe, 0x39, 0xfb, 0x0c, 0x2a, 0x41, 0xb8,
	0x08, 0xd5, 0x40, 0xf4, 0x86, 0x68, 0x80, 0xf0, 0x14, 0x47, 0x5a, 0x0b, 0xcb, 0x0d, 0x45, 0x54,
	0x87, 0xb4, 0xb4, 0x28, 0xaf, 0x60, 0xd4, 0x69, 0x2d, 0xc5, 0x99, 0x50, 0x81, 0x8b, 0x02, 0x46,
	0x27, 0x18, 0x95, 0x46, 0x09, 0x3a, 0x24, 0x91, 0x21, 0x17, 0x08, 0x8c, 0x4e, 0x68, 0x7b, 0x33,
	0x3a, 0x99, 0x48, 0x45, 0x27, 0x02, 0x83, 0xe1, 0xea, 0x13, 0xcb, 0x40, 0x37, 0x1a, 0xdd, 0x6e,
	0x88, 0xcb, 0xac, 0x09, 0x25, 0xc7, 0x33, 0xcc, 0xb1, 0x71, 0x1c, 0xdd, 0xcb, 0x91, 0x45, 0xfd,
	0x31, 0xd4, 0x53, 0xc2, 0xa6, 0xdd, 0x01, 0x5a, 0x81, 0x6e, 0x1f, 0x2d, 0x51, 0x46, 0x31, 0x5e,
	0x59, 0xc5, 0x60, 0xe5, 0x14, 0x43, 0x96, 0x27, 0xd3, 0xd4, 0xe5, 0xfb, 0x5d, 0xad, 0xa0, 0xff,
	0xb3, 0x2c, 0x5c, 0x1a, 0xfb, 0x86, 0x1b, 0x18, 0xe2, 0xcc, 0xcb, 0x0d, 0x7d, 0xcf, 0x61, 0x5f,
	0x41, 0x39, 0x9c, 0x39, 0xea, 0xb8, 0xbd, 0x21, 0x67, 0x7e, 0x9d, 0xf4, 0xfe, 0x78, 0xe6, 0xd0,
	0xe8, 0x95, 0x42, 0xf1, 0xc1, 0x7e, 0x0e, 0x85, 0xa9, 0x75, 0x6c, 0xbb, 0x72, 0x03, 0xe6, 0xea,
	0x3a, 0xe3, 0x1e, 0x22, 0x0f, 0xb6, 0xb8, 0xa0, 0x62, 0x1f, 0x42, 0x71, 0xe6, 0x2d, 0x30, 0xe8,
	0xcb, 0xa9, 0xa7, 0xa8, 0x6a, 0x43, 0x88, 0x3d, 0xd8, 0xe2, 0x92, 0x8e, 0x7d, 0x06, 0x65, 0xdf,
	0x73, 0x9c, 0xa9, 0x31, 0x3b, 0x91, 0x27, 0xaf, 0xcd, 0x75, 0x1e, 0x2e, 0xf1, 0x07, 0x5b, 0x3c,
	0xa6, 0xd5, 0xef, 0x43, 0x49, 0x0a, 0x8b, 0x03, 0xb0, 0xd7, 0xdd, 0xef, 0xc9, 0xb1, 0x6b, 0x0f,
	0x1f, 0x3e, 0xec, 0x8d, 0xc5, 0xa9, 0x3f, 0x1f, 0xf6, 0xfb, 0x7b, 0xad, 0xf6, 0xb7, 0x5a, 0x76,
	0xaf, 0x0c, 0x45, 0x83, 0xf6, 0xb5, 0xf5, 0xbf, 0x9d, 0x81, 0xed, 0xb5, 0x0e, 0xb0, 0x2f, 0x20,
	0xbf, 0xf0, 0xcc, 0x68, 0x78, 0xee, 0x6c, 0xec, 0xa5, 0x52, 0x46, 0x0b, 0xcc, 0x89, 0x43, 0xff,
	0x12, 0x1a, 0x69, 0xb8, 0x72, 0xcd, 0xb1, 0x0e, 0x15, 0xde, 0x6d, 0x75, 0x26, 0xc3, 0x41, 0xff,
	0x3b, 0xe1, 0xd7, 0xa9, 0xf8, 0x98, 0xf7, 0xc6, 0x5d, 0x2d, 0xab, 0xff, 0x19, 0x68, 0xeb, 0x03,
	0xc3, 0xf6, 0x61, 0x7b, 0xe6, 0x2d, 0x96, 0x8e, 0x25, 0x8e, 0xeb, 0x92, 0x29, 0xbb, 0xbd, 0x61,
	0x24, 0x25, 0x19, 0xcd, 0x58, 0x63, 0x96, 0x2a, 0xeb, 0x7f, 0x0b, 0xd8, 0xc5, 0x11, 0xfc, 0xe9,
	0xaa, 0xff, 0x9f, 0x19, 0xc8, 0x1f, 0x3a, 0x86, 0xcb, 0xde, 0x82, 0x02, 0x5d, 0x21, 0x94, 0x9b,
	0xaa, 0x55, 0x65, 0x45, 0xa2, 0x5a, 0x10, 0x8e, 0xbd, 0x07, 0xb9, 0x70, 0xe6, 0x48, 0x1d, 0xba,
	0xfe, 0x1c, 0xe5, 0x3b, 0xd8, 0xe2, 0x48, 0xc5, 0xee, 0x42, 0xce, 0x34, 0x1d, 0xa9, 0x40, 0xf2,
	0x50, 0x0a, 0x83, 0xe3, 0x8e, 0x35, 0xb7, 0x5d, 0x5b, 0x5e, 0x68, 0x44, 0x12, 0xf6, 0x33, 0xc8,
	0x99, 0x33, 0x47, 0xaa, 0xcd, 0xa5, 0x84, 0x52, 0xa9, 0xd0, 0x9c, 0x39, 0xec, 0x3e, 0xd4, 0x5a,
	0x61, 0x88, 0xc1, 0x9f, 0x89, 0x22, 0xa7, 0x2f, 0xd2, 0x21, 0x84, 0xa7, 0xf0, 0x7b, 0x45, 0xa0,
	0x07, 0x33, 0xfa, 0xfb, 0x74, 0xc1, 0x6f, 0xb5, 0x70, 0xd1, 0x14, 0x88, 0xaf, 0x0d, 0x5b, 0xd8,
	0x12, 0xa3, 0xff, 0xbf, 0x2c, 0x54, 0x95, 0xc6, 0xd9, 0x27, 0x50, 0x36, 0xd3, 0xab, 0xee, 0xc6,
	0x05, 0x09, 0xef, 0x77, 0xa2, 0xf5, 0x66, 0x4a, 0x5d, 0xfe, 0x12, 0xea, 0x68, 0x4a, 0x9f, 0x19,
	0xbe, 0x8d, 0x66, 0x39, 0x90, 0x63, 0x26, 0xe3, 0xde, 0x91, 0x15, 0x3e, 0x8a, 0x30, 0x07, 0x5b,
	0xbc, 0x16, 0x28, 0x65, 0xf6, 0x2e, 0x94, 0x96, 0xbe, 0xb5, 0x34, 0x7c, 0x4b, 0x8e, 0x5d, 0x3d,
	0x3a, 0x3d, 0x22, 0xe0, 0xc1, 0x16, 0x8f, 0xf0, 0x48, 0x6a, 0x9d, 0x59, 0xb3, 0x55, 0x68, 0xc9,
	0xc1, 0xab, 0x47, 0x1d, 0x22, 0x20, 0x92, 0x4a, 0x3c, 0xdb, 0xc5, 0x64, 0xc3, 0x70, 0x1c, 0x8f,
	0x0c, 0x74, 0x41, 0xcd, 0x61, 0x3a, 0x31, 0x5c, 0xbc, 0x94, 0x88, 0x4a, 0xfa, 0x31, 0x94, 0x64,
	0xc7, 0x30, 0x94, 0x1a, 0x75, 0xc7, 0x93, 0x47, 0x2d, 0xde, 0xc3, 0x90, 0x76, 0xa4, 0x6d, 0xe1,
	0x72, 0xdd, 0xe7, 0xad, 0x81, 0x34, 0x6f, 0xbc, 0xfb, 0x68, 0xf8, 0x6d, 0x57, 0xcb, 0x8a, 0x23,
	0x87, 0xc1, 0x77, 0x5a, 0x4e, 0x84, 0xad, 0xdd, 0xc3, 0x16, 0x47, 0xeb, 0x56, 0x85, 0x52, 0xf7,
	0x37, 0xdd, 0xf6, 0xd1, 0xb8, 0xab, 0x15, 0x70, 0x05, 0x75, 0xba, 0xad, 0x7e, 0x7f, 0xd8, 0x46,
	0xd3, 0x57, 0xdc, 0xab, 0x40, 0x69, 0x26, 0x46, 0x52, 0xff, 0x37, 0x75, 0x68, 0xa4, 0xb5, 0x84,
	0x7d, 0x0e, 0x65, 0xd3, 0x4c, 0xcd, 0xc0, 0xad, 0x4d, 0xda, 0x74, 0xbf, 0x63, 0x46, 0x93, 0x20,
	0x3e, 0xd8, 0x9b, 0x91, 0x4e, 0x67, 0x2f, 0xe8, 0x74, 0xa4, 0xd1, 0xbf, 0x84, 0x6d, 0x79, 0x2d,
	0x0f, 0x73, 0xbb, 0xa9, 0x11, 0x58, 0x69, 0x85, 0x6d, 0x13, 0xb2, 0x23, 0x71, 0x07, 0x5b, 0xbc,
	0x31, 0x4b, 0x41, 0xd8, 0xd7, 0xd0, 0x30, 0x68, 0x87, 0x20, 0xe6, 0xcf, 0xab, 0x47, 0x7e, 0x2d,
	0xc4, 0x29, 0xec, 0x75, 0x43, 0x05, 0xa0, 0x9a, 0x98, 0xbe, 0xb7, 0x4c, 0x98, 0x0b, 0xaa, 0x9a,
	0x74, 0x7c, 0x6f, 0xa9, 0xf0, 0xd6, 0x4c, 0xa5, 0xcc, 0x3e, 0x83, 0x9a, 0x94, 0x3c, 0x79, 0x5a,
	0x15, 0xaf, 0x1e, 0x21, 0x36, 0x45, 0x04, 0x07, 0x5b, 0xbc, 0x3a, 0x4b, 0x8a, 0xec, 0x63, 0xa8,
	0x0a, 0x81, 0x05, 0x5b, 0x49, 0xd5, 0x04, 0x92, 0x36, 0xe2, 0x02, 0x23, 0x2e, 0xb1, 0x0f, 0x01,
	0x48, 0x4e, 0xf5, 0x7c, 0x60, 0x3b, 0x11, 0x32, 0x62, 0xa9, 0x98, 0x51, 0x41, 0x11, 0x4f, 0x1c,
	0xd8, 0x56, 0x2e, 0x8a, 0x47, 0x07, 0x9c, 0x89, 0x78, 0xe2, 0x80, 0x36, 0x16, 0x4f, 0xb0, 0xc1,
	0x05, 0xf1, 0x22, 0x2e, 0x21, 0x9e, 0x60, 0x8a, 0xc4, 0x13, 0x3c, 0xd5, 0x75, 0xf1, 0x22, 0x16,
	0x12, 0x4f, 0x70, 0x7c, 0x0d, 0x8d, 0x28, 0x5a, 0x91, 0x9d, 0xaa, 0xa5, 0xee, 0x14, 0x48, 0x5c,
	0xd4, 0xb1, 0x7a, 0xa8, 0x02, 0x90, 0x3b, 0x78, 0xe2, 0x9d, 0x2a, 0xcb, 0xbb, 0xae, 0x72, 0x8f,
	0x9e, 0x78, 0xa7, 0xea, 0xfa, 0xae, 0x07, 0x2a, 0x00, 0xa5, 0x15, 0x5d, 0xa4, 0x2b, 0x19, 0x0d,
	0x55, 0x5a, 0xea, 0xe1, 0x23, 0xdb, 0x3a, 0x45, 0x69, 0x8d, 0xa8, 0x80, 0x83, 0x42, 0xa7, 0xb1,
	0xa1, 0x68, 0x6c, 0x5b, 0x1d, 0x14, 0x3a, 0x83, 0x8e, 0x5a, 0x02, 0x27, 0x2e, 0xa1, 0x6e, 0xad,
	0x5c, 0x95, 0x4d, 0x53, 0x75, 0xeb, 0xc8, 0x4d, 0x31, 0xd6, 0x04, 0xa9, 0x64, 0x4d, 0x56, 0x45,
	0x60, 0x7d, 0xbf, 0xb2, 0xdc, 0x99, 0x25, 0x77, 0x6c, 0x52, 0xab, 0x62, 0x24, 0x71, 0xc9, 0xaa,
	0x88, 0x20, 0xb1, 0x5e, 0xc7, 0xec, 0x6c, 0x5d, 0xaf, 0x15, 0x66, 0xd2, 0xeb, 0x98, 0x35, 0x5e,
	0x50, 0x31, 0xef, 0xe5, 0x0b, 0x0b, 0x4a, 0x61, 0x16, 0x0b, 0x2a, 0x02, 0xe8, 0xff, 0x37, 0x0f,
	0x25, 0x69, 0x07, 0xd8, 0x65, 0xd8, 0x6e, 0xf3, 0x6e, 0x6b, 0xdc, 0x9d, 0x74, 0x5a, 0xe3, 0xd6,
	0x5e, 0x6b, 0x84, 0xbe, 0x9c, 0x41, 0xa3, 0x85, 0x59, 0x6d, 0x02, 0xcb, 0xa0, 0x71, 0xeb, 0xf0,
	0xe1, 0x61, 0x02, 0xca, 0x32, 0x0d, 0x6a, 0x92, 0x57, 0xbc, 0x68, 0xc8, 0xb1, 0x6d, 0xa8, 0x0a,
	0x46, 0x01, 0xa0, 0x03, 0x54, 0xe2, 0x12, 0xe5, 0x82, 0xc2, 0xd2, 0x1b, 0x74, 0xba, 0xbf, 0xd1,
	0x8a, 0x09, 0x8b, 0x00, 0x94, 0x62, 0x16, 0x51, 0x2e, 0xa3, 0x30, 0x63, 0x7e, 0x34, 0x68, 0x27,
	0xed, 0x54, 0x90, 0x49, 0x56, 0xf3, 0xa8, 0xd7, 0x7d, 0xac, 0x01, 0x32, 0x89, 0x5a, 0xa8, 0x5c,
	0xc5, 0x68, 0x84, 0x2a, 0xa1, 0x62, 0x8d, 0x5d, 0x87, 0xcb, 0xa3, 0x83, 0xe1, 0xe3, 0x89, 0x60,
	0x8a, 0xbb, 0x50, 0x67, 0x57, 0x40, 0x53, 0x10, 0xa2, 0xfa, 0x06, 0x36, 0x49, 0xd0, 0x88, 0x70,
	0xa4, 0x6d, 0xd3, 0x4d, 0x4a, 0x84, 0x8d, 0x85, 0x69, 0xd7, 0xb0, 0x2b, 0x82, 0x75, 0xd8, 0x3f,
	0x7a, 0x38, 0x18, 0x69, 0x97, 0x50, 0x08, 0x82, 0x08, 0xc9, 0x59, 0x5c, 0x4d, 0xe2, 0x10, 0x2e,
	0x93, 0x8f, 0x40, 0xd8, 0xe3, 0x16, 0x1f, 0xf4, 0x06, 0xfb, 0x23, 0xed, 0x4a, 0x5c, 0x73, 0x97,
	0xf3, 0x21, 0x1f, 0x69, 0x57, 0x63, 0xc0, 0x68, 0xdc, 0x1a, 0x1f, 0x8d, 0xb4, 0x6b, 0xb1, 0x94,
	0x87, 0x7c, 0xd8, 0xee, 0x8e, 0x46, 0xfd, 0xde, 0x68, 0xac, 0x5d, 0x67, 0x57, 0xe1, 0x52, 0x22,
	0x51, 0x44, 0xdc, 0x54, 0x04, 0xe5, 0xfb, 0xdd, 0xb1, 0x76, 0x23, 0x16, 0xa3, 0x3d, 0xec, 0xf7,
	0x5b, 0xb4, 0x13, 0x72, 0x13, 0x89, 0xfa, 0xc3, 0xf6, 0xb7, 0x51, 0x6f, 0x5e, 0x43, 0xb9, 0x8e,
	0x06, 0x2a, 0xe8, 0x96, 0xa2, 0x1a, 0xa3, 0xee, 0xaf, 0x8f, 0xba, 0x83, 0x76, 0x57, 0x7b, 0x3d,
	0x51, 0x8d, 0x18, 0x76, 0x3b, 0x56, 0x8d, 0x18, 0xf4, 0x46, 0xdc, 0x66, 0x04, 0x1a, 0x69, 0x3b,
	0x7b, 0x35, 0x7a, 0x75, 0x28, 0x1d, 0x91, 0xfe, 0x0d, 0x30, 0xf5, 0x75, 0x90, 0xbc, 0x01, 0xce,
	0x20, 0x3f, 0xf7, 0xbd, 0x45, 0x74, 0x0f, 0x03, 0xbf, 0x69, 0x03, 0x6d, 0x35, 0xa5, 0xf3, 0xd3,
	0xe4, 0x62, 0x80, 0x0a, 0xd2, 0x7f, 0x9f, 0x81, 0x46, 0xda, 0x09, 0x31, 0x1d, 0xea, 0xf6, 0x7c,
	0xe2, 0x7a, 0xa1, 0xb8, 0xa5, 0x1c, 0xc8, 0x5b, 0xe4, 0x55, 0x7b, 0x3e, 0xf0, 0x42, 0xba, 0xa6,
	0x4c, 0x09, 0x4d, 0xec, 0x53, 0x44, 0xad, 0x71, 0x99, 0xf5, 0xe0, 0x72, 0xea, 0x41, 0x54, 0xea,
	0x8e, 0x78, 0x33, 0x7e, 0x51, 0xb2, 0x26, 0x3f, 0x67, 0xc1, 0x05, 0x98, 0x7e, 0x00, 0xf5, 0x94,
	0x87, 0x63, 0xaf, 0x41, 0xc5, 0x9e, 0xa7, 0xe5, 0x2a, 0xdb, 0xf3, 0x17, 0x0b, 0xa5, 0xef, 0x43,
	0x4d, 0x75, 0x77, 0xaf, 0x5e, 0xd1, 0x1b, 0x50, 0x79, 0x70, 0x12, 0x5d, 0x59, 0x57, 0x6f, 0xcd,
	0x57, 0xe4, 0xd5, 0x8d, 0xff, 0x9d, 0x85, 0xaa, 0xe2, 0x1f, 0x5f, 0x6a, 0x38, 0x6f, 0x41, 0x25,
	0xb4, 0x16, 0x4b, 0xcf, 0x37, 0x64, 0x34, 0x51, 0xe6, 0x09, 0x20, 0x25, 0x4e, 0x6e, 0x6d, 0xb0,
	0x53, 0xfb, 0xd8, 0xf9, 0x17, 0xec, 0x63, 0x7f, 0x04, 0x35, 0xe5, 0xa2, 0x7a, 0x20, 0xf7, 0x31,
	0x2e, 0x6c, 0x63, 0x27, 0x97, 0xd6, 0x03, 0x76, 0x15, 0x8a, 0xf3, 0x93, 0x89, 0x39, 0x15, 0x97,
	0x07, 0x2b, 0xbc, 0x30, 0x3f, 0xe9, 0x4c, 0xe9, 0x02, 0xcf, 0x3c, 0x36, 0xfc, 0x25, 0x91, 0xd1,
	0xce, 0x23, 0xf3, 0x7e, 0x17, 0x4a, 0xf3, 0x13, 0x71, 0x0b, 0xbc, 0xac, 0x26, 0xf8, 0xf1, 0xb8,
	0xf1, 0xe2, 0xfc, 0x84, 0x6e, 0x84, 0x7f, 0x09, 0xda, 0xda, 0xa5, 0xc3, 0x40, 0xee, 0x51, 0xac,
	0x0b, 0xb5, 0x9d, 0xbe, 0x80, 0x18, 0xe8, 0xff, 0x2e, 0x03, 0x8d, 0x24, 0x9e, 0xc0, 0xb9, 0x65,
	0xf7, 0xd4, 0x57, 0x94, 0xcd, 0xf5, 0x90, 0x03, 0x49, 0xee, 0x8f, 0xcf, 0x97, 0xe2, 0x39, 0xcc,
	0xa6, 0x9b, 0x87, 0x9b, 0xee, 0xf1, 0xe7, 0x36, 0xdd, 0xe3, 0xd7, 0xf7, 0x21, 0x37, 0x3e, 0x5f,
	0x8a, 0x34, 0x12, 0x4d, 0x98, 0x08, 0x57, 0x85, 0xf1, 0xa2, 0xdd, 0xb5, 0x6f, 0xbb, 0xdf, 0x89,
	0x4b, 0x31, 0x87, 0xbc, 0xf7, 0xb0, 0xc5, 0xbf, 0x9b, 0x20, 0x80, 0x8c, 0xfc, 0x83, 0x21, 0xef,
	0xf6, 0xf6, 0x07, 0x04, 0xc8, 0x53, 0x92, 0x99, 0x88, 0xd8, 0x32, 0xcd, 0x07, 0x27, 0xea, 0xab,
	0xbd, 0x4c, 0xea, 0xd5, 0x5e, 0x7c, 0xbf, 0x51, 0x7d, 0xb4, 0x10, 0xc6, 0x8f, 0x0b, 0x22, 0x65,
	0xcc, 0x25, 0xca, 0xc8, 0xde, 0x81, 0xfc, 0xfc, 0xc4, 0x3a, 0x4f, 0x07, 0x8d, 0xe9, 0x7b, 0x83,
	0x44, 0xa0, 0xff, 0x90, 0x01, 0x96, 0x12, 0x44, 0xc4, 0x31, 0xaf, 0x2a, 0xcb, 0xe7, 0xd0, 0x94,
	0x4f, 0x58, 0x04, 0x95, 0x7c, 0x8f, 0x33, 0x41, 0x59, 0xc4, 0x90, 0x5e, 0x15, 0x78, 0x6a, 0x2e,
	0xb9, 0x1c, 0xc9, 0x3e, 0x00, 0xf1, 0x0c, 0xa3, 0xe7, 0xce, 0xbd, 0x74, 0xc6, 0xa6, 0xac, 0x29,
	0x9e, 0xd0, 0xb0, 0x7b, 0x70, 0x49, 0x9d, 0x34, 0xf1, 0xb0, 0xa2, 0x40, 0x4b, 0x68, 0x3b, 0x99,
	0x35, 0x5a, 0x67, 0xfa, 0x3f, 0xc8, 0xc0, 0xe5, 0xb4, 0x42, 0xfc, 0x69, 0xbd, 0x4c, 0xbf, 0x22,
	0xc9, 0xad, 0xbf, 0x22, 0xd9, 0xa4, 0x4f, 0xf9, 0x8d, 0xfa, 0xf4, 0x77, 0x32, 0x70, 0x45, 0x19,
	0xfd, 0x24, 0xf2, 0xfc, 0x6b, 0x92, 0x4c, 0x79, 0x4c, 0x92, 0x4f, 0x3d, 0x26, 0xd1, 0x7f, 0x9f,
	0x03, 0x48, 0x24, 0x49, 0x99, 0x9e, 0xcc, 0x1f, 0x33, 0x3d, 0x2f, 0x71, 0x05, 0xca, 0x0e, 0x26,
	0xe9, 0xb3, 0x9a, 0x5c, 0x74, 0x0d, 0x5d, 0x3d, 0xa7, 0x61, 0x1f, 0x41, 0x49, 0xec, 0xc0, 0x44,
	0x1b, 0x6a, 0xd7, 0xd7, 0x57, 0xf2, 0x7d, 0xf9, 0xc2, 0x23, 0xa2, 0xbb, 0xf9, 0x97, 0x19, 0x28,
	0xca, 0xe7, 0x1d, 0xf7, 0x20, 0x8f, 0xe1, 0x9e, 0xdc, 0x66, 0xb8, 0xb2, 0xc9, 0x08, 0xd0, 0x8f,
	0x23, 0xa0, 0xbd, 0xb8, 0x0f, 0x45, 0xc3, 0x34, 0x27, 0xf3, 0x93, 0xf4, 0xae, 0xd5, 0xda, 0x7a,
	0x3c, 0xd8, 0xe2, 0x05, 0x83, 0x16, 0xe6, 0xe7, 0x50, 0x41, 0x7a, 0x91, 0x05, 0xa4, 0xdc, 0xd9,
	0xc5, 0x95, 0x73, 0xb0, 0xc5, 0xcb, 0x46, 0xb4, 0x8a, 0x7e, 0x91, 0x4e, 0x3a, 0x84, 0x5a, 0xdf,
	0xbc, 0xc0, 0xfa, 0x9c, 0xf4, 0x43, 0xd9, 0x93, 0xfa, 0x97, 0x59, 0xa8, 0xc4, 0x09, 0xd1, 0x2b,
	0xfb, 0xb0, 0xe4, 0xf7, 0x32, 0x72, 0xca, 0xef, 0x65, 0xac, 0xaf, 0x24, 0x71, 0xad, 0x3f, 0x4f,
	0xc6, 0x64, 0x3b, 0xad, 0xaf, 0xc1, 0xc5, 0x73, 0xb7, 0xc2, 0x4b, 0x9e, 0xbb, 0xdd, 0x00, 0xa1,
	0x13, 0x13, 0xdb, 0xa4, 0x94, 0x32, 0xcf, 0x4b, 0x54, 0xee, 0x99, 0xeb, 0x4f, 0x8c, 0x4a, 0x74,
	0x6d, 0x59, 0x7d, 0x62, 0xf4, 0xdc, 0xb7, 0x07, 0xe5, 0xe7, 0xbf, 0x3d, 0xf8, 0x1e, 0x2a, 0x71,
	0xd2, 0xf3, 0xea, 0x03, 0xf6, 0x63, 0xbc, 0xac, 0xfe, 0xe7, 0x51, 0x44, 0x15, 0xe7, 0x1c, 0x7f,
	0x6a, 0x44, 0x95, 0x6a, 0x3e, 0xf7, 0x82, 0xe6, 0xcf, 0x44, 0xa4, 0x13, 0x37, 0xfe, 0x13, 0x6b,
	0x89, 0x3a, 0x81, 0xf9, 0xd4, 0x04, 0xea, 0xdb, 0x32, 0x5a, 0x8b, 0xb3, 0xa5, 0x7f, 0x9b, 0x89,
	0x42, 0xa1, 0xf8, 0x76, 0xf4, 0x73, 0xad, 0x49, 0xdc, 0x5a, 0x56, 0x6d, 0xed, 0x95, 0xfd, 0xc8,
	0x3b, 0x50, 0x50, 0x17, 0xdb, 0x06, 0x1f, 0x22, 0xf0, 0xeb, 0x4f, 0xf2, 0x0a, 0xeb, 0x4f, 0xf2,
	0x74, 0x5d, 0x1a, 0x44, 0xd1, 0x85, 0x2b, 0x51, 0xbd, 0xd1, 0x73, 0x42, 0x2c, 0xa0, 0x1b, 0xaf,
	0x24, 0xee, 0xe4, 0xc7, 0x77, 0xf3, 0x27, 0x73, 0x24, 0x3f, 0x64, 0xa0, 0x9e, 0xda, 0x5c, 0x78,
	0x05, 0x61, 0x36, 0xda, 0x81, 0xdc, 0x4b, 0xda, 0x81, 0xfc, 0x2b, 0xd8, 0x81, 0xc2, 0x1f, 0xb5,
	0x03, 0xc5, 0x75, 0x3b, 0xa0, 0xff, 0xfd, 0x4c, 0xfc, 0x70, 0x4e, 0x54, 0xb6, 0xc9, 0xb9, 0x64,
	0x36, 0x3a, 0x97, 0xdb, 0xf1, 0x0f, 0x26, 0xf4, 0x3a, 0xe2, 0xa4, 0xa7, 0xce, 0x15, 0x08, 0xfb,
	0x12, 0x6e, 0x88, 0x7d, 0x5a, 0x61, 0xaa, 0x27, 0xde, 0x7c, 0x12, 0xff, 0x9c, 0x82, 0xbc, 0x42,
	0x7c, 0x4d, 0x10, 0x88, 0xe7, 0x95, 0xf3, 0xe4, 0x47, 0x1b, 0x7a, 0x50, 0x4f, 0x6d, 0xcc, 0x28,
	0xbf, 0xab, 0x92, 0x51, 0x7f, 0x57, 0x85, 0xed, 0x40, 0xe1, 0xf4, 0x89, 0xe5, 0x5b, 0x1b, 0x7e,
	0x0d, 0x41, 0x20, 0xf4, 0xaf, 0xa1, 0xa6, 0x6e, 0xe1, 0xb2, 0xf7, 0xa1, 0x60, 0x87, 0xd6, 0x22,
	0xba, 0x31, 0x7e, 0xed, 0xe2, 0x2e, 0x2f, 0x3d, 0x0a, 0x13, 0x44, 0xfa, 0x1f, 0x32, 0xa0, 0xad,
	0xe3, 0x94, 0x1f, 0x7f, 0xc9, 0x3c, 0xe7, 0xc7, 0x5f, 0xb2, 0x29, 0x21, 0x37, 0xfc, 0x80, 0x4b,
	0x72, 0xcb, 0x36, 0xff, 0x9c, 0x5b, 0xb6, 0xec, 0x6d, 0x28, 0xfb, 0x16, 0xfd, 0xe0, 0x86, 0x99,
	0xde, 0x3e, 0x17, 0x8f, 0x8d, 0x22, 0x9c, 0xfe, 0x77, 0x33, 0x50, 0x92, 0xfb, 0xcd, 0x1b, 0xdf,
	0x0f, 0xbc, 0x0b, 0x25, 0xf1, 0xe3, 0x1b, 0xd1, 0x4f, 0x46, 0x5c, 0x38, 0xb2, 0x8c, 0xf0, 0xec,
	0xb6, 0xd8, 0x85, 0x4f, 0x3f, 0xe5, 0xa3, 0xdd, 0x7a, 0x82, 0xa3, 0x36, 0xd1, 0x21, 0x1c, 0xed,
	0xef, 0x06, 0xf2, 0x6c, 0x17, 0x08, 0x34, 0x46, 0x88, 0xfe, 0x0b, 0x28, 0xc9, 0xfd, 0xec, 0x8d,
	0xa2, 0xbc, 0xe8, 0xa7, 0x2b, 0x76, 0x00, 0x92, 0x0d, 0xee, 0x4d, 0x35, 0xe8, 0x8e, 0x7c, 0x31,
	0xd1, 0xf7, 0x66, 0x27, 0x14, 0xb2, 0x7e, 0x00, 0x65, 0x27, 0x7a, 0x03, 0x92, 0x79, 0xfe, 0x1b,
	0x90, 0x98, 0x88, 0xdd, 0x83, 0xd8, 0xbc, 0xbf, 0x28, 0xd0, 0xd2, 0x5b, 0x00, 0xc9, 0xce, 0x1b,
	0xfb, 0x58, 0x86, 0x89, 0x08, 0x8a, 0xd4, 0x67, 0xbd, 0x31, 0xba, 0xb0, 0xa3, 0x90, 0xe9, 0x0d,
	0xa8, 0xa9, 0xdb, 0x77, 0xf7, 0xde, 0x84, 0x9a, 0xfa, 0x6b, 0x03, 0x74, 0x72, 0xe5, 0xb9, 0x96,
	0x78, 0x08, 0xd0, 0xff, 0xed, 0x27, 0x5a, 0xe6, 0xde, 0x9f, 0x2b, 0xcf, 0xe5, 0x88, 0x46, 0xe6,
	0x40, 0x74, 0x6b, 0xa5, 0xdf, 0x1b, 0x74, 0x5b, 0x9c, 0x32, 0x1e, 0x7a, 0x32, 0x70, 0xd0, 0x1a,
	0x1d, 0x88, 0xec, 0x48, 0x62, 0x08, 0x90, 0xa3, 0x1b, 0x10, 0xad, 0xc1, 0x7e, 0x57, 0xdc, 0x52,
	0xa1, 0xcf, 0x78, 0x8b, 0xa8, 0x40, 0x37, 0x25, 0x7a, 0xa3, 0xb1, 0x56, 0x64, 0x1a, 0xd4, 0xf0,
	0x2b, 0xc6, 0x95, 0xee, 0xfd, 0x0a, 0x9a, 0xcf, 0x3b, 0x92, 0xc2, 0x5a, 0xdb, 0x07, 0x2d, 0x3a,
	0xf6, 0xab, 0x41, 0x79, 0x30, 0x9c, 0x88, 0x52, 0x86, 0x55, 0xa1, 0xc4, 0xbb, 0xfd, 0x2e, 0x6d,
	0xc8, 0xdd, 0xfb, 0x5d, 0x46, 0x99, 0xa5, 0xe8, 0x48, 0x22, 0x06, 0xc8, 0xee, 0xaa, 0x20, 0x6e,
	0x19, 0xa6, 0x96, 0x61, 0xd7, 0x80, 0xa5, 0x40, 0x7d, 0x6f, 0x66, 0x38, 0x5a, 0x96, 0xb6, 0xde,
	0x22, 0xf8, 0x63, 0xdf, 0x0e, 0x2d, 0x2d, 0xc7, 0x5e, 0x87, 0x1b, 0x31, 0xac, 0xef, 0x9d, 0x1e,
	0xfa, 0xb6, 0xe7, 0xdb, 0xe1, 0xb9, 0x40, 0xe7, 0xf7, 0x7e, 0xf9, 0xef, 0x7f, 0xb8, 0x9d, 0xf9,
	0x4f, 0x3f, 0xdc, 0xce, 0xfc, 0x8f, 0x1f, 0x6e, 0x6f, 0xfd, 0xe1, 0x7f, 0xdd, 0xce, 0xfc, 0x4d,
	0xf5, 0xa7, 0xd8, 0x16, 0x46, 0xe8, 0xdb, 0x67, 0xc2, 0xd9, 0x45, 0x05, 0xd7, 0xfa, 0x60, 0x79,
	0x72, 0xfc, 0xc1, 0x72, 0xfa, 0x01, 0xce, 0xe8, 0xb4, 0x48, 0xbf, 0xc8, 0xf6, 0xf1, 0xff, 0x0f,
	0x00, 0x00, 0xff, 0xff, 0x29, 0xe6, 0xe0, 0x46, 0xd4, 0x4d, 0x00, 0x00,
}

func (m *Type) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Type) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Type) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x32
	}
	if m.Scale != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Scale))
		i--
		dAtA[i] = 0x28
	}
	if m.Width != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x20
	}
	if m.AutoIncr {
		i--
		if m.AutoIncr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.NotNullable {
		i--
		if m.NotNullable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Const) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Const) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Src != nil {
		{
			size, err := m.Src.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.IsBin {
		i--
		if m.IsBin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.Value != nil {
		{
			size := m.Value.ProtoSize()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Isnull {
		i--
		if m.Isnull {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Const_I8Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_I8Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.I8Val))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *Const_I16Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_I16Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.I16Val))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *Const_I32Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_I32Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.I32Val))
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *Const_I64Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_I64Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.I64Val))
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *Const_U8Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_U8Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.U8Val))
	i--
	dAtA[i] = 0x30
	return len(dAtA) - i, nil
}
func (m *Const_U16Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_U16Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.U16Val))
	i--
	dAtA[i] = 0x38
	return len(dAtA) - i, nil
}
func (m *Const_U32Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_U32Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.U32Val))
	i--
	dAtA[i] = 0x40
	return len(dAtA) - i, nil
}
func (m *Const_U64Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_U64Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.U64Val))
	i--
	dAtA[i] = 0x48
	return len(dAtA) - i, nil
}
func (m *Const_Dval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Dval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Dval))))
	i--
	dAtA[i] = 0x51
	return len(dAtA) - i, nil
}
func (m *Const_Sval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Sval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Sval)
	copy(dAtA[i:], m.Sval)
	i = encodeVarintPlan(dAtA, i, uint64(len(m.Sval)))
	i--
	dAtA[i] = 0x5a
	return len(dAtA) - i, nil
}
func (m *Const_Bval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Bval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Bval {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x60
	return len(dAtA) - i, nil
}
func (m *Const_Fval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Fval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Fval))))
	i--
	dAtA[i] = 0x6d
	return len(dAtA) - i, nil
}
func (m *Const_Dateval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Dateval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.Dateval))
	i--
	dAtA[i] = 0x70
	return len(dAtA) - i, nil
}
func (m *Const_Timeval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Timeval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.Timeval))
	i--
	dAtA[i] = 0x78
	return len(dAtA) - i, nil
}
func (m *Const_Datetimeval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Datetimeval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.Datetimeval))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	return len(dAtA) - i, nil
}
func (m *Const_Decimal64Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Decimal64Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Decimal64Val != nil {
		{
			size, err := m.Decimal64Val.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *Const_Decimal128Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Decimal128Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Decimal128Val != nil {
		{
			size, err := m.Decimal128Val.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *Const_Timestampval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Timestampval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.Timestampval))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x98
	return len(dAtA) - i, nil
}
func (m *Const_Jsonval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Jsonval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Jsonval)
	copy(dAtA[i:], m.Jsonval)
	i = encodeVarintPlan(dAtA, i, uint64(len(m.Jsonval)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa2
	return len(dAtA) - i, nil
}
func (m *Const_Defaultval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Defaultval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Defaultval {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa8
	return len(dAtA) - i, nil
}
func (m *Const_UpdateVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_UpdateVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.UpdateVal {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb0
	return len(dAtA) - i, nil
}
func (m *ParamRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParamRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParamRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Pos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Pos))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VarRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VarRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VarRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Global {
		i--
		if m.Global {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.System {
		i--
		if m.System {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ColRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ColPos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ColPos))
		i--
		dAtA[i] = 0x10
	}
	if m.RelPos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RelPos))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RawColRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawColRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawColRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ColId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ColId))
		i--
		dAtA[i] = 0x10
	}
	if m.TblId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TblId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CorrColRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CorrColRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CorrColRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Depth != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Depth))
		i--
		dAtA[i] = 0x18
	}
	if m.ColPos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ColPos))
		i--
		dAtA[i] = 0x10
	}
	if m.RelPos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RelPos))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExprList) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExprList) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExprList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MaxValue) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaxValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaxValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TargetType) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TargetType) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TargetType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Typ != nil {
		{
			size, err := m.Typ.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubqueryRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubqueryRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubqueryRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RowSize != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RowSize))
		i--
		dAtA[i] = 0x28
	}
	if m.Child != nil {
		{
			size, err := m.Child.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Op) > 0 {
		i -= len(m.Op)
		copy(dAtA[i:], m.Op)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Op)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NodeId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x10
	}
	if m.Typ != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Typ))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ObjectRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PubAccountId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.PubAccountId))
		i--
		dAtA[i] = 0x50
	}
	if len(m.SubscriptionName) > 0 {
		i -= len(m.SubscriptionName)
		copy(dAtA[i:], m.SubscriptionName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.SubscriptionName)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ObjName) > 0 {
		i -= len(m.ObjName)
		copy(dAtA[i:], m.ObjName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ObjName)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SchemaName) > 0 {
		i -= len(m.SchemaName)
		copy(dAtA[i:], m.SchemaName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.SchemaName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ServerName) > 0 {
		i -= len(m.ServerName)
		copy(dAtA[i:], m.ServerName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ServerName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Obj != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Obj))
		i--
		dAtA[i] = 0x20
	}
	if m.Schema != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Schema))
		i--
		dAtA[i] = 0x18
	}
	if m.Db != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Db))
		i--
		dAtA[i] = 0x10
	}
	if m.Server != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Server))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubscriptionMeta) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscriptionMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscriptionMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SubName) > 0 {
		i -= len(m.SubName)
		copy(dAtA[i:], m.SubName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.SubName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AccountName) > 0 {
		i -= len(m.AccountName)
		copy(dAtA[i:], m.AccountName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.AccountName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AccountId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.AccountId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Function) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Function) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Function) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Args[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Func != nil {
		{
			size, err := m.Func.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Expr) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Expr) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Expr != nil {
		{
			size := m.Expr.ProtoSize()
			i -= size
			if _, err := m.Expr.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Typ != nil {
		{
			size, err := m.Typ.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Expr_C) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_C) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.C != nil {
		{
			size, err := m.C.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Expr_P) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_P) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.P != nil {
		{
			size, err := m.P.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Expr_V) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_V) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.V != nil {
		{
			size, err := m.V.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Expr_Col) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_Col) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Col != nil {
		{
			size, err := m.Col.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Expr_Raw) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_Raw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Raw != nil {
		{
			size, err := m.Raw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Expr_F) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_F) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.F != nil {
		{
			size, err := m.F.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Expr_Sub) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_Sub) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Sub != nil {
		{
			size, err := m.Sub.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Expr_Corr) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_Corr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Corr != nil {
		{
			size, err := m.Corr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Expr_T) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_T) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.T != nil {
		{
			size, err := m.T.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *Expr_List) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_List) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.List != nil {
		{
			size, err := m.List.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *Expr_Max) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_Max) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Max != nil {
		{
			size, err := m.Max.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *Decimal64) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Decimal64) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Decimal64) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.A != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.A))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Decimal128) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Decimal128) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Decimal128) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.B != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.B))
		i--
		dAtA[i] = 0x10
	}
	if m.A != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.A))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResultColDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultColDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultColDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ResultCols) > 0 {
		for iNdEx := len(m.ResultCols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResultCols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ColDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Seqnum != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Seqnum))
		i--
		dAtA[i] = 0x70
	}
	if m.Pkidx != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Pkidx))
		i--
		dAtA[i] = 0x68
	}
	if m.Primary {
		i--
		if m.Primary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.ClusterBy {
		i--
		if m.ClusterBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.LowCard {
		i--
		if m.LowCard {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.OnUpdate != nil {
		{
			size, err := m.OnUpdate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x42
	}
	if m.Default != nil {
		{
			size, err := m.Default.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.NotNull {
		i--
		if m.NotNull {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Typ != nil {
		{
			size, err := m.Typ.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Alg != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Alg))
		i--
		dAtA[i] = 0x20
	}
	if m.Hidden {
		i--
		if m.Hidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ColId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ColId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Default) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Default) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Default) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NullAbility {
		i--
		if m.NullAbility {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.OriginString) > 0 {
		i -= len(m.OriginString)
		copy(dAtA[i:], m.OriginString)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.OriginString)))
		i--
		dAtA[i] = 0x12
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OnUpdate) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OnUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OriginString) > 0 {
		i -= len(m.OriginString)
		copy(dAtA[i:], m.OriginString)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.OriginString)))
		i--
		dAtA[i] = 0x12
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IndexOption) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CreateExtraTable {
		i--
		if m.CreateExtraTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PrimaryKeyDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrimaryKeyDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrimaryKeyDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CompPkeyCol != nil {
		{
			size, err := m.CompPkeyCol.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Names) > 0 {
		for iNdEx := len(m.Names) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Names[iNdEx])
			copy(dAtA[i:], m.Names[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.Names[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.PkeyColName) > 0 {
		i -= len(m.PkeyColName)
		copy(dAtA[i:], m.PkeyColName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.PkeyColName)))
		i--
		dAtA[i] = 0x22
	}
	if m.Option != nil {
		{
			size, err := m.Option.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PkeyColId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.PkeyColId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Cols) > 0 {
		dAtA27 := make([]byte, len(m.Cols)*10)
		var j26 int
		for _, num := range m.Cols {
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		i -= j26
		copy(dAtA[i:], dAtA27[:j26])
		i = encodeVarintPlan(dAtA, i, uint64(j26))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IndexDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Option != nil {
		{
			size, err := m.Option.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Visible {
		i--
		if m.Visible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x3a
	}
	if m.TableExist {
		i--
		if m.TableExist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.IndexTableName) > 0 {
		i -= len(m.IndexTableName)
		copy(dAtA[i:], m.IndexTableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexTableName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Unique {
		i--
		if m.Unique {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Parts) > 0 {
		for iNdEx := len(m.Parts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Parts[iNdEx])
			copy(dAtA[i:], m.Parts[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.Parts[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.IndexName) > 0 {
		i -= len(m.IndexName)
		copy(dAtA[i:], m.IndexName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.IdxId) > 0 {
		i -= len(m.IdxId)
		copy(dAtA[i:], m.IdxId)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IdxId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ForeignKeyDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForeignKeyDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForeignKeyDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OnUpdate != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.OnUpdate))
		i--
		dAtA[i] = 0x30
	}
	if m.OnDelete != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.OnDelete))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ForeignCols) > 0 {
		dAtA30 := make([]byte, len(m.ForeignCols)*10)
		var j29 int
		for _, num := range m.ForeignCols {
			for num >= 1<<7 {
				dAtA30[j29] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j29++
			}
			dAtA30[j29] = uint8(num)
			j29++
		}
		i -= j29
		copy(dAtA[i:], dAtA30[:j29])
		i = encodeVarintPlan(dAtA, i, uint64(j29))
		i--
		dAtA[i] = 0x22
	}
	if m.ForeignTbl != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ForeignTbl))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Cols) > 0 {
		dAtA32 := make([]byte, len(m.Cols)*10)
		var j31 int
		for _, num := range m.Cols {
			for num >= 1<<7 {
				dAtA32[j31] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j31++
			}
			dAtA32[j31] = uint8(num)
			j31++
		}
		i -= j31
		copy(dAtA[i:], dAtA32[:j31])
		i = encodeVarintPlan(dAtA, i, uint64(j31))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Check != nil {
		{
			size, err := m.Check.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterByDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterByDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterByDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Parts) > 0 {
		for iNdEx := len(m.Parts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PropertyDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropertyDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PropertyDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Property) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Property) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Property) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PropertiesDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropertiesDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PropertiesDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Properties) > 0 {
		for iNdEx := len(m.Properties) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Properties[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PartitionByDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionByDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionByDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PartitionTableNames) > 0 {
		for iNdEx := len(m.PartitionTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionTableNames[iNdEx])
			copy(dAtA[i:], m.PartitionTableNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionTableNames[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.PartitionMsg) > 0 {
		i -= len(m.PartitionMsg)
		copy(dAtA[i:], m.PartitionMsg)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionMsg)))
		i--
		dAtA[i] = 0x4a
	}
	if m.IsSubPartition {
		i--
		if m.IsSubPartition {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Algorithm != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Algorithm))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Partitions) > 0 {
		for iNdEx := len(m.Partitions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Partitions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.PartitionNum != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.PartitionNum))
		i--
		dAtA[i] = 0x28
	}
	if m.PartitionColumns != nil {
		{
			size, err := m.PartitionColumns.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PartitionExpression != nil {
		{
			size, err := m.PartitionExpression.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PartitionExpr != nil {
		{
			size, err := m.PartitionExpr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PartitionExpr) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionExpr) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionExpr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExprStr) > 0 {
		i -= len(m.ExprStr)
		copy(dAtA[i:], m.ExprStr)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ExprStr)))
		i--
		dAtA[i] = 0x12
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PartitionColumns) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionColumns) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionColumns) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PartitionColumns) > 0 {
		for iNdEx := len(m.PartitionColumns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionColumns[iNdEx])
			copy(dAtA[i:], m.PartitionColumns[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionColumns[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PartitionItem) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PartitionTableName) > 0 {
		i -= len(m.PartitionTableName)
		copy(dAtA[i:], m.PartitionTableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionTableName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.InValues) > 0 {
		for iNdEx := len(m.InValues) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InValues[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.LessThan) > 0 {
		for iNdEx := len(m.LessThan) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LessThan[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OrdinalPosition != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.OrdinalPosition))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PartitionName) > 0 {
		i -= len(m.PartitionName)
		copy(dAtA[i:], m.PartitionName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ViewDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ViewDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.View) > 0 {
		i -= len(m.View)
		copy(dAtA[i:], m.View)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.View)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableLockType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TableLockType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.IsLocked {
		i--
		if m.IsLocked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if len(m.Name2ColIndex) > 0 {
		for k := range m.Name2ColIndex {
			v := m.Name2ColIndex[k]
			baseI := i
			i = encodeVarintPlan(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPlan(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPlan(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.Defs) > 0 {
		for iNdEx := len(m.Defs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Defs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	if m.ViewSql != nil {
		{
			size, err := m.ViewSql.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.Props) > 0 {
		for iNdEx := len(m.Props) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Props[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if m.ClusterBy != nil {
		{
			size, err := m.ClusterBy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.Partition != nil {
		{
			size, err := m.Partition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.Checks) > 0 {
		for iNdEx := len(m.Checks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Checks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.RefChildTbls) > 0 {
		dAtA42 := make([]byte, len(m.RefChildTbls)*10)
		var j41 int
		for _, num := range m.RefChildTbls {
			for num >= 1<<7 {
				dAtA42[j41] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j41++
			}
			dAtA42[j41] = uint8(num)
			j41++
		}
		i -= j41
		copy(dAtA[i:], dAtA42[:j41])
		i = encodeVarintPlan(dAtA, i, uint64(j41))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Fkeys) > 0 {
		for iNdEx := len(m.Fkeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fkeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.Indexes) > 0 {
		for iNdEx := len(m.Indexes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Indexes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.Pkey != nil {
		{
			size, err := m.Pkey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Version != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x40
	}
	if m.TblFunc != nil {
		{
			size, err := m.TblFunc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Createsql) > 0 {
		i -= len(m.Createsql)
		copy(dAtA[i:], m.Createsql)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Createsql)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.TableType) > 0 {
		i -= len(m.TableType)
		copy(dAtA[i:], m.TableType)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TableType)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Cols) > 0 {
		for iNdEx := len(m.Cols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Hidden {
		i--
		if m.Hidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.TblId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TblId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableDef_DefType) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDef_DefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDef_DefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Def != nil {
		{
			size := m.Def.ProtoSize()
			i -= size
			if _, err := m.Def.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *TableDef_DefType_Properties) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDef_DefType_Properties) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Properties != nil {
		{
			size, err := m.Properties.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *TableFunction) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableFunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableFunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Param) > 0 {
		i -= len(m.Param)
		copy(dAtA[i:], m.Param)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Param)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Stats) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stats) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Stats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Selectivity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Selectivity))))
		i--
		dAtA[i] = 0x39
	}
	if m.TableCnt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TableCnt))))
		i--
		dAtA[i] = 0x31
	}
	if m.HashmapSize != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.HashmapSize))))
		i--
		dAtA[i] = 0x29
	}
	if m.Rowsize != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Rowsize))))
		i--
		dAtA[i] = 0x21
	}
	if m.Outcnt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Outcnt))))
		i--
		dAtA[i] = 0x19
	}
	if m.Cost != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Cost))))
		i--
		dAtA[i] = 0x11
	}
	if m.BlockNum != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.BlockNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColData) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColData) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RowsetData) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowsetData) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowsetData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cols) > 0 {
		for iNdEx := len(m.Cols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OrderBySpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderBySpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderBySpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Flag != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Flag))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Collation) > 0 {
		i -= len(m.Collation)
		copy(dAtA[i:], m.Collation)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Collation)))
		i--
		dAtA[i] = 0x12
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WindowSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WindowSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Lag != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Lag))
		i--
		dAtA[i] = 0x20
	}
	if m.Lead != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Lead))
		i--
		dAtA[i] = 0x18
	}
	if len(m.OrderBy) > 0 {
		for iNdEx := len(m.OrderBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OrderBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PartitionBy) > 0 {
		for iNdEx := len(m.PartitionBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PartitionBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *InsertCtx) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsertCtx) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InsertCtx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ClusterTable != nil {
		{
			size, err := m.ClusterTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.ParentIdx) > 0 {
		for k := range m.ParentIdx {
			v := m.ParentIdx[k]
			baseI := i
			i = encodeVarintPlan(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPlan(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPlan(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.IdxIdx) > 0 {
		dAtA49 := make([]byte, len(m.IdxIdx)*10)
		var j48 int
		for _, num1 := range m.IdxIdx {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA49[j48] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j48++
			}
			dAtA49[j48] = uint8(num)
			j48++
		}
		i -= j48
		copy(dAtA[i:], dAtA49[:j48])
		i = encodeVarintPlan(dAtA, i, uint64(j48))
		i--
		dAtA[i] = 0x32
	}
	if len(m.IdxRef) > 0 {
		for iNdEx := len(m.IdxRef) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IdxRef[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.OnDuplicateExpr) > 0 {
		for k := range m.OnDuplicateExpr {
			v := m.OnDuplicateExpr[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPlan(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPlan(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPlan(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.OnDuplicateIdx) > 0 {
		dAtA52 := make([]byte, len(m.OnDuplicateIdx)*10)
		var j51 int
		for _, num1 := range m.OnDuplicateIdx {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA52[j51] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j51++
			}
			dAtA52[j51] = uint8(num)
			j51++
		}
		i -= j51
		copy(dAtA[i:], dAtA52[:j51])
		i = encodeVarintPlan(dAtA, i, uint64(j51))
		i--
		dAtA[i] = 0x1a
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Ref != nil {
		{
			size, err := m.Ref.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateCtx) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateCtx) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateCtx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ParentIdx) > 0 {
		for iNdEx := len(m.ParentIdx) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ParentIdx[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.OnSetUpdateCol) > 0 {
		for iNdEx := len(m.OnSetUpdateCol) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OnSetUpdateCol[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.OnSetDef) > 0 {
		for iNdEx := len(m.OnSetDef) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OnSetDef[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.OnSetIdx) > 0 {
		for iNdEx := len(m.OnSetIdx) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OnSetIdx[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.OnSetRef) > 0 {
		for iNdEx := len(m.OnSetRef) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OnSetRef[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.OnCascadeUpdateCol) > 0 {
		for iNdEx := len(m.OnCascadeUpdateCol) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OnCascadeUpdateCol[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.OnCascadeDef) > 0 {
		for iNdEx := len(m.OnCascadeDef) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OnCascadeDef[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.OnCascadeIdx) > 0 {
		for iNdEx := len(m.OnCascadeIdx) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OnCascadeIdx[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.OnCascadeRef) > 0 {
		for iNdEx := len(m.OnCascadeRef) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OnCascadeRef[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.OnRestrictIdx) > 0 {
		dAtA56 := make([]byte, len(m.OnRestrictIdx)*10)
		var j55 int
		for _, num1 := range m.OnRestrictIdx {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA56[j55] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j55++
			}
			dAtA56[j55] = uint8(num)
			j55++
		}
		i -= j55
		copy(dAtA[i:], dAtA56[:j55])
		i = encodeVarintPlan(dAtA, i, uint64(j55))
		i--
		dAtA[i] = 0x42
	}
	if len(m.OnRestrictRef) > 0 {
		for iNdEx := len(m.OnRestrictRef) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OnRestrictRef[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.IdxIdx) > 0 {
		dAtA58 := make([]byte, len(m.IdxIdx)*10)
		var j57 int
		for _, num1 := range m.IdxIdx {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA58[j57] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j57++
			}
			dAtA58[j57] = uint8(num)
			j57++
		}
		i -= j57
		copy(dAtA[i:], dAtA58[:j57])
		i = encodeVarintPlan(dAtA, i, uint64(j57))
		i--
		dAtA[i] = 0x32
	}
	if len(m.IdxRef) > 0 {
		for iNdEx := len(m.IdxRef) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IdxRef[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.UpdateCol) > 0 {
		for iNdEx := len(m.UpdateCol) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UpdateCol[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TableDefs) > 0 {
		for iNdEx := len(m.TableDefs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TableDefs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Idx) > 0 {
		for iNdEx := len(m.Idx) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Idx[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Ref) > 0 {
		for iNdEx := len(m.Ref) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ref[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AnalyzeInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalyzeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnalyzeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.InsertTime != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.InsertTime))
		i--
		dAtA[i] = 0x70
	}
	if m.ScanTime != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ScanTime))
		i--
		dAtA[i] = 0x68
	}
	if m.NetworkIO != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.NetworkIO))
		i--
		dAtA[i] = 0x60
	}
	if m.S3IOOutputCount != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.S3IOOutputCount))
		i--
		dAtA[i] = 0x58
	}
	if m.S3IOInputCount != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.S3IOInputCount))
		i--
		dAtA[i] = 0x50
	}
	if m.S3IOByte != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.S3IOByte))
		i--
		dAtA[i] = 0x48
	}
	if m.DiskIO != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.DiskIO))
		i--
		dAtA[i] = 0x40
	}
	if m.WaitTimeConsumed != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.WaitTimeConsumed))
		i--
		dAtA[i] = 0x38
	}
	if m.MemorySize != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.MemorySize))
		i--
		dAtA[i] = 0x30
	}
	if m.TimeConsumed != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TimeConsumed))
		i--
		dAtA[i] = 0x28
	}
	if m.OutputSize != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.OutputSize))
		i--
		dAtA[i] = 0x20
	}
	if m.InputSize != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.InputSize))
		i--
		dAtA[i] = 0x18
	}
	if m.OutputRows != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.OutputRows))
		i--
		dAtA[i] = 0x10
	}
	if m.InputRows != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.InputRows))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SourceStep != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.SourceStep))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.CurrentStep != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.CurrentStep))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.InsertCtx != nil {
		{
			size, err := m.InsertCtx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.NotCacheable {
		i--
		if m.NotCacheable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.ClusterTable != nil {
		{
			size, err := m.ClusterTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.Parallelism != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Parallelism))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if len(m.TblFuncExprList) > 0 {
		for iNdEx := len(m.TblFuncExprList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TblFuncExprList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if m.AnalyzeInfo != nil {
		{
			size, err := m.AnalyzeInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.BindingTags) > 0 {
		dAtA63 := make([]byte, len(m.BindingTags)*10)
		var j62 int
		for _, num1 := range m.BindingTags {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA63[j62] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j62++
			}
			dAtA63[j62] = uint8(num)
			j62++
		}
		i -= j62
		copy(dAtA[i:], dAtA63[:j62])
		i = encodeVarintPlan(dAtA, i, uint64(j62))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.DeleteCtx != nil {
		{
			size, err := m.DeleteCtx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.ExtraOptions) > 0 {
		i -= len(m.ExtraOptions)
		copy(dAtA[i:], m.ExtraOptions)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ExtraOptions)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.RowsetData != nil {
		{
			size, err := m.RowsetData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.ObjRef != nil {
		{
			size, err := m.ObjRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.TableDefVec) > 0 {
		for iNdEx := len(m.TableDefVec) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TableDefVec[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.UpdateCtx != nil {
		{
			size, err := m.UpdateCtx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.Offset != nil {
		{
			size, err := m.Offset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Limit != nil {
		{
			size, err := m.Limit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if len(m.OrderBy) > 0 {
		for iNdEx := len(m.OrderBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OrderBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if m.WinSpec != nil {
		{
			size, err := m.WinSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if len(m.AggList) > 0 {
		for iNdEx := len(m.AggList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AggList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.GroupingSet) > 0 {
		for iNdEx := len(m.GroupingSet) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GroupingSet[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.GroupBy) > 0 {
		for iNdEx := len(m.GroupBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GroupBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.FilterList) > 0 {
		for iNdEx := len(m.FilterList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FilterList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.BuildOnLeft {
		i--
		if m.BuildOnLeft {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.OnList) > 0 {
		for iNdEx := len(m.OnList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OnList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.JoinType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.JoinType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ProjectList) > 0 {
		for iNdEx := len(m.ProjectList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProjectList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Children) > 0 {
		dAtA73 := make([]byte, len(m.Children)*10)
		var j72 int
		for _, num1 := range m.Children {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA73[j72] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j72++
			}
			dAtA73[j72] = uint8(num)
			j72++
		}
		i -= j72
		copy(dAtA[i:], dAtA73[:j72])
		i = encodeVarintPlan(dAtA, i, uint64(j72))
		i--
		dAtA[i] = 0x22
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.NodeId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x10
	}
	if m.NodeType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.NodeType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IdList) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdList) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IdList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.List) > 0 {
		dAtA76 := make([]byte, len(m.List)*10)
		var j75 int
		for _, num1 := range m.List {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA76[j75] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j75++
			}
			dAtA76[j75] = uint8(num)
			j75++
		}
		i -= j75
		copy(dAtA[i:], dAtA76[:j75])
		i = encodeVarintPlan(dAtA, i, uint64(j75))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ColPosMap) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColPosMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColPosMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Map) > 0 {
		for k := range m.Map {
			v := m.Map[k]
			baseI := i
			i = encodeVarintPlan(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPlan(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPlan(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeleteCtx) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteCtx) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteCtx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CanTruncate {
		i--
		if m.CanTruncate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if len(m.OnSetUpdateCol) > 0 {
		for iNdEx := len(m.OnSetUpdateCol) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OnSetUpdateCol[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.OnSetIdx) > 0 {
		for iNdEx := len(m.OnSetIdx) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OnSetIdx[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.OnSetDef) > 0 {
		for iNdEx := len(m.OnSetDef) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OnSetDef[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.OnSetRef) > 0 {
		for iNdEx := len(m.OnSetRef) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OnSetRef[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.OnCascadeIdx) > 0 {
		dAtA78 := make([]byte, len(m.OnCascadeIdx)*10)
		var j77 int
		for _, num1 := range m.OnCascadeIdx {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA78[j77] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j77++
			}
			dAtA78[j77] = uint8(num)
			j77++
		}
		i -= j77
		copy(dAtA[i:], dAtA78[:j77])
		i = encodeVarintPlan(dAtA, i, uint64(j77))
		i--
		dAtA[i] = 0x42
	}
	if len(m.OnCascadeRef) > 0 {
		for iNdEx := len(m.OnCascadeRef) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OnCascadeRef[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.OnRestrictIdx) > 0 {
		dAtA80 := make([]byte, len(m.OnRestrictIdx)*10)
		var j79 int
		for _, num1 := range m.OnRestrictIdx {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA80[j79] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j79++
			}
			dAtA80[j79] = uint8(num)
			j79++
		}
		i -= j79
		copy(dAtA[i:], dAtA80[:j79])
		i = encodeVarintPlan(dAtA, i, uint64(j79))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OnRestrictRef) > 0 {
		for iNdEx := len(m.OnRestrictRef) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OnRestrictRef[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.IdxIdx) > 0 {
		dAtA82 := make([]byte, len(m.IdxIdx)*10)
		var j81 int
		for _, num1 := range m.IdxIdx {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA82[j81] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j81++
			}
			dAtA82[j81] = uint8(num)
			j81++
		}
		i -= j81
		copy(dAtA[i:], dAtA82[:j81])
		i = encodeVarintPlan(dAtA, i, uint64(j81))
		i--
		dAtA[i] = 0x22
	}
	if len(m.IdxRef) > 0 {
		for iNdEx := len(m.IdxRef) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IdxRef[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Idx) > 0 {
		for iNdEx := len(m.Idx) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Idx[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Ref) > 0 {
		for iNdEx := len(m.Ref) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ref[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Query) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Query) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Query) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LoadTag {
		i--
		if m.LoadTag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Headings) > 0 {
		for iNdEx := len(m.Headings) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Headings[iNdEx])
			copy(dAtA[i:], m.Headings[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.Headings[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Params) > 0 {
		for iNdEx := len(m.Params) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Params[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Steps) > 0 {
		dAtA84 := make([]byte, len(m.Steps)*10)
		var j83 int
		for _, num1 := range m.Steps {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA84[j83] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j83++
			}
			dAtA84[j83] = uint8(num)
			j83++
		}
		i -= j83
		copy(dAtA[i:], dAtA84[:j83])
		i = encodeVarintPlan(dAtA, i, uint64(j83))
		i--
		dAtA[i] = 0x12
	}
	if m.StmtType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.StmtType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransationControl) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransationControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Action != nil {
		{
			size := m.Action.ProtoSize()
			i -= size
			if _, err := m.Action.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TclType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TclType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransationControl_Begin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationControl_Begin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Begin != nil {
		{
			size, err := m.Begin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *TransationControl_Commit) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationControl_Commit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *TransationControl_Rollback) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationControl_Rollback) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Rollback != nil {
		{
			size, err := m.Rollback.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *TransationBegin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransationBegin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationBegin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mode != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransationCommit) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransationCommit) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationCommit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CompletionType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.CompletionType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransationRollback) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransationRollback) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationRollback) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CompletionType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.CompletionType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Plan) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Plan) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AttachedPlan != nil {
		{
			size, err := m.AttachedPlan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Plan != nil {
		{
			size := m.Plan.ProtoSize()
			i -= size
			if _, err := m.Plan.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Plan_Query) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan_Query) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Plan_Tcl) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan_Tcl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Tcl != nil {
		{
			size, err := m.Tcl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Plan_Ddl) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan_Ddl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ddl != nil {
		{
			size, err := m.Ddl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Plan_Dcl) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan_Dcl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Dcl != nil {
		{
			size, err := m.Dcl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Column) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Column) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Column) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Column) > 0 {
		for iNdEx := len(m.Column) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Column[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataControl) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Control != nil {
		{
			size := m.Control.ProtoSize()
			i -= size
			if _, err := m.Control.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DclType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.DclType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataControl_SetVariables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataControl_SetVariables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SetVariables != nil {
		{
			size, err := m.SetVariables.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *DataControl_Prepare) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataControl_Prepare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Prepare != nil {
		{
			size, err := m.Prepare.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DataControl_Execute) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataControl_Execute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Execute != nil {
		{
			size, err := m.Execute.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DataControl_Deallocate) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataControl_Deallocate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Deallocate != nil {
		{
			size, err := m.Deallocate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataDefinition) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Definition != nil {
		{
			size := m.Definition.ProtoSize()
			i -= size
			if _, err := m.Definition.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.DdlType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.DdlType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataDefinition_CreateDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_CreateDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateDatabase != nil {
		{
			size, err := m.CreateDatabase.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_AlterDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_AlterDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterDatabase != nil {
		{
			size, err := m.AlterDatabase.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_DropDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_DropDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DropDatabase != nil {
		{
			size, err := m.DropDatabase.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_CreateTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_CreateTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateTable != nil {
		{
			size, err := m.CreateTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_AlterTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_AlterTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterTable != nil {
		{
			size, err := m.AlterTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_DropTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_DropTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DropTable != nil {
		{
			size, err := m.DropTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_CreateIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_CreateIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateIndex != nil {
		{
			size, err := m.CreateIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_AlterIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_AlterIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterIndex != nil {
		{
			size, err := m.AlterIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_DropIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_DropIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DropIndex != nil {
		{
			size, err := m.DropIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_TruncateTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_TruncateTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TruncateTable != nil {
		{
			size, err := m.TruncateTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_ShowVariables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_ShowVariables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ShowVariables != nil {
		{
			size, err := m.ShowVariables.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_AlterView) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_AlterView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterView != nil {
		{
			size, err := m.AlterView.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_LockTables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_LockTables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LockTables != nil {
		{
			size, err := m.LockTables.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_UnlockTables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_UnlockTables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UnlockTables != nil {
		{
			size, err := m.UnlockTables.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_CreateSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_CreateSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateSequence != nil {
		{
			size, err := m.CreateSequence.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_DropSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_DropSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DropSequence != nil {
		{
			size, err := m.DropSequence.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_AlterSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_AlterSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterSequence != nil {
		{
			size, err := m.AlterSequence.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *SubscriptionOption) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscriptionOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscriptionOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Publication) > 0 {
		i -= len(m.Publication)
		copy(dAtA[i:], m.Publication)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Publication)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateDatabase) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubscriptionOption != nil {
		{
			size, err := m.SubscriptionOption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfNotExists {
		i--
		if m.IfNotExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlterDatabase) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfExists {
		i--
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DropDatabase) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfExists {
		i--
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FkColName) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FkColName) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FkColName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cols) > 0 {
		for iNdEx := len(m.Cols) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Cols[iNdEx])
			copy(dAtA[i:], m.Cols[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.Cols[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateTable) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PartitionTables) > 0 {
		for iNdEx := len(m.PartitionTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PartitionTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.FkCols) > 0 {
		for iNdEx := len(m.FkCols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FkCols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.FkTables) > 0 {
		for iNdEx := len(m.FkTables) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FkTables[iNdEx])
			copy(dAtA[i:], m.FkTables[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.FkTables[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.FkDbs) > 0 {
		for iNdEx := len(m.FkDbs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FkDbs[iNdEx])
			copy(dAtA[i:], m.FkDbs[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.FkDbs[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.IndexTables) > 0 {
		for iNdEx := len(m.IndexTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IndexTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Temporary {
		i--
		if m.Temporary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.IfNotExists {
		i--
		if m.IfNotExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlterTableDrop) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTableDrop) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTableDrop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IndexTableName) > 0 {
		i -= len(m.IndexTableName)
		copy(dAtA[i:], m.IndexTableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexTableName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Typ != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Typ))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlterTableAddFk) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTableAddFk) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTableAddFk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Fkey != nil {
		{
			size, err := m.Fkey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Cols) > 0 {
		for iNdEx := len(m.Cols) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Cols[iNdEx])
			copy(dAtA[i:], m.Cols[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.Cols[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterTableAddIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTableAddIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTableAddIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IndexTableExist {
		i--
		if m.IndexTableExist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.IndexInfo != nil {
		{
			size, err := m.IndexInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.OriginTablePrimaryKey) > 0 {
		i -= len(m.OriginTablePrimaryKey)
		copy(dAtA[i:], m.OriginTablePrimaryKey)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.OriginTablePrimaryKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterTableDropIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTableDropIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTableDropIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IndexTableName) > 0 {
		i -= len(m.IndexTableName)
		copy(dAtA[i:], m.IndexTableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexTableName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.IndexName) > 0 {
		i -= len(m.IndexName)
		copy(dAtA[i:], m.IndexName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterTableAlterIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTableAlterIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTableAlterIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Visible {
		i--
		if m.Visible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.IndexName) > 0 {
		i -= len(m.IndexName)
		copy(dAtA[i:], m.IndexName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterTable) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Actions) > 0 {
		for iNdEx := len(m.Actions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Actions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.IsClusterTable {
		i--
		if m.IsClusterTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterTable_Action) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTable_Action) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Action != nil {
		{
			size := m.Action.ProtoSize()
			i -= size
			if _, err := m.Action.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AlterTable_Action_Drop) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action_Drop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Drop != nil {
		{
			size, err := m.Drop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AlterTable_Action_AddFk) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action_AddFk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddFk != nil {
		{
			size, err := m.AddFk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AlterTable_Action_AddIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action_AddIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddIndex != nil {
		{
			size, err := m.AddIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AlterTable_Action_AlterIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action_AlterIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterIndex != nil {
		{
			size, err := m.AlterIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DropTable) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PartitionTableNames) > 0 {
		for iNdEx := len(m.PartitionTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionTableNames[iNdEx])
			copy(dAtA[i:], m.PartitionTableNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionTableNames[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ForeignTbl) > 0 {
		dAtA125 := make([]byte, len(m.ForeignTbl)*10)
		var j124 int
		for _, num := range m.ForeignTbl {
			for num >= 1<<7 {
				dAtA125[j124] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j124++
			}
			dAtA125[j124] = uint8(num)
			j124++
		}
		i -= j124
		copy(dAtA[i:], dAtA125[:j124])
		i = encodeVarintPlan(dAtA, i, uint64(j124))
		i--
		dAtA[i] = 0x3a
	}
	if m.TableId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x30
	}
	if m.ClusterTable != nil {
		{
			size, err := m.ClusterTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.IndexTableNames) > 0 {
		for iNdEx := len(m.IndexTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IndexTableNames[iNdEx])
			copy(dAtA[i:], m.IndexTableNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexTableNames[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfExists {
		i--
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlterView) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterView) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfExists {
		i--
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateSequence) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfNotExists {
		i--
		if m.IfNotExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DropSequence) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfExists {
		i--
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlterSequence) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *CreateIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableExist {
		i--
		if m.TableExist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Index != nil {
		{
			size, err := m.Index.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.OriginTablePrimaryKey) > 0 {
		i -= len(m.OriginTablePrimaryKey)
		copy(dAtA[i:], m.OriginTablePrimaryKey)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.OriginTablePrimaryKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Index) > 0 {
		i -= len(m.Index)
		copy(dAtA[i:], m.Index)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Index)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DropIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IndexTableName) > 0 {
		i -= len(m.IndexTableName)
		copy(dAtA[i:], m.IndexTableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexTableName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.IndexName) > 0 {
		i -= len(m.IndexName)
		copy(dAtA[i:], m.IndexName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TruncateTable) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TruncateTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TruncateTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ForeignTbl) > 0 {
		dAtA131 := make([]byte, len(m.ForeignTbl)*10)
		var j130 int
		for _, num := range m.ForeignTbl {
			for num >= 1<<7 {
				dAtA131[j130] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j130++
			}
			dAtA131[j130] = uint8(num)
			j130++
		}
		i -= j130
		copy(dAtA[i:], dAtA131[:j130])
		i = encodeVarintPlan(dAtA, i, uint64(j130))
		i--
		dAtA[i] = 0x32
	}
	if m.TableId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x28
	}
	if m.ClusterTable != nil {
		{
			size, err := m.ClusterTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.IndexTableNames) > 0 {
		for iNdEx := len(m.IndexTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IndexTableNames[iNdEx])
			copy(dAtA[i:], m.IndexTableNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexTableNames[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterTable) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ColumnIndexOfAccountId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ColumnIndexOfAccountId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AccountIDs) > 0 {
		dAtA134 := make([]byte, len(m.AccountIDs)*10)
		var j133 int
		for _, num := range m.AccountIDs {
			for num >= 1<<7 {
				dAtA134[j133] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j133++
			}
			dAtA134[j133] = uint8(num)
			j133++
		}
		i -= j133
		copy(dAtA[i:], dAtA134[:j133])
		i = encodeVarintPlan(dAtA, i, uint64(j133))
		i--
		dAtA[i] = 0x12
	}
	if m.IsClusterTable {
		i--
		if m.IsClusterTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShowVariables) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowVariables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShowVariables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Where) > 0 {
		for iNdEx := len(m.Where) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Where[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Global {
		i--
		if m.Global {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetVariables) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetVariables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetVariables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SetVariablesItem) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetVariablesItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetVariablesItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Reserved != nil {
		{
			size, err := m.Reserved.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Global {
		i--
		if m.Global {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.System {
		i--
		if m.System {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Prepare) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Prepare) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Prepare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ParamTypes) > 0 {
		dAtA138 := make([]byte, len(m.ParamTypes)*10)
		var j137 int
		for _, num1 := range m.ParamTypes {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA138[j137] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j137++
			}
			dAtA138[j137] = uint8(num)
			j137++
		}
		i -= j137
		copy(dAtA[i:], dAtA138[:j137])
		i = encodeVarintPlan(dAtA, i, uint64(j137))
		i--
		dAtA[i] = 0x22
	}
	if m.Plan != nil {
		{
			size, err := m.Plan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Schemas) > 0 {
		for iNdEx := len(m.Schemas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Schemas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Execute) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Execute) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Execute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Args[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Deallocate) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deallocate) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Deallocate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableLockInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableLockInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableLockInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LockType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.LockType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LockTables) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockTables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockTables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TableLocks) > 0 {
		for iNdEx := len(m.TableLocks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TableLocks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UnLockTables) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnLockTables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnLockTables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func encodeVarintPlan(dAtA []byte, offset int, v uint64) int {
	offset -= sovPlan(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Type) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlan(uint64(m.Id))
	}
	if m.NotNullable {
		n += 2
	}
	if m.AutoIncr {
		n += 2
	}
	if m.Width != 0 {
		n += 1 + sovPlan(uint64(m.Width))
	}
	if m.Scale != 0 {
		n += 1 + sovPlan(uint64(m.Scale))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Const) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Isnull {
		n += 2
	}
	if m.Value != nil {
		n += m.Value.ProtoSize()
	}
	if m.IsBin {
		n += 3
	}
	if m.Src != nil {
		l = m.Src.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Const_I8Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.I8Val))
	return n
}
func (m *Const_I16Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.I16Val))
	return n
}
func (m *Const_I32Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.I32Val))
	return n
}
func (m *Const_I64Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.I64Val))
	return n
}
func (m *Const_U8Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.U8Val))
	return n
}
func (m *Const_U16Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.U16Val))
	return n
}
func (m *Const_U32Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.U32Val))
	return n
}
func (m *Const_U64Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.U64Val))
	return n
}
func (m *Const_Dval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *Const_Sval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sval)
	n += 1 + l + sovPlan(uint64(l))
	return n
}
func (m *Const_Bval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *Const_Fval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	return n
}
func (m *Const_Dateval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.Dateval))
	return n
}
func (m *Const_Timeval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.Timeval))
	return n
}
func (m *Const_Datetimeval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sovPlan(uint64(m.Datetimeval))
	return n
}
func (m *Const_Decimal64Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Decimal64Val != nil {
		l = m.Decimal64Val.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Const_Decimal128Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Decimal128Val != nil {
		l = m.Decimal128Val.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Const_Timestampval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sovPlan(uint64(m.Timestampval))
	return n
}
func (m *Const_Jsonval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Jsonval)
	n += 2 + l + sovPlan(uint64(l))
	return n
}
func (m *Const_Defaultval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 3
	return n
}
func (m *Const_UpdateVal) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 3
	return n
}
func (m *ParamRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pos != 0 {
		n += 1 + sovPlan(uint64(m.Pos))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VarRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.System {
		n += 2
	}
	if m.Global {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RelPos != 0 {
		n += 1 + sovPlan(uint64(m.RelPos))
	}
	if m.ColPos != 0 {
		n += 1 + sovPlan(uint64(m.ColPos))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RawColRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TblId != 0 {
		n += 1 + sovPlan(uint64(m.TblId))
	}
	if m.ColId != 0 {
		n += 1 + sovPlan(uint64(m.ColId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CorrColRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RelPos != 0 {
		n += 1 + sovPlan(uint64(m.RelPos))
	}
	if m.ColPos != 0 {
		n += 1 + sovPlan(uint64(m.ColPos))
	}
	if m.Depth != 0 {
		n += 1 + sovPlan(uint64(m.Depth))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExprList) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MaxValue) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TargetType) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Typ != nil {
		l = m.Typ.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubqueryRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Typ != 0 {
		n += 1 + sovPlan(uint64(m.Typ))
	}
	if m.NodeId != 0 {
		n += 1 + sovPlan(uint64(m.NodeId))
	}
	l = len(m.Op)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Child != nil {
		l = m.Child.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.RowSize != 0 {
		n += 1 + sovPlan(uint64(m.RowSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Server != 0 {
		n += 1 + sovPlan(uint64(m.Server))
	}
	if m.Db != 0 {
		n += 1 + sovPlan(uint64(m.Db))
	}
	if m.Schema != 0 {
		n += 1 + sovPlan(uint64(m.Schema))
	}
	if m.Obj != 0 {
		n += 1 + sovPlan(uint64(m.Obj))
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.SchemaName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.ObjName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.SubscriptionName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.PubAccountId != 0 {
		n += 1 + sovPlan(uint64(m.PubAccountId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubscriptionMeta) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.AccountId != 0 {
		n += 1 + sovPlan(uint64(m.AccountId))
	}
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.AccountName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.SubName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Function) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Func != nil {
		l = m.Func.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, e := range m.Args {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Expr) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Typ != nil {
		l = m.Typ.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Expr != nil {
		n += m.Expr.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Expr_C) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.C != nil {
		l = m.C.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_P) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.P != nil {
		l = m.P.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_V) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.V != nil {
		l = m.V.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_Col) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Col != nil {
		l = m.Col.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_Raw) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Raw != nil {
		l = m.Raw.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_F) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.F != nil {
		l = m.F.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_Sub) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sub != nil {
		l = m.Sub.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_Corr) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Corr != nil {
		l = m.Corr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_T) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.T != nil {
		l = m.T.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_List) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.List != nil {
		l = m.List.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_Max) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Max != nil {
		l = m.Max.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Decimal64) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A != 0 {
		n += 1 + sovPlan(uint64(m.A))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Decimal128) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A != 0 {
		n += 1 + sovPlan(uint64(m.A))
	}
	if m.B != 0 {
		n += 1 + sovPlan(uint64(m.B))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultColDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ResultCols) > 0 {
		for _, e := range m.ResultCols {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColId != 0 {
		n += 1 + sovPlan(uint64(m.ColId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Hidden {
		n += 2
	}
	if m.Alg != 0 {
		n += 1 + sovPlan(uint64(m.Alg))
	}
	if m.Typ != nil {
		l = m.Typ.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.NotNull {
		n += 2
	}
	if m.Default != nil {
		l = m.Default.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.OnUpdate != nil {
		l = m.OnUpdate.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.LowCard {
		n += 2
	}
	if m.ClusterBy {
		n += 2
	}
	if m.Primary {
		n += 2
	}
	if m.Pkidx != 0 {
		n += 1 + sovPlan(uint64(m.Pkidx))
	}
	if m.Seqnum != 0 {
		n += 1 + sovPlan(uint64(m.Seqnum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Default) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.OriginString)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.NullAbility {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OnUpdate) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.OriginString)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IndexOption) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateExtraTable {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrimaryKeyDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cols) > 0 {
		l = 0
		for _, e := range m.Cols {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.PkeyColId != 0 {
		n += 1 + sovPlan(uint64(m.PkeyColId))
	}
	if m.Option != nil {
		l = m.Option.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.PkeyColName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.CompPkeyCol != nil {
		l = m.CompPkeyCol.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IndexDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IdxId)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Parts) > 0 {
		for _, s := range m.Parts {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Unique {
		n += 2
	}
	l = len(m.IndexTableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableExist {
		n += 2
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Visible {
		n += 2
	}
	if m.Option != nil {
		l = m.Option.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ForeignKeyDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Cols) > 0 {
		l = 0
		for _, e := range m.Cols {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.ForeignTbl != 0 {
		n += 1 + sovPlan(uint64(m.ForeignTbl))
	}
	if len(m.ForeignCols) > 0 {
		l = 0
		for _, e := range m.ForeignCols {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.OnDelete != 0 {
		n += 1 + sovPlan(uint64(m.OnDelete))
	}
	if m.OnUpdate != 0 {
		n += 1 + sovPlan(uint64(m.OnUpdate))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Check != nil {
		l = m.Check.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterByDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Parts) > 0 {
		for _, e := range m.Parts {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PropertyDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Property) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PropertiesDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Properties) > 0 {
		for _, e := range m.Properties {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionByDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPlan(uint64(m.Type))
	}
	if m.PartitionExpr != nil {
		l = m.PartitionExpr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.PartitionExpression != nil {
		l = m.PartitionExpression.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.PartitionColumns != nil {
		l = m.PartitionColumns.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.PartitionNum != 0 {
		n += 1 + sovPlan(uint64(m.PartitionNum))
	}
	if len(m.Partitions) > 0 {
		for _, e := range m.Partitions {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Algorithm != 0 {
		n += 1 + sovPlan(uint64(m.Algorithm))
	}
	if m.IsSubPartition {
		n += 2
	}
	l = len(m.PartitionMsg)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.PartitionTableNames) > 0 {
		for _, s := range m.PartitionTableNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionExpr) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.ExprStr)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionColumns) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.PartitionColumns) > 0 {
		for _, s := range m.PartitionColumns {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionItem) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PartitionName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.OrdinalPosition != 0 {
		n += 1 + sovPlan(uint64(m.OrdinalPosition))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.LessThan) > 0 {
		for _, e := range m.LessThan {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.InValues) > 0 {
		for _, e := range m.InValues {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	l = len(m.PartitionTableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ViewDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.View)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TblId != 0 {
		n += 1 + sovPlan(uint64(m.TblId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Hidden {
		n += 2
	}
	if len(m.Cols) > 0 {
		for _, e := range m.Cols {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	l = len(m.TableType)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Createsql)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TblFunc != nil {
		l = m.TblFunc.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovPlan(uint64(m.Version))
	}
	if m.Pkey != nil {
		l = m.Pkey.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Indexes) > 0 {
		for _, e := range m.Indexes {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Fkeys) > 0 {
		for _, e := range m.Fkeys {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.RefChildTbls) > 0 {
		l = 0
		for _, e := range m.RefChildTbls {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.Checks) > 0 {
		for _, e := range m.Checks {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Partition != nil {
		l = m.Partition.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.ClusterBy != nil {
		l = m.ClusterBy.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if len(m.Props) > 0 {
		for _, e := range m.Props {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if m.ViewSql != nil {
		l = m.ViewSql.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if len(m.Defs) > 0 {
		for _, e := range m.Defs {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Name2ColIndex) > 0 {
		for k, v := range m.Name2ColIndex {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPlan(uint64(len(k))) + 1 + sovPlan(uint64(v))
			n += mapEntrySize + 2 + sovPlan(uint64(mapEntrySize))
		}
	}
	if m.IsLocked {
		n += 3
	}
	if m.TableLockType != 0 {
		n += 2 + sovPlan(uint64(m.TableLockType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableDef_DefType) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Def != nil {
		n += m.Def.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableDef_DefType_Properties) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Properties != nil {
		l = m.Properties.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TableFunction) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Param)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Stats) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockNum != 0 {
		n += 1 + sovPlan(uint64(m.BlockNum))
	}
	if m.Cost != 0 {
		n += 9
	}
	if m.Outcnt != 0 {
		n += 9
	}
	if m.Rowsize != 0 {
		n += 9
	}
	if m.HashmapSize != 0 {
		n += 9
	}
	if m.TableCnt != 0 {
		n += 9
	}
	if m.Selectivity != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColData) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RowsetData) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cols) > 0 {
		for _, e := range m.Cols {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrderBySpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Collation)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Flag != 0 {
		n += 1 + sovPlan(uint64(m.Flag))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WindowSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PartitionBy) > 0 {
		for _, e := range m.PartitionBy {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OrderBy) > 0 {
		for _, e := range m.OrderBy {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Lead != 0 {
		n += 1 + sovPlan(uint64(m.Lead))
	}
	if m.Lag != 0 {
		n += 1 + sovPlan(uint64(m.Lag))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InsertCtx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ref != nil {
		l = m.Ref.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.OnDuplicateIdx) > 0 {
		l = 0
		for _, e := range m.OnDuplicateIdx {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.OnDuplicateExpr) > 0 {
		for k, v := range m.OnDuplicateExpr {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.ProtoSize()
				l += 1 + sovPlan(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPlan(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPlan(uint64(mapEntrySize))
		}
	}
	if len(m.IdxRef) > 0 {
		for _, e := range m.IdxRef {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.IdxIdx) > 0 {
		l = 0
		for _, e := range m.IdxIdx {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.ParentIdx) > 0 {
		for k, v := range m.ParentIdx {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPlan(uint64(len(k))) + 1 + sovPlan(uint64(v))
			n += mapEntrySize + 1 + sovPlan(uint64(mapEntrySize))
		}
	}
	if m.ClusterTable != nil {
		l = m.ClusterTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateCtx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, e := range m.Ref {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Idx) > 0 {
		for _, e := range m.Idx {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.TableDefs) > 0 {
		for _, e := range m.TableDefs {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.UpdateCol) > 0 {
		for _, e := range m.UpdateCol {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.IdxRef) > 0 {
		for _, e := range m.IdxRef {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.IdxIdx) > 0 {
		l = 0
		for _, e := range m.IdxIdx {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.OnRestrictRef) > 0 {
		for _, e := range m.OnRestrictRef {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OnRestrictIdx) > 0 {
		l = 0
		for _, e := range m.OnRestrictIdx {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.OnCascadeRef) > 0 {
		for _, e := range m.OnCascadeRef {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OnCascadeIdx) > 0 {
		for _, e := range m.OnCascadeIdx {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OnCascadeDef) > 0 {
		for _, e := range m.OnCascadeDef {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OnCascadeUpdateCol) > 0 {
		for _, e := range m.OnCascadeUpdateCol {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OnSetRef) > 0 {
		for _, e := range m.OnSetRef {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OnSetIdx) > 0 {
		for _, e := range m.OnSetIdx {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OnSetDef) > 0 {
		for _, e := range m.OnSetDef {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OnSetUpdateCol) > 0 {
		for _, e := range m.OnSetUpdateCol {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if len(m.ParentIdx) > 0 {
		for _, e := range m.ParentIdx {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnalyzeInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InputRows != 0 {
		n += 1 + sovPlan(uint64(m.InputRows))
	}
	if m.OutputRows != 0 {
		n += 1 + sovPlan(uint64(m.OutputRows))
	}
	if m.InputSize != 0 {
		n += 1 + sovPlan(uint64(m.InputSize))
	}
	if m.OutputSize != 0 {
		n += 1 + sovPlan(uint64(m.OutputSize))
	}
	if m.TimeConsumed != 0 {
		n += 1 + sovPlan(uint64(m.TimeConsumed))
	}
	if m.MemorySize != 0 {
		n += 1 + sovPlan(uint64(m.MemorySize))
	}
	if m.WaitTimeConsumed != 0 {
		n += 1 + sovPlan(uint64(m.WaitTimeConsumed))
	}
	if m.DiskIO != 0 {
		n += 1 + sovPlan(uint64(m.DiskIO))
	}
	if m.S3IOByte != 0 {
		n += 1 + sovPlan(uint64(m.S3IOByte))
	}
	if m.S3IOInputCount != 0 {
		n += 1 + sovPlan(uint64(m.S3IOInputCount))
	}
	if m.S3IOOutputCount != 0 {
		n += 1 + sovPlan(uint64(m.S3IOOutputCount))
	}
	if m.NetworkIO != 0 {
		n += 1 + sovPlan(uint64(m.NetworkIO))
	}
	if m.ScanTime != 0 {
		n += 1 + sovPlan(uint64(m.ScanTime))
	}
	if m.InsertTime != 0 {
		n += 1 + sovPlan(uint64(m.InsertTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Node) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeType != 0 {
		n += 1 + sovPlan(uint64(m.NodeType))
	}
	if m.NodeId != 0 {
		n += 1 + sovPlan(uint64(m.NodeId))
	}
	if m.Stats != nil {
		l = m.Stats.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Children) > 0 {
		l = 0
		for _, e := range m.Children {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.ProjectList) > 0 {
		for _, e := range m.ProjectList {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.JoinType != 0 {
		n += 1 + sovPlan(uint64(m.JoinType))
	}
	if len(m.OnList) > 0 {
		for _, e := range m.OnList {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.BuildOnLeft {
		n += 2
	}
	if len(m.FilterList) > 0 {
		for _, e := range m.FilterList {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.GroupBy) > 0 {
		for _, e := range m.GroupBy {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.GroupingSet) > 0 {
		for _, e := range m.GroupingSet {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.AggList) > 0 {
		for _, e := range m.AggList {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.WinSpec != nil {
		l = m.WinSpec.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.OrderBy) > 0 {
		for _, e := range m.OrderBy {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Limit != nil {
		l = m.Limit.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Offset != nil {
		l = m.Offset.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.UpdateCtx != nil {
		l = m.UpdateCtx.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if len(m.TableDefVec) > 0 {
		for _, e := range m.TableDefVec {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if m.ObjRef != nil {
		l = m.ObjRef.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.RowsetData != nil {
		l = m.RowsetData.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	l = len(m.ExtraOptions)
	if l > 0 {
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.DeleteCtx != nil {
		l = m.DeleteCtx.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if len(m.BindingTags) > 0 {
		l = 0
		for _, e := range m.BindingTags {
			l += sovPlan(uint64(e))
		}
		n += 2 + sovPlan(uint64(l)) + l
	}
	if m.AnalyzeInfo != nil {
		l = m.AnalyzeInfo.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if len(m.TblFuncExprList) > 0 {
		for _, e := range m.TblFuncExprList {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if m.Parallelism != 0 {
		n += 2 + sovPlan(uint64(m.Parallelism))
	}
	if m.ClusterTable != nil {
		l = m.ClusterTable.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.NotCacheable {
		n += 3
	}
	if m.InsertCtx != nil {
		l = m.InsertCtx.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.CurrentStep != 0 {
		n += 2 + sovPlan(uint64(m.CurrentStep))
	}
	if m.SourceStep != 0 {
		n += 2 + sovPlan(uint64(m.SourceStep))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IdList) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		l = 0
		for _, e := range m.List {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColPosMap) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Map) > 0 {
		for k, v := range m.Map {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPlan(uint64(len(k))) + 1 + sovPlan(uint64(v))
			n += mapEntrySize + 1 + sovPlan(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteCtx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, e := range m.Ref {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Idx) > 0 {
		for _, e := range m.Idx {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.IdxRef) > 0 {
		for _, e := range m.IdxRef {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.IdxIdx) > 0 {
		l = 0
		for _, e := range m.IdxIdx {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.OnRestrictRef) > 0 {
		for _, e := range m.OnRestrictRef {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OnRestrictIdx) > 0 {
		l = 0
		for _, e := range m.OnRestrictIdx {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.OnCascadeRef) > 0 {
		for _, e := range m.OnCascadeRef {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OnCascadeIdx) > 0 {
		l = 0
		for _, e := range m.OnCascadeIdx {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.OnSetRef) > 0 {
		for _, e := range m.OnSetRef {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OnSetDef) > 0 {
		for _, e := range m.OnSetDef {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OnSetIdx) > 0 {
		for _, e := range m.OnSetIdx {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OnSetUpdateCol) > 0 {
		for _, e := range m.OnSetUpdateCol {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.CanTruncate {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Query) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StmtType != 0 {
		n += 1 + sovPlan(uint64(m.StmtType))
	}
	if len(m.Steps) > 0 {
		l = 0
		for _, e := range m.Steps {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Params) > 0 {
		for _, e := range m.Params {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Headings) > 0 {
		for _, s := range m.Headings {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.LoadTag {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransationControl) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TclType != 0 {
		n += 1 + sovPlan(uint64(m.TclType))
	}
	if m.Action != nil {
		n += m.Action.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransationControl_Begin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Begin != nil {
		l = m.Begin.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TransationControl_Commit) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TransationControl_Rollback) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rollback != nil {
		l = m.Rollback.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TransationBegin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovPlan(uint64(m.Mode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransationCommit) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompletionType != 0 {
		n += 1 + sovPlan(uint64(m.CompletionType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransationRollback) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompletionType != 0 {
		n += 1 + sovPlan(uint64(m.CompletionType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Plan) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Plan != nil {
		n += m.Plan.ProtoSize()
	}
	if m.AttachedPlan != nil {
		l = m.AttachedPlan.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Plan_Query) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Query != nil {
		l = m.Query.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Plan_Tcl) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tcl != nil {
		l = m.Tcl.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Plan_Ddl) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ddl != nil {
		l = m.Ddl.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Plan_Dcl) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dcl != nil {
		l = m.Dcl.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Column) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Column) > 0 {
		for _, e := range m.Column {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataControl) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DclType != 0 {
		n += 1 + sovPlan(uint64(m.DclType))
	}
	if m.Control != nil {
		n += m.Control.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataControl_SetVariables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SetVariables != nil {
		l = m.SetVariables.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataControl_Prepare) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prepare != nil {
		l = m.Prepare.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataControl_Execute) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Execute != nil {
		l = m.Execute.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataControl_Deallocate) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Deallocate != nil {
		l = m.Deallocate.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DdlType != 0 {
		n += 1 + sovPlan(uint64(m.DdlType))
	}
	if m.Query != nil {
		l = m.Query.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Definition != nil {
		n += m.Definition.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataDefinition_CreateDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateDatabase != nil {
		l = m.CreateDatabase.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_AlterDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterDatabase != nil {
		l = m.AlterDatabase.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_DropDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropDatabase != nil {
		l = m.DropDatabase.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_CreateTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateTable != nil {
		l = m.CreateTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_AlterTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterTable != nil {
		l = m.AlterTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_DropTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropTable != nil {
		l = m.DropTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_CreateIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateIndex != nil {
		l = m.CreateIndex.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_AlterIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterIndex != nil {
		l = m.AlterIndex.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_DropIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropIndex != nil {
		l = m.DropIndex.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_TruncateTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TruncateTable != nil {
		l = m.TruncateTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_ShowVariables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowVariables != nil {
		l = m.ShowVariables.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_AlterView) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterView != nil {
		l = m.AlterView.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_LockTables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LockTables != nil {
		l = m.LockTables.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_UnlockTables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnlockTables != nil {
		l = m.UnlockTables.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_CreateSequence) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateSequence != nil {
		l = m.CreateSequence.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_DropSequence) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropSequence != nil {
		l = m.DropSequence.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_AlterSequence) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterSequence != nil {
		l = m.AlterSequence.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *SubscriptionOption) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Publication)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfNotExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.SubscriptionOption != nil {
		l = m.SubscriptionOption.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DropDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FkColName) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cols) > 0 {
		for _, s := range m.Cols {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfNotExists {
		n += 2
	}
	if m.Temporary {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.IndexTables) > 0 {
		for _, e := range m.IndexTables {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.FkDbs) > 0 {
		for _, s := range m.FkDbs {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.FkTables) > 0 {
		for _, s := range m.FkTables {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.FkCols) > 0 {
		for _, e := range m.FkCols {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.PartitionTables) > 0 {
		for _, e := range m.PartitionTables {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTableDrop) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Typ != 0 {
		n += 1 + sovPlan(uint64(m.Typ))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexTableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTableAddFk) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Cols) > 0 {
		for _, s := range m.Cols {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Fkey != nil {
		l = m.Fkey.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTableAddIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.OriginTablePrimaryKey)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.IndexInfo != nil {
		l = m.IndexInfo.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.IndexTableExist {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTableDropIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexTableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTableAlterIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Visible {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.IsClusterTable {
		n += 2
	}
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTable_Action) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != nil {
		n += m.Action.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTable_Action_Drop) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Drop != nil {
		l = m.Drop.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *AlterTable_Action_AddFk) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddFk != nil {
		l = m.AddFk.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *AlterTable_Action_AddIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddIndex != nil {
		l = m.AddIndex.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *AlterTable_Action_AlterIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterIndex != nil {
		l = m.AlterIndex.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DropTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.IndexTableNames) > 0 {
		for _, s := range m.IndexTableNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.ClusterTable != nil {
		l = m.ClusterTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableId != 0 {
		n += 1 + sovPlan(uint64(m.TableId))
	}
	if len(m.ForeignTbl) > 0 {
		l = 0
		for _, e := range m.ForeignTbl {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.PartitionTableNames) > 0 {
		for _, s := range m.PartitionTableNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterView) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateSequence) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfNotExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DropSequence) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableId != 0 {
		n += 1 + sovPlan(uint64(m.TableId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterSequence) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.OriginTablePrimaryKey)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Index != nil {
		l = m.Index.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableExist {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Index)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DropIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexTableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TruncateTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.IndexTableNames) > 0 {
		for _, s := range m.IndexTableNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.ClusterTable != nil {
		l = m.ClusterTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableId != 0 {
		n += 1 + sovPlan(uint64(m.TableId))
	}
	if len(m.ForeignTbl) > 0 {
		l = 0
		for _, e := range m.ForeignTbl {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsClusterTable {
		n += 2
	}
	if len(m.AccountIDs) > 0 {
		l = 0
		for _, e := range m.AccountIDs {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.ColumnIndexOfAccountId != 0 {
		n += 1 + sovPlan(uint64(m.ColumnIndexOfAccountId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowVariables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Global {
		n += 2
	}
	if len(m.Where) > 0 {
		for _, e := range m.Where {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetVariables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetVariablesItem) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.System {
		n += 2
	}
	if m.Global {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Reserved != nil {
		l = m.Reserved.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Prepare) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Schemas) > 0 {
		for _, e := range m.Schemas {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Plan != nil {
		l = m.Plan.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.ParamTypes) > 0 {
		l = 0
		for _, e := range m.ParamTypes {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Execute) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, e := range m.Args {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Deallocate) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableLockInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LockType != 0 {
		n += 1 + sovPlan(uint64(m.LockType))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LockTables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TableLocks) > 0 {
		for _, e := range m.TableLocks {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnLockTables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPlan(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPlan(x uint64) (n int) {
	return sovPlan(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Type) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotNullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotNullable = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoIncr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoIncr = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			m.Scale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scale |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Const) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Const: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Const: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isnull", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Isnull = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field I8Val", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_I8Val{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field I16Val", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_I16Val{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field I32Val", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_I32Val{v}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field I64Val", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_I64Val{v}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field U8Val", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_U8Val{v}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field U16Val", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_U16Val{v}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field U32Val", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_U32Val{v}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field U64Val", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_U64Val{v}
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dval", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = &Const_Dval{float64(math.Float64frombits(v))}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &Const_Sval{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bval", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &Const_Bval{b}
		case 13:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fval", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Value = &Const_Fval{float32(math.Float32frombits(v))}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dateval", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_Dateval{v}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeval", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_Timeval{v}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datetimeval", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_Datetimeval{v}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimal64Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Decimal64{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Const_Decimal64Val{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimal128Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Decimal128{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Const_Decimal128Val{v}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestampval", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_Timestampval{v}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jsonval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &Const_Jsonval{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defaultval", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &Const_Defaultval{b}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateVal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &Const_UpdateVal{b}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBin = bool(v != 0)
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Src == nil {
				m.Src = &Expr{}
			}
			if err := m.Src.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParamRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParamRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParamRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VarRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VarRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VarRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field System", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.System = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Global = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelPos", wireType)
			}
			m.RelPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColPos", wireType)
			}
			m.ColPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawColRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawColRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawColRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TblId", wireType)
			}
			m.TblId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TblId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColId", wireType)
			}
			m.ColId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CorrColRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CorrColRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CorrColRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelPos", wireType)
			}
			m.RelPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColPos", wireType)
			}
			m.ColPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depth", wireType)
			}
			m.Depth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Depth |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExprList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExprList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExprList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &Expr{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaxValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaxValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaxValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TargetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Typ == nil {
				m.Typ = &Type{}
			}
			if err := m.Typ.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubqueryRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubqueryRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubqueryRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			m.Typ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typ |= SubqueryRef_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Op = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Expr{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowSize", wireType)
			}
			m.RowSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			m.Server = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Server |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Db", wireType)
			}
			m.Db = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Db |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			m.Schema = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Schema |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Obj", wireType)
			}
			m.Obj = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Obj |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubscriptionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubAccountId", wireType)
			}
			m.PubAccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PubAccountId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscriptionMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriptionMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriptionMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			m.AccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Function) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Function: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Function: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Func", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Func == nil {
				m.Func = &ObjectRef{}
			}
			if err := m.Func.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, &Expr{})
			if err := m.Args[len(m.Args)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Expr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Typ == nil {
				m.Typ = &Type{}
			}
			if err := m.Typ.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field C", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Const{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_C{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ParamRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_P{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VarRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_V{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Col", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Col{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Raw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RawColRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Raw{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Function{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_F{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sub", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SubqueryRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Sub{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Corr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CorrColRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Corr{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TargetType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_T{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ExprList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_List{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MaxValue{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Max{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Decimal64) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: decimal64: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: decimal64: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			m.A = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.A |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Decimal128) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: decimal128: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: decimal128: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			m.A = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.A |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			m.B = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.B |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultColDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultColDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultColDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultCols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResultCols = append(m.ResultCols, &ColDef{})
			if err := m.ResultCols[len(m.ResultCols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColId", wireType)
			}
			m.ColId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hidden = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alg", wireType)
			}
			m.Alg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alg |= CompressType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Typ == nil {
				m.Typ = &Type{}
			}
			if err := m.Typ.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotNull", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotNull = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Default == nil {
				m.Default = &Default{}
			}
			if err := m.Default.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OnUpdate == nil {
				m.OnUpdate = &OnUpdate{}
			}
			if err := m.OnUpdate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowCard", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LowCard = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClusterBy = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Primary = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pkidx", wireType)
			}
			m.Pkidx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pkidx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seqnum", wireType)
			}
			m.Seqnum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seqnum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Default) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Default: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Default: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullAbility", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NullAbility = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateExtraTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateExtraTable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimaryKeyDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimaryKeyDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimaryKeyDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cols = append(m.Cols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Cols) == 0 {
					m.Cols = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cols = append(m.Cols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkeyColId", wireType)
			}
			m.PkeyColId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PkeyColId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Option == nil {
				m.Option = &IndexOption{}
			}
			if err := m.Option.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkeyColName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PkeyColName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompPkeyCol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompPkeyCol == nil {
				m.CompPkeyCol = &ColDef{}
			}
			if err := m.CompPkeyCol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parts = append(m.Parts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unique = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableExist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TableExist = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Visible = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Option == nil {
				m.Option = &IndexOption{}
			}
			if err := m.Option.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForeignKeyDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForeignKeyDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForeignKeyDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cols = append(m.Cols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Cols) == 0 {
					m.Cols = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cols = append(m.Cols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForeignTbl", wireType)
			}
			m.ForeignTbl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForeignTbl |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ForeignCols = append(m.ForeignCols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ForeignCols) == 0 {
					m.ForeignCols = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ForeignCols = append(m.ForeignCols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ForeignCols", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDelete", wireType)
			}
			m.OnDelete = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnDelete |= ForeignKeyDef_RefAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnUpdate", wireType)
			}
			m.OnUpdate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnUpdate |= ForeignKeyDef_RefAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Check", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Check == nil {
				m.Check = &Expr{}
			}
			if err := m.Check.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterByDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterByDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterByDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parts = append(m.Parts, &Expr{})
			if err := m.Parts[len(m.Parts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropertyDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropertyDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropertyDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Property) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Property: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Property: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropertiesDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropertiesDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropertiesDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = append(m.Properties, &Property{})
			if err := m.Properties[len(m.Properties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionByDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionByDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionByDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= PartitionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PartitionExpr == nil {
				m.PartitionExpr = &PartitionExpr{}
			}
			if err := m.PartitionExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionExpression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PartitionExpression == nil {
				m.PartitionExpression = &Expr{}
			}
			if err := m.PartitionExpression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PartitionColumns == nil {
				m.PartitionColumns = &PartitionColumns{}
			}
			if err := m.PartitionColumns.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionNum", wireType)
			}
			m.PartitionNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partitions = append(m.Partitions, &PartitionItem{})
			if err := m.Partitions[len(m.Partitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algorithm", wireType)
			}
			m.Algorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algorithm |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSubPartition", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSubPartition = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTableNames = append(m.PartitionTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExprStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExprStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionColumns) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionColumns: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionColumns: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &Expr{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionColumns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionColumns = append(m.PartitionColumns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrdinalPosition", wireType)
			}
			m.OrdinalPosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrdinalPosition |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LessThan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LessThan = append(m.LessThan, &Expr{})
			if err := m.LessThan[len(m.LessThan)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InValues = append(m.InValues, &Expr{})
			if err := m.InValues[len(m.InValues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.View = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TblId", wireType)
			}
			m.TblId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TblId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hidden = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cols = append(m.Cols, &ColDef{})
			if err := m.Cols[len(m.Cols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Createsql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Createsql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TblFunc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TblFunc == nil {
				m.TblFunc = &TableFunction{}
			}
			if err := m.TblFunc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pkey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pkey == nil {
				m.Pkey = &PrimaryKeyDef{}
			}
			if err := m.Pkey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Indexes = append(m.Indexes, &IndexDef{})
			if err := m.Indexes[len(m.Indexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fkeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fkeys = append(m.Fkeys, &ForeignKeyDef{})
			if err := m.Fkeys[len(m.Fkeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RefChildTbls = append(m.RefChildTbls, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RefChildTbls) == 0 {
					m.RefChildTbls = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RefChildTbls = append(m.RefChildTbls, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RefChildTbls", wireType)
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checks = append(m.Checks, &CheckDef{})
			if err := m.Checks[len(m.Checks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Partition == nil {
				m.Partition = &PartitionByDef{}
			}
			if err := m.Partition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterBy == nil {
				m.ClusterBy = &ClusterByDef{}
			}
			if err := m.ClusterBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Props", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Props = append(m.Props, &PropertyDef{})
			if err := m.Props[len(m.Props)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewSql", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ViewSql == nil {
				m.ViewSql = &ViewDef{}
			}
			if err := m.ViewSql.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Defs = append(m.Defs, &TableDef_DefType{})
			if err := m.Defs[len(m.Defs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name2ColIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name2ColIndex == nil {
				m.Name2ColIndex = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPlan
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPlan
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPlan(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPlan
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Name2ColIndex[mapkey] = mapvalue
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLocked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLocked = bool(v != 0)
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableLockType", wireType)
			}
			m.TableLockType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableLockType |= TableLockType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDef_DefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PropertiesDef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Def = &TableDef_DefType_Properties{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableFunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableFunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableFunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Param = append(m.Param[:0], dAtA[iNdEx:postIndex]...)
			if m.Param == nil {
				m.Param = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNum", wireType)
			}
			m.BlockNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Cost = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outcnt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Outcnt = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rowsize", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Rowsize = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashmapSize", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.HashmapSize = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableCnt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TableCnt = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selectivity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Selectivity = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &Expr{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowsetData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowsetData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowsetData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cols = append(m.Cols, &ColData{})
			if err := m.Cols[len(m.Cols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderBySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderBySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderBySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= OrderBySpec_OrderByFlag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionBy = append(m.PartitionBy, &Expr{})
			if err := m.PartitionBy[len(m.PartitionBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBy = append(m.OrderBy, &OrderBySpec{})
			if err := m.OrderBy[len(m.OrderBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lead", wireType)
			}
			m.Lead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lead |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lag", wireType)
			}
			m.Lag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsertCtx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsertCtx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsertCtx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ref == nil {
				m.Ref = &ObjectRef{}
			}
			if err := m.Ref.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OnDuplicateIdx = append(m.OnDuplicateIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OnDuplicateIdx) == 0 {
					m.OnDuplicateIdx = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OnDuplicateIdx = append(m.OnDuplicateIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDuplicateIdx", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDuplicateExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OnDuplicateExpr == nil {
				m.OnDuplicateExpr = make(map[string]*Expr)
			}
			var mapkey string
			var mapvalue *Expr
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPlan
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPlan
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPlan
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPlan
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Expr{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPlan(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPlan
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.OnDuplicateExpr[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdxRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdxRef = append(m.IdxRef, &ObjectRef{})
			if err := m.IdxRef[len(m.IdxRef)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IdxIdx = append(m.IdxIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IdxIdx) == 0 {
					m.IdxIdx = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IdxIdx = append(m.IdxIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IdxIdx", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentIdx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParentIdx == nil {
				m.ParentIdx = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPlan
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPlan
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPlan(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPlan
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ParentIdx[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterTable == nil {
				m.ClusterTable = &ClusterTable{}
			}
			if err := m.ClusterTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateCtx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateCtx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateCtx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = append(m.Ref, &ObjectRef{})
			if err := m.Ref[len(m.Ref)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Idx = append(m.Idx, &IdList{})
			if err := m.Idx[len(m.Idx)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDefs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableDefs = append(m.TableDefs, &TableDef{})
			if err := m.TableDefs[len(m.TableDefs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdateCol = append(m.UpdateCol, &ColPosMap{})
			if err := m.UpdateCol[len(m.UpdateCol)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdxRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdxRef = append(m.IdxRef, &ObjectRef{})
			if err := m.IdxRef[len(m.IdxRef)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IdxIdx = append(m.IdxIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IdxIdx) == 0 {
					m.IdxIdx = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IdxIdx = append(m.IdxIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IdxIdx", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnRestrictRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnRestrictRef = append(m.OnRestrictRef, &ObjectRef{})
			if err := m.OnRestrictRef[len(m.OnRestrictRef)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OnRestrictIdx = append(m.OnRestrictIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OnRestrictIdx) == 0 {
					m.OnRestrictIdx = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OnRestrictIdx = append(m.OnRestrictIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OnRestrictIdx", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnCascadeRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnCascadeRef = append(m.OnCascadeRef, &ObjectRef{})
			if err := m.OnCascadeRef[len(m.OnCascadeRef)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnCascadeIdx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnCascadeIdx = append(m.OnCascadeIdx, &IdList{})
			if err := m.OnCascadeIdx[len(m.OnCascadeIdx)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnCascadeDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnCascadeDef = append(m.OnCascadeDef, &TableDef{})
			if err := m.OnCascadeDef[len(m.OnCascadeDef)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnCascadeUpdateCol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnCascadeUpdateCol = append(m.OnCascadeUpdateCol, &ColPosMap{})
			if err := m.OnCascadeUpdateCol[len(m.OnCascadeUpdateCol)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnSetRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnSetRef = append(m.OnSetRef, &ObjectRef{})
			if err := m.OnSetRef[len(m.OnSetRef)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnSetIdx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnSetIdx = append(m.OnSetIdx, &IdList{})
			if err := m.OnSetIdx[len(m.OnSetIdx)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnSetDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnSetDef = append(m.OnSetDef, &TableDef{})
			if err := m.OnSetDef[len(m.OnSetDef)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnSetUpdateCol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnSetUpdateCol = append(m.OnSetUpdateCol, &ColPosMap{})
			if err := m.OnSetUpdateCol[len(m.OnSetUpdateCol)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentIdx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentIdx = append(m.ParentIdx, &ColPosMap{})
			if err := m.ParentIdx[len(m.ParentIdx)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnalyzeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalyzeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalyzeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputRows", wireType)
			}
			m.InputRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputRows |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputRows", wireType)
			}
			m.OutputRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputRows |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputSize", wireType)
			}
			m.InputSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputSize", wireType)
			}
			m.OutputSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeConsumed", wireType)
			}
			m.TimeConsumed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeConsumed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemorySize", wireType)
			}
			m.MemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemorySize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitTimeConsumed", wireType)
			}
			m.WaitTimeConsumed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitTimeConsumed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskIO", wireType)
			}
			m.DiskIO = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskIO |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3IOByte", wireType)
			}
			m.S3IOByte = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.S3IOByte |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3IOInputCount", wireType)
			}
			m.S3IOInputCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.S3IOInputCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3IOOutputCount", wireType)
			}
			m.S3IOOutputCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.S3IOOutputCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkIO", wireType)
			}
			m.NetworkIO = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkIO |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanTime", wireType)
			}
			m.ScanTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScanTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertTime", wireType)
			}
			m.InsertTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InsertTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeType", wireType)
			}
			m.NodeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeType |= Node_NodeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &Stats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Children = append(m.Children, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Children) == 0 {
					m.Children = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Children = append(m.Children, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectList = append(m.ProjectList, &Expr{})
			if err := m.ProjectList[len(m.ProjectList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinType", wireType)
			}
			m.JoinType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinType |= Node_JoinType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnList = append(m.OnList, &Expr{})
			if err := m.OnList[len(m.OnList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildOnLeft", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BuildOnLeft = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilterList = append(m.FilterList, &Expr{})
			if err := m.FilterList[len(m.FilterList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = append(m.GroupBy, &Expr{})
			if err := m.GroupBy[len(m.GroupBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupingSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupingSet = append(m.GroupingSet, &Expr{})
			if err := m.GroupingSet[len(m.GroupingSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggList = append(m.AggList, &Expr{})
			if err := m.AggList[len(m.AggList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WinSpec == nil {
				m.WinSpec = &WindowSpec{}
			}
			if err := m.WinSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBy = append(m.OrderBy, &OrderBySpec{})
			if err := m.OrderBy[len(m.OrderBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limit == nil {
				m.Limit = &Expr{}
			}
			if err := m.Limit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Offset == nil {
				m.Offset = &Expr{}
			}
			if err := m.Offset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateCtx == nil {
				m.UpdateCtx = &UpdateCtx{}
			}
			if err := m.UpdateCtx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDefVec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableDefVec = append(m.TableDefVec, &TableDef{})
			if err := m.TableDefVec[len(m.TableDefVec)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjRef == nil {
				m.ObjRef = &ObjectRef{}
			}
			if err := m.ObjRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowsetData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RowsetData == nil {
				m.RowsetData = &RowsetData{}
			}
			if err := m.RowsetData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraOptions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraOptions = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteCtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteCtx == nil {
				m.DeleteCtx = &DeleteCtx{}
			}
			if err := m.DeleteCtx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BindingTags = append(m.BindingTags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BindingTags) == 0 {
					m.BindingTags = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BindingTags = append(m.BindingTags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BindingTags", wireType)
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalyzeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnalyzeInfo == nil {
				m.AnalyzeInfo = &AnalyzeInfo{}
			}
			if err := m.AnalyzeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TblFuncExprList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TblFuncExprList = append(m.TblFuncExprList, &Expr{})
			if err := m.TblFuncExprList[len(m.TblFuncExprList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parallelism", wireType)
			}
			m.Parallelism = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Parallelism |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterTable == nil {
				m.ClusterTable = &ClusterTable{}
			}
			if err := m.ClusterTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotCacheable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotCacheable = bool(v != 0)
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertCtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InsertCtx == nil {
				m.InsertCtx = &InsertCtx{}
			}
			if err := m.InsertCtx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentStep", wireType)
			}
			m.CurrentStep = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentStep |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceStep", wireType)
			}
			m.SourceStep = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceStep |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.List = append(m.List, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.List) == 0 {
					m.List = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.List = append(m.List, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColPosMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColPosMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColPosMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Map == nil {
				m.Map = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPlan
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPlan
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPlan(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPlan
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Map[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteCtx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteCtx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteCtx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = append(m.Ref, &ObjectRef{})
			if err := m.Ref[len(m.Ref)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Idx = append(m.Idx, &IdList{})
			if err := m.Idx[len(m.Idx)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdxRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdxRef = append(m.IdxRef, &ObjectRef{})
			if err := m.IdxRef[len(m.IdxRef)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IdxIdx = append(m.IdxIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IdxIdx) == 0 {
					m.IdxIdx = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IdxIdx = append(m.IdxIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IdxIdx", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnRestrictRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnRestrictRef = append(m.OnRestrictRef, &ObjectRef{})
			if err := m.OnRestrictRef[len(m.OnRestrictRef)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OnRestrictIdx = append(m.OnRestrictIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OnRestrictIdx) == 0 {
					m.OnRestrictIdx = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OnRestrictIdx = append(m.OnRestrictIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OnRestrictIdx", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnCascadeRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnCascadeRef = append(m.OnCascadeRef, &ObjectRef{})
			if err := m.OnCascadeRef[len(m.OnCascadeRef)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OnCascadeIdx = append(m.OnCascadeIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OnCascadeIdx) == 0 {
					m.OnCascadeIdx = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OnCascadeIdx = append(m.OnCascadeIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OnCascadeIdx", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnSetRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnSetRef = append(m.OnSetRef, &ObjectRef{})
			if err := m.OnSetRef[len(m.OnSetRef)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnSetDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnSetDef = append(m.OnSetDef, &TableDef{})
			if err := m.OnSetDef[len(m.OnSetDef)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnSetIdx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnSetIdx = append(m.OnSetIdx, &IdList{})
			if err := m.OnSetIdx[len(m.OnSetIdx)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnSetUpdateCol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnSetUpdateCol = append(m.OnSetUpdateCol, &ColPosMap{})
			if err := m.OnSetUpdateCol[len(m.OnSetUpdateCol)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanTruncate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanTruncate = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Query) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Query: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Query: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StmtType", wireType)
			}
			m.StmtType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StmtType |= Query_StatementType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Steps = append(m.Steps, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Steps) == 0 {
					m.Steps = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Steps = append(m.Steps, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params, &Expr{})
			if err := m.Params[len(m.Params)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headings = append(m.Headings, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadTag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LoadTag = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransationControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransationControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransationControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TclType", wireType)
			}
			m.TclType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TclType |= TransationControl_TclType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TransationBegin{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &TransationControl_Begin{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TransationCommit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &TransationControl_Commit{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rollback", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TransationRollback{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &TransationControl_Rollback{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransationBegin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransationBegin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransationBegin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= TransationBegin_TransationMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransationCommit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransationCommit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransationCommit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionType", wireType)
			}
			m.CompletionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletionType |= TransationCompletionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransationRollback) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransationRollback: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransationRollback: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionType", wireType)
			}
			m.CompletionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletionType |= TransationCompletionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Plan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Plan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Plan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Query{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Plan = &Plan_Query{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tcl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TransationControl{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Plan = &Plan_Tcl{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ddl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataDefinition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Plan = &Plan_Ddl{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dcl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataControl{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Plan = &Plan_Dcl{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachedPlan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AttachedPlan == nil {
				m.AttachedPlan = &Plan{}
			}
			if err := m.AttachedPlan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Column) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: column: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: column: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Column = append(m.Column, &Expr{})
			if err := m.Column[len(m.Column)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DclType", wireType)
			}
			m.DclType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DclType |= DataControl_DclType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetVariables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SetVariables{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Control = &DataControl_SetVariables{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prepare", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Prepare{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Control = &DataControl_Prepare{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Execute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Execute{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Control = &DataControl_Execute{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deallocate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Deallocate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Control = &DataControl_Deallocate{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DdlType", wireType)
			}
			m.DdlType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DdlType |= DataDefinition_DdlType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &Query{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateDatabase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateDatabase{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_CreateDatabase{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterDatabase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterDatabase{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_AlterDatabase{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropDatabase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DropDatabase{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_DropDatabase{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_CreateTable{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_AlterTable{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DropTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_DropTable{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_CreateIndex{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_AlterIndex{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DropIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_DropIndex{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TruncateTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TruncateTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_TruncateTable{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowVariables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShowVariables{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_ShowVariables{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterView", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterView{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_AlterView{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LockTables{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_LockTables{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UnLockTables{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_UnlockTables{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateSequence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateSequence{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_CreateSequence{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropSequence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DropSequence{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_DropSequence{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterSequence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterSequence{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_AlterSequence{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscriptionOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriptionOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriptionOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publication", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Publication = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateDatabase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateDatabase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateDatabase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfNotExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfNotExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubscriptionOption == nil {
				m.SubscriptionOption = &SubscriptionOption{}
			}
			if err := m.SubscriptionOption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterDatabase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterDatabase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterDatabase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropDatabase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropDatabase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropDatabase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FkColName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FkColName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FkColName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cols = append(m.Cols, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfNotExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfNotExists = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temporary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Temporary = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTables = append(m.IndexTables, &TableDef{})
			if err := m.IndexTables[len(m.IndexTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FkDbs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FkDbs = append(m.FkDbs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FkTables", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FkTables = append(m.FkTables, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FkCols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FkCols = append(m.FkCols, &FkColName{})
			if err := m.FkCols[len(m.FkCols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTables = append(m.PartitionTables, &TableDef{})
			if err := m.PartitionTables[len(m.PartitionTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTableDrop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTableDrop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTableDrop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			m.Typ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typ |= AlterTableDrop_Typ(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTableAddFk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTableAddFk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTableAddFk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cols = append(m.Cols, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fkey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fkey == nil {
				m.Fkey = &ForeignKeyDef{}
			}
			if err := m.Fkey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTableAddIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTableAddIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTableAddIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginTablePrimaryKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginTablePrimaryKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IndexInfo == nil {
				m.IndexInfo = &CreateTable{}
			}
			if err := m.IndexInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTableExist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IndexTableExist = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTableDropIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTableDropIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTableDropIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTableAlterIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTableAlterIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTableAlterIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Visible = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClusterTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClusterTable = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &AlterTable_Action{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTable_Action) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Action: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Action: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterTableDrop{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AlterTable_Action_Drop{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddFk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterTableAddFk{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AlterTable_Action_AddFk{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterTableAddIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AlterTable_Action_AddIndex{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterTableAlterIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AlterTable_Action_AlterIndex{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTableNames = append(m.IndexTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterTable == nil {
				m.ClusterTable = &ClusterTable{}
			}
			if err := m.ClusterTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ForeignTbl = append(m.ForeignTbl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ForeignTbl) == 0 {
					m.ForeignTbl = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ForeignTbl = append(m.ForeignTbl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ForeignTbl", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTableNames = append(m.PartitionTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfNotExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfNotExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginTablePrimaryKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginTablePrimaryKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Index == nil {
				m.Index = &CreateTable{}
			}
			if err := m.Index.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableExist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TableExist = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TruncateTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TruncateTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TruncateTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTableNames = append(m.IndexTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterTable == nil {
				m.ClusterTable = &ClusterTable{}
			}
			if err := m.ClusterTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ForeignTbl = append(m.ForeignTbl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ForeignTbl) == 0 {
					m.ForeignTbl = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ForeignTbl = append(m.ForeignTbl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ForeignTbl", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClusterTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClusterTable = bool(v != 0)
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AccountIDs = append(m.AccountIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AccountIDs) == 0 {
					m.AccountIDs = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AccountIDs = append(m.AccountIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountIDs", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIndexOfAccountId", wireType)
			}
			m.ColumnIndexOfAccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnIndexOfAccountId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowVariables) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowVariables: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowVariables: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Global = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Where = append(m.Where, &Expr{})
			if err := m.Where[len(m.Where)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetVariables) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetVariables: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetVariables: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &SetVariablesItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetVariablesItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetVariablesItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetVariablesItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field System", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.System = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Global = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Expr{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reserved == nil {
				m.Reserved = &Expr{}
			}
			if err := m.Reserved.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Prepare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Prepare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Prepare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schemas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schemas = append(m.Schemas, &ObjectRef{})
			if err := m.Schemas[len(m.Schemas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Plan == nil {
				m.Plan = &Plan{}
			}
			if err := m.Plan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ParamTypes = append(m.ParamTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ParamTypes) == 0 {
					m.ParamTypes = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ParamTypes = append(m.ParamTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ParamTypes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Execute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Execute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Execute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, &Expr{})
			if err := m.Args[len(m.Args)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deallocate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deallocate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deallocate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableLockInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableLockInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableLockInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockType", wireType)
			}
			m.LockType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockType |= TableLockType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockTables) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockTables: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockTables: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableLocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableLocks = append(m.TableLocks, &TableLockInfo{})
			if err := m.TableLocks[len(m.TableLocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnLockTables) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnLockTables: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnLockTables: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPlan(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPlan
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPlan
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPlan
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPlan        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPlan          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPlan = fmt.Errorf("proto: unexpected end of group")
)
