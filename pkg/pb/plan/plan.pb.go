// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: plan.proto

package plan

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type CompressType int32

const (
	CompressType_None CompressType = 0
	CompressType_Lz4  CompressType = 1
)

var CompressType_name = map[int32]string{
	0: "None",
	1: "Lz4",
}

var CompressType_value = map[string]int32{
	"None": 0,
	"Lz4":  1,
}

func (x CompressType) String() string {
	return proto.EnumName(CompressType_name, int32(x))
}

func (CompressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{0}
}

type TransationCompletionType int32

const (
	TransationCompletionType_CHAIN    TransationCompletionType = 0
	TransationCompletionType_NO_CHAIN TransationCompletionType = 1
	TransationCompletionType_RELEASE  TransationCompletionType = 2
)

var TransationCompletionType_name = map[int32]string{
	0: "CHAIN",
	1: "NO_CHAIN",
	2: "RELEASE",
}

var TransationCompletionType_value = map[string]int32{
	"CHAIN":    0,
	"NO_CHAIN": 1,
	"RELEASE":  2,
}

func (x TransationCompletionType) String() string {
	return proto.EnumName(TransationCompletionType_name, int32(x))
}

func (TransationCompletionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{1}
}

type Type_TypeId int32

const (
	Type_ANY  Type_TypeId = 0
	Type_STAR Type_TypeId = 1
	Type_BOOL Type_TypeId = 10
	// INTs
	Type_INT8   Type_TypeId = 20
	Type_INT16  Type_TypeId = 21
	Type_INT32  Type_TypeId = 22
	Type_INT64  Type_TypeId = 23
	Type_INT128 Type_TypeId = 24
	// UINT are mysql quirks.
	Type_UINT8      Type_TypeId = 25
	Type_UINT16     Type_TypeId = 26
	Type_UINT32     Type_TypeId = 27
	Type_UINT64     Type_TypeId = 28
	Type_UINT128    Type_TypeId = 29
	Type_FLOAT32    Type_TypeId = 30
	Type_FLOAT64    Type_TypeId = 31
	Type_DECIMAL64  Type_TypeId = 32
	Type_DECIMAL128 Type_TypeId = 33
	Type_DECIMAL    Type_TypeId = 34
	Type_ANYINT     Type_TypeId = 37
	Type_ANYFLOAT   Type_TypeId = 38
	Type_ANYNUMBER  Type_TypeId = 39
	// Some special small (<= 32 bytes) fixed len types that worth optimize
	Type_UUID  Type_TypeId = 40
	Type_UB160 Type_TypeId = 41
	Type_UB184 Type_TypeId = 42
	Type_UB192 Type_TypeId = 43
	Type_UB224 Type_TypeId = 44
	Type_UB256 Type_TypeId = 45
	// Time
	Type_DATE      Type_TypeId = 50
	Type_TIME      Type_TypeId = 51
	Type_DATETIME  Type_TypeId = 52
	Type_TIMESTAMP Type_TypeId = 53
	Type_INTERVAL  Type_TypeId = 54
	Type_ANYTIME   Type_TypeId = 59
	// Strings and binaries
	Type_CHAR      Type_TypeId = 60
	Type_VARCHAR   Type_TypeId = 61
	Type_JSON      Type_TypeId = 62
	Type_BINARY    Type_TypeId = 70
	Type_VARBINARY Type_TypeId = 71
	// Special
	Type_ARRAY      Type_TypeId = 90
	Type_FLEXBUFFER Type_TypeId = 91
	// Physical for varlen
	Type_BYTEA8  Type_TypeId = 100
	Type_BYTEA16 Type_TypeId = 101
	Type_BYTEA   Type_TypeId = 102
	// MO Special, not sure if we really need these.
	Type_SEL   Type_TypeId = 200
	Type_TUPLE Type_TypeId = 201
)

var Type_TypeId_name = map[int32]string{
	0:   "ANY",
	1:   "STAR",
	10:  "BOOL",
	20:  "INT8",
	21:  "INT16",
	22:  "INT32",
	23:  "INT64",
	24:  "INT128",
	25:  "UINT8",
	26:  "UINT16",
	27:  "UINT32",
	28:  "UINT64",
	29:  "UINT128",
	30:  "FLOAT32",
	31:  "FLOAT64",
	32:  "DECIMAL64",
	33:  "DECIMAL128",
	34:  "DECIMAL",
	37:  "ANYINT",
	38:  "ANYFLOAT",
	39:  "ANYNUMBER",
	40:  "UUID",
	41:  "UB160",
	42:  "UB184",
	43:  "UB192",
	44:  "UB224",
	45:  "UB256",
	50:  "DATE",
	51:  "TIME",
	52:  "DATETIME",
	53:  "TIMESTAMP",
	54:  "INTERVAL",
	59:  "ANYTIME",
	60:  "CHAR",
	61:  "VARCHAR",
	62:  "JSON",
	70:  "BINARY",
	71:  "VARBINARY",
	90:  "ARRAY",
	91:  "FLEXBUFFER",
	100: "BYTEA8",
	101: "BYTEA16",
	102: "BYTEA",
	200: "SEL",
	201: "TUPLE",
}

var Type_TypeId_value = map[string]int32{
	"ANY":        0,
	"STAR":       1,
	"BOOL":       10,
	"INT8":       20,
	"INT16":      21,
	"INT32":      22,
	"INT64":      23,
	"INT128":     24,
	"UINT8":      25,
	"UINT16":     26,
	"UINT32":     27,
	"UINT64":     28,
	"UINT128":    29,
	"FLOAT32":    30,
	"FLOAT64":    31,
	"DECIMAL64":  32,
	"DECIMAL128": 33,
	"DECIMAL":    34,
	"ANYINT":     37,
	"ANYFLOAT":   38,
	"ANYNUMBER":  39,
	"UUID":       40,
	"UB160":      41,
	"UB184":      42,
	"UB192":      43,
	"UB224":      44,
	"UB256":      45,
	"DATE":       50,
	"TIME":       51,
	"DATETIME":   52,
	"TIMESTAMP":  53,
	"INTERVAL":   54,
	"ANYTIME":    59,
	"CHAR":       60,
	"VARCHAR":    61,
	"JSON":       62,
	"BINARY":     70,
	"VARBINARY":  71,
	"ARRAY":      90,
	"FLEXBUFFER": 91,
	"BYTEA8":     100,
	"BYTEA16":    101,
	"BYTEA":      102,
	"SEL":        200,
	"TUPLE":      201,
}

func (x Type_TypeId) String() string {
	return proto.EnumName(Type_TypeId_name, int32(x))
}

func (Type_TypeId) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{0, 0}
}

// Function flags
type Function_FuncFlag int32

const (
	Function_NONE Function_FuncFlag = 0
	// Internal function is generated by system, cannot
	// by called by user.
	Function_INTERNAL Function_FuncFlag = 1
	// Function, by default is immutable.
	Function_STABLE   Function_FuncFlag = 2
	Function_VOLATILE Function_FuncFlag = 4
	// Nulls
	Function_STRICT          Function_FuncFlag = 8
	Function_PRODUCE_NULL    Function_FuncFlag = 16
	Function_PRODUCE_NO_NULL Function_FuncFlag = 32
	// Vararg, all trailing args must be of the same type.
	Function_VARARG Function_FuncFlag = 64
	// Window and Agg
	Function_AGG Function_FuncFlag = 128
	Function_WIN Function_FuncFlag = 256
)

var Function_FuncFlag_name = map[int32]string{
	0:   "NONE",
	1:   "INTERNAL",
	2:   "STABLE",
	4:   "VOLATILE",
	8:   "STRICT",
	16:  "PRODUCE_NULL",
	32:  "PRODUCE_NO_NULL",
	64:  "VARARG",
	128: "AGG",
	256: "WIN",
}

var Function_FuncFlag_value = map[string]int32{
	"NONE":            0,
	"INTERNAL":        1,
	"STABLE":          2,
	"VOLATILE":        4,
	"STRICT":          8,
	"PRODUCE_NULL":    16,
	"PRODUCE_NO_NULL": 32,
	"VARARG":          64,
	"AGG":             128,
	"WIN":             256,
}

func (x Function_FuncFlag) String() string {
	return proto.EnumName(Function_FuncFlag_name, int32(x))
}

func (Function_FuncFlag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{10, 0}
}

type IndexDef_IndexType int32

const (
	IndexDef_INVAILD IndexDef_IndexType = 0
	IndexDef_ZONEMAP IndexDef_IndexType = 1
	IndexDef_BSI     IndexDef_IndexType = 2
)

var IndexDef_IndexType_name = map[int32]string{
	0: "INVAILD",
	1: "ZONEMAP",
	2: "BSI",
}

var IndexDef_IndexType_value = map[string]int32{
	"INVAILD": 0,
	"ZONEMAP": 1,
	"BSI":     2,
}

func (x IndexDef_IndexType) String() string {
	return proto.EnumName(IndexDef_IndexType_name, int32(x))
}

func (IndexDef_IndexType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{16, 0}
}

type OrderBySpec_OrderByFlag int32

const (
	OrderBySpec_ASC         OrderBySpec_OrderByFlag = 0
	OrderBySpec_DESC        OrderBySpec_OrderByFlag = 1
	OrderBySpec_NULLS_FIRST OrderBySpec_OrderByFlag = 2
	OrderBySpec_NULLS_LAST  OrderBySpec_OrderByFlag = 4
	OrderBySpec_UNIQUE      OrderBySpec_OrderByFlag = 8
	OrderBySpec_INTERNAL    OrderBySpec_OrderByFlag = 16
)

var OrderBySpec_OrderByFlag_name = map[int32]string{
	0:  "ASC",
	1:  "DESC",
	2:  "NULLS_FIRST",
	4:  "NULLS_LAST",
	8:  "UNIQUE",
	16: "INTERNAL",
}

var OrderBySpec_OrderByFlag_value = map[string]int32{
	"ASC":         0,
	"DESC":        1,
	"NULLS_FIRST": 2,
	"NULLS_LAST":  4,
	"UNIQUE":      8,
	"INTERNAL":    16,
}

func (x OrderBySpec_OrderByFlag) String() string {
	return proto.EnumName(OrderBySpec_OrderByFlag_name, int32(x))
}

func (OrderBySpec_OrderByFlag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{24, 0}
}

type Node_NodeType int32

const (
	Node_UNKNOWN Node_NodeType = 0
	// Scans
	Node_VALUE_SCAN    Node_NodeType = 1
	Node_TABLE_SCAN    Node_NodeType = 2
	Node_FUNCTION_SCAN Node_NodeType = 3
	Node_EXTERNAL_SCAN Node_NodeType = 4
	Node_MATERIAL_SCAN Node_NodeType = 5
	// Proj, for convenience
	Node_PROJECT Node_NodeType = 10
	// External function call (UDF)
	Node_EXTERNAL_FUNCTION Node_NodeType = 11
	// Material, CTE, etc.
	Node_MATERIAL      Node_NodeType = 20
	Node_RECURSIVE_CTE Node_NodeType = 21
	Node_SINK          Node_NodeType = 22
	Node_SINK_SCAN     Node_NodeType = 23
	// Proper Relational Operators
	Node_AGG       Node_NodeType = 30
	Node_JOIN      Node_NodeType = 31
	Node_SAMPLE    Node_NodeType = 32
	Node_SORT      Node_NodeType = 33
	Node_UNION     Node_NodeType = 34
	Node_UNION_ALL Node_NodeType = 35
	Node_UNIQUE    Node_NodeType = 36
	Node_WINDOW    Node_NodeType = 37
	// Physical tuple mover
	Node_BROADCAST Node_NodeType = 40
	Node_SPLIT     Node_NodeType = 41
	Node_GATHER    Node_NodeType = 42
	// Misc
	Node_ASSERT Node_NodeType = 50
	//
	Node_INSERT Node_NodeType = 51
	Node_UPDATE Node_NodeType = 52
	Node_DELETE Node_NodeType = 53
)

var Node_NodeType_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "VALUE_SCAN",
	2:  "TABLE_SCAN",
	3:  "FUNCTION_SCAN",
	4:  "EXTERNAL_SCAN",
	5:  "MATERIAL_SCAN",
	10: "PROJECT",
	11: "EXTERNAL_FUNCTION",
	20: "MATERIAL",
	21: "RECURSIVE_CTE",
	22: "SINK",
	23: "SINK_SCAN",
	30: "AGG",
	31: "JOIN",
	32: "SAMPLE",
	33: "SORT",
	34: "UNION",
	35: "UNION_ALL",
	36: "UNIQUE",
	37: "WINDOW",
	40: "BROADCAST",
	41: "SPLIT",
	42: "GATHER",
	50: "ASSERT",
	51: "INSERT",
	52: "UPDATE",
	53: "DELETE",
}

var Node_NodeType_value = map[string]int32{
	"UNKNOWN":           0,
	"VALUE_SCAN":        1,
	"TABLE_SCAN":        2,
	"FUNCTION_SCAN":     3,
	"EXTERNAL_SCAN":     4,
	"MATERIAL_SCAN":     5,
	"PROJECT":           10,
	"EXTERNAL_FUNCTION": 11,
	"MATERIAL":          20,
	"RECURSIVE_CTE":     21,
	"SINK":              22,
	"SINK_SCAN":         23,
	"AGG":               30,
	"JOIN":              31,
	"SAMPLE":            32,
	"SORT":              33,
	"UNION":             34,
	"UNION_ALL":         35,
	"UNIQUE":            36,
	"WINDOW":            37,
	"BROADCAST":         40,
	"SPLIT":             41,
	"GATHER":            42,
	"ASSERT":            50,
	"INSERT":            51,
	"UPDATE":            52,
	"DELETE":            53,
}

func (x Node_NodeType) String() string {
	return proto.EnumName(Node_NodeType_name, int32(x))
}

func (Node_NodeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{27, 0}
}

type Node_JoinFlag int32

const (
	Node_INNER  Node_JoinFlag = 0
	Node_OUTER  Node_JoinFlag = 1
	Node_SEMI   Node_JoinFlag = 2
	Node_ANTI   Node_JoinFlag = 4
	Node_SINGLE Node_JoinFlag = 8
	Node_MARK   Node_JoinFlag = 16
	Node_APPLY  Node_JoinFlag = 32
)

var Node_JoinFlag_name = map[int32]string{
	0:  "INNER",
	1:  "OUTER",
	2:  "SEMI",
	4:  "ANTI",
	8:  "SINGLE",
	16: "MARK",
	32: "APPLY",
}

var Node_JoinFlag_value = map[string]int32{
	"INNER":  0,
	"OUTER":  1,
	"SEMI":   2,
	"ANTI":   4,
	"SINGLE": 8,
	"MARK":   16,
	"APPLY":  32,
}

func (x Node_JoinFlag) String() string {
	return proto.EnumName(Node_JoinFlag_name, int32(x))
}

func (Node_JoinFlag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{27, 1}
}

type Node_AggMode int32

const (
	Node_FULL   Node_AggMode = 0
	Node_BOTTOM Node_AggMode = 1
	Node_TOP    Node_AggMode = 2
)

var Node_AggMode_name = map[int32]string{
	0: "FULL",
	1: "BOTTOM",
	2: "TOP",
}

var Node_AggMode_value = map[string]int32{
	"FULL":   0,
	"BOTTOM": 1,
	"TOP":    2,
}

func (x Node_AggMode) String() string {
	return proto.EnumName(Node_AggMode_name, int32(x))
}

func (Node_AggMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{27, 2}
}

type Query_StatementType int32

const (
	Query_UNKNOWN Query_StatementType = 0
	Query_SELECT  Query_StatementType = 1
	Query_INSERT  Query_StatementType = 2
	Query_DELETE  Query_StatementType = 3
	Query_UPDATE  Query_StatementType = 4
	Query_MERGE   Query_StatementType = 5
)

var Query_StatementType_name = map[int32]string{
	0: "UNKNOWN",
	1: "SELECT",
	2: "INSERT",
	3: "DELETE",
	4: "UPDATE",
	5: "MERGE",
}

var Query_StatementType_value = map[string]int32{
	"UNKNOWN": 0,
	"SELECT":  1,
	"INSERT":  2,
	"DELETE":  3,
	"UPDATE":  4,
	"MERGE":   5,
}

func (x Query_StatementType) String() string {
	return proto.EnumName(Query_StatementType_name, int32(x))
}

func (Query_StatementType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{28, 0}
}

type TransationControl_TclType int32

const (
	TransationControl_BEGIN    TransationControl_TclType = 0
	TransationControl_COMMIT   TransationControl_TclType = 1
	TransationControl_ROLLBACK TransationControl_TclType = 2
)

var TransationControl_TclType_name = map[int32]string{
	0: "BEGIN",
	1: "COMMIT",
	2: "ROLLBACK",
}

var TransationControl_TclType_value = map[string]int32{
	"BEGIN":    0,
	"COMMIT":   1,
	"ROLLBACK": 2,
}

func (x TransationControl_TclType) String() string {
	return proto.EnumName(TransationControl_TclType_name, int32(x))
}

func (TransationControl_TclType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{29, 0}
}

type TransationBegin_TransationMode int32

const (
	TransationBegin_NONE       TransationBegin_TransationMode = 0
	TransationBegin_READ_ONLY  TransationBegin_TransationMode = 1
	TransationBegin_READ_WRITE TransationBegin_TransationMode = 2
)

var TransationBegin_TransationMode_name = map[int32]string{
	0: "NONE",
	1: "READ_ONLY",
	2: "READ_WRITE",
}

var TransationBegin_TransationMode_value = map[string]int32{
	"NONE":       0,
	"READ_ONLY":  1,
	"READ_WRITE": 2,
}

func (x TransationBegin_TransationMode) String() string {
	return proto.EnumName(TransationBegin_TransationMode_name, int32(x))
}

func (TransationBegin_TransationMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{30, 0}
}

type DataDefinition_DdlType int32

const (
	DataDefinition_CREATE_DATABASE     DataDefinition_DdlType = 0
	DataDefinition_ALTER_DATABASE      DataDefinition_DdlType = 1
	DataDefinition_DROP_DATABASE       DataDefinition_DdlType = 2
	DataDefinition_CREATE_TABLE        DataDefinition_DdlType = 3
	DataDefinition_ALTER_TABLE         DataDefinition_DdlType = 4
	DataDefinition_DROP_TABLE          DataDefinition_DdlType = 5
	DataDefinition_CREATE_INDEX        DataDefinition_DdlType = 6
	DataDefinition_ALTER_INDEX         DataDefinition_DdlType = 7
	DataDefinition_DROP_INDEX          DataDefinition_DdlType = 8
	DataDefinition_TRUNCATE_TABLE      DataDefinition_DdlType = 9
	DataDefinition_SHOW_CREATEDATABASE DataDefinition_DdlType = 10
	DataDefinition_SHOW_CREATETABLE    DataDefinition_DdlType = 11
	DataDefinition_SHOW_DATABASES      DataDefinition_DdlType = 12
	DataDefinition_SHOW_TABLES         DataDefinition_DdlType = 13
	DataDefinition_SHOW_COLUMNS        DataDefinition_DdlType = 14
	DataDefinition_SHOW_INDEX          DataDefinition_DdlType = 15
	DataDefinition_SHOW_VARIABLES      DataDefinition_DdlType = 16
	DataDefinition_SHOW_WARNINGS       DataDefinition_DdlType = 17
	DataDefinition_SHOW_ERRORS         DataDefinition_DdlType = 18
	DataDefinition_SHOW_STATUS         DataDefinition_DdlType = 19
	DataDefinition_SHOW_PROCESSLIST    DataDefinition_DdlType = 20
)

var DataDefinition_DdlType_name = map[int32]string{
	0:  "CREATE_DATABASE",
	1:  "ALTER_DATABASE",
	2:  "DROP_DATABASE",
	3:  "CREATE_TABLE",
	4:  "ALTER_TABLE",
	5:  "DROP_TABLE",
	6:  "CREATE_INDEX",
	7:  "ALTER_INDEX",
	8:  "DROP_INDEX",
	9:  "TRUNCATE_TABLE",
	10: "SHOW_CREATEDATABASE",
	11: "SHOW_CREATETABLE",
	12: "SHOW_DATABASES",
	13: "SHOW_TABLES",
	14: "SHOW_COLUMNS",
	15: "SHOW_INDEX",
	16: "SHOW_VARIABLES",
	17: "SHOW_WARNINGS",
	18: "SHOW_ERRORS",
	19: "SHOW_STATUS",
	20: "SHOW_PROCESSLIST",
}

var DataDefinition_DdlType_value = map[string]int32{
	"CREATE_DATABASE":     0,
	"ALTER_DATABASE":      1,
	"DROP_DATABASE":       2,
	"CREATE_TABLE":        3,
	"ALTER_TABLE":         4,
	"DROP_TABLE":          5,
	"CREATE_INDEX":        6,
	"ALTER_INDEX":         7,
	"DROP_INDEX":          8,
	"TRUNCATE_TABLE":      9,
	"SHOW_CREATEDATABASE": 10,
	"SHOW_CREATETABLE":    11,
	"SHOW_DATABASES":      12,
	"SHOW_TABLES":         13,
	"SHOW_COLUMNS":        14,
	"SHOW_INDEX":          15,
	"SHOW_VARIABLES":      16,
	"SHOW_WARNINGS":       17,
	"SHOW_ERRORS":         18,
	"SHOW_STATUS":         19,
	"SHOW_PROCESSLIST":    20,
}

func (x DataDefinition_DdlType) String() string {
	return proto.EnumName(DataDefinition_DdlType_name, int32(x))
}

func (DataDefinition_DdlType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{34, 0}
}

type Type struct {
	Id                   Type_TypeId `protobuf:"varint,1,opt,name=id,proto3,enum=plan.Type_TypeId" json:"id,omitempty"`
	Nullable             bool        `protobuf:"varint,2,opt,name=nullable,proto3" json:"nullable,omitempty"`
	Width                int32       `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
	Precision            int32       `protobuf:"varint,4,opt,name=precision,proto3" json:"precision,omitempty"`
	Size                 int32       `protobuf:"varint,5,opt,name=size,proto3" json:"size,omitempty"`
	Scale                int32       `protobuf:"varint,6,opt,name=scale,proto3" json:"scale,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Type) Reset()         { *m = Type{} }
func (m *Type) String() string { return proto.CompactTextString(m) }
func (*Type) ProtoMessage()    {}
func (*Type) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{0}
}
func (m *Type) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Type) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Type.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Type) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Type.Merge(m, src)
}
func (m *Type) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Type) XXX_DiscardUnknown() {
	xxx_messageInfo_Type.DiscardUnknown(m)
}

var xxx_messageInfo_Type proto.InternalMessageInfo

func (m *Type) GetId() Type_TypeId {
	if m != nil {
		return m.Id
	}
	return Type_ANY
}

func (m *Type) GetNullable() bool {
	if m != nil {
		return m.Nullable
	}
	return false
}

func (m *Type) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Type) GetPrecision() int32 {
	if m != nil {
		return m.Precision
	}
	return 0
}

func (m *Type) GetSize() int32 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *Type) GetScale() int32 {
	if m != nil {
		return m.Scale
	}
	return 0
}

// Const: if a const value can be reprensented by int64 or
// double, use that, otherwise store a string representation.
type Const struct {
	Isnull bool `protobuf:"varint,1,opt,name=isnull,proto3" json:"isnull,omitempty"`
	// Types that are valid to be assigned to Value:
	//	*Const_Ival
	//	*Const_Dval
	//	*Const_Sval
	//	*Const_Bval
	Value                isConst_Value `protobuf_oneof:"value"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Const) Reset()         { *m = Const{} }
func (m *Const) String() string { return proto.CompactTextString(m) }
func (*Const) ProtoMessage()    {}
func (*Const) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{1}
}
func (m *Const) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Const) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Const.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Const) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Const.Merge(m, src)
}
func (m *Const) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Const) XXX_DiscardUnknown() {
	xxx_messageInfo_Const.DiscardUnknown(m)
}

var xxx_messageInfo_Const proto.InternalMessageInfo

type isConst_Value interface {
	isConst_Value()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type Const_Ival struct {
	Ival int64 `protobuf:"varint,2,opt,name=ival,proto3,oneof"`
}
type Const_Dval struct {
	Dval float64 `protobuf:"fixed64,3,opt,name=dval,proto3,oneof"`
}
type Const_Sval struct {
	Sval string `protobuf:"bytes,4,opt,name=sval,proto3,oneof"`
}
type Const_Bval struct {
	Bval bool `protobuf:"varint,5,opt,name=bval,proto3,oneof"`
}

func (*Const_Ival) isConst_Value() {}
func (*Const_Dval) isConst_Value() {}
func (*Const_Sval) isConst_Value() {}
func (*Const_Bval) isConst_Value() {}

func (m *Const) GetValue() isConst_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Const) GetIsnull() bool {
	if m != nil {
		return m.Isnull
	}
	return false
}

func (m *Const) GetIval() int64 {
	if x, ok := m.GetValue().(*Const_Ival); ok {
		return x.Ival
	}
	return 0
}

func (m *Const) GetDval() float64 {
	if x, ok := m.GetValue().(*Const_Dval); ok {
		return x.Dval
	}
	return 0
}

func (m *Const) GetSval() string {
	if x, ok := m.GetValue().(*Const_Sval); ok {
		return x.Sval
	}
	return ""
}

func (m *Const) GetBval() bool {
	if x, ok := m.GetValue().(*Const_Bval); ok {
		return x.Bval
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Const) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Const_OneofMarshaler, _Const_OneofUnmarshaler, _Const_OneofSizer, []interface{}{
		(*Const_Ival)(nil),
		(*Const_Dval)(nil),
		(*Const_Sval)(nil),
		(*Const_Bval)(nil),
	}
}

func _Const_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Const)
	// value
	switch x := m.Value.(type) {
	case *Const_Ival:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Ival))
	case *Const_Dval:
		_ = b.EncodeVarint(3<<3 | proto.WireFixed64)
		_ = b.EncodeFixed64(math.Float64bits(x.Dval))
	case *Const_Sval:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Sval)
	case *Const_Bval:
		t := uint64(0)
		if x.Bval {
			t = 1
		}
		_ = b.EncodeVarint(5<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("Const.Value has unexpected type %T", x)
	}
	return nil
}

func _Const_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Const)
	switch tag {
	case 2: // value.ival
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Const_Ival{int64(x)}
		return true, err
	case 3: // value.dval
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.Value = &Const_Dval{math.Float64frombits(x)}
		return true, err
	case 4: // value.sval
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &Const_Sval{x}
		return true, err
	case 5: // value.bval
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Const_Bval{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _Const_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Const)
	// value
	switch x := m.Value.(type) {
	case *Const_Ival:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Ival))
	case *Const_Dval:
		n += 1 // tag and wire
		n += 8
	case *Const_Sval:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Sval)))
		n += len(x.Sval)
	case *Const_Bval:
		n += 1 // tag and wire
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Bounded param for prepared statement.  User fill on execution.
type ParamRef struct {
	Pos                  int32    `protobuf:"varint,1,opt,name=pos,proto3" json:"pos,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ParamRef) Reset()         { *m = ParamRef{} }
func (m *ParamRef) String() string { return proto.CompactTextString(m) }
func (*ParamRef) ProtoMessage()    {}
func (*ParamRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{2}
}
func (m *ParamRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParamRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParamRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParamRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParamRef.Merge(m, src)
}
func (m *ParamRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ParamRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ParamRef.DiscardUnknown(m)
}

var xxx_messageInfo_ParamRef proto.InternalMessageInfo

func (m *ParamRef) GetPos() int32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

// Session variable ref, compiler should fold.
type VarRef struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VarRef) Reset()         { *m = VarRef{} }
func (m *VarRef) String() string { return proto.CompactTextString(m) }
func (*VarRef) ProtoMessage()    {}
func (*VarRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{3}
}
func (m *VarRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VarRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VarRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VarRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VarRef.Merge(m, src)
}
func (m *VarRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *VarRef) XXX_DiscardUnknown() {
	xxx_messageInfo_VarRef.DiscardUnknown(m)
}

var xxx_messageInfo_VarRef proto.InternalMessageInfo

func (m *VarRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Reference a column in the proj list of a node.
type ColRef struct {
	RelPos               int32    `protobuf:"varint,1,opt,name=rel_pos,json=relPos,proto3" json:"rel_pos,omitempty"`
	ColPos               int32    `protobuf:"varint,2,opt,name=col_pos,json=colPos,proto3" json:"col_pos,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ColRef) Reset()         { *m = ColRef{} }
func (m *ColRef) String() string { return proto.CompactTextString(m) }
func (*ColRef) ProtoMessage()    {}
func (*ColRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{4}
}
func (m *ColRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColRef.Merge(m, src)
}
func (m *ColRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ColRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ColRef.DiscardUnknown(m)
}

var xxx_messageInfo_ColRef proto.InternalMessageInfo

func (m *ColRef) GetRelPos() int32 {
	if m != nil {
		return m.RelPos
	}
	return 0
}

func (m *ColRef) GetColPos() int32 {
	if m != nil {
		return m.ColPos
	}
	return 0
}

// Reference a correlated column in the proj list of a node.
type CorrColRef struct {
	NodeId               int32    `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	ColPos               int32    `protobuf:"varint,2,opt,name=col_pos,json=colPos,proto3" json:"col_pos,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CorrColRef) Reset()         { *m = CorrColRef{} }
func (m *CorrColRef) String() string { return proto.CompactTextString(m) }
func (*CorrColRef) ProtoMessage()    {}
func (*CorrColRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{5}
}
func (m *CorrColRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CorrColRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CorrColRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CorrColRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CorrColRef.Merge(m, src)
}
func (m *CorrColRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CorrColRef) XXX_DiscardUnknown() {
	xxx_messageInfo_CorrColRef.DiscardUnknown(m)
}

var xxx_messageInfo_CorrColRef proto.InternalMessageInfo

func (m *CorrColRef) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *CorrColRef) GetColPos() int32 {
	if m != nil {
		return m.ColPos
	}
	return 0
}

// ExprList is a type of Expr
type ExprList struct {
	List                 []*Expr  `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExprList) Reset()         { *m = ExprList{} }
func (m *ExprList) String() string { return proto.CompactTextString(m) }
func (*ExprList) ProtoMessage()    {}
func (*ExprList) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{6}
}
func (m *ExprList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExprList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExprList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExprList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExprList.Merge(m, src)
}
func (m *ExprList) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExprList) XXX_DiscardUnknown() {
	xxx_messageInfo_ExprList.DiscardUnknown(m)
}

var xxx_messageInfo_ExprList proto.InternalMessageInfo

func (m *ExprList) GetList() []*Expr {
	if m != nil {
		return m.List
	}
	return nil
}

// TargetType used in cast function as target type
type TargetType struct {
	Typ                  *Type    `protobuf:"bytes,1,opt,name=typ,proto3" json:"typ,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TargetType) Reset()         { *m = TargetType{} }
func (m *TargetType) String() string { return proto.CompactTextString(m) }
func (*TargetType) ProtoMessage()    {}
func (*TargetType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{7}
}
func (m *TargetType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TargetType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TargetType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TargetType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TargetType.Merge(m, src)
}
func (m *TargetType) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TargetType) XXX_DiscardUnknown() {
	xxx_messageInfo_TargetType.DiscardUnknown(m)
}

var xxx_messageInfo_TargetType proto.InternalMessageInfo

func (m *TargetType) GetTyp() *Type {
	if m != nil {
		return m.Typ
	}
	return nil
}

// Reference a subquery
type SubQuery struct {
	NodeId               int32    `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	IsCorrelated         bool     `protobuf:"varint,2,opt,name=is_correlated,json=isCorrelated,proto3" json:"is_correlated,omitempty"`
	IsScalar             bool     `protobuf:"varint,3,opt,name=is_scalar,json=isScalar,proto3" json:"is_scalar,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubQuery) Reset()         { *m = SubQuery{} }
func (m *SubQuery) String() string { return proto.CompactTextString(m) }
func (*SubQuery) ProtoMessage()    {}
func (*SubQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{8}
}
func (m *SubQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubQuery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubQuery.Merge(m, src)
}
func (m *SubQuery) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SubQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_SubQuery.DiscardUnknown(m)
}

var xxx_messageInfo_SubQuery proto.InternalMessageInfo

func (m *SubQuery) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *SubQuery) GetIsCorrelated() bool {
	if m != nil {
		return m.IsCorrelated
	}
	return false
}

func (m *SubQuery) GetIsScalar() bool {
	if m != nil {
		return m.IsScalar
	}
	return false
}

// Object ref, reference a object in database, 4 part name.
type ObjectRef struct {
	Server               int64    `protobuf:"varint,1,opt,name=server,proto3" json:"server,omitempty"`
	Db                   int64    `protobuf:"varint,2,opt,name=db,proto3" json:"db,omitempty"`
	Schema               int64    `protobuf:"varint,3,opt,name=schema,proto3" json:"schema,omitempty"`
	Obj                  int64    `protobuf:"varint,4,opt,name=obj,proto3" json:"obj,omitempty"`
	ServerName           string   `protobuf:"bytes,5,opt,name=server_name,json=serverName,proto3" json:"server_name,omitempty"`
	DbName               string   `protobuf:"bytes,6,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	SchemaName           string   `protobuf:"bytes,7,opt,name=schema_name,json=schemaName,proto3" json:"schema_name,omitempty"`
	ObjName              string   `protobuf:"bytes,8,opt,name=obj_name,json=objName,proto3" json:"obj_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectRef) Reset()         { *m = ObjectRef{} }
func (m *ObjectRef) String() string { return proto.CompactTextString(m) }
func (*ObjectRef) ProtoMessage()    {}
func (*ObjectRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{9}
}
func (m *ObjectRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectRef.Merge(m, src)
}
func (m *ObjectRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ObjectRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectRef.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectRef proto.InternalMessageInfo

func (m *ObjectRef) GetServer() int64 {
	if m != nil {
		return m.Server
	}
	return 0
}

func (m *ObjectRef) GetDb() int64 {
	if m != nil {
		return m.Db
	}
	return 0
}

func (m *ObjectRef) GetSchema() int64 {
	if m != nil {
		return m.Schema
	}
	return 0
}

func (m *ObjectRef) GetObj() int64 {
	if m != nil {
		return m.Obj
	}
	return 0
}

func (m *ObjectRef) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

func (m *ObjectRef) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *ObjectRef) GetSchemaName() string {
	if m != nil {
		return m.SchemaName
	}
	return ""
}

func (m *ObjectRef) GetObjName() string {
	if m != nil {
		return m.ObjName
	}
	return ""
}

type Function struct {
	Func                 *ObjectRef `protobuf:"bytes,1,opt,name=func,proto3" json:"func,omitempty"`
	Args                 []*Expr    `protobuf:"bytes,2,rep,name=args,proto3" json:"args,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Function) Reset()         { *m = Function{} }
func (m *Function) String() string { return proto.CompactTextString(m) }
func (*Function) ProtoMessage()    {}
func (*Function) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{10}
}
func (m *Function) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Function) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Function.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Function) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Function.Merge(m, src)
}
func (m *Function) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Function) XXX_DiscardUnknown() {
	xxx_messageInfo_Function.DiscardUnknown(m)
}

var xxx_messageInfo_Function proto.InternalMessageInfo

func (m *Function) GetFunc() *ObjectRef {
	if m != nil {
		return m.Func
	}
	return nil
}

func (m *Function) GetArgs() []*Expr {
	if m != nil {
		return m.Args
	}
	return nil
}

type Expr struct {
	Typ       *Type  `protobuf:"bytes,1,opt,name=typ,proto3" json:"typ,omitempty"`
	TableName string `protobuf:"bytes,2,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	ColName   string `protobuf:"bytes,3,opt,name=col_name,json=colName,proto3" json:"col_name,omitempty"`
	// Types that are valid to be assigned to Expr:
	//	*Expr_C
	//	*Expr_P
	//	*Expr_V
	//	*Expr_Col
	//	*Expr_F
	//	*Expr_List
	//	*Expr_Sub
	//	*Expr_Corr
	//	*Expr_T
	Expr                 isExpr_Expr `protobuf_oneof:"expr"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Expr) Reset()         { *m = Expr{} }
func (m *Expr) String() string { return proto.CompactTextString(m) }
func (*Expr) ProtoMessage()    {}
func (*Expr) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{11}
}
func (m *Expr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Expr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Expr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Expr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Expr.Merge(m, src)
}
func (m *Expr) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Expr) XXX_DiscardUnknown() {
	xxx_messageInfo_Expr.DiscardUnknown(m)
}

var xxx_messageInfo_Expr proto.InternalMessageInfo

type isExpr_Expr interface {
	isExpr_Expr()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type Expr_C struct {
	C *Const `protobuf:"bytes,4,opt,name=c,proto3,oneof"`
}
type Expr_P struct {
	P *ParamRef `protobuf:"bytes,5,opt,name=p,proto3,oneof"`
}
type Expr_V struct {
	V *VarRef `protobuf:"bytes,6,opt,name=v,proto3,oneof"`
}
type Expr_Col struct {
	Col *ColRef `protobuf:"bytes,7,opt,name=col,proto3,oneof"`
}
type Expr_F struct {
	F *Function `protobuf:"bytes,8,opt,name=f,proto3,oneof"`
}
type Expr_List struct {
	List *ExprList `protobuf:"bytes,9,opt,name=list,proto3,oneof"`
}
type Expr_Sub struct {
	Sub *SubQuery `protobuf:"bytes,10,opt,name=sub,proto3,oneof"`
}
type Expr_Corr struct {
	Corr *CorrColRef `protobuf:"bytes,11,opt,name=corr,proto3,oneof"`
}
type Expr_T struct {
	T *TargetType `protobuf:"bytes,12,opt,name=t,proto3,oneof"`
}

func (*Expr_C) isExpr_Expr()    {}
func (*Expr_P) isExpr_Expr()    {}
func (*Expr_V) isExpr_Expr()    {}
func (*Expr_Col) isExpr_Expr()  {}
func (*Expr_F) isExpr_Expr()    {}
func (*Expr_List) isExpr_Expr() {}
func (*Expr_Sub) isExpr_Expr()  {}
func (*Expr_Corr) isExpr_Expr() {}
func (*Expr_T) isExpr_Expr()    {}

func (m *Expr) GetExpr() isExpr_Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Expr) GetTyp() *Type {
	if m != nil {
		return m.Typ
	}
	return nil
}

func (m *Expr) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *Expr) GetColName() string {
	if m != nil {
		return m.ColName
	}
	return ""
}

func (m *Expr) GetC() *Const {
	if x, ok := m.GetExpr().(*Expr_C); ok {
		return x.C
	}
	return nil
}

func (m *Expr) GetP() *ParamRef {
	if x, ok := m.GetExpr().(*Expr_P); ok {
		return x.P
	}
	return nil
}

func (m *Expr) GetV() *VarRef {
	if x, ok := m.GetExpr().(*Expr_V); ok {
		return x.V
	}
	return nil
}

func (m *Expr) GetCol() *ColRef {
	if x, ok := m.GetExpr().(*Expr_Col); ok {
		return x.Col
	}
	return nil
}

func (m *Expr) GetF() *Function {
	if x, ok := m.GetExpr().(*Expr_F); ok {
		return x.F
	}
	return nil
}

func (m *Expr) GetList() *ExprList {
	if x, ok := m.GetExpr().(*Expr_List); ok {
		return x.List
	}
	return nil
}

func (m *Expr) GetSub() *SubQuery {
	if x, ok := m.GetExpr().(*Expr_Sub); ok {
		return x.Sub
	}
	return nil
}

func (m *Expr) GetCorr() *CorrColRef {
	if x, ok := m.GetExpr().(*Expr_Corr); ok {
		return x.Corr
	}
	return nil
}

func (m *Expr) GetT() *TargetType {
	if x, ok := m.GetExpr().(*Expr_T); ok {
		return x.T
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Expr) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Expr_OneofMarshaler, _Expr_OneofUnmarshaler, _Expr_OneofSizer, []interface{}{
		(*Expr_C)(nil),
		(*Expr_P)(nil),
		(*Expr_V)(nil),
		(*Expr_Col)(nil),
		(*Expr_F)(nil),
		(*Expr_List)(nil),
		(*Expr_Sub)(nil),
		(*Expr_Corr)(nil),
		(*Expr_T)(nil),
	}
}

func _Expr_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Expr)
	// expr
	switch x := m.Expr.(type) {
	case *Expr_C:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.C); err != nil {
			return err
		}
	case *Expr_P:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.P); err != nil {
			return err
		}
	case *Expr_V:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.V); err != nil {
			return err
		}
	case *Expr_Col:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Col); err != nil {
			return err
		}
	case *Expr_F:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.F); err != nil {
			return err
		}
	case *Expr_List:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.List); err != nil {
			return err
		}
	case *Expr_Sub:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Sub); err != nil {
			return err
		}
	case *Expr_Corr:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Corr); err != nil {
			return err
		}
	case *Expr_T:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.T); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Expr.Expr has unexpected type %T", x)
	}
	return nil
}

func _Expr_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Expr)
	switch tag {
	case 4: // expr.c
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Const)
		err := b.DecodeMessage(msg)
		m.Expr = &Expr_C{msg}
		return true, err
	case 5: // expr.p
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ParamRef)
		err := b.DecodeMessage(msg)
		m.Expr = &Expr_P{msg}
		return true, err
	case 6: // expr.v
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VarRef)
		err := b.DecodeMessage(msg)
		m.Expr = &Expr_V{msg}
		return true, err
	case 7: // expr.col
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ColRef)
		err := b.DecodeMessage(msg)
		m.Expr = &Expr_Col{msg}
		return true, err
	case 8: // expr.f
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Function)
		err := b.DecodeMessage(msg)
		m.Expr = &Expr_F{msg}
		return true, err
	case 9: // expr.list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ExprList)
		err := b.DecodeMessage(msg)
		m.Expr = &Expr_List{msg}
		return true, err
	case 10: // expr.sub
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SubQuery)
		err := b.DecodeMessage(msg)
		m.Expr = &Expr_Sub{msg}
		return true, err
	case 11: // expr.corr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CorrColRef)
		err := b.DecodeMessage(msg)
		m.Expr = &Expr_Corr{msg}
		return true, err
	case 12: // expr.t
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TargetType)
		err := b.DecodeMessage(msg)
		m.Expr = &Expr_T{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Expr_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Expr)
	// expr
	switch x := m.Expr.(type) {
	case *Expr_C:
		s := proto.Size(x.C)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expr_P:
		s := proto.Size(x.P)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expr_V:
		s := proto.Size(x.V)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expr_Col:
		s := proto.Size(x.Col)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expr_F:
		s := proto.Size(x.F)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expr_List:
		s := proto.Size(x.List)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expr_Sub:
		s := proto.Size(x.Sub)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expr_Corr:
		s := proto.Size(x.Corr)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expr_T:
		s := proto.Size(x.T)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type DefaultExpr struct {
	Exist                bool           `protobuf:"varint,1,opt,name=exist,proto3" json:"exist,omitempty"`
	Value                *ConstantValue `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	IsNull               bool           `protobuf:"varint,3,opt,name=is_null,json=isNull,proto3" json:"is_null,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *DefaultExpr) Reset()         { *m = DefaultExpr{} }
func (m *DefaultExpr) String() string { return proto.CompactTextString(m) }
func (*DefaultExpr) ProtoMessage()    {}
func (*DefaultExpr) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{12}
}
func (m *DefaultExpr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DefaultExpr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DefaultExpr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DefaultExpr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DefaultExpr.Merge(m, src)
}
func (m *DefaultExpr) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DefaultExpr) XXX_DiscardUnknown() {
	xxx_messageInfo_DefaultExpr.DiscardUnknown(m)
}

var xxx_messageInfo_DefaultExpr proto.InternalMessageInfo

func (m *DefaultExpr) GetExist() bool {
	if m != nil {
		return m.Exist
	}
	return false
}

func (m *DefaultExpr) GetValue() *ConstantValue {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *DefaultExpr) GetIsNull() bool {
	if m != nil {
		return m.IsNull
	}
	return false
}

type ConstantValue struct {
	// Types that are valid to be assigned to ConstantValue:
	//	*ConstantValue_UnknownV
	//	*ConstantValue_Int64V
	//	*ConstantValue_Decimal64V
	//	*ConstantValue_Decimal128V
	//	*ConstantValue_Uint64V
	//	*ConstantValue_Float32V
	//	*ConstantValue_Float64V
	//	*ConstantValue_DateV
	//	*ConstantValue_DateTimeV
	//	*ConstantValue_TimeStampV
	//	*ConstantValue_StringV
	ConstantValue        isConstantValue_ConstantValue `protobuf_oneof:"constantValue"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *ConstantValue) Reset()         { *m = ConstantValue{} }
func (m *ConstantValue) String() string { return proto.CompactTextString(m) }
func (*ConstantValue) ProtoMessage()    {}
func (*ConstantValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{13}
}
func (m *ConstantValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConstantValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConstantValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConstantValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConstantValue.Merge(m, src)
}
func (m *ConstantValue) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ConstantValue) XXX_DiscardUnknown() {
	xxx_messageInfo_ConstantValue.DiscardUnknown(m)
}

var xxx_messageInfo_ConstantValue proto.InternalMessageInfo

type isConstantValue_ConstantValue interface {
	isConstantValue_ConstantValue()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type ConstantValue_UnknownV struct {
	UnknownV int32 `protobuf:"varint,1,opt,name=unknown_v,json=unknownV,proto3,oneof"`
}
type ConstantValue_Int64V struct {
	Int64V int64 `protobuf:"varint,2,opt,name=int64_v,json=int64V,proto3,oneof"`
}
type ConstantValue_Decimal64V struct {
	Decimal64V int64 `protobuf:"varint,3,opt,name=decimal64_v,json=decimal64V,proto3,oneof"`
}
type ConstantValue_Decimal128V struct {
	Decimal128V *Decimal128 `protobuf:"bytes,4,opt,name=decimal128_v,json=decimal128V,proto3,oneof"`
}
type ConstantValue_Uint64V struct {
	Uint64V uint64 `protobuf:"varint,5,opt,name=uint64_v,json=uint64V,proto3,oneof"`
}
type ConstantValue_Float32V struct {
	Float32V float32 `protobuf:"fixed32,6,opt,name=float32_v,json=float32V,proto3,oneof"`
}
type ConstantValue_Float64V struct {
	Float64V float64 `protobuf:"fixed64,7,opt,name=float64_v,json=float64V,proto3,oneof"`
}
type ConstantValue_DateV struct {
	DateV int32 `protobuf:"varint,8,opt,name=date_v,json=dateV,proto3,oneof"`
}
type ConstantValue_DateTimeV struct {
	DateTimeV int64 `protobuf:"varint,9,opt,name=dateTime_v,json=dateTimeV,proto3,oneof"`
}
type ConstantValue_TimeStampV struct {
	TimeStampV int64 `protobuf:"varint,10,opt,name=timeStamp_v,json=timeStampV,proto3,oneof"`
}
type ConstantValue_StringV struct {
	StringV string `protobuf:"bytes,11,opt,name=string_v,json=stringV,proto3,oneof"`
}

func (*ConstantValue_UnknownV) isConstantValue_ConstantValue()    {}
func (*ConstantValue_Int64V) isConstantValue_ConstantValue()      {}
func (*ConstantValue_Decimal64V) isConstantValue_ConstantValue()  {}
func (*ConstantValue_Decimal128V) isConstantValue_ConstantValue() {}
func (*ConstantValue_Uint64V) isConstantValue_ConstantValue()     {}
func (*ConstantValue_Float32V) isConstantValue_ConstantValue()    {}
func (*ConstantValue_Float64V) isConstantValue_ConstantValue()    {}
func (*ConstantValue_DateV) isConstantValue_ConstantValue()       {}
func (*ConstantValue_DateTimeV) isConstantValue_ConstantValue()   {}
func (*ConstantValue_TimeStampV) isConstantValue_ConstantValue()  {}
func (*ConstantValue_StringV) isConstantValue_ConstantValue()     {}

func (m *ConstantValue) GetConstantValue() isConstantValue_ConstantValue {
	if m != nil {
		return m.ConstantValue
	}
	return nil
}

func (m *ConstantValue) GetUnknownV() int32 {
	if x, ok := m.GetConstantValue().(*ConstantValue_UnknownV); ok {
		return x.UnknownV
	}
	return 0
}

func (m *ConstantValue) GetInt64V() int64 {
	if x, ok := m.GetConstantValue().(*ConstantValue_Int64V); ok {
		return x.Int64V
	}
	return 0
}

func (m *ConstantValue) GetDecimal64V() int64 {
	if x, ok := m.GetConstantValue().(*ConstantValue_Decimal64V); ok {
		return x.Decimal64V
	}
	return 0
}

func (m *ConstantValue) GetDecimal128V() *Decimal128 {
	if x, ok := m.GetConstantValue().(*ConstantValue_Decimal128V); ok {
		return x.Decimal128V
	}
	return nil
}

func (m *ConstantValue) GetUint64V() uint64 {
	if x, ok := m.GetConstantValue().(*ConstantValue_Uint64V); ok {
		return x.Uint64V
	}
	return 0
}

func (m *ConstantValue) GetFloat32V() float32 {
	if x, ok := m.GetConstantValue().(*ConstantValue_Float32V); ok {
		return x.Float32V
	}
	return 0
}

func (m *ConstantValue) GetFloat64V() float64 {
	if x, ok := m.GetConstantValue().(*ConstantValue_Float64V); ok {
		return x.Float64V
	}
	return 0
}

func (m *ConstantValue) GetDateV() int32 {
	if x, ok := m.GetConstantValue().(*ConstantValue_DateV); ok {
		return x.DateV
	}
	return 0
}

func (m *ConstantValue) GetDateTimeV() int64 {
	if x, ok := m.GetConstantValue().(*ConstantValue_DateTimeV); ok {
		return x.DateTimeV
	}
	return 0
}

func (m *ConstantValue) GetTimeStampV() int64 {
	if x, ok := m.GetConstantValue().(*ConstantValue_TimeStampV); ok {
		return x.TimeStampV
	}
	return 0
}

func (m *ConstantValue) GetStringV() string {
	if x, ok := m.GetConstantValue().(*ConstantValue_StringV); ok {
		return x.StringV
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ConstantValue) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ConstantValue_OneofMarshaler, _ConstantValue_OneofUnmarshaler, _ConstantValue_OneofSizer, []interface{}{
		(*ConstantValue_UnknownV)(nil),
		(*ConstantValue_Int64V)(nil),
		(*ConstantValue_Decimal64V)(nil),
		(*ConstantValue_Decimal128V)(nil),
		(*ConstantValue_Uint64V)(nil),
		(*ConstantValue_Float32V)(nil),
		(*ConstantValue_Float64V)(nil),
		(*ConstantValue_DateV)(nil),
		(*ConstantValue_DateTimeV)(nil),
		(*ConstantValue_TimeStampV)(nil),
		(*ConstantValue_StringV)(nil),
	}
}

func _ConstantValue_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ConstantValue)
	// constantValue
	switch x := m.ConstantValue.(type) {
	case *ConstantValue_UnknownV:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.UnknownV))
	case *ConstantValue_Int64V:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Int64V))
	case *ConstantValue_Decimal64V:
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Decimal64V))
	case *ConstantValue_Decimal128V:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Decimal128V); err != nil {
			return err
		}
	case *ConstantValue_Uint64V:
		_ = b.EncodeVarint(5<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Uint64V))
	case *ConstantValue_Float32V:
		_ = b.EncodeVarint(6<<3 | proto.WireFixed32)
		_ = b.EncodeFixed32(uint64(math.Float32bits(x.Float32V)))
	case *ConstantValue_Float64V:
		_ = b.EncodeVarint(7<<3 | proto.WireFixed64)
		_ = b.EncodeFixed64(math.Float64bits(x.Float64V))
	case *ConstantValue_DateV:
		_ = b.EncodeVarint(8<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.DateV))
	case *ConstantValue_DateTimeV:
		_ = b.EncodeVarint(9<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.DateTimeV))
	case *ConstantValue_TimeStampV:
		_ = b.EncodeVarint(10<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.TimeStampV))
	case *ConstantValue_StringV:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.StringV)
	case nil:
	default:
		return fmt.Errorf("ConstantValue.ConstantValue has unexpected type %T", x)
	}
	return nil
}

func _ConstantValue_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ConstantValue)
	switch tag {
	case 1: // constantValue.unknown_v
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ConstantValue = &ConstantValue_UnknownV{int32(x)}
		return true, err
	case 2: // constantValue.int64_v
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ConstantValue = &ConstantValue_Int64V{int64(x)}
		return true, err
	case 3: // constantValue.decimal64_v
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ConstantValue = &ConstantValue_Decimal64V{int64(x)}
		return true, err
	case 4: // constantValue.decimal128_v
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Decimal128)
		err := b.DecodeMessage(msg)
		m.ConstantValue = &ConstantValue_Decimal128V{msg}
		return true, err
	case 5: // constantValue.uint64_v
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ConstantValue = &ConstantValue_Uint64V{x}
		return true, err
	case 6: // constantValue.float32_v
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.ConstantValue = &ConstantValue_Float32V{math.Float32frombits(uint32(x))}
		return true, err
	case 7: // constantValue.float64_v
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.ConstantValue = &ConstantValue_Float64V{math.Float64frombits(x)}
		return true, err
	case 8: // constantValue.date_v
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ConstantValue = &ConstantValue_DateV{int32(x)}
		return true, err
	case 9: // constantValue.dateTime_v
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ConstantValue = &ConstantValue_DateTimeV{int64(x)}
		return true, err
	case 10: // constantValue.timeStamp_v
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ConstantValue = &ConstantValue_TimeStampV{int64(x)}
		return true, err
	case 11: // constantValue.string_v
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.ConstantValue = &ConstantValue_StringV{x}
		return true, err
	default:
		return false, nil
	}
}

func _ConstantValue_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ConstantValue)
	// constantValue
	switch x := m.ConstantValue.(type) {
	case *ConstantValue_UnknownV:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.UnknownV))
	case *ConstantValue_Int64V:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Int64V))
	case *ConstantValue_Decimal64V:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Decimal64V))
	case *ConstantValue_Decimal128V:
		s := proto.Size(x.Decimal128V)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ConstantValue_Uint64V:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Uint64V))
	case *ConstantValue_Float32V:
		n += 1 // tag and wire
		n += 4
	case *ConstantValue_Float64V:
		n += 1 // tag and wire
		n += 8
	case *ConstantValue_DateV:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.DateV))
	case *ConstantValue_DateTimeV:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.DateTimeV))
	case *ConstantValue_TimeStampV:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.TimeStampV))
	case *ConstantValue_StringV:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.StringV)))
		n += len(x.StringV)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Decimal128 struct {
	Lo                   int64    `protobuf:"varint,1,opt,name=Lo,proto3" json:"Lo,omitempty"`
	Hi                   int64    `protobuf:"varint,2,opt,name=Hi,proto3" json:"Hi,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Decimal128) Reset()         { *m = Decimal128{} }
func (m *Decimal128) String() string { return proto.CompactTextString(m) }
func (*Decimal128) ProtoMessage()    {}
func (*Decimal128) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{14}
}
func (m *Decimal128) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Decimal128) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Decimal128.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Decimal128) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Decimal128.Merge(m, src)
}
func (m *Decimal128) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Decimal128) XXX_DiscardUnknown() {
	xxx_messageInfo_Decimal128.DiscardUnknown(m)
}

var xxx_messageInfo_Decimal128 proto.InternalMessageInfo

func (m *Decimal128) GetLo() int64 {
	if m != nil {
		return m.Lo
	}
	return 0
}

func (m *Decimal128) GetHi() int64 {
	if m != nil {
		return m.Hi
	}
	return 0
}

type ColDef struct {
	Name                 string       `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Alias                string       `protobuf:"bytes,2,opt,name=alias,proto3" json:"alias,omitempty"`
	Alg                  CompressType `protobuf:"varint,3,opt,name=alg,proto3,enum=plan.CompressType" json:"alg,omitempty"`
	Typ                  *Type        `protobuf:"bytes,4,opt,name=typ,proto3" json:"typ,omitempty"`
	Default              *DefaultExpr `protobuf:"bytes,5,opt,name=default,proto3" json:"default,omitempty"`
	Primary              bool         `protobuf:"varint,6,opt,name=primary,proto3" json:"primary,omitempty"`
	Pkidx                int32        `protobuf:"varint,7,opt,name=pkidx,proto3" json:"pkidx,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ColDef) Reset()         { *m = ColDef{} }
func (m *ColDef) String() string { return proto.CompactTextString(m) }
func (*ColDef) ProtoMessage()    {}
func (*ColDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{15}
}
func (m *ColDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColDef.Merge(m, src)
}
func (m *ColDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ColDef) XXX_DiscardUnknown() {
	xxx_messageInfo_ColDef.DiscardUnknown(m)
}

var xxx_messageInfo_ColDef proto.InternalMessageInfo

func (m *ColDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ColDef) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

func (m *ColDef) GetAlg() CompressType {
	if m != nil {
		return m.Alg
	}
	return CompressType_None
}

func (m *ColDef) GetTyp() *Type {
	if m != nil {
		return m.Typ
	}
	return nil
}

func (m *ColDef) GetDefault() *DefaultExpr {
	if m != nil {
		return m.Default
	}
	return nil
}

func (m *ColDef) GetPrimary() bool {
	if m != nil {
		return m.Primary
	}
	return false
}

func (m *ColDef) GetPkidx() int32 {
	if m != nil {
		return m.Pkidx
	}
	return 0
}

type IndexDef struct {
	Typ                  IndexDef_IndexType `protobuf:"varint,1,opt,name=typ,proto3,enum=plan.IndexDef_IndexType" json:"typ,omitempty"`
	Name                 string             `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	ColNames             []string           `protobuf:"bytes,3,rep,name=col_names,json=colNames,proto3" json:"col_names,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *IndexDef) Reset()         { *m = IndexDef{} }
func (m *IndexDef) String() string { return proto.CompactTextString(m) }
func (*IndexDef) ProtoMessage()    {}
func (*IndexDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{16}
}
func (m *IndexDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexDef.Merge(m, src)
}
func (m *IndexDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *IndexDef) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexDef.DiscardUnknown(m)
}

var xxx_messageInfo_IndexDef proto.InternalMessageInfo

func (m *IndexDef) GetTyp() IndexDef_IndexType {
	if m != nil {
		return m.Typ
	}
	return IndexDef_INVAILD
}

func (m *IndexDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *IndexDef) GetColNames() []string {
	if m != nil {
		return m.ColNames
	}
	return nil
}

type PrimaryKeyDef struct {
	Names                []string `protobuf:"bytes,1,rep,name=names,proto3" json:"names,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PrimaryKeyDef) Reset()         { *m = PrimaryKeyDef{} }
func (m *PrimaryKeyDef) String() string { return proto.CompactTextString(m) }
func (*PrimaryKeyDef) ProtoMessage()    {}
func (*PrimaryKeyDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{17}
}
func (m *PrimaryKeyDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrimaryKeyDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrimaryKeyDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrimaryKeyDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrimaryKeyDef.Merge(m, src)
}
func (m *PrimaryKeyDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PrimaryKeyDef) XXX_DiscardUnknown() {
	xxx_messageInfo_PrimaryKeyDef.DiscardUnknown(m)
}

var xxx_messageInfo_PrimaryKeyDef proto.InternalMessageInfo

func (m *PrimaryKeyDef) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

type Property struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Property) Reset()         { *m = Property{} }
func (m *Property) String() string { return proto.CompactTextString(m) }
func (*Property) ProtoMessage()    {}
func (*Property) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{18}
}
func (m *Property) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Property) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Property.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Property) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Property.Merge(m, src)
}
func (m *Property) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Property) XXX_DiscardUnknown() {
	xxx_messageInfo_Property.DiscardUnknown(m)
}

var xxx_messageInfo_Property proto.InternalMessageInfo

func (m *Property) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Property) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type PropertiesDef struct {
	Properties           []*Property `protobuf:"bytes,1,rep,name=properties,proto3" json:"properties,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *PropertiesDef) Reset()         { *m = PropertiesDef{} }
func (m *PropertiesDef) String() string { return proto.CompactTextString(m) }
func (*PropertiesDef) ProtoMessage()    {}
func (*PropertiesDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{19}
}
func (m *PropertiesDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropertiesDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropertiesDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropertiesDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropertiesDef.Merge(m, src)
}
func (m *PropertiesDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PropertiesDef) XXX_DiscardUnknown() {
	xxx_messageInfo_PropertiesDef.DiscardUnknown(m)
}

var xxx_messageInfo_PropertiesDef proto.InternalMessageInfo

func (m *PropertiesDef) GetProperties() []*Property {
	if m != nil {
		return m.Properties
	}
	return nil
}

type TableDef struct {
	Name                 string              `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Alias                string              `protobuf:"bytes,2,opt,name=alias,proto3" json:"alias,omitempty"`
	Cols                 []*ColDef           `protobuf:"bytes,3,rep,name=cols,proto3" json:"cols,omitempty"`
	Defs                 []*TableDef_DefType `protobuf:"bytes,4,rep,name=defs,proto3" json:"defs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TableDef) Reset()         { *m = TableDef{} }
func (m *TableDef) String() string { return proto.CompactTextString(m) }
func (*TableDef) ProtoMessage()    {}
func (*TableDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{20}
}
func (m *TableDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDef.Merge(m, src)
}
func (m *TableDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableDef) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDef.DiscardUnknown(m)
}

var xxx_messageInfo_TableDef proto.InternalMessageInfo

func (m *TableDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TableDef) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

func (m *TableDef) GetCols() []*ColDef {
	if m != nil {
		return m.Cols
	}
	return nil
}

func (m *TableDef) GetDefs() []*TableDef_DefType {
	if m != nil {
		return m.Defs
	}
	return nil
}

type TableDef_DefType struct {
	// Types that are valid to be assigned to Def:
	//	*TableDef_DefType_Pk
	//	*TableDef_DefType_Idx
	//	*TableDef_DefType_Properties
	Def                  isTableDef_DefType_Def `protobuf_oneof:"def"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *TableDef_DefType) Reset()         { *m = TableDef_DefType{} }
func (m *TableDef_DefType) String() string { return proto.CompactTextString(m) }
func (*TableDef_DefType) ProtoMessage()    {}
func (*TableDef_DefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{20, 0}
}
func (m *TableDef_DefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDef_DefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableDef_DefType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableDef_DefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDef_DefType.Merge(m, src)
}
func (m *TableDef_DefType) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableDef_DefType) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDef_DefType.DiscardUnknown(m)
}

var xxx_messageInfo_TableDef_DefType proto.InternalMessageInfo

type isTableDef_DefType_Def interface {
	isTableDef_DefType_Def()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type TableDef_DefType_Pk struct {
	Pk *PrimaryKeyDef `protobuf:"bytes,1,opt,name=pk,proto3,oneof"`
}
type TableDef_DefType_Idx struct {
	Idx *IndexDef `protobuf:"bytes,2,opt,name=idx,proto3,oneof"`
}
type TableDef_DefType_Properties struct {
	Properties *PropertiesDef `protobuf:"bytes,3,opt,name=properties,proto3,oneof"`
}

func (*TableDef_DefType_Pk) isTableDef_DefType_Def()         {}
func (*TableDef_DefType_Idx) isTableDef_DefType_Def()        {}
func (*TableDef_DefType_Properties) isTableDef_DefType_Def() {}

func (m *TableDef_DefType) GetDef() isTableDef_DefType_Def {
	if m != nil {
		return m.Def
	}
	return nil
}

func (m *TableDef_DefType) GetPk() *PrimaryKeyDef {
	if x, ok := m.GetDef().(*TableDef_DefType_Pk); ok {
		return x.Pk
	}
	return nil
}

func (m *TableDef_DefType) GetIdx() *IndexDef {
	if x, ok := m.GetDef().(*TableDef_DefType_Idx); ok {
		return x.Idx
	}
	return nil
}

func (m *TableDef_DefType) GetProperties() *PropertiesDef {
	if x, ok := m.GetDef().(*TableDef_DefType_Properties); ok {
		return x.Properties
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TableDef_DefType) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TableDef_DefType_OneofMarshaler, _TableDef_DefType_OneofUnmarshaler, _TableDef_DefType_OneofSizer, []interface{}{
		(*TableDef_DefType_Pk)(nil),
		(*TableDef_DefType_Idx)(nil),
		(*TableDef_DefType_Properties)(nil),
	}
}

func _TableDef_DefType_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TableDef_DefType)
	// def
	switch x := m.Def.(type) {
	case *TableDef_DefType_Pk:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Pk); err != nil {
			return err
		}
	case *TableDef_DefType_Idx:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Idx); err != nil {
			return err
		}
	case *TableDef_DefType_Properties:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Properties); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TableDef_DefType.Def has unexpected type %T", x)
	}
	return nil
}

func _TableDef_DefType_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TableDef_DefType)
	switch tag {
	case 1: // def.pk
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PrimaryKeyDef)
		err := b.DecodeMessage(msg)
		m.Def = &TableDef_DefType_Pk{msg}
		return true, err
	case 2: // def.idx
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IndexDef)
		err := b.DecodeMessage(msg)
		m.Def = &TableDef_DefType_Idx{msg}
		return true, err
	case 3: // def.properties
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PropertiesDef)
		err := b.DecodeMessage(msg)
		m.Def = &TableDef_DefType_Properties{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TableDef_DefType_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TableDef_DefType)
	// def
	switch x := m.Def.(type) {
	case *TableDef_DefType_Pk:
		s := proto.Size(x.Pk)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TableDef_DefType_Idx:
		s := proto.Size(x.Idx)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TableDef_DefType_Properties:
		s := proto.Size(x.Properties)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Cost struct {
	Card                 float64  `protobuf:"fixed64,1,opt,name=card,proto3" json:"card,omitempty"`
	Rowsize              float64  `protobuf:"fixed64,2,opt,name=rowsize,proto3" json:"rowsize,omitempty"`
	Ndv                  float64  `protobuf:"fixed64,3,opt,name=ndv,proto3" json:"ndv,omitempty"`
	Start                float64  `protobuf:"fixed64,4,opt,name=start,proto3" json:"start,omitempty"`
	Total                float64  `protobuf:"fixed64,5,opt,name=total,proto3" json:"total,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Cost) Reset()         { *m = Cost{} }
func (m *Cost) String() string { return proto.CompactTextString(m) }
func (*Cost) ProtoMessage()    {}
func (*Cost) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{21}
}
func (m *Cost) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cost) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cost.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cost) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cost.Merge(m, src)
}
func (m *Cost) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Cost) XXX_DiscardUnknown() {
	xxx_messageInfo_Cost.DiscardUnknown(m)
}

var xxx_messageInfo_Cost proto.InternalMessageInfo

func (m *Cost) GetCard() float64 {
	if m != nil {
		return m.Card
	}
	return 0
}

func (m *Cost) GetRowsize() float64 {
	if m != nil {
		return m.Rowsize
	}
	return 0
}

func (m *Cost) GetNdv() float64 {
	if m != nil {
		return m.Ndv
	}
	return 0
}

func (m *Cost) GetStart() float64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Cost) GetTotal() float64 {
	if m != nil {
		return m.Total
	}
	return 0
}

type ColData struct {
	RowCount             int32     `protobuf:"varint,1,opt,name=row_count,json=rowCount,proto3" json:"row_count,omitempty"`
	NullCount            int32     `protobuf:"varint,2,opt,name=null_count,json=nullCount,proto3" json:"null_count,omitempty"`
	Nulls                []bool    `protobuf:"varint,3,rep,packed,name=nulls,proto3" json:"nulls,omitempty"`
	I32                  []int32   `protobuf:"varint,4,rep,packed,name=i32,proto3" json:"i32,omitempty"`
	I64                  []int64   `protobuf:"varint,5,rep,packed,name=i64,proto3" json:"i64,omitempty"`
	F32                  []float32 `protobuf:"fixed32,6,rep,packed,name=f32,proto3" json:"f32,omitempty"`
	F64                  []float64 `protobuf:"fixed64,7,rep,packed,name=f64,proto3" json:"f64,omitempty"`
	S                    []string  `protobuf:"bytes,8,rep,name=s,proto3" json:"s,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ColData) Reset()         { *m = ColData{} }
func (m *ColData) String() string { return proto.CompactTextString(m) }
func (*ColData) ProtoMessage()    {}
func (*ColData) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{22}
}
func (m *ColData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColData.Merge(m, src)
}
func (m *ColData) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ColData) XXX_DiscardUnknown() {
	xxx_messageInfo_ColData.DiscardUnknown(m)
}

var xxx_messageInfo_ColData proto.InternalMessageInfo

func (m *ColData) GetRowCount() int32 {
	if m != nil {
		return m.RowCount
	}
	return 0
}

func (m *ColData) GetNullCount() int32 {
	if m != nil {
		return m.NullCount
	}
	return 0
}

func (m *ColData) GetNulls() []bool {
	if m != nil {
		return m.Nulls
	}
	return nil
}

func (m *ColData) GetI32() []int32 {
	if m != nil {
		return m.I32
	}
	return nil
}

func (m *ColData) GetI64() []int64 {
	if m != nil {
		return m.I64
	}
	return nil
}

func (m *ColData) GetF32() []float32 {
	if m != nil {
		return m.F32
	}
	return nil
}

func (m *ColData) GetF64() []float64 {
	if m != nil {
		return m.F64
	}
	return nil
}

func (m *ColData) GetS() []string {
	if m != nil {
		return m.S
	}
	return nil
}

type RowsetData struct {
	Schema               *TableDef  `protobuf:"bytes,1,opt,name=schema,proto3" json:"schema,omitempty"`
	Cols                 []*ColData `protobuf:"bytes,2,rep,name=cols,proto3" json:"cols,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RowsetData) Reset()         { *m = RowsetData{} }
func (m *RowsetData) String() string { return proto.CompactTextString(m) }
func (*RowsetData) ProtoMessage()    {}
func (*RowsetData) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{23}
}
func (m *RowsetData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowsetData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RowsetData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RowsetData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowsetData.Merge(m, src)
}
func (m *RowsetData) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RowsetData) XXX_DiscardUnknown() {
	xxx_messageInfo_RowsetData.DiscardUnknown(m)
}

var xxx_messageInfo_RowsetData proto.InternalMessageInfo

func (m *RowsetData) GetSchema() *TableDef {
	if m != nil {
		return m.Schema
	}
	return nil
}

func (m *RowsetData) GetCols() []*ColData {
	if m != nil {
		return m.Cols
	}
	return nil
}

type OrderBySpec struct {
	Expr                 *Expr                   `protobuf:"bytes,1,opt,name=expr,proto3" json:"expr,omitempty"`
	Collation            string                  `protobuf:"bytes,2,opt,name=collation,proto3" json:"collation,omitempty"`
	Flag                 OrderBySpec_OrderByFlag `protobuf:"varint,3,opt,name=flag,proto3,enum=plan.OrderBySpec_OrderByFlag" json:"flag,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *OrderBySpec) Reset()         { *m = OrderBySpec{} }
func (m *OrderBySpec) String() string { return proto.CompactTextString(m) }
func (*OrderBySpec) ProtoMessage()    {}
func (*OrderBySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{24}
}
func (m *OrderBySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderBySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderBySpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderBySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderBySpec.Merge(m, src)
}
func (m *OrderBySpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *OrderBySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderBySpec.DiscardUnknown(m)
}

var xxx_messageInfo_OrderBySpec proto.InternalMessageInfo

func (m *OrderBySpec) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *OrderBySpec) GetCollation() string {
	if m != nil {
		return m.Collation
	}
	return ""
}

func (m *OrderBySpec) GetFlag() OrderBySpec_OrderByFlag {
	if m != nil {
		return m.Flag
	}
	return OrderBySpec_ASC
}

type WindowSpec struct {
	PartitionBy          []*Expr        `protobuf:"bytes,1,rep,name=partition_by,json=partitionBy,proto3" json:"partition_by,omitempty"`
	OrderBy              []*OrderBySpec `protobuf:"bytes,2,rep,name=order_by,json=orderBy,proto3" json:"order_by,omitempty"`
	Lead                 int32          `protobuf:"varint,3,opt,name=lead,proto3" json:"lead,omitempty"`
	Lag                  int32          `protobuf:"varint,4,opt,name=lag,proto3" json:"lag,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *WindowSpec) Reset()         { *m = WindowSpec{} }
func (m *WindowSpec) String() string { return proto.CompactTextString(m) }
func (*WindowSpec) ProtoMessage()    {}
func (*WindowSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{25}
}
func (m *WindowSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WindowSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WindowSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowSpec.Merge(m, src)
}
func (m *WindowSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *WindowSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowSpec.DiscardUnknown(m)
}

var xxx_messageInfo_WindowSpec proto.InternalMessageInfo

func (m *WindowSpec) GetPartitionBy() []*Expr {
	if m != nil {
		return m.PartitionBy
	}
	return nil
}

func (m *WindowSpec) GetOrderBy() []*OrderBySpec {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *WindowSpec) GetLead() int32 {
	if m != nil {
		return m.Lead
	}
	return 0
}

func (m *WindowSpec) GetLag() int32 {
	if m != nil {
		return m.Lag
	}
	return 0
}

type UpdateList struct {
	Columns              []*Expr  `protobuf:"bytes,1,rep,name=columns,proto3" json:"columns,omitempty"`
	Values               []*Expr  `protobuf:"bytes,2,rep,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateList) Reset()         { *m = UpdateList{} }
func (m *UpdateList) String() string { return proto.CompactTextString(m) }
func (*UpdateList) ProtoMessage()    {}
func (*UpdateList) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{26}
}
func (m *UpdateList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateList.Merge(m, src)
}
func (m *UpdateList) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UpdateList) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateList.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateList proto.InternalMessageInfo

func (m *UpdateList) GetColumns() []*Expr {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *UpdateList) GetValues() []*Expr {
	if m != nil {
		return m.Values
	}
	return nil
}

type Node struct {
	NodeType             Node_NodeType  `protobuf:"varint,1,opt,name=node_type,json=nodeType,proto3,enum=plan.Node_NodeType" json:"node_type,omitempty"`
	NodeId               int32          `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Cost                 *Cost          `protobuf:"bytes,3,opt,name=cost,proto3" json:"cost,omitempty"`
	ProjectList          []*Expr        `protobuf:"bytes,4,rep,name=project_list,json=projectList,proto3" json:"project_list,omitempty"`
	Children             []int32        `protobuf:"varint,5,rep,packed,name=children,proto3" json:"children,omitempty"`
	JoinType             Node_JoinFlag  `protobuf:"varint,6,opt,name=join_type,json=joinType,proto3,enum=plan.Node_JoinFlag" json:"join_type,omitempty"`
	OnList               []*Expr        `protobuf:"bytes,7,rep,name=on_list,json=onList,proto3" json:"on_list,omitempty"`
	WhereList            []*Expr        `protobuf:"bytes,8,rep,name=where_list,json=whereList,proto3" json:"where_list,omitempty"`
	GroupBy              []*Expr        `protobuf:"bytes,9,rep,name=group_by,json=groupBy,proto3" json:"group_by,omitempty"`
	GroupingSet          []*Expr        `protobuf:"bytes,10,rep,name=grouping_set,json=groupingSet,proto3" json:"grouping_set,omitempty"`
	AggList              []*Expr        `protobuf:"bytes,11,rep,name=agg_list,json=aggList,proto3" json:"agg_list,omitempty"`
	OrderBy              []*OrderBySpec `protobuf:"bytes,12,rep,name=order_by,json=orderBy,proto3" json:"order_by,omitempty"`
	UpdateList           *UpdateList    `protobuf:"bytes,13,opt,name=update_list,json=updateList,proto3" json:"update_list,omitempty"`
	WinSpec              *WindowSpec    `protobuf:"bytes,14,opt,name=win_spec,json=winSpec,proto3" json:"win_spec,omitempty"`
	Limit                *Expr          `protobuf:"bytes,15,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset               *Expr          `protobuf:"bytes,16,opt,name=offset,proto3" json:"offset,omitempty"`
	TableDef             *TableDef      `protobuf:"bytes,17,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	ObjRef               *ObjectRef     `protobuf:"bytes,18,opt,name=obj_ref,json=objRef,proto3" json:"obj_ref,omitempty"`
	RowsetData           *RowsetData    `protobuf:"bytes,19,opt,name=rowset_data,json=rowsetData,proto3" json:"rowset_data,omitempty"`
	ExtraOptions         string         `protobuf:"bytes,20,opt,name=extra_options,json=extraOptions,proto3" json:"extra_options,omitempty"`
	UseDeleteKey         string         `protobuf:"bytes,21,opt,name=useDeleteKey,proto3" json:"useDeleteKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{27}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetNodeType() Node_NodeType {
	if m != nil {
		return m.NodeType
	}
	return Node_UNKNOWN
}

func (m *Node) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *Node) GetCost() *Cost {
	if m != nil {
		return m.Cost
	}
	return nil
}

func (m *Node) GetProjectList() []*Expr {
	if m != nil {
		return m.ProjectList
	}
	return nil
}

func (m *Node) GetChildren() []int32 {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *Node) GetJoinType() Node_JoinFlag {
	if m != nil {
		return m.JoinType
	}
	return Node_INNER
}

func (m *Node) GetOnList() []*Expr {
	if m != nil {
		return m.OnList
	}
	return nil
}

func (m *Node) GetWhereList() []*Expr {
	if m != nil {
		return m.WhereList
	}
	return nil
}

func (m *Node) GetGroupBy() []*Expr {
	if m != nil {
		return m.GroupBy
	}
	return nil
}

func (m *Node) GetGroupingSet() []*Expr {
	if m != nil {
		return m.GroupingSet
	}
	return nil
}

func (m *Node) GetAggList() []*Expr {
	if m != nil {
		return m.AggList
	}
	return nil
}

func (m *Node) GetOrderBy() []*OrderBySpec {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *Node) GetUpdateList() *UpdateList {
	if m != nil {
		return m.UpdateList
	}
	return nil
}

func (m *Node) GetWinSpec() *WindowSpec {
	if m != nil {
		return m.WinSpec
	}
	return nil
}

func (m *Node) GetLimit() *Expr {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *Node) GetOffset() *Expr {
	if m != nil {
		return m.Offset
	}
	return nil
}

func (m *Node) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *Node) GetObjRef() *ObjectRef {
	if m != nil {
		return m.ObjRef
	}
	return nil
}

func (m *Node) GetRowsetData() *RowsetData {
	if m != nil {
		return m.RowsetData
	}
	return nil
}

func (m *Node) GetExtraOptions() string {
	if m != nil {
		return m.ExtraOptions
	}
	return ""
}

func (m *Node) GetUseDeleteKey() string {
	if m != nil {
		return m.UseDeleteKey
	}
	return ""
}

type Query struct {
	StmtType Query_StatementType `protobuf:"varint,1,opt,name=stmt_type,json=stmtType,proto3,enum=plan.Query_StatementType" json:"stmt_type,omitempty"`
	// Each step is simply a root node.  Root node refers to other
	// node as children and the whole step is a DAG.
	Steps []int32 `protobuf:"varint,2,rep,packed,name=steps,proto3" json:"steps,omitempty"`
	// All the nodes.  It is OK to have dangle nodes, we only excute nodes
	// reachable from step roots.
	Nodes []*Node `protobuf:"bytes,3,rep,name=nodes,proto3" json:"nodes,omitempty"`
	// Bound Parameter for the query.
	Params               []*Expr  `protobuf:"bytes,4,rep,name=params,proto3" json:"params,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Query) Reset()         { *m = Query{} }
func (m *Query) String() string { return proto.CompactTextString(m) }
func (*Query) ProtoMessage()    {}
func (*Query) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{28}
}
func (m *Query) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Query) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Query.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Query) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Query.Merge(m, src)
}
func (m *Query) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Query) XXX_DiscardUnknown() {
	xxx_messageInfo_Query.DiscardUnknown(m)
}

var xxx_messageInfo_Query proto.InternalMessageInfo

func (m *Query) GetStmtType() Query_StatementType {
	if m != nil {
		return m.StmtType
	}
	return Query_UNKNOWN
}

func (m *Query) GetSteps() []int32 {
	if m != nil {
		return m.Steps
	}
	return nil
}

func (m *Query) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *Query) GetParams() []*Expr {
	if m != nil {
		return m.Params
	}
	return nil
}

type TransationControl struct {
	//TransationControl type
	TclType TransationControl_TclType `protobuf:"varint,1,opt,name=tcl_type,json=tclType,proto3,enum=plan.TransationControl_TclType" json:"tcl_type,omitempty"`
	// Types that are valid to be assigned to Action:
	//	*TransationControl_Begin
	//	*TransationControl_Commit
	//	*TransationControl_Rollback
	Action               isTransationControl_Action `protobuf_oneof:"action"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *TransationControl) Reset()         { *m = TransationControl{} }
func (m *TransationControl) String() string { return proto.CompactTextString(m) }
func (*TransationControl) ProtoMessage()    {}
func (*TransationControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{29}
}
func (m *TransationControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransationControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransationControl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransationControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransationControl.Merge(m, src)
}
func (m *TransationControl) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransationControl) XXX_DiscardUnknown() {
	xxx_messageInfo_TransationControl.DiscardUnknown(m)
}

var xxx_messageInfo_TransationControl proto.InternalMessageInfo

type isTransationControl_Action interface {
	isTransationControl_Action()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type TransationControl_Begin struct {
	Begin *TransationBegin `protobuf:"bytes,2,opt,name=begin,proto3,oneof"`
}
type TransationControl_Commit struct {
	Commit *TransationCommit `protobuf:"bytes,3,opt,name=commit,proto3,oneof"`
}
type TransationControl_Rollback struct {
	Rollback *TransationRollback `protobuf:"bytes,4,opt,name=rollback,proto3,oneof"`
}

func (*TransationControl_Begin) isTransationControl_Action()    {}
func (*TransationControl_Commit) isTransationControl_Action()   {}
func (*TransationControl_Rollback) isTransationControl_Action() {}

func (m *TransationControl) GetAction() isTransationControl_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *TransationControl) GetTclType() TransationControl_TclType {
	if m != nil {
		return m.TclType
	}
	return TransationControl_BEGIN
}

func (m *TransationControl) GetBegin() *TransationBegin {
	if x, ok := m.GetAction().(*TransationControl_Begin); ok {
		return x.Begin
	}
	return nil
}

func (m *TransationControl) GetCommit() *TransationCommit {
	if x, ok := m.GetAction().(*TransationControl_Commit); ok {
		return x.Commit
	}
	return nil
}

func (m *TransationControl) GetRollback() *TransationRollback {
	if x, ok := m.GetAction().(*TransationControl_Rollback); ok {
		return x.Rollback
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TransationControl) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TransationControl_OneofMarshaler, _TransationControl_OneofUnmarshaler, _TransationControl_OneofSizer, []interface{}{
		(*TransationControl_Begin)(nil),
		(*TransationControl_Commit)(nil),
		(*TransationControl_Rollback)(nil),
	}
}

func _TransationControl_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TransationControl)
	// action
	switch x := m.Action.(type) {
	case *TransationControl_Begin:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Begin); err != nil {
			return err
		}
	case *TransationControl_Commit:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Commit); err != nil {
			return err
		}
	case *TransationControl_Rollback:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Rollback); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TransationControl.Action has unexpected type %T", x)
	}
	return nil
}

func _TransationControl_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TransationControl)
	switch tag {
	case 2: // action.begin
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TransationBegin)
		err := b.DecodeMessage(msg)
		m.Action = &TransationControl_Begin{msg}
		return true, err
	case 3: // action.commit
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TransationCommit)
		err := b.DecodeMessage(msg)
		m.Action = &TransationControl_Commit{msg}
		return true, err
	case 4: // action.rollback
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TransationRollback)
		err := b.DecodeMessage(msg)
		m.Action = &TransationControl_Rollback{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TransationControl_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TransationControl)
	// action
	switch x := m.Action.(type) {
	case *TransationControl_Begin:
		s := proto.Size(x.Begin)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TransationControl_Commit:
		s := proto.Size(x.Commit)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TransationControl_Rollback:
		s := proto.Size(x.Rollback)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TransationBegin struct {
	Mode                 TransationBegin_TransationMode `protobuf:"varint,1,opt,name=mode,proto3,enum=plan.TransationBegin_TransationMode" json:"mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *TransationBegin) Reset()         { *m = TransationBegin{} }
func (m *TransationBegin) String() string { return proto.CompactTextString(m) }
func (*TransationBegin) ProtoMessage()    {}
func (*TransationBegin) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{30}
}
func (m *TransationBegin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransationBegin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransationBegin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransationBegin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransationBegin.Merge(m, src)
}
func (m *TransationBegin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransationBegin) XXX_DiscardUnknown() {
	xxx_messageInfo_TransationBegin.DiscardUnknown(m)
}

var xxx_messageInfo_TransationBegin proto.InternalMessageInfo

func (m *TransationBegin) GetMode() TransationBegin_TransationMode {
	if m != nil {
		return m.Mode
	}
	return TransationBegin_NONE
}

type TransationCommit struct {
	CompletionType       TransationCompletionType `protobuf:"varint,1,opt,name=completion_type,json=completionType,proto3,enum=plan.TransationCompletionType" json:"completion_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *TransationCommit) Reset()         { *m = TransationCommit{} }
func (m *TransationCommit) String() string { return proto.CompactTextString(m) }
func (*TransationCommit) ProtoMessage()    {}
func (*TransationCommit) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{31}
}
func (m *TransationCommit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransationCommit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransationCommit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransationCommit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransationCommit.Merge(m, src)
}
func (m *TransationCommit) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransationCommit) XXX_DiscardUnknown() {
	xxx_messageInfo_TransationCommit.DiscardUnknown(m)
}

var xxx_messageInfo_TransationCommit proto.InternalMessageInfo

func (m *TransationCommit) GetCompletionType() TransationCompletionType {
	if m != nil {
		return m.CompletionType
	}
	return TransationCompletionType_CHAIN
}

type TransationRollback struct {
	CompletionType       TransationCompletionType `protobuf:"varint,1,opt,name=completion_type,json=completionType,proto3,enum=plan.TransationCompletionType" json:"completion_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *TransationRollback) Reset()         { *m = TransationRollback{} }
func (m *TransationRollback) String() string { return proto.CompactTextString(m) }
func (*TransationRollback) ProtoMessage()    {}
func (*TransationRollback) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{32}
}
func (m *TransationRollback) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransationRollback) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransationRollback.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransationRollback) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransationRollback.Merge(m, src)
}
func (m *TransationRollback) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransationRollback) XXX_DiscardUnknown() {
	xxx_messageInfo_TransationRollback.DiscardUnknown(m)
}

var xxx_messageInfo_TransationRollback proto.InternalMessageInfo

func (m *TransationRollback) GetCompletionType() TransationCompletionType {
	if m != nil {
		return m.CompletionType
	}
	return TransationCompletionType_CHAIN
}

type Plan struct {
	// Types that are valid to be assigned to Plan:
	//	*Plan_Query
	//	*Plan_Tcl
	//	*Plan_Ddl
	Plan                 isPlan_Plan `protobuf_oneof:"plan"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Plan) Reset()         { *m = Plan{} }
func (m *Plan) String() string { return proto.CompactTextString(m) }
func (*Plan) ProtoMessage()    {}
func (*Plan) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{33}
}
func (m *Plan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Plan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Plan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Plan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Plan.Merge(m, src)
}
func (m *Plan) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Plan) XXX_DiscardUnknown() {
	xxx_messageInfo_Plan.DiscardUnknown(m)
}

var xxx_messageInfo_Plan proto.InternalMessageInfo

type isPlan_Plan interface {
	isPlan_Plan()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type Plan_Query struct {
	Query *Query `protobuf:"bytes,1,opt,name=query,proto3,oneof"`
}
type Plan_Tcl struct {
	Tcl *TransationControl `protobuf:"bytes,2,opt,name=tcl,proto3,oneof"`
}
type Plan_Ddl struct {
	Ddl *DataDefinition `protobuf:"bytes,3,opt,name=ddl,proto3,oneof"`
}

func (*Plan_Query) isPlan_Plan() {}
func (*Plan_Tcl) isPlan_Plan()   {}
func (*Plan_Ddl) isPlan_Plan()   {}

func (m *Plan) GetPlan() isPlan_Plan {
	if m != nil {
		return m.Plan
	}
	return nil
}

func (m *Plan) GetQuery() *Query {
	if x, ok := m.GetPlan().(*Plan_Query); ok {
		return x.Query
	}
	return nil
}

func (m *Plan) GetTcl() *TransationControl {
	if x, ok := m.GetPlan().(*Plan_Tcl); ok {
		return x.Tcl
	}
	return nil
}

func (m *Plan) GetDdl() *DataDefinition {
	if x, ok := m.GetPlan().(*Plan_Ddl); ok {
		return x.Ddl
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Plan) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Plan_OneofMarshaler, _Plan_OneofUnmarshaler, _Plan_OneofSizer, []interface{}{
		(*Plan_Query)(nil),
		(*Plan_Tcl)(nil),
		(*Plan_Ddl)(nil),
	}
}

func _Plan_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Plan)
	// plan
	switch x := m.Plan.(type) {
	case *Plan_Query:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Query); err != nil {
			return err
		}
	case *Plan_Tcl:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Tcl); err != nil {
			return err
		}
	case *Plan_Ddl:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ddl); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Plan.Plan has unexpected type %T", x)
	}
	return nil
}

func _Plan_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Plan)
	switch tag {
	case 1: // plan.query
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Query)
		err := b.DecodeMessage(msg)
		m.Plan = &Plan_Query{msg}
		return true, err
	case 2: // plan.tcl
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TransationControl)
		err := b.DecodeMessage(msg)
		m.Plan = &Plan_Tcl{msg}
		return true, err
	case 3: // plan.ddl
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DataDefinition)
		err := b.DecodeMessage(msg)
		m.Plan = &Plan_Ddl{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Plan_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Plan)
	// plan
	switch x := m.Plan.(type) {
	case *Plan_Query:
		s := proto.Size(x.Query)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Plan_Tcl:
		s := proto.Size(x.Tcl)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Plan_Ddl:
		s := proto.Size(x.Ddl)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type DataDefinition struct {
	//DataDefinition type
	DdlType DataDefinition_DdlType `protobuf:"varint,1,opt,name=ddl_type,json=ddlType,proto3,enum=plan.DataDefinition_DdlType" json:"ddl_type,omitempty"`
	//other show statement we will rewrite to a select statement
	//then we will get a Query
	//eg: 'show databases' will rewrite to 'select md.datname as `Database` from mo_database md'
	Query *Query `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// Types that are valid to be assigned to Definition:
	//	*DataDefinition_CreateDatabase
	//	*DataDefinition_AlterDatabase
	//	*DataDefinition_DropDatabase
	//	*DataDefinition_CreateTable
	//	*DataDefinition_AlterTable
	//	*DataDefinition_DropTable
	//	*DataDefinition_CreateIndex
	//	*DataDefinition_AlterIndex
	//	*DataDefinition_DropIndex
	//	*DataDefinition_TruncateTable
	//	*DataDefinition_ShowVariables
	Definition           isDataDefinition_Definition `protobuf_oneof:"definition"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *DataDefinition) Reset()         { *m = DataDefinition{} }
func (m *DataDefinition) String() string { return proto.CompactTextString(m) }
func (*DataDefinition) ProtoMessage()    {}
func (*DataDefinition) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{34}
}
func (m *DataDefinition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataDefinition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataDefinition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataDefinition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataDefinition.Merge(m, src)
}
func (m *DataDefinition) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DataDefinition) XXX_DiscardUnknown() {
	xxx_messageInfo_DataDefinition.DiscardUnknown(m)
}

var xxx_messageInfo_DataDefinition proto.InternalMessageInfo

type isDataDefinition_Definition interface {
	isDataDefinition_Definition()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type DataDefinition_CreateDatabase struct {
	CreateDatabase *CreateDatabase `protobuf:"bytes,3,opt,name=create_database,json=createDatabase,proto3,oneof"`
}
type DataDefinition_AlterDatabase struct {
	AlterDatabase *AlterDatabase `protobuf:"bytes,4,opt,name=alter_database,json=alterDatabase,proto3,oneof"`
}
type DataDefinition_DropDatabase struct {
	DropDatabase *DropDatabase `protobuf:"bytes,5,opt,name=drop_database,json=dropDatabase,proto3,oneof"`
}
type DataDefinition_CreateTable struct {
	CreateTable *CreateTable `protobuf:"bytes,6,opt,name=create_table,json=createTable,proto3,oneof"`
}
type DataDefinition_AlterTable struct {
	AlterTable *AlterTable `protobuf:"bytes,7,opt,name=alter_table,json=alterTable,proto3,oneof"`
}
type DataDefinition_DropTable struct {
	DropTable *DropTable `protobuf:"bytes,8,opt,name=drop_table,json=dropTable,proto3,oneof"`
}
type DataDefinition_CreateIndex struct {
	CreateIndex *CreateIndex `protobuf:"bytes,9,opt,name=create_index,json=createIndex,proto3,oneof"`
}
type DataDefinition_AlterIndex struct {
	AlterIndex *AlterIndex `protobuf:"bytes,10,opt,name=alter_index,json=alterIndex,proto3,oneof"`
}
type DataDefinition_DropIndex struct {
	DropIndex *DropIndex `protobuf:"bytes,11,opt,name=drop_index,json=dropIndex,proto3,oneof"`
}
type DataDefinition_TruncateTable struct {
	TruncateTable *TruncateTable `protobuf:"bytes,12,opt,name=truncate_table,json=truncateTable,proto3,oneof"`
}
type DataDefinition_ShowVariables struct {
	ShowVariables *ShowVariables `protobuf:"bytes,13,opt,name=show_variables,json=showVariables,proto3,oneof"`
}

func (*DataDefinition_CreateDatabase) isDataDefinition_Definition() {}
func (*DataDefinition_AlterDatabase) isDataDefinition_Definition()  {}
func (*DataDefinition_DropDatabase) isDataDefinition_Definition()   {}
func (*DataDefinition_CreateTable) isDataDefinition_Definition()    {}
func (*DataDefinition_AlterTable) isDataDefinition_Definition()     {}
func (*DataDefinition_DropTable) isDataDefinition_Definition()      {}
func (*DataDefinition_CreateIndex) isDataDefinition_Definition()    {}
func (*DataDefinition_AlterIndex) isDataDefinition_Definition()     {}
func (*DataDefinition_DropIndex) isDataDefinition_Definition()      {}
func (*DataDefinition_TruncateTable) isDataDefinition_Definition()  {}
func (*DataDefinition_ShowVariables) isDataDefinition_Definition()  {}

func (m *DataDefinition) GetDefinition() isDataDefinition_Definition {
	if m != nil {
		return m.Definition
	}
	return nil
}

func (m *DataDefinition) GetDdlType() DataDefinition_DdlType {
	if m != nil {
		return m.DdlType
	}
	return DataDefinition_CREATE_DATABASE
}

func (m *DataDefinition) GetQuery() *Query {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *DataDefinition) GetCreateDatabase() *CreateDatabase {
	if x, ok := m.GetDefinition().(*DataDefinition_CreateDatabase); ok {
		return x.CreateDatabase
	}
	return nil
}

func (m *DataDefinition) GetAlterDatabase() *AlterDatabase {
	if x, ok := m.GetDefinition().(*DataDefinition_AlterDatabase); ok {
		return x.AlterDatabase
	}
	return nil
}

func (m *DataDefinition) GetDropDatabase() *DropDatabase {
	if x, ok := m.GetDefinition().(*DataDefinition_DropDatabase); ok {
		return x.DropDatabase
	}
	return nil
}

func (m *DataDefinition) GetCreateTable() *CreateTable {
	if x, ok := m.GetDefinition().(*DataDefinition_CreateTable); ok {
		return x.CreateTable
	}
	return nil
}

func (m *DataDefinition) GetAlterTable() *AlterTable {
	if x, ok := m.GetDefinition().(*DataDefinition_AlterTable); ok {
		return x.AlterTable
	}
	return nil
}

func (m *DataDefinition) GetDropTable() *DropTable {
	if x, ok := m.GetDefinition().(*DataDefinition_DropTable); ok {
		return x.DropTable
	}
	return nil
}

func (m *DataDefinition) GetCreateIndex() *CreateIndex {
	if x, ok := m.GetDefinition().(*DataDefinition_CreateIndex); ok {
		return x.CreateIndex
	}
	return nil
}

func (m *DataDefinition) GetAlterIndex() *AlterIndex {
	if x, ok := m.GetDefinition().(*DataDefinition_AlterIndex); ok {
		return x.AlterIndex
	}
	return nil
}

func (m *DataDefinition) GetDropIndex() *DropIndex {
	if x, ok := m.GetDefinition().(*DataDefinition_DropIndex); ok {
		return x.DropIndex
	}
	return nil
}

func (m *DataDefinition) GetTruncateTable() *TruncateTable {
	if x, ok := m.GetDefinition().(*DataDefinition_TruncateTable); ok {
		return x.TruncateTable
	}
	return nil
}

func (m *DataDefinition) GetShowVariables() *ShowVariables {
	if x, ok := m.GetDefinition().(*DataDefinition_ShowVariables); ok {
		return x.ShowVariables
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DataDefinition) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DataDefinition_OneofMarshaler, _DataDefinition_OneofUnmarshaler, _DataDefinition_OneofSizer, []interface{}{
		(*DataDefinition_CreateDatabase)(nil),
		(*DataDefinition_AlterDatabase)(nil),
		(*DataDefinition_DropDatabase)(nil),
		(*DataDefinition_CreateTable)(nil),
		(*DataDefinition_AlterTable)(nil),
		(*DataDefinition_DropTable)(nil),
		(*DataDefinition_CreateIndex)(nil),
		(*DataDefinition_AlterIndex)(nil),
		(*DataDefinition_DropIndex)(nil),
		(*DataDefinition_TruncateTable)(nil),
		(*DataDefinition_ShowVariables)(nil),
	}
}

func _DataDefinition_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DataDefinition)
	// definition
	switch x := m.Definition.(type) {
	case *DataDefinition_CreateDatabase:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CreateDatabase); err != nil {
			return err
		}
	case *DataDefinition_AlterDatabase:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AlterDatabase); err != nil {
			return err
		}
	case *DataDefinition_DropDatabase:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DropDatabase); err != nil {
			return err
		}
	case *DataDefinition_CreateTable:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CreateTable); err != nil {
			return err
		}
	case *DataDefinition_AlterTable:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AlterTable); err != nil {
			return err
		}
	case *DataDefinition_DropTable:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DropTable); err != nil {
			return err
		}
	case *DataDefinition_CreateIndex:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CreateIndex); err != nil {
			return err
		}
	case *DataDefinition_AlterIndex:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AlterIndex); err != nil {
			return err
		}
	case *DataDefinition_DropIndex:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DropIndex); err != nil {
			return err
		}
	case *DataDefinition_TruncateTable:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TruncateTable); err != nil {
			return err
		}
	case *DataDefinition_ShowVariables:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ShowVariables); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DataDefinition.Definition has unexpected type %T", x)
	}
	return nil
}

func _DataDefinition_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DataDefinition)
	switch tag {
	case 3: // definition.create_database
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CreateDatabase)
		err := b.DecodeMessage(msg)
		m.Definition = &DataDefinition_CreateDatabase{msg}
		return true, err
	case 4: // definition.alter_database
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AlterDatabase)
		err := b.DecodeMessage(msg)
		m.Definition = &DataDefinition_AlterDatabase{msg}
		return true, err
	case 5: // definition.drop_database
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DropDatabase)
		err := b.DecodeMessage(msg)
		m.Definition = &DataDefinition_DropDatabase{msg}
		return true, err
	case 6: // definition.create_table
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CreateTable)
		err := b.DecodeMessage(msg)
		m.Definition = &DataDefinition_CreateTable{msg}
		return true, err
	case 7: // definition.alter_table
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AlterTable)
		err := b.DecodeMessage(msg)
		m.Definition = &DataDefinition_AlterTable{msg}
		return true, err
	case 8: // definition.drop_table
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DropTable)
		err := b.DecodeMessage(msg)
		m.Definition = &DataDefinition_DropTable{msg}
		return true, err
	case 9: // definition.create_index
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CreateIndex)
		err := b.DecodeMessage(msg)
		m.Definition = &DataDefinition_CreateIndex{msg}
		return true, err
	case 10: // definition.alter_index
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AlterIndex)
		err := b.DecodeMessage(msg)
		m.Definition = &DataDefinition_AlterIndex{msg}
		return true, err
	case 11: // definition.drop_index
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DropIndex)
		err := b.DecodeMessage(msg)
		m.Definition = &DataDefinition_DropIndex{msg}
		return true, err
	case 12: // definition.truncate_table
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TruncateTable)
		err := b.DecodeMessage(msg)
		m.Definition = &DataDefinition_TruncateTable{msg}
		return true, err
	case 13: // definition.show_variables
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ShowVariables)
		err := b.DecodeMessage(msg)
		m.Definition = &DataDefinition_ShowVariables{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DataDefinition_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DataDefinition)
	// definition
	switch x := m.Definition.(type) {
	case *DataDefinition_CreateDatabase:
		s := proto.Size(x.CreateDatabase)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DataDefinition_AlterDatabase:
		s := proto.Size(x.AlterDatabase)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DataDefinition_DropDatabase:
		s := proto.Size(x.DropDatabase)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DataDefinition_CreateTable:
		s := proto.Size(x.CreateTable)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DataDefinition_AlterTable:
		s := proto.Size(x.AlterTable)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DataDefinition_DropTable:
		s := proto.Size(x.DropTable)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DataDefinition_CreateIndex:
		s := proto.Size(x.CreateIndex)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DataDefinition_AlterIndex:
		s := proto.Size(x.AlterIndex)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DataDefinition_DropIndex:
		s := proto.Size(x.DropIndex)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DataDefinition_TruncateTable:
		s := proto.Size(x.TruncateTable)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DataDefinition_ShowVariables:
		s := proto.Size(x.ShowVariables)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CreateDatabase struct {
	IfNotExists          bool     `protobuf:"varint,1,opt,name=if_not_exists,json=ifNotExists,proto3" json:"if_not_exists,omitempty"`
	Database             string   `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateDatabase) Reset()         { *m = CreateDatabase{} }
func (m *CreateDatabase) String() string { return proto.CompactTextString(m) }
func (*CreateDatabase) ProtoMessage()    {}
func (*CreateDatabase) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{35}
}
func (m *CreateDatabase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateDatabase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateDatabase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateDatabase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateDatabase.Merge(m, src)
}
func (m *CreateDatabase) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CreateDatabase) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateDatabase.DiscardUnknown(m)
}

var xxx_messageInfo_CreateDatabase proto.InternalMessageInfo

func (m *CreateDatabase) GetIfNotExists() bool {
	if m != nil {
		return m.IfNotExists
	}
	return false
}

func (m *CreateDatabase) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

type AlterDatabase struct {
	IfExists             bool     `protobuf:"varint,1,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	Database             string   `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterDatabase) Reset()         { *m = AlterDatabase{} }
func (m *AlterDatabase) String() string { return proto.CompactTextString(m) }
func (*AlterDatabase) ProtoMessage()    {}
func (*AlterDatabase) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{36}
}
func (m *AlterDatabase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterDatabase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterDatabase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterDatabase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterDatabase.Merge(m, src)
}
func (m *AlterDatabase) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterDatabase) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterDatabase.DiscardUnknown(m)
}

var xxx_messageInfo_AlterDatabase proto.InternalMessageInfo

func (m *AlterDatabase) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

func (m *AlterDatabase) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

type DropDatabase struct {
	IfExists             bool     `protobuf:"varint,1,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	Database             string   `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DropDatabase) Reset()         { *m = DropDatabase{} }
func (m *DropDatabase) String() string { return proto.CompactTextString(m) }
func (*DropDatabase) ProtoMessage()    {}
func (*DropDatabase) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{37}
}
func (m *DropDatabase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropDatabase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropDatabase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropDatabase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropDatabase.Merge(m, src)
}
func (m *DropDatabase) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DropDatabase) XXX_DiscardUnknown() {
	xxx_messageInfo_DropDatabase.DiscardUnknown(m)
}

var xxx_messageInfo_DropDatabase proto.InternalMessageInfo

func (m *DropDatabase) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

func (m *DropDatabase) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

type CreateTable struct {
	IfNotExists          bool      `protobuf:"varint,1,opt,name=if_not_exists,json=ifNotExists,proto3" json:"if_not_exists,omitempty"`
	Temporary            bool      `protobuf:"varint,2,opt,name=temporary,proto3" json:"temporary,omitempty"`
	Database             string    `protobuf:"bytes,3,opt,name=database,proto3" json:"database,omitempty"`
	TableDef             *TableDef `protobuf:"bytes,4,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *CreateTable) Reset()         { *m = CreateTable{} }
func (m *CreateTable) String() string { return proto.CompactTextString(m) }
func (*CreateTable) ProtoMessage()    {}
func (*CreateTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{38}
}
func (m *CreateTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateTable.Merge(m, src)
}
func (m *CreateTable) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CreateTable) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateTable.DiscardUnknown(m)
}

var xxx_messageInfo_CreateTable proto.InternalMessageInfo

func (m *CreateTable) GetIfNotExists() bool {
	if m != nil {
		return m.IfNotExists
	}
	return false
}

func (m *CreateTable) GetTemporary() bool {
	if m != nil {
		return m.Temporary
	}
	return false
}

func (m *CreateTable) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *CreateTable) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

type AlterTable struct {
	Table                string    `protobuf:"bytes,1,opt,name=table,proto3" json:"table,omitempty"`
	TableDef             *TableDef `protobuf:"bytes,2,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *AlterTable) Reset()         { *m = AlterTable{} }
func (m *AlterTable) String() string { return proto.CompactTextString(m) }
func (*AlterTable) ProtoMessage()    {}
func (*AlterTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{39}
}
func (m *AlterTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTable.Merge(m, src)
}
func (m *AlterTable) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTable) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTable.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTable proto.InternalMessageInfo

func (m *AlterTable) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *AlterTable) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

type DropTable struct {
	IfExists             bool     `protobuf:"varint,1,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	Database             string   `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	Table                string   `protobuf:"bytes,3,opt,name=table,proto3" json:"table,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DropTable) Reset()         { *m = DropTable{} }
func (m *DropTable) String() string { return proto.CompactTextString(m) }
func (*DropTable) ProtoMessage()    {}
func (*DropTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{40}
}
func (m *DropTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropTable.Merge(m, src)
}
func (m *DropTable) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DropTable) XXX_DiscardUnknown() {
	xxx_messageInfo_DropTable.DiscardUnknown(m)
}

var xxx_messageInfo_DropTable proto.InternalMessageInfo

func (m *DropTable) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

func (m *DropTable) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *DropTable) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

type CreateIndex struct {
	IfNotExists          bool     `protobuf:"varint,1,opt,name=if_not_exists,json=ifNotExists,proto3" json:"if_not_exists,omitempty"`
	Index                string   `protobuf:"bytes,2,opt,name=index,proto3" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateIndex) Reset()         { *m = CreateIndex{} }
func (m *CreateIndex) String() string { return proto.CompactTextString(m) }
func (*CreateIndex) ProtoMessage()    {}
func (*CreateIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{41}
}
func (m *CreateIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateIndex.Merge(m, src)
}
func (m *CreateIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CreateIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateIndex.DiscardUnknown(m)
}

var xxx_messageInfo_CreateIndex proto.InternalMessageInfo

func (m *CreateIndex) GetIfNotExists() bool {
	if m != nil {
		return m.IfNotExists
	}
	return false
}

func (m *CreateIndex) GetIndex() string {
	if m != nil {
		return m.Index
	}
	return ""
}

type AlterIndex struct {
	Index                string   `protobuf:"bytes,1,opt,name=index,proto3" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterIndex) Reset()         { *m = AlterIndex{} }
func (m *AlterIndex) String() string { return proto.CompactTextString(m) }
func (*AlterIndex) ProtoMessage()    {}
func (*AlterIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{42}
}
func (m *AlterIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterIndex.Merge(m, src)
}
func (m *AlterIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterIndex.DiscardUnknown(m)
}

var xxx_messageInfo_AlterIndex proto.InternalMessageInfo

func (m *AlterIndex) GetIndex() string {
	if m != nil {
		return m.Index
	}
	return ""
}

type DropIndex struct {
	IfExists             bool     `protobuf:"varint,1,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	Index                string   `protobuf:"bytes,2,opt,name=index,proto3" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DropIndex) Reset()         { *m = DropIndex{} }
func (m *DropIndex) String() string { return proto.CompactTextString(m) }
func (*DropIndex) ProtoMessage()    {}
func (*DropIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{43}
}
func (m *DropIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropIndex.Merge(m, src)
}
func (m *DropIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DropIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_DropIndex.DiscardUnknown(m)
}

var xxx_messageInfo_DropIndex proto.InternalMessageInfo

func (m *DropIndex) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

func (m *DropIndex) GetIndex() string {
	if m != nil {
		return m.Index
	}
	return ""
}

type TruncateTable struct {
	Table                string   `protobuf:"bytes,1,opt,name=table,proto3" json:"table,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TruncateTable) Reset()         { *m = TruncateTable{} }
func (m *TruncateTable) String() string { return proto.CompactTextString(m) }
func (*TruncateTable) ProtoMessage()    {}
func (*TruncateTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{44}
}
func (m *TruncateTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TruncateTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TruncateTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TruncateTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TruncateTable.Merge(m, src)
}
func (m *TruncateTable) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TruncateTable) XXX_DiscardUnknown() {
	xxx_messageInfo_TruncateTable.DiscardUnknown(m)
}

var xxx_messageInfo_TruncateTable proto.InternalMessageInfo

func (m *TruncateTable) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

type ShowVariables struct {
	Global               bool     `protobuf:"varint,1,opt,name=global,proto3" json:"global,omitempty"`
	Where                []*Expr  `protobuf:"bytes,2,rep,name=where,proto3" json:"where,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShowVariables) Reset()         { *m = ShowVariables{} }
func (m *ShowVariables) String() string { return proto.CompactTextString(m) }
func (*ShowVariables) ProtoMessage()    {}
func (*ShowVariables) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{45}
}
func (m *ShowVariables) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowVariables) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowVariables.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowVariables) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowVariables.Merge(m, src)
}
func (m *ShowVariables) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ShowVariables) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowVariables.DiscardUnknown(m)
}

var xxx_messageInfo_ShowVariables proto.InternalMessageInfo

func (m *ShowVariables) GetGlobal() bool {
	if m != nil {
		return m.Global
	}
	return false
}

func (m *ShowVariables) GetWhere() []*Expr {
	if m != nil {
		return m.Where
	}
	return nil
}

func init() {
	proto.RegisterEnum("plan.CompressType", CompressType_name, CompressType_value)
	proto.RegisterEnum("plan.TransationCompletionType", TransationCompletionType_name, TransationCompletionType_value)
	proto.RegisterEnum("plan.Type_TypeId", Type_TypeId_name, Type_TypeId_value)
	proto.RegisterEnum("plan.Function_FuncFlag", Function_FuncFlag_name, Function_FuncFlag_value)
	proto.RegisterEnum("plan.IndexDef_IndexType", IndexDef_IndexType_name, IndexDef_IndexType_value)
	proto.RegisterEnum("plan.OrderBySpec_OrderByFlag", OrderBySpec_OrderByFlag_name, OrderBySpec_OrderByFlag_value)
	proto.RegisterEnum("plan.Node_NodeType", Node_NodeType_name, Node_NodeType_value)
	proto.RegisterEnum("plan.Node_JoinFlag", Node_JoinFlag_name, Node_JoinFlag_value)
	proto.RegisterEnum("plan.Node_AggMode", Node_AggMode_name, Node_AggMode_value)
	proto.RegisterEnum("plan.Query_StatementType", Query_StatementType_name, Query_StatementType_value)
	proto.RegisterEnum("plan.TransationControl_TclType", TransationControl_TclType_name, TransationControl_TclType_value)
	proto.RegisterEnum("plan.TransationBegin_TransationMode", TransationBegin_TransationMode_name, TransationBegin_TransationMode_value)
	proto.RegisterEnum("plan.DataDefinition_DdlType", DataDefinition_DdlType_name, DataDefinition_DdlType_value)
	proto.RegisterType((*Type)(nil), "plan.Type")
	proto.RegisterType((*Const)(nil), "plan.Const")
	proto.RegisterType((*ParamRef)(nil), "plan.ParamRef")
	proto.RegisterType((*VarRef)(nil), "plan.VarRef")
	proto.RegisterType((*ColRef)(nil), "plan.ColRef")
	proto.RegisterType((*CorrColRef)(nil), "plan.CorrColRef")
	proto.RegisterType((*ExprList)(nil), "plan.ExprList")
	proto.RegisterType((*TargetType)(nil), "plan.TargetType")
	proto.RegisterType((*SubQuery)(nil), "plan.SubQuery")
	proto.RegisterType((*ObjectRef)(nil), "plan.ObjectRef")
	proto.RegisterType((*Function)(nil), "plan.Function")
	proto.RegisterType((*Expr)(nil), "plan.Expr")
	proto.RegisterType((*DefaultExpr)(nil), "plan.DefaultExpr")
	proto.RegisterType((*ConstantValue)(nil), "plan.ConstantValue")
	proto.RegisterType((*Decimal128)(nil), "plan.decimal128")
	proto.RegisterType((*ColDef)(nil), "plan.ColDef")
	proto.RegisterType((*IndexDef)(nil), "plan.IndexDef")
	proto.RegisterType((*PrimaryKeyDef)(nil), "plan.PrimaryKeyDef")
	proto.RegisterType((*Property)(nil), "plan.Property")
	proto.RegisterType((*PropertiesDef)(nil), "plan.PropertiesDef")
	proto.RegisterType((*TableDef)(nil), "plan.TableDef")
	proto.RegisterType((*TableDef_DefType)(nil), "plan.TableDef.DefType")
	proto.RegisterType((*Cost)(nil), "plan.Cost")
	proto.RegisterType((*ColData)(nil), "plan.ColData")
	proto.RegisterType((*RowsetData)(nil), "plan.RowsetData")
	proto.RegisterType((*OrderBySpec)(nil), "plan.OrderBySpec")
	proto.RegisterType((*WindowSpec)(nil), "plan.WindowSpec")
	proto.RegisterType((*UpdateList)(nil), "plan.UpdateList")
	proto.RegisterType((*Node)(nil), "plan.Node")
	proto.RegisterType((*Query)(nil), "plan.Query")
	proto.RegisterType((*TransationControl)(nil), "plan.TransationControl")
	proto.RegisterType((*TransationBegin)(nil), "plan.TransationBegin")
	proto.RegisterType((*TransationCommit)(nil), "plan.TransationCommit")
	proto.RegisterType((*TransationRollback)(nil), "plan.TransationRollback")
	proto.RegisterType((*Plan)(nil), "plan.Plan")
	proto.RegisterType((*DataDefinition)(nil), "plan.DataDefinition")
	proto.RegisterType((*CreateDatabase)(nil), "plan.CreateDatabase")
	proto.RegisterType((*AlterDatabase)(nil), "plan.AlterDatabase")
	proto.RegisterType((*DropDatabase)(nil), "plan.DropDatabase")
	proto.RegisterType((*CreateTable)(nil), "plan.CreateTable")
	proto.RegisterType((*AlterTable)(nil), "plan.AlterTable")
	proto.RegisterType((*DropTable)(nil), "plan.DropTable")
	proto.RegisterType((*CreateIndex)(nil), "plan.CreateIndex")
	proto.RegisterType((*AlterIndex)(nil), "plan.AlterIndex")
	proto.RegisterType((*DropIndex)(nil), "plan.DropIndex")
	proto.RegisterType((*TruncateTable)(nil), "plan.TruncateTable")
	proto.RegisterType((*ShowVariables)(nil), "plan.ShowVariables")
}

func init() { proto.RegisterFile("plan.proto", fileDescriptor_2d655ab2f7683c23) }

var fileDescriptor_2d655ab2f7683c23 = []byte{
	// 3982 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x3a, 0x5d, 0x6f, 0x1b, 0xc7,
	0x76, 0x5a, 0x7e, 0x2e, 0x0f, 0x25, 0x79, 0x3c, 0x76, 0x6c, 0x26, 0x71, 0x1c, 0x79, 0x1d, 0xdf,
	0x3a, 0x4e, 0xe2, 0xc4, 0xb2, 0xa2, 0x3a, 0xb7, 0x69, 0x72, 0x97, 0xe4, 0x5a, 0x62, 0x4c, 0x2d,
	0x75, 0x87, 0x4b, 0x39, 0x4e, 0x50, 0x10, 0x4b, 0x72, 0x49, 0xaf, 0xbd, 0xe2, 0xb2, 0xbb, 0x4b,
	0xc9, 0xba, 0x4f, 0x79, 0x69, 0x81, 0xf6, 0xa5, 0x40, 0x51, 0x20, 0x7d, 0x2c, 0x0a, 0xf4, 0x07,
	0xf4, 0x5f, 0xdc, 0xa2, 0x2f, 0x05, 0xfa, 0xd8, 0x97, 0x36, 0x45, 0xff, 0x41, 0xdf, 0x5b, 0x9c,
	0x33, 0xb3, 0xe4, 0xd2, 0x52, 0x72, 0xd3, 0x8b, 0xbe, 0x08, 0xe7, 0x7b, 0xce, 0x9c, 0x39, 0xe7,
	0xec, 0x99, 0xa1, 0x00, 0x66, 0x81, 0x3b, 0xbd, 0x3f, 0x8b, 0xc2, 0x24, 0xe4, 0x05, 0x84, 0xdf,
	0xfa, 0x68, 0xe2, 0x27, 0xcf, 0xe7, 0x83, 0xfb, 0xc3, 0xf0, 0xf8, 0xe3, 0x49, 0x38, 0x09, 0x3f,
	0x26, 0xe6, 0x60, 0x3e, 0x26, 0x8c, 0x10, 0x82, 0xa4, 0x92, 0xf1, 0xcf, 0x45, 0x28, 0x38, 0x67,
	0x33, 0x8f, 0xdf, 0x82, 0x9c, 0x3f, 0xaa, 0x69, 0x5b, 0xda, 0xdd, 0xcd, 0xed, 0xcb, 0xf7, 0xc9,
	0x2c, 0xd2, 0xe9, 0x4f, 0x6b, 0x24, 0x72, 0xfe, 0x88, 0xbf, 0x05, 0xfa, 0x74, 0x1e, 0x04, 0xee,
	0x20, 0xf0, 0x6a, 0xb9, 0x2d, 0xed, 0xae, 0x2e, 0x16, 0x38, 0xbf, 0x0a, 0xc5, 0x53, 0x7f, 0x94,
	0x3c, 0xaf, 0xe5, 0xb7, 0xb4, 0xbb, 0x45, 0x21, 0x11, 0x7e, 0x03, 0x2a, 0xb3, 0xc8, 0x1b, 0xfa,
	0xb1, 0x1f, 0x4e, 0x6b, 0x05, 0xe2, 0x2c, 0x09, 0x9c, 0x43, 0x21, 0xf6, 0x7f, 0xe3, 0xd5, 0x8a,
	0xc4, 0x20, 0x18, 0xed, 0xc4, 0x43, 0x37, 0xf0, 0x6a, 0x25, 0x69, 0x87, 0x10, 0xe3, 0x1f, 0x0a,
	0x50, 0x92, 0x8e, 0xf0, 0x32, 0xe4, 0x4d, 0xfb, 0x19, 0x5b, 0xe3, 0x3a, 0x14, 0xba, 0x8e, 0x29,
	0x98, 0x86, 0x50, 0xbd, 0xd3, 0x69, 0x33, 0x40, 0xa8, 0x65, 0x3b, 0x8f, 0xd8, 0x55, 0x5e, 0x81,
	0x62, 0xcb, 0x76, 0x1e, 0xec, 0xb2, 0x37, 0x14, 0xf8, 0x70, 0x9b, 0x5d, 0x53, 0xe0, 0xee, 0x0e,
	0xbb, 0xce, 0x01, 0x4a, 0x28, 0xb0, 0xfd, 0x88, 0xd5, 0x90, 0xdc, 0x23, 0xbd, 0x37, 0x91, 0xdc,
	0x93, 0x8a, 0x6f, 0xa5, 0xf0, 0xc3, 0x6d, 0xf6, 0x76, 0x0a, 0xef, 0xee, 0xb0, 0x1b, 0xbc, 0x0a,
	0xe5, 0x9e, 0xd2, 0x7d, 0x07, 0x91, 0xc7, 0xed, 0x8e, 0x89, 0x52, 0x37, 0x17, 0xc8, 0xee, 0x0e,
	0x7b, 0x97, 0x6f, 0x40, 0xa5, 0x69, 0x35, 0x5a, 0x07, 0x66, 0x7b, 0x77, 0x87, 0x6d, 0xf1, 0x4d,
	0x00, 0x85, 0xa2, 0xe2, 0x2d, 0x94, 0x55, 0x38, 0x33, 0xd0, 0xbc, 0x69, 0x3f, 0x6b, 0xd9, 0x0e,
	0xbb, 0xc3, 0xd7, 0x41, 0x37, 0xed, 0x67, 0x64, 0x87, 0xfd, 0x02, 0xad, 0x98, 0xf6, 0x33, 0xbb,
	0x77, 0x50, 0xb7, 0x04, 0xfb, 0x03, 0xdc, 0x61, 0xaf, 0xd7, 0x6a, 0xb2, 0xbb, 0xe4, 0x74, 0xfd,
	0xc1, 0xee, 0x27, 0xec, 0x7d, 0x05, 0x3e, 0xda, 0x61, 0xf7, 0x14, 0xf8, 0xd9, 0x36, 0xfb, 0x40,
	0x82, 0xdb, 0xdb, 0x3b, 0xec, 0x43, 0x05, 0x7e, 0xba, 0xcb, 0x3e, 0x42, 0x03, 0x4d, 0xd3, 0xb1,
	0xd8, 0x36, 0x42, 0x4e, 0xeb, 0xc0, 0x62, 0x0f, 0x71, 0x45, 0xa4, 0x11, 0xb6, 0x83, 0x2b, 0x22,
	0xd4, 0x75, 0xcc, 0x83, 0x43, 0xf6, 0x29, 0x32, 0x5b, 0xb6, 0x63, 0x89, 0x23, 0xb3, 0xcd, 0x76,
	0xd1, 0x6b, 0xd3, 0x7e, 0x46, 0x92, 0x7f, 0x84, 0x16, 0x1a, 0xfb, 0xa6, 0x60, 0x9f, 0x23, 0xf9,
	0xc8, 0x14, 0x84, 0xfc, 0x31, 0x92, 0xbf, 0xea, 0x76, 0x6c, 0xf6, 0x05, 0x6e, 0xab, 0xde, 0xb2,
	0x4d, 0xf1, 0x8c, 0x3d, 0x46, 0xb3, 0x47, 0xa6, 0x50, 0xe8, 0x1e, 0xba, 0x64, 0x0a, 0x61, 0x3e,
	0x63, 0xdf, 0x60, 0x64, 0x1e, 0xb7, 0xad, 0xaf, 0xeb, 0xbd, 0xc7, 0x8f, 0x2d, 0xc1, 0xbe, 0x25,
	0xad, 0x67, 0x8e, 0x65, 0x3e, 0x62, 0x23, 0x34, 0x4c, 0xf0, 0x83, 0x5d, 0xe6, 0xa1, 0x0e, 0x21,
	0x6c, 0xcc, 0x75, 0xc8, 0x77, 0xad, 0x36, 0xfb, 0xad, 0xc6, 0x01, 0x8a, 0x4e, 0xef, 0xb0, 0x6d,
	0xb1, 0x7f, 0xd2, 0x8c, 0xef, 0x34, 0x28, 0x36, 0xc2, 0x69, 0x9c, 0xf0, 0x6b, 0x50, 0xf2, 0x63,
	0xcc, 0x4e, 0x4a, 0x69, 0x5d, 0x28, 0x8c, 0x5f, 0x85, 0x82, 0x7f, 0xe2, 0x06, 0x94, 0xbf, 0xf9,
	0xfd, 0x35, 0x41, 0x18, 0x52, 0x47, 0x48, 0xc5, 0xe4, 0xd5, 0x90, 0x3a, 0x52, 0xd4, 0x18, 0xa9,
	0x98, 0xb8, 0x15, 0xa4, 0xc6, 0x8a, 0x3a, 0x40, 0x2a, 0x66, 0xad, 0x8e, 0x54, 0xc4, 0xea, 0x65,
	0x28, 0x9e, 0xb8, 0xc1, 0xdc, 0x33, 0x6e, 0x80, 0x7e, 0xe8, 0x46, 0xee, 0xb1, 0xf0, 0xc6, 0x9c,
	0x41, 0x7e, 0x16, 0xc6, 0xe4, 0x41, 0x51, 0x20, 0x68, 0xdc, 0x80, 0xd2, 0x91, 0x1b, 0x21, 0x8f,
	0x43, 0x61, 0xea, 0x1e, 0x7b, 0xc4, 0xac, 0x08, 0x82, 0x8d, 0x5f, 0x42, 0xa9, 0x11, 0x06, 0xc8,
	0xbd, 0x0e, 0xe5, 0xc8, 0x0b, 0xfa, 0x4b, 0xed, 0x52, 0xe4, 0x05, 0x87, 0x61, 0x8c, 0x8c, 0x61,
	0x28, 0x19, 0x39, 0xc9, 0x18, 0x86, 0xc8, 0x30, 0xbe, 0x00, 0x68, 0x84, 0x51, 0xb4, 0xd4, 0x9f,
	0x86, 0x23, 0xaf, 0xaf, 0x4a, 0xba, 0x28, 0x4a, 0x88, 0xb6, 0x46, 0x3f, 0xae, 0x7f, 0x0f, 0x74,
	0xeb, 0xd5, 0x2c, 0x6a, 0xfb, 0x71, 0xc2, 0x6f, 0x42, 0x21, 0xf0, 0xe3, 0xa4, 0xa6, 0x6d, 0xe5,
	0xef, 0x56, 0xb7, 0x41, 0x76, 0x03, 0xe4, 0x0a, 0xa2, 0x1b, 0xf7, 0x00, 0x1c, 0x37, 0x9a, 0x78,
	0x09, 0x75, 0x8e, 0x1b, 0x90, 0x4f, 0xce, 0x66, 0xb4, 0xce, 0x42, 0x18, 0x19, 0x02, 0xc9, 0x86,
	0x07, 0x7a, 0x77, 0x3e, 0xf8, 0xf5, 0xdc, 0x8b, 0xce, 0x7e, 0xdc, 0xab, 0xdb, 0xb0, 0xe1, 0xc7,
	0xfd, 0x61, 0x18, 0x45, 0x5e, 0xe0, 0x26, 0xde, 0x48, 0xb5, 0x97, 0x75, 0x3f, 0x6e, 0x2c, 0x68,
	0xfc, 0x6d, 0xa8, 0xf8, 0x71, 0x1f, 0x1b, 0x82, 0x1b, 0xd1, 0x49, 0xe9, 0x42, 0xf7, 0xe3, 0x2e,
	0xe1, 0xc6, 0xbf, 0x6a, 0x50, 0xe9, 0x0c, 0x5e, 0x78, 0xc3, 0x04, 0xb7, 0x7f, 0x0d, 0x4a, 0xb1,
	0x17, 0x9d, 0x78, 0x11, 0xad, 0x93, 0x17, 0x0a, 0xe3, 0x9b, 0x90, 0x1b, 0x0d, 0xe4, 0xd9, 0x8b,
	0xdc, 0x68, 0x40, 0x72, 0xc3, 0xe7, 0xde, 0xb1, 0x4b, 0xf6, 0x50, 0x8e, 0x30, 0x3c, 0xb8, 0x70,
	0xf0, 0x82, 0x0e, 0x3e, 0x2f, 0x10, 0xe4, 0xef, 0x42, 0x55, 0xda, 0xe8, 0xd3, 0xa9, 0x15, 0xe9,
	0xd4, 0x40, 0x92, 0x6c, 0xf7, 0xd8, 0xc3, 0xbd, 0x8d, 0x06, 0x92, 0x59, 0x22, 0x66, 0x69, 0x34,
	0x20, 0x06, 0x6a, 0x92, 0x55, 0xc9, 0x2c, 0x2b, 0x4d, 0x22, 0x91, 0xc0, 0x9b, 0xa0, 0x87, 0x83,
	0x17, 0x92, 0xab, 0x13, 0xb7, 0x1c, 0x0e, 0x5e, 0x20, 0xcb, 0xf8, 0x0f, 0x0d, 0xf4, 0xc7, 0xf3,
	0xe9, 0x30, 0xc1, 0x76, 0x79, 0x1b, 0x0a, 0xe3, 0xf9, 0x74, 0xa8, 0x02, 0x7d, 0x49, 0x06, 0x7a,
	0xb1, 0x67, 0x41, 0x4c, 0x3c, 0x3a, 0x37, 0x9a, 0xe0, 0xe1, 0x9e, 0x3b, 0x3a, 0xa4, 0x1b, 0x7f,
	0xa5, 0x2c, 0x3e, 0x0e, 0xdc, 0x09, 0x16, 0xaa, 0xdd, 0xb1, 0x2d, 0xb6, 0xb6, 0x28, 0x72, 0xdb,
	0x6c, 0x33, 0x2c, 0xa9, 0x52, 0xd7, 0x31, 0xeb, 0x6d, 0x8b, 0xe5, 0x90, 0x73, 0xd4, 0x69, 0x9b,
	0x4e, 0xab, 0x6d, 0xb1, 0x82, 0xe4, 0x88, 0x56, 0xc3, 0x61, 0x3a, 0x67, 0xb0, 0x7e, 0x28, 0x3a,
	0xcd, 0x5e, 0xc3, 0xea, 0xdb, 0xbd, 0x76, 0x9b, 0x31, 0x7e, 0x05, 0x2e, 0x2d, 0x28, 0x1d, 0x49,
	0xdc, 0x42, 0x95, 0x23, 0x53, 0x98, 0x62, 0x8f, 0xfd, 0x0a, 0xab, 0xd6, 0xdc, 0xdb, 0x63, 0xdf,
	0x61, 0xcf, 0xce, 0x3f, 0x6d, 0xd9, 0xec, 0xbb, 0x9c, 0xf1, 0x7d, 0x1e, 0x0a, 0xe8, 0xe0, 0x4f,
	0xe7, 0x11, 0x7f, 0x07, 0x20, 0xc1, 0x2f, 0x8d, 0x8c, 0x53, 0x8e, 0xe2, 0x54, 0x21, 0x4a, 0x1a,
	0x44, 0xcc, 0x6b, 0x62, 0xe6, 0x65, 0x10, 0x87, 0x61, 0x40, 0xac, 0xb7, 0x41, 0x1b, 0xd2, 0x51,
	0x56, 0xb7, 0xab, 0xd2, 0x2a, 0xb5, 0x88, 0xfd, 0x35, 0xa1, 0x61, 0xbc, 0xb4, 0x19, 0x9d, 0x66,
	0x75, 0x7b, 0x53, 0x32, 0xd3, 0xea, 0x45, 0xfe, 0x8c, 0xdf, 0x00, 0xed, 0x84, 0x0e, 0xb4, 0xba,
	0xbd, 0x2e, 0xf9, 0xb2, 0x7e, 0x91, 0x7b, 0xc2, 0xb7, 0x20, 0x3f, 0x0c, 0x03, 0x3a, 0xd3, 0x05,
	0x5f, 0x56, 0xe0, 0xfe, 0x9a, 0x40, 0x16, 0xda, 0x1f, 0xd3, 0xa9, 0x2e, 0xec, 0xa7, 0xe7, 0x89,
	0x16, 0xc6, 0xfc, 0x3d, 0x55, 0x6a, 0x95, 0xac, 0x48, 0x5a, 0x88, 0xd8, 0x5d, 0x90, 0xcb, 0x0d,
	0xc8, 0xc7, 0xf3, 0x41, 0x0d, 0xb2, 0x42, 0x69, 0x55, 0xe1, 0x4a, 0xf1, 0x7c, 0xc0, 0x7f, 0x01,
	0x05, 0x2c, 0xa0, 0x5a, 0x95, 0x84, 0x58, 0xea, 0x4c, 0xda, 0x12, 0xd0, 0x16, 0xf2, 0xf9, 0x16,
	0x68, 0x49, 0x6d, 0x3d, 0x2b, 0xb4, 0xac, 0x65, 0xf4, 0x29, 0xa9, 0x97, 0xa0, 0xe0, 0xbd, 0x9a,
	0x45, 0xc6, 0x04, 0xaa, 0x4d, 0x6f, 0xec, 0xce, 0x83, 0x84, 0xce, 0xe7, 0x2a, 0x14, 0xbd, 0x57,
	0xb2, 0x2d, 0x60, 0xed, 0x49, 0x84, 0xbf, 0xaf, 0x1a, 0x1f, 0x1d, 0x49, 0x75, 0xfb, 0x4a, 0x26,
	0xc2, 0xee, 0x34, 0x39, 0x42, 0x96, 0x90, 0x12, 0x58, 0x22, 0x7e, 0xdc, 0xa7, 0xa6, 0x9c, 0x4f,
	0x9b, 0xb2, 0x3d, 0x0f, 0x02, 0xe3, 0x2f, 0xf2, 0xb0, 0xb1, 0xa2, 0xc1, 0xdf, 0x81, 0xca, 0x7c,
	0xfa, 0x72, 0x1a, 0x9e, 0x4e, 0xfb, 0x27, 0xb2, 0x57, 0xec, 0xaf, 0x09, 0x5d, 0x91, 0x8e, 0xf8,
	0x9b, 0x50, 0xf6, 0xa7, 0xc9, 0xee, 0x4e, 0xff, 0x64, 0xd1, 0xc8, 0x4b, 0x44, 0x38, 0xe2, 0xb7,
	0xa0, 0x3a, 0xf2, 0x86, 0xfe, 0xb1, 0x1b, 0x10, 0x3b, 0xaf, 0xd8, 0xb0, 0x20, 0x1e, 0xf1, 0x4f,
	0x61, 0x5d, 0x61, 0x0f, 0xb6, 0x1f, 0xf5, 0x4f, 0x54, 0x6e, 0xa8, 0x60, 0x2c, 0x39, 0xfb, 0x6b,
	0xa2, 0xba, 0xc4, 0x8e, 0xf8, 0xdb, 0xa0, 0xcf, 0xd3, 0x55, 0x31, 0x63, 0x0a, 0xfb, 0x6b, 0xa2,
	0x3c, 0x57, 0xcb, 0xbe, 0x03, 0x95, 0x71, 0x10, 0xba, 0xc9, 0xc3, 0xed, 0xbe, 0xcc, 0x97, 0x1c,
	0x3a, 0xac, 0x48, 0x4b, 0x36, 0x29, 0x97, 0xd5, 0x57, 0x46, 0x57, 0xa4, 0x23, 0x7e, 0x1d, 0x4a,
	0x23, 0x37, 0xf1, 0xfa, 0x27, 0x94, 0x2a, 0xb8, 0xd7, 0x22, 0xe2, 0x47, 0xfc, 0x5d, 0x00, 0x04,
	0x1c, 0xff, 0x18, 0x99, 0x15, 0xb5, 0x99, 0x4a, 0x4a, 0xa3, 0xed, 0x26, 0xfe, 0xb1, 0xd7, 0x4d,
	0xdc, 0xe3, 0x59, 0xff, 0x84, 0x32, 0x84, 0xb6, 0xbb, 0x20, 0x92, 0xdf, 0x71, 0x12, 0xf9, 0xd3,
	0x49, 0xff, 0x84, 0x92, 0x03, 0x3f, 0x65, 0x65, 0x49, 0x39, 0xaa, 0x5f, 0x82, 0x8d, 0x61, 0x36,
	0xf2, 0xc6, 0x87, 0x00, 0xcb, 0x4d, 0x63, 0xc3, 0x6c, 0x87, 0xaa, 0x89, 0xe6, 0xda, 0x21, 0xe2,
	0xfb, 0x7e, 0xda, 0x40, 0xf7, 0x7d, 0x6c, 0xbb, 0xf8, 0xc9, 0x6a, 0x5e, 0xfc, 0x41, 0xc3, 0x94,
	0x71, 0x03, 0xdf, 0x8d, 0x55, 0xbd, 0x4a, 0x84, 0xbf, 0x07, 0x79, 0x37, 0x98, 0xd0, 0xd1, 0x6c,
	0x6e, 0xf3, 0x34, 0x61, 0x8e, 0x67, 0x91, 0x17, 0xc7, 0xb2, 0xe0, 0xdd, 0x60, 0x92, 0xb6, 0x83,
	0xc2, 0xc5, 0xed, 0xe0, 0x03, 0x28, 0x8f, 0x64, 0x6e, 0xaa, 0xea, 0x55, 0x33, 0x6b, 0x26, 0x61,
	0x45, 0x2a, 0xc1, 0x6b, 0x50, 0x9e, 0x45, 0xfe, 0xb1, 0x1b, 0x9d, 0xd1, 0xd1, 0xe8, 0x22, 0x45,
	0xd1, 0xc1, 0xd9, 0x4b, 0x7f, 0xf4, 0x8a, 0xce, 0xa4, 0x28, 0x24, 0x62, 0x7c, 0xaf, 0x81, 0xde,
	0x9a, 0x8e, 0xbc, 0x57, 0xb8, 0xaf, 0x7b, 0xcb, 0xb6, 0xb4, 0xb9, 0x5d, 0x93, 0xab, 0xa4, 0x4c,
	0x09, 0x2c, 0xbd, 0x4a, 0x63, 0x90, 0xcb, 0xc4, 0xe0, 0x6d, 0xa8, 0xa4, 0x9d, 0x29, 0xae, 0xe5,
	0xb7, 0xf2, 0x77, 0x2b, 0x42, 0x57, 0xad, 0x29, 0x36, 0xee, 0x43, 0x65, 0x61, 0x02, 0x67, 0x9d,
	0x96, 0x7d, 0x64, 0xb6, 0xda, 0x4d, 0xb6, 0x86, 0xc8, 0x37, 0x1d, 0xdb, 0x3a, 0x30, 0x0f, 0x99,
	0x86, 0x43, 0x6f, 0xbd, 0xdb, 0x62, 0x39, 0xe3, 0x0e, 0x6c, 0x1c, 0x4a, 0xd7, 0x9f, 0x78, 0x67,
	0xe8, 0xdd, 0x55, 0x28, 0x4a, 0xcb, 0x1a, 0x59, 0x96, 0x88, 0xb1, 0x0d, 0xfa, 0x61, 0x14, 0xce,
	0xbc, 0x28, 0x39, 0xc3, 0x6f, 0xd9, 0x4b, 0xef, 0x4c, 0x1d, 0x0b, 0x82, 0xa8, 0xb3, 0x2c, 0xd9,
	0x8a, 0xaa, 0x4e, 0xe3, 0x4b, 0x34, 0x4d, 0x3a, 0xbe, 0x17, 0xa3, 0xe9, 0xfb, 0x00, 0xb3, 0x05,
	0x41, 0xcd, 0x02, 0x69, 0x8f, 0x54, 0xc6, 0x45, 0x46, 0xc2, 0xf8, 0x3e, 0x07, 0xba, 0x83, 0x0d,
	0xf9, 0xff, 0x96, 0x0d, 0x5b, 0xd8, 0xb7, 0x02, 0x19, 0x9a, 0x6c, 0x13, 0x6d, 0xe2, 0x37, 0x0d,
	0x39, 0xfc, 0x1e, 0x14, 0x46, 0xde, 0x38, 0xae, 0x15, 0x48, 0xe2, 0x5a, 0xda, 0xb4, 0xe4, 0x4a,
	0x78, 0xe2, 0x74, 0x00, 0x24, 0xf3, 0xd6, 0x5f, 0x6b, 0x50, 0x56, 0x14, 0x7e, 0x07, 0x72, 0xb3,
	0x97, 0xea, 0x7b, 0x72, 0x25, 0x75, 0x3c, 0x13, 0xbc, 0xfd, 0x35, 0x91, 0x9b, 0xbd, 0xc4, 0xe6,
	0x8a, 0x19, 0x90, 0xcb, 0x36, 0xd7, 0xf4, 0x80, 0xb1, 0xb9, 0xfa, 0xa3, 0x57, 0xfc, 0xd3, 0x95,
	0x58, 0xe4, 0x57, 0x4d, 0x66, 0x82, 0x86, 0xa5, 0xb7, 0x14, 0xac, 0x17, 0x21, 0x3f, 0xf2, 0xc6,
	0x46, 0x04, 0x85, 0x46, 0x18, 0x27, 0x18, 0x94, 0xa1, 0x1b, 0xc9, 0xe1, 0x47, 0x13, 0x04, 0x63,
	0x6e, 0x46, 0xe1, 0x29, 0xdd, 0x83, 0x72, 0x44, 0x4e, 0x51, 0x3c, 0xb8, 0xe9, 0x48, 0x76, 0x30,
	0x4d, 0x20, 0x48, 0x97, 0xa3, 0xc4, 0x8d, 0x12, 0x2a, 0x0a, 0x4d, 0x48, 0x04, 0xa9, 0x49, 0x98,
	0xa8, 0x89, 0x54, 0x13, 0x12, 0x31, 0xfe, 0x51, 0x83, 0x32, 0x46, 0xd1, 0x4d, 0x5c, 0x4c, 0xc1,
	0x28, 0x3c, 0xed, 0x0f, 0xc3, 0xf9, 0x34, 0x51, 0x93, 0x97, 0x1e, 0x85, 0xa7, 0x0d, 0xc4, 0xf1,
	0xc3, 0x8a, 0x2d, 0x59, 0x71, 0xe5, 0x50, 0x58, 0x41, 0x8a, 0x64, 0x63, 0x82, 0xcd, 0x03, 0x75,
	0x3e, 0xba, 0x90, 0x08, 0xfa, 0xe6, 0x3f, 0xdc, 0xa6, 0x13, 0x29, 0x0a, 0x04, 0x89, 0xb2, 0xbb,
	0x53, 0x2b, 0x6e, 0xe5, 0x71, 0x64, 0xf2, 0x77, 0x77, 0x90, 0x32, 0x7e, 0xb8, 0x5d, 0x2b, 0x6d,
	0xe5, 0xef, 0xe6, 0x04, 0x82, 0x44, 0xd9, 0xdd, 0xa9, 0x95, 0xb7, 0xf2, 0xb8, 0xa3, 0xf1, 0xee,
	0x0e, 0x5f, 0x07, 0x2d, 0xae, 0xe9, 0x94, 0xba, 0x5a, 0x6c, 0x3c, 0x05, 0x10, 0xe1, 0x69, 0xec,
	0x25, 0xe4, 0xf5, 0x2f, 0x16, 0xc3, 0x99, 0x96, 0x3d, 0x9a, 0xf4, 0xe0, 0x17, 0xc3, 0xda, 0x2d,
	0x95, 0x40, 0x72, 0xe4, 0xd9, 0x58, 0x26, 0x90, 0x9b, 0xb8, 0x32, 0x83, 0x8c, 0x7f, 0xd3, 0xa0,
	0xda, 0x89, 0x46, 0x5e, 0x54, 0x3f, 0xeb, 0xce, 0x3c, 0x9a, 0x92, 0xf0, 0x0b, 0xb7, 0x3a, 0x6b,
	0xc8, 0x29, 0xc9, 0x93, 0xa3, 0x08, 0xd6, 0x6c, 0xe0, 0xe2, 0x77, 0x3a, 0x9d, 0x35, 0x16, 0x04,
	0xfe, 0x00, 0x0a, 0xe3, 0xc0, 0x4d, 0x1b, 0xd8, 0x3b, 0x6a, 0x10, 0x5b, 0x9a, 0x4f, 0x61, 0x9c,
	0xb1, 0x04, 0x89, 0x1a, 0xdf, 0x2e, 0xd6, 0xa7, 0xc1, 0x0b, 0x2f, 0xb1, 0xdd, 0x86, 0xbc, 0xc4,
	0x36, 0xad, 0x6e, 0x83, 0x69, 0xfc, 0x12, 0x54, 0x71, 0x60, 0xea, 0xf6, 0x1f, 0xb7, 0x44, 0xd7,
	0x61, 0x39, 0xbc, 0x15, 0x49, 0x42, 0xdb, 0xec, 0x3a, 0x72, 0xf4, 0xea, 0xd9, 0xad, 0x5f, 0xf7,
	0x2c, 0xa6, 0xaf, 0x8c, 0x6b, 0x0c, 0x67, 0x3a, 0x78, 0xea, 0x4f, 0x47, 0xe1, 0x29, 0x6d, 0xee,
	0x23, 0x58, 0x9f, 0xb9, 0x51, 0xe2, 0xa3, 0xaf, 0xfd, 0xc1, 0xd9, 0x05, 0x53, 0x7c, 0x75, 0xc1,
	0xaf, 0x9f, 0xf1, 0x0f, 0x41, 0x0f, 0xd1, 0x35, 0x14, 0x95, 0x21, 0xbc, 0x7c, 0x6e, 0x47, 0xa2,
	0x1c, 0x4a, 0x04, 0x53, 0x38, 0xf0, 0xdc, 0x91, 0xba, 0xe6, 0x13, 0x8c, 0xc7, 0x8a, 0xe1, 0x90,
	0xf7, 0x7b, 0x04, 0x8d, 0x23, 0x80, 0xde, 0x0c, 0x3f, 0x52, 0x74, 0x9d, 0x78, 0x8f, 0xee, 0x1c,
	0xf3, 0xe3, 0x69, 0x7c, 0x81, 0x2f, 0x29, 0x8b, 0x1b, 0x50, 0xa2, 0x46, 0x74, 0xd1, 0xec, 0xaa,
	0x38, 0xc6, 0x7f, 0x01, 0x14, 0xec, 0x70, 0xe4, 0xf1, 0x4f, 0xa0, 0x42, 0x37, 0x89, 0xe4, 0x6c,
	0xe6, 0xa9, 0xd6, 0xac, 0xca, 0x11, 0xd9, 0xf4, 0x87, 0x9a, 0x82, 0x3e, 0x55, 0x50, 0xf6, 0xee,
	0x91, 0x5b, 0xb9, 0x7b, 0xdc, 0xc4, 0xf4, 0x89, 0x13, 0x55, 0xd4, 0x90, 0xa6, 0x4f, 0x9c, 0x08,
	0xa2, 0x53, 0x38, 0xa3, 0x10, 0xa7, 0xec, 0x3e, 0x4d, 0x6a, 0x85, 0x0b, 0xc2, 0x29, 0xf9, 0xb4,
	0xd9, 0xb7, 0x40, 0x1f, 0x3e, 0xf7, 0x83, 0x51, 0xe4, 0x4d, 0xa9, 0x18, 0x8a, 0x62, 0x81, 0xa3,
	0xd7, 0x2f, 0x42, 0x7f, 0x2a, 0xbd, 0x2e, 0x9d, 0xf3, 0xfa, 0xab, 0xd0, 0x9f, 0x52, 0xce, 0xe8,
	0x28, 0x45, 0x5e, 0xdf, 0x86, 0x72, 0x38, 0x95, 0xeb, 0x96, 0xcf, 0x47, 0x25, 0x9c, 0xb6, 0xe5,
	0x08, 0x06, 0xa7, 0xcf, 0xbd, 0xc8, 0x93, 0x72, 0xfa, 0x39, 0xb9, 0x0a, 0x71, 0x49, 0xf4, 0x0e,
	0xe8, 0x93, 0x28, 0x9c, 0xcf, 0xf0, 0xb0, 0x2b, 0xe7, 0xcf, 0x82, 0x78, 0xf5, 0x33, 0xdc, 0x33,
	0x81, 0x38, 0x34, 0xc4, 0x5e, 0x52, 0x83, 0xf3, 0x7b, 0x4e, 0xf9, 0x5d, 0x8f, 0xac, 0xba, 0x93,
	0x89, 0x5c, 0xbe, 0x7a, 0xde, 0xaa, 0x3b, 0x99, 0xd0, 0xe2, 0xd9, 0x4c, 0x5b, 0xff, 0x9d, 0x99,
	0xf6, 0x00, 0xaa, 0x73, 0xca, 0x21, 0x69, 0x77, 0x23, 0x3b, 0xa4, 0x2d, 0x93, 0x4b, 0xc0, 0x7c,
	0x99, 0x68, 0x1f, 0x80, 0x7e, 0xea, 0x4f, 0xfb, 0xf1, 0xcc, 0x1b, 0xd6, 0x36, 0xb3, 0xf2, 0xcb,
	0xea, 0x10, 0xe5, 0x53, 0x7f, 0x4a, 0x65, 0xb2, 0x05, 0xc5, 0xc0, 0x3f, 0xf6, 0x93, 0xda, 0xa5,
	0x73, 0x4d, 0x40, 0x32, 0x30, 0x23, 0xc3, 0xf1, 0x18, 0xf7, 0xcf, 0xce, 0x89, 0x28, 0x0e, 0xff,
	0x00, 0xe4, 0x25, 0xa4, 0x3f, 0xf2, 0xc6, 0xb5, 0xcb, 0x17, 0xf6, 0x29, 0x3d, 0x49, 0x3f, 0x8a,
	0x77, 0x01, 0x6f, 0x76, 0xfd, 0xc8, 0x1b, 0xd7, 0xf8, 0xc5, 0x97, 0xb8, 0x52, 0x38, 0x78, 0x81,
	0x17, 0xd8, 0x07, 0x50, 0x8d, 0xa8, 0x13, 0xf6, 0x47, 0x6e, 0xe2, 0xd6, 0xae, 0x64, 0x37, 0xb3,
	0x6c, 0x91, 0x02, 0xa2, 0x65, 0xbb, 0xbc, 0x0d, 0x1b, 0xde, 0xab, 0x24, 0x72, 0xfb, 0xe1, 0x0c,
	0x2b, 0x3b, 0xae, 0x5d, 0xa5, 0xbe, 0xb5, 0x4e, 0xc4, 0x8e, 0xa4, 0x71, 0x03, 0xd6, 0xe7, 0xb1,
	0xd7, 0xf4, 0x02, 0x2f, 0xf1, 0x9e, 0x78, 0x67, 0xb5, 0x37, 0xa4, 0x4c, 0x96, 0x66, 0xfc, 0x4f,
	0x0e, 0xf4, 0xb4, 0x80, 0xe8, 0xad, 0xcb, 0x7e, 0x62, 0x77, 0x9e, 0xda, 0x6c, 0x0d, 0x5b, 0xd2,
	0x91, 0xd9, 0xee, 0x59, 0xfd, 0x6e, 0xc3, 0xb4, 0x99, 0x86, 0x38, 0x5d, 0x13, 0x25, 0x9e, 0xe3,
	0x97, 0x61, 0xe3, 0x71, 0xcf, 0x6e, 0x38, 0xad, 0x8e, 0x2d, 0x49, 0x79, 0x24, 0x59, 0x5f, 0xcb,
	0x4e, 0x25, 0x49, 0x05, 0x24, 0x1d, 0x98, 0x8e, 0x25, 0x5a, 0x29, 0xa9, 0x88, 0xab, 0x1c, 0x8a,
	0xce, 0x57, 0x56, 0xc3, 0x61, 0xc0, 0xdf, 0x80, 0xcb, 0x0b, 0x95, 0xd4, 0x1c, 0xab, 0x62, 0xcf,
	0x4b, 0xd5, 0xd8, 0x55, 0x34, 0x22, 0xac, 0x46, 0x4f, 0x74, 0x5b, 0x47, 0x56, 0xbf, 0xe1, 0x58,
	0xec, 0x0d, 0x7a, 0x10, 0x6c, 0xd9, 0x4f, 0xd8, 0x35, 0xbe, 0x01, 0x15, 0x84, 0xa4, 0xf5, 0xeb,
	0xd4, 0x6d, 0xf7, 0xf6, 0xd8, 0x4d, 0x7a, 0x98, 0xea, 0xb4, 0x6c, 0xf6, 0x2e, 0xdd, 0x63, 0xcd,
	0x83, 0xc3, 0xb6, 0xc5, 0xb6, 0x48, 0xaf, 0x23, 0x1c, 0x76, 0x8b, 0x9e, 0xc9, 0x6c, 0x5c, 0xcd,
	0x40, 0x13, 0x04, 0xf6, 0xcd, 0x76, 0x9b, 0xdd, 0xce, 0x34, 0xdf, 0xf7, 0x10, 0x7e, 0xda, 0xb2,
	0x9b, 0x9d, 0xa7, 0xec, 0x0e, 0x8a, 0xd5, 0x45, 0xc7, 0x6c, 0x36, 0xb0, 0x47, 0xd3, 0x9b, 0x5c,
	0xf7, 0xb0, 0xdd, 0x72, 0xd8, 0xfb, 0x28, 0xb5, 0x67, 0x3a, 0xfb, 0x96, 0x60, 0xf7, 0xe8, 0x75,
	0xaf, 0xdb, 0xb5, 0x84, 0xc3, 0xb6, 0xe5, 0xbb, 0x23, 0xc1, 0x0f, 0xc9, 0xea, 0x21, 0xbd, 0xc6,
	0xed, 0x20, 0xdc, 0xb4, 0xda, 0x96, 0x63, 0xb1, 0x4f, 0x8d, 0x1e, 0xe8, 0x69, 0x2f, 0x90, 0x4f,
	0x96, 0xb6, 0x25, 0xd8, 0x1a, 0x82, 0x9d, 0x9e, 0x63, 0xa9, 0x27, 0xcf, 0xae, 0x75, 0xd0, 0x62,
	0x39, 0x84, 0x4c, 0xdb, 0x69, 0xa9, 0xbb, 0x79, 0xcb, 0xde, 0x6b, 0xe3, 0x07, 0x42, 0x87, 0xc2,
	0x81, 0x29, 0x9e, 0x30, 0x46, 0xef, 0x6c, 0x87, 0x87, 0xed, 0x67, 0x6c, 0xcb, 0xb8, 0x0b, 0x65,
	0x73, 0x32, 0x39, 0xc0, 0xfe, 0xa9, 0x43, 0xe1, 0x31, 0x5e, 0xcf, 0xd7, 0xe8, 0xb1, 0xad, 0xe3,
	0x38, 0x9d, 0x03, 0x39, 0x66, 0x3a, 0x9d, 0x43, 0x96, 0x33, 0xfe, 0x5b, 0x83, 0xa2, 0x7c, 0xb2,
	0xd9, 0x85, 0x4a, 0x9c, 0x1c, 0x27, 0xd9, 0x46, 0xfb, 0xa6, 0x4c, 0x43, 0xe2, 0xdf, 0xef, 0x26,
	0x6e, 0xe2, 0x1d, 0x7b, 0xd3, 0x44, 0xb6, 0x5b, 0x94, 0xa5, 0xbc, 0xa1, 0x51, 0xc5, 0x9b, 0xc9,
	0x66, 0x5e, 0x14, 0x12, 0xc1, 0x9a, 0xc3, 0xae, 0x9b, 0x0e, 0x7b, 0xb0, 0x6c, 0x7e, 0x42, 0x32,
	0xb0, 0xe6, 0x66, 0x78, 0x01, 0x8f, 0x2f, 0xe8, 0xb3, 0x8a, 0x63, 0x3c, 0x85, 0x8d, 0x95, 0x65,
	0x57, 0x93, 0x14, 0xc3, 0x60, 0xb5, 0x31, 0x95, 0xb4, 0x4c, 0xb0, 0x73, 0x99, 0x00, 0xe7, 0x33,
	0x81, 0x2f, 0x60, 0x80, 0x0e, 0x2c, 0xb1, 0x67, 0xb1, 0xa2, 0xf1, 0xf7, 0x39, 0xb8, 0xec, 0x44,
	0xee, 0x34, 0xa6, 0xef, 0x7c, 0x23, 0x9c, 0x26, 0x51, 0x18, 0xf0, 0x5f, 0x82, 0x9e, 0x0c, 0x83,
	0x6c, 0x04, 0xde, 0x55, 0x15, 0xfe, 0xba, 0xe8, 0x7d, 0x67, 0x18, 0x50, 0x1c, 0xca, 0x89, 0x04,
	0xf8, 0x47, 0x50, 0x1c, 0x78, 0x13, 0x7f, 0xaa, 0xa6, 0xcb, 0x37, 0x5e, 0x57, 0xac, 0x23, 0x13,
	0xaf, 0x7b, 0x24, 0xc5, 0x3f, 0x81, 0xd2, 0x30, 0x3c, 0xc6, 0xa6, 0x24, 0xbf, 0x46, 0xd7, 0xce,
	0x2f, 0x84, 0x5c, 0xbc, 0xee, 0x4a, 0x39, 0xbe, 0x0b, 0x7a, 0x14, 0x06, 0xc1, 0xc0, 0x1d, 0xbe,
	0x54, 0x57, 0xa5, 0xda, 0xeb, 0x3a, 0x42, 0xf1, 0xf1, 0xc6, 0x99, 0xca, 0x1a, 0xf7, 0xa1, 0xac,
	0x9c, 0xa5, 0x57, 0x55, 0x6b, 0xaf, 0xa5, 0x62, 0xd7, 0xe8, 0x1c, 0x1c, 0xb4, 0x30, 0x76, 0xeb,
	0xa0, 0x8b, 0x4e, 0xbb, 0x5d, 0x37, 0x1b, 0x4f, 0x58, 0xae, 0xae, 0x43, 0xc9, 0xa5, 0x67, 0x0b,
	0xe3, 0xcf, 0x35, 0xb8, 0xf4, 0xda, 0x06, 0xf8, 0x23, 0x28, 0x1c, 0x87, 0xa3, 0x34, 0x3c, 0xef,
	0x5d, 0xb8, 0xcb, 0x0c, 0x8e, 0x29, 0x28, 0x48, 0xc3, 0xf8, 0x0c, 0x36, 0x57, 0xe9, 0x99, 0x47,
	0xa9, 0x0d, 0xa8, 0x08, 0xcb, 0x6c, 0xf6, 0x3b, 0x76, 0xfb, 0x99, 0xec, 0x36, 0x84, 0x3e, 0x15,
	0x2d, 0xc7, 0x62, 0x39, 0xe3, 0x5b, 0x60, 0xaf, 0x07, 0x86, 0xef, 0xc1, 0xa5, 0x61, 0x78, 0x3c,
	0x0b, 0x3c, 0x1a, 0x7e, 0x32, 0x47, 0x76, 0xf3, 0x82, 0x48, 0x2a, 0x31, 0x3a, 0xb1, 0xcd, 0xe1,
	0x0a, 0x6e, 0xfc, 0x09, 0xf0, 0xf3, 0x11, 0xfc, 0xff, 0x33, 0xff, 0x97, 0x1a, 0x14, 0x0e, 0x03,
	0x77, 0xca, 0x6f, 0x43, 0xf1, 0x4f, 0xb1, 0x90, 0xd4, 0x28, 0x5a, 0xcd, 0xd4, 0x16, 0xa6, 0x05,
	0xf1, 0xf8, 0x07, 0x90, 0x4f, 0x86, 0x81, 0xca, 0xa1, 0xeb, 0x3f, 0x92, 0x7c, 0x78, 0x55, 0x49,
	0x86, 0x01, 0xbf, 0x0b, 0xf9, 0xd1, 0x28, 0x50, 0x09, 0x74, 0x55, 0xdd, 0x8a, 0xdd, 0xc4, 0x6d,
	0x7a, 0x63, 0x7f, 0xea, 0xab, 0x97, 0x27, 0x14, 0xa9, 0x97, 0x80, 0x7e, 0x32, 0x32, 0xfe, 0xac,
	0x02, 0x9b, 0xab, 0x12, 0xfc, 0x0f, 0x41, 0x1f, 0x8d, 0x56, 0x72, 0xfe, 0xc6, 0x45, 0x96, 0xee,
	0x37, 0x47, 0x2a, 0xe1, 0x47, 0x12, 0xe0, 0xb7, 0xd2, 0xfd, 0xe4, 0xce, 0xed, 0x27, 0xdd, 0xcd,
	0x97, 0x70, 0x69, 0x18, 0x79, 0xf8, 0x61, 0xc7, 0x6f, 0xdb, 0xc0, 0x8d, 0xbd, 0x55, 0x67, 0x1b,
	0xc4, 0x6c, 0x2a, 0xde, 0xfe, 0x9a, 0xd8, 0x1c, 0xae, 0x50, 0xf8, 0xe7, 0xb0, 0xe9, 0x06, 0x89,
	0x17, 0x2d, 0xf5, 0x0b, 0xd9, 0x0b, 0x99, 0x89, 0xbc, 0x8c, 0xfa, 0x86, 0x9b, 0x25, 0xf0, 0xcf,
	0x60, 0x63, 0x14, 0x85, 0xb3, 0xa5, 0xb2, 0x7c, 0x3f, 0x50, 0xef, 0x10, 0xcd, 0x28, 0x9c, 0x65,
	0x74, 0xd7, 0x47, 0x19, 0x9c, 0xef, 0xc2, 0xba, 0xf2, 0x9c, 0x3e, 0xe9, 0xea, 0x5d, 0xf0, 0x72,
	0xd6, 0x6d, 0xfa, 0xea, 0xef, 0xaf, 0x89, 0xea, 0x70, 0x89, 0xf2, 0x87, 0x50, 0x95, 0x0e, 0x4b,
	0xb5, 0x72, 0xf6, 0x6b, 0x4e, 0xde, 0xa6, 0x5a, 0xe0, 0x2e, 0x30, 0xfe, 0x09, 0x00, 0xf9, 0x29,
	0x75, 0xf4, 0xec, 0xbc, 0x80, 0x4e, 0xa6, 0x2a, 0x95, 0x51, 0x8a, 0x64, 0xdc, 0xf3, 0xf1, 0xfa,
	0xaa, 0xde, 0x14, 0x57, 0xdc, 0xa3, 0x7b, 0xed, 0xd2, 0x3d, 0x42, 0x97, 0xee, 0x49, 0x35, 0x38,
	0xe7, 0x5e, 0xaa, 0x25, 0xdd, 0x93, 0x4a, 0xa9, 0x7b, 0x52, 0xa7, 0xfa, 0xba, 0x7b, 0xa9, 0x0a,
	0xb9, 0x27, 0x35, 0x3e, 0x87, 0xcd, 0x24, 0x9a, 0x4f, 0x87, 0xcb, 0xf8, 0xad, 0x67, 0x8f, 0xcd,
	0x51, 0xbc, 0x74, 0x63, 0x1b, 0x49, 0x96, 0x80, 0xda, 0xf1, 0xf3, 0xf0, 0xb4, 0x7f, 0xe2, 0x46,
	0x3e, 0x12, 0x62, 0x35, 0x11, 0x2a, 0xed, 0xee, 0xf3, 0xf0, 0xf4, 0x28, 0x65, 0xa1, 0x76, 0x9c,
	0x25, 0x18, 0x7f, 0x93, 0x87, 0xb2, 0xca, 0x55, 0x7e, 0x05, 0x2e, 0x35, 0x84, 0x65, 0x3a, 0x56,
	0xbf, 0x69, 0x3a, 0x66, 0xdd, 0xec, 0x62, 0xaf, 0xe1, 0xb0, 0x69, 0xb6, 0x1d, 0x4b, 0x2c, 0x69,
	0x1a, 0xce, 0x18, 0x4d, 0xd1, 0x39, 0x5c, 0x92, 0x72, 0x9c, 0xc1, 0xba, 0xd2, 0x95, 0xef, 0xe3,
	0x79, 0xbc, 0xb7, 0x49, 0x45, 0x49, 0x28, 0xd0, 0xef, 0x7c, 0xa8, 0x25, 0xf1, 0x62, 0x46, 0xa5,
	0x65, 0x37, 0xad, 0xaf, 0x59, 0x69, 0xa9, 0x22, 0x09, 0xe5, 0x85, 0x8a, 0xc4, 0x75, 0x74, 0xc6,
	0x11, 0x3d, 0xbb, 0xb1, 0x5c, 0xa7, 0xc2, 0xaf, 0xc3, 0x95, 0xee, 0x7e, 0xe7, 0x69, 0x5f, 0xda,
	0x5a, 0xb8, 0x04, 0xfc, 0x2a, 0xb0, 0x0c, 0x43, 0x8a, 0x57, 0xd1, 0x04, 0x51, 0x53, 0xc1, 0x2e,
	0x5b, 0xc7, 0x75, 0x89, 0x46, 0x32, 0x5d, 0xb6, 0x81, 0xae, 0x49, 0xd5, 0x4e, 0xbb, 0x77, 0x60,
	0x77, 0xd9, 0x26, 0x7a, 0x42, 0x14, 0xe9, 0xc9, 0xa5, 0x85, 0x99, 0x23, 0x53, 0xb4, 0xa4, 0x16,
	0xc3, 0xb0, 0x10, 0xed, 0xa9, 0x29, 0xec, 0x96, 0xbd, 0xd7, 0x65, 0x97, 0x17, 0x96, 0x2d, 0x21,
	0x3a, 0xa2, 0xcb, 0xf8, 0x82, 0xd0, 0x75, 0x4c, 0xa7, 0xd7, 0x65, 0x57, 0x16, 0x5e, 0x1e, 0x8a,
	0x4e, 0xc3, 0xea, 0x76, 0xdb, 0xad, 0xae, 0xc3, 0xae, 0xd6, 0xd7, 0x01, 0x46, 0x8b, 0x66, 0x62,
	0x1c, 0xc2, 0xe6, 0x6a, 0xed, 0x73, 0x03, 0x36, 0xfc, 0x71, 0x7f, 0x1a, 0x26, 0x7d, 0x7a, 0x6c,
	0x8e, 0xd5, 0xd3, 0x73, 0xd5, 0x1f, 0xdb, 0x61, 0x62, 0x11, 0x09, 0x2f, 0x5c, 0x8b, 0x52, 0x96,
	0x57, 0xf5, 0x05, 0x6e, 0xec, 0xc3, 0xc6, 0x4a, 0x37, 0xa0, 0xdf, 0x90, 0xc6, 0xab, 0xc6, 0x74,
	0x7f, 0xfc, 0x33, 0x2c, 0xed, 0xc1, 0x7a, 0xb6, 0x35, 0xfc, 0xfe, 0x86, 0xfe, 0x56, 0x83, 0x6a,
	0xa6, 0x55, 0xfc, 0xac, 0x2d, 0xde, 0x80, 0x4a, 0xe2, 0x1d, 0xcf, 0xc2, 0xc8, 0x55, 0x8d, 0x55,
	0x17, 0x4b, 0xc2, 0xca, 0x6a, 0xf9, 0xd5, 0xd5, 0x56, 0xaf, 0x27, 0x85, 0x9f, 0xbe, 0x9e, 0x18,
	0x1d, 0x80, 0x65, 0x37, 0xa2, 0x67, 0x25, 0xaa, 0x52, 0xf9, 0x84, 0x27, 0x91, 0x55, 0x83, 0xb9,
	0xdf, 0x61, 0xf0, 0x1b, 0xa8, 0x2c, 0x5a, 0xd5, 0xef, 0x1d, 0xb1, 0xa5, 0x23, 0xf9, 0x8c, 0x23,
	0xc6, 0x5e, 0x1a, 0x46, 0xd9, 0x5c, 0x7e, 0x4e, 0x18, 0xaf, 0x42, 0x51, 0x76, 0x2b, 0xf5, 0xfe,
	0x48, 0x88, 0x61, 0xa8, 0x5d, 0x4b, 0x3b, 0x0b, 0x19, 0x2d, 0x2b, 0xf3, 0x85, 0xdc, 0x88, 0x14,
	0xf9, 0xc9, 0x8d, 0x5c, 0xbc, 0xc6, 0x1d, 0xd8, 0x58, 0x69, 0x6f, 0x17, 0x07, 0xd7, 0x68, 0xc1,
	0xc6, 0x4a, 0x1f, 0xe3, 0xd7, 0xa0, 0x34, 0x09, 0xc2, 0x81, 0xbb, 0xf8, 0x15, 0x5b, 0x62, 0x38,
	0x47, 0xd3, 0x9d, 0xfe, 0x82, 0xa7, 0x12, 0xc9, 0xb8, 0x77, 0x0b, 0xd6, 0xb3, 0x4f, 0xea, 0x34,
	0x55, 0x85, 0x53, 0x8f, 0xad, 0xe1, 0x90, 0xdf, 0xfe, 0xcd, 0x0e, 0xd3, 0xee, 0xfd, 0x0a, 0x6a,
	0x3f, 0x36, 0xaf, 0xe0, 0x4c, 0xd8, 0xd8, 0x37, 0x69, 0x26, 0x5c, 0x07, 0xdd, 0xee, 0xf4, 0x25,
	0xa6, 0xe1, 0xa8, 0x2d, 0xac, 0xb6, 0x45, 0xdd, 0xb0, 0xfe, 0xe5, 0x6f, 0x7f, 0xb8, 0xa9, 0xfd,
	0xcb, 0x0f, 0x37, 0xb5, 0x7f, 0xff, 0xe1, 0xe6, 0xda, 0xdf, 0xfd, 0xe7, 0x4d, 0xed, 0x9b, 0xec,
	0x7f, 0x9f, 0x1c, 0xbb, 0x49, 0xe4, 0xbf, 0x0a, 0x23, 0x7f, 0xe2, 0x4f, 0x53, 0x64, 0xea, 0x7d,
	0x3c, 0x7b, 0x39, 0xf9, 0x78, 0x36, 0xf8, 0x18, 0x3d, 0x1e, 0x94, 0xe8, 0x9f, 0x50, 0x1e, 0xfe,
	0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x89, 0xd6, 0xc1, 0xfc, 0xc7, 0x22, 0x00, 0x00,
}

func (m *Type) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Type) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Id))
	}
	if m.Nullable {
		dAtA[i] = 0x10
		i++
		if m.Nullable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Width != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Width))
	}
	if m.Precision != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Precision))
	}
	if m.Size != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Size))
	}
	if m.Scale != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Scale))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Const) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Const) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Isnull {
		dAtA[i] = 0x8
		i++
		if m.Isnull {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Value != nil {
		nn1, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Const_Ival) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintPlan(dAtA, i, uint64(m.Ival))
	return i, nil
}
func (m *Const_Dval) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x19
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Dval))))
	i += 8
	return i, nil
}
func (m *Const_Sval) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x22
	i++
	i = encodeVarintPlan(dAtA, i, uint64(len(m.Sval)))
	i += copy(dAtA[i:], m.Sval)
	return i, nil
}
func (m *Const_Bval) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x28
	i++
	if m.Bval {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *ParamRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParamRef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pos != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Pos))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VarRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VarRef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ColRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColRef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RelPos != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.RelPos))
	}
	if m.ColPos != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.ColPos))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CorrColRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CorrColRef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.NodeId))
	}
	if m.ColPos != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.ColPos))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExprList) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExprList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPlan(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TargetType) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TargetType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Typ != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Typ.ProtoSize()))
		n2, err := m.Typ.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SubQuery) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.NodeId))
	}
	if m.IsCorrelated {
		dAtA[i] = 0x10
		i++
		if m.IsCorrelated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsScalar {
		dAtA[i] = 0x18
		i++
		if m.IsScalar {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ObjectRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectRef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Server != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Server))
	}
	if m.Db != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Db))
	}
	if m.Schema != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Schema))
	}
	if m.Obj != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Obj))
	}
	if len(m.ServerName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ServerName)))
		i += copy(dAtA[i:], m.ServerName)
	}
	if len(m.DbName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i += copy(dAtA[i:], m.DbName)
	}
	if len(m.SchemaName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.SchemaName)))
		i += copy(dAtA[i:], m.SchemaName)
	}
	if len(m.ObjName) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ObjName)))
		i += copy(dAtA[i:], m.ObjName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Function) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Function) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Func != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Func.ProtoSize()))
		n3, err := m.Func.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Args) > 0 {
		for _, msg := range m.Args {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPlan(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Expr) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Expr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Typ != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Typ.ProtoSize()))
		n4, err := m.Typ.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.TableName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TableName)))
		i += copy(dAtA[i:], m.TableName)
	}
	if len(m.ColName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ColName)))
		i += copy(dAtA[i:], m.ColName)
	}
	if m.Expr != nil {
		nn5, err := m.Expr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Expr_C) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.C != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.C.ProtoSize()))
		n6, err := m.C.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *Expr_P) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.P != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.P.ProtoSize()))
		n7, err := m.P.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *Expr_V) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.V != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.V.ProtoSize()))
		n8, err := m.V.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *Expr_Col) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Col != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Col.ProtoSize()))
		n9, err := m.Col.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *Expr_F) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.F != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.F.ProtoSize()))
		n10, err := m.F.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *Expr_List) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.List != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.List.ProtoSize()))
		n11, err := m.List.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *Expr_Sub) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Sub != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Sub.ProtoSize()))
		n12, err := m.Sub.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *Expr_Corr) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Corr != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Corr.ProtoSize()))
		n13, err := m.Corr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *Expr_T) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.T != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.T.ProtoSize()))
		n14, err := m.T.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func (m *DefaultExpr) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefaultExpr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exist {
		dAtA[i] = 0x8
		i++
		if m.Exist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Value.ProtoSize()))
		n15, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.IsNull {
		dAtA[i] = 0x18
		i++
		if m.IsNull {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConstantValue) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConstantValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConstantValue != nil {
		nn16, err := m.ConstantValue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn16
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConstantValue_UnknownV) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintPlan(dAtA, i, uint64(m.UnknownV))
	return i, nil
}
func (m *ConstantValue_Int64V) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintPlan(dAtA, i, uint64(m.Int64V))
	return i, nil
}
func (m *ConstantValue_Decimal64V) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	i = encodeVarintPlan(dAtA, i, uint64(m.Decimal64V))
	return i, nil
}
func (m *ConstantValue_Decimal128V) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Decimal128V != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Decimal128V.ProtoSize()))
		n17, err := m.Decimal128V.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *ConstantValue_Uint64V) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x28
	i++
	i = encodeVarintPlan(dAtA, i, uint64(m.Uint64V))
	return i, nil
}
func (m *ConstantValue_Float32V) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x35
	i++
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Float32V))))
	i += 4
	return i, nil
}
func (m *ConstantValue_Float64V) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x39
	i++
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Float64V))))
	i += 8
	return i, nil
}
func (m *ConstantValue_DateV) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x40
	i++
	i = encodeVarintPlan(dAtA, i, uint64(m.DateV))
	return i, nil
}
func (m *ConstantValue_DateTimeV) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x48
	i++
	i = encodeVarintPlan(dAtA, i, uint64(m.DateTimeV))
	return i, nil
}
func (m *ConstantValue_TimeStampV) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x50
	i++
	i = encodeVarintPlan(dAtA, i, uint64(m.TimeStampV))
	return i, nil
}
func (m *ConstantValue_StringV) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x5a
	i++
	i = encodeVarintPlan(dAtA, i, uint64(len(m.StringV)))
	i += copy(dAtA[i:], m.StringV)
	return i, nil
}
func (m *Decimal128) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Decimal128) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Lo != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Lo))
	}
	if m.Hi != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Hi))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ColDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColDef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Alias) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Alias)))
		i += copy(dAtA[i:], m.Alias)
	}
	if m.Alg != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Alg))
	}
	if m.Typ != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Typ.ProtoSize()))
		n18, err := m.Typ.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Default != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Default.ProtoSize()))
		n19, err := m.Default.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.Primary {
		dAtA[i] = 0x30
		i++
		if m.Primary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Pkidx != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Pkidx))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IndexDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexDef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Typ != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Typ))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.ColNames) > 0 {
		for _, s := range m.ColNames {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PrimaryKeyDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrimaryKeyDef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Property) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Property) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PropertiesDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropertiesDef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Properties) > 0 {
		for _, msg := range m.Properties {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPlan(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TableDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Alias) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Alias)))
		i += copy(dAtA[i:], m.Alias)
	}
	if len(m.Cols) > 0 {
		for _, msg := range m.Cols {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintPlan(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Defs) > 0 {
		for _, msg := range m.Defs {
			dAtA[i] = 0x22
			i++
			i = encodeVarintPlan(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TableDef_DefType) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDef_DefType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Def != nil {
		nn20, err := m.Def.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn20
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TableDef_DefType_Pk) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Pk != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Pk.ProtoSize()))
		n21, err := m.Pk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}
func (m *TableDef_DefType_Idx) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Idx != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Idx.ProtoSize()))
		n22, err := m.Idx.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}
func (m *TableDef_DefType_Properties) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Properties != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Properties.ProtoSize()))
		n23, err := m.Properties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *Cost) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cost) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Card != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Card))))
		i += 8
	}
	if m.Rowsize != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Rowsize))))
		i += 8
	}
	if m.Ndv != 0 {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Ndv))))
		i += 8
	}
	if m.Start != 0 {
		dAtA[i] = 0x21
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Start))))
		i += 8
	}
	if m.Total != 0 {
		dAtA[i] = 0x29
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Total))))
		i += 8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ColData) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RowCount != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.RowCount))
	}
	if m.NullCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.NullCount))
	}
	if len(m.Nulls) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Nulls)))
		for _, b := range m.Nulls {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.I32) > 0 {
		dAtA25 := make([]byte, len(m.I32)*10)
		var j24 int
		for _, num1 := range m.I32 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintPlan(dAtA, i, uint64(j24))
		i += copy(dAtA[i:], dAtA25[:j24])
	}
	if len(m.I64) > 0 {
		dAtA27 := make([]byte, len(m.I64)*10)
		var j26 int
		for _, num1 := range m.I64 {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(j26))
		i += copy(dAtA[i:], dAtA27[:j26])
	}
	if len(m.F32) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.F32)*4))
		for _, num := range m.F32 {
			f28 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f28))
			i += 4
		}
	}
	if len(m.F64) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.F64)*8))
		for _, num := range m.F64 {
			f29 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f29))
			i += 8
		}
	}
	if len(m.S) > 0 {
		for _, s := range m.S {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RowsetData) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowsetData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Schema != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Schema.ProtoSize()))
		n30, err := m.Schema.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if len(m.Cols) > 0 {
		for _, msg := range m.Cols {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPlan(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OrderBySpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderBySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Expr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Expr.ProtoSize()))
		n31, err := m.Expr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if len(m.Collation) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Collation)))
		i += copy(dAtA[i:], m.Collation)
	}
	if m.Flag != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Flag))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WindowSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PartitionBy) > 0 {
		for _, msg := range m.PartitionBy {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPlan(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OrderBy) > 0 {
		for _, msg := range m.OrderBy {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPlan(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Lead != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Lead))
	}
	if m.Lag != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Lag))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateList) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, msg := range m.Columns {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPlan(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Values) > 0 {
		for _, msg := range m.Values {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPlan(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.NodeType))
	}
	if m.NodeId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.NodeId))
	}
	if m.Cost != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Cost.ProtoSize()))
		n32, err := m.Cost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if len(m.ProjectList) > 0 {
		for _, msg := range m.ProjectList {
			dAtA[i] = 0x22
			i++
			i = encodeVarintPlan(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Children) > 0 {
		dAtA34 := make([]byte, len(m.Children)*10)
		var j33 int
		for _, num1 := range m.Children {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA34[j33] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j33++
			}
			dAtA34[j33] = uint8(num)
			j33++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(j33))
		i += copy(dAtA[i:], dAtA34[:j33])
	}
	if m.JoinType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.JoinType))
	}
	if len(m.OnList) > 0 {
		for _, msg := range m.OnList {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintPlan(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.WhereList) > 0 {
		for _, msg := range m.WhereList {
			dAtA[i] = 0x42
			i++
			i = encodeVarintPlan(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.GroupBy) > 0 {
		for _, msg := range m.GroupBy {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintPlan(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.GroupingSet) > 0 {
		for _, msg := range m.GroupingSet {
			dAtA[i] = 0x52
			i++
			i = encodeVarintPlan(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AggList) > 0 {
		for _, msg := range m.AggList {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintPlan(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OrderBy) > 0 {
		for _, msg := range m.OrderBy {
			dAtA[i] = 0x62
			i++
			i = encodeVarintPlan(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.UpdateList != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.UpdateList.ProtoSize()))
		n35, err := m.UpdateList.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.WinSpec != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.WinSpec.ProtoSize()))
		n36, err := m.WinSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.Limit != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Limit.ProtoSize()))
		n37, err := m.Limit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.Offset != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Offset.ProtoSize()))
		n38, err := m.Offset.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.TableDef != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.TableDef.ProtoSize()))
		n39, err := m.TableDef.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.ObjRef != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.ObjRef.ProtoSize()))
		n40, err := m.ObjRef.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.RowsetData != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.RowsetData.ProtoSize()))
		n41, err := m.RowsetData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if len(m.ExtraOptions) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ExtraOptions)))
		i += copy(dAtA[i:], m.ExtraOptions)
	}
	if len(m.UseDeleteKey) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.UseDeleteKey)))
		i += copy(dAtA[i:], m.UseDeleteKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Query) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Query) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StmtType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.StmtType))
	}
	if len(m.Steps) > 0 {
		dAtA43 := make([]byte, len(m.Steps)*10)
		var j42 int
		for _, num1 := range m.Steps {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA43[j42] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j42++
			}
			dAtA43[j42] = uint8(num)
			j42++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlan(dAtA, i, uint64(j42))
		i += copy(dAtA[i:], dAtA43[:j42])
	}
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintPlan(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Params) > 0 {
		for _, msg := range m.Params {
			dAtA[i] = 0x22
			i++
			i = encodeVarintPlan(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransationControl) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransationControl) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TclType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.TclType))
	}
	if m.Action != nil {
		nn44, err := m.Action.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn44
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransationControl_Begin) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Begin != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Begin.ProtoSize()))
		n45, err := m.Begin.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	return i, nil
}
func (m *TransationControl_Commit) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Commit != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Commit.ProtoSize()))
		n46, err := m.Commit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	return i, nil
}
func (m *TransationControl_Rollback) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Rollback != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Rollback.ProtoSize()))
		n47, err := m.Rollback.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}
func (m *TransationBegin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransationBegin) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Mode))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransationCommit) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransationCommit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CompletionType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.CompletionType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransationRollback) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransationRollback) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CompletionType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.CompletionType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Plan) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Plan) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Plan != nil {
		nn48, err := m.Plan.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn48
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Plan_Query) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Query != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Query.ProtoSize()))
		n49, err := m.Query.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	return i, nil
}
func (m *Plan_Tcl) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Tcl != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Tcl.ProtoSize()))
		n50, err := m.Tcl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	return i, nil
}
func (m *Plan_Ddl) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Ddl != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Ddl.ProtoSize()))
		n51, err := m.Ddl.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	return i, nil
}
func (m *DataDefinition) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataDefinition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DdlType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.DdlType))
	}
	if m.Query != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.Query.ProtoSize()))
		n52, err := m.Query.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.Definition != nil {
		nn53, err := m.Definition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn53
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DataDefinition_CreateDatabase) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CreateDatabase != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.CreateDatabase.ProtoSize()))
		n54, err := m.CreateDatabase.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	return i, nil
}
func (m *DataDefinition_AlterDatabase) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AlterDatabase != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.AlterDatabase.ProtoSize()))
		n55, err := m.AlterDatabase.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	return i, nil
}
func (m *DataDefinition_DropDatabase) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DropDatabase != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.DropDatabase.ProtoSize()))
		n56, err := m.DropDatabase.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	return i, nil
}
func (m *DataDefinition_CreateTable) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CreateTable != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.CreateTable.ProtoSize()))
		n57, err := m.CreateTable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	return i, nil
}
func (m *DataDefinition_AlterTable) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AlterTable != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.AlterTable.ProtoSize()))
		n58, err := m.AlterTable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	return i, nil
}
func (m *DataDefinition_DropTable) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DropTable != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.DropTable.ProtoSize()))
		n59, err := m.DropTable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	return i, nil
}
func (m *DataDefinition_CreateIndex) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CreateIndex != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.CreateIndex.ProtoSize()))
		n60, err := m.CreateIndex.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	return i, nil
}
func (m *DataDefinition_AlterIndex) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AlterIndex != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.AlterIndex.ProtoSize()))
		n61, err := m.AlterIndex.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	return i, nil
}
func (m *DataDefinition_DropIndex) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DropIndex != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.DropIndex.ProtoSize()))
		n62, err := m.DropIndex.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	return i, nil
}
func (m *DataDefinition_TruncateTable) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TruncateTable != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.TruncateTable.ProtoSize()))
		n63, err := m.TruncateTable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	return i, nil
}
func (m *DataDefinition_ShowVariables) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ShowVariables != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.ShowVariables.ProtoSize()))
		n64, err := m.ShowVariables.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	return i, nil
}
func (m *CreateDatabase) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateDatabase) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IfNotExists {
		dAtA[i] = 0x8
		i++
		if m.IfNotExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Database) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i += copy(dAtA[i:], m.Database)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AlterDatabase) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterDatabase) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IfExists {
		dAtA[i] = 0x8
		i++
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Database) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i += copy(dAtA[i:], m.Database)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DropDatabase) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropDatabase) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IfExists {
		dAtA[i] = 0x8
		i++
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Database) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i += copy(dAtA[i:], m.Database)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateTable) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateTable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IfNotExists {
		dAtA[i] = 0x8
		i++
		if m.IfNotExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Temporary {
		dAtA[i] = 0x10
		i++
		if m.Temporary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Database) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i += copy(dAtA[i:], m.Database)
	}
	if m.TableDef != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.TableDef.ProtoSize()))
		n65, err := m.TableDef.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AlterTable) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Table) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i += copy(dAtA[i:], m.Table)
	}
	if m.TableDef != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlan(dAtA, i, uint64(m.TableDef.ProtoSize()))
		n66, err := m.TableDef.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DropTable) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropTable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IfExists {
		dAtA[i] = 0x8
		i++
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Database) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i += copy(dAtA[i:], m.Database)
	}
	if len(m.Table) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i += copy(dAtA[i:], m.Table)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateIndex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IfNotExists {
		dAtA[i] = 0x8
		i++
		if m.IfNotExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Index) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Index)))
		i += copy(dAtA[i:], m.Index)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AlterIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterIndex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Index) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Index)))
		i += copy(dAtA[i:], m.Index)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DropIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropIndex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IfExists {
		dAtA[i] = 0x8
		i++
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Index) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Index)))
		i += copy(dAtA[i:], m.Index)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TruncateTable) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TruncateTable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Table) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i += copy(dAtA[i:], m.Table)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShowVariables) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowVariables) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Global {
		dAtA[i] = 0x8
		i++
		if m.Global {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Where) > 0 {
		for _, msg := range m.Where {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPlan(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintPlan(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Type) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlan(uint64(m.Id))
	}
	if m.Nullable {
		n += 2
	}
	if m.Width != 0 {
		n += 1 + sovPlan(uint64(m.Width))
	}
	if m.Precision != 0 {
		n += 1 + sovPlan(uint64(m.Precision))
	}
	if m.Size != 0 {
		n += 1 + sovPlan(uint64(m.Size))
	}
	if m.Scale != 0 {
		n += 1 + sovPlan(uint64(m.Scale))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Const) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Isnull {
		n += 2
	}
	if m.Value != nil {
		n += m.Value.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Const_Ival) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.Ival))
	return n
}
func (m *Const_Dval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *Const_Sval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sval)
	n += 1 + l + sovPlan(uint64(l))
	return n
}
func (m *Const_Bval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *ParamRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pos != 0 {
		n += 1 + sovPlan(uint64(m.Pos))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VarRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RelPos != 0 {
		n += 1 + sovPlan(uint64(m.RelPos))
	}
	if m.ColPos != 0 {
		n += 1 + sovPlan(uint64(m.ColPos))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CorrColRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeId != 0 {
		n += 1 + sovPlan(uint64(m.NodeId))
	}
	if m.ColPos != 0 {
		n += 1 + sovPlan(uint64(m.ColPos))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExprList) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TargetType) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Typ != nil {
		l = m.Typ.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubQuery) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeId != 0 {
		n += 1 + sovPlan(uint64(m.NodeId))
	}
	if m.IsCorrelated {
		n += 2
	}
	if m.IsScalar {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Server != 0 {
		n += 1 + sovPlan(uint64(m.Server))
	}
	if m.Db != 0 {
		n += 1 + sovPlan(uint64(m.Db))
	}
	if m.Schema != 0 {
		n += 1 + sovPlan(uint64(m.Schema))
	}
	if m.Obj != 0 {
		n += 1 + sovPlan(uint64(m.Obj))
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.SchemaName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.ObjName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Function) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Func != nil {
		l = m.Func.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, e := range m.Args {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Expr) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Typ != nil {
		l = m.Typ.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.ColName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Expr != nil {
		n += m.Expr.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Expr_C) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.C != nil {
		l = m.C.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_P) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.P != nil {
		l = m.P.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_V) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.V != nil {
		l = m.V.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_Col) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Col != nil {
		l = m.Col.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_F) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.F != nil {
		l = m.F.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_List) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.List != nil {
		l = m.List.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_Sub) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sub != nil {
		l = m.Sub.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_Corr) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Corr != nil {
		l = m.Corr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_T) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.T != nil {
		l = m.T.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DefaultExpr) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Exist {
		n += 2
	}
	if m.Value != nil {
		l = m.Value.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.IsNull {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConstantValue) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConstantValue != nil {
		n += m.ConstantValue.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConstantValue_UnknownV) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.UnknownV))
	return n
}
func (m *ConstantValue_Int64V) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.Int64V))
	return n
}
func (m *ConstantValue_Decimal64V) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.Decimal64V))
	return n
}
func (m *ConstantValue_Decimal128V) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Decimal128V != nil {
		l = m.Decimal128V.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *ConstantValue_Uint64V) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.Uint64V))
	return n
}
func (m *ConstantValue_Float32V) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	return n
}
func (m *ConstantValue_Float64V) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *ConstantValue_DateV) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.DateV))
	return n
}
func (m *ConstantValue_DateTimeV) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.DateTimeV))
	return n
}
func (m *ConstantValue_TimeStampV) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.TimeStampV))
	return n
}
func (m *ConstantValue_StringV) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StringV)
	n += 1 + l + sovPlan(uint64(l))
	return n
}
func (m *Decimal128) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lo != 0 {
		n += 1 + sovPlan(uint64(m.Lo))
	}
	if m.Hi != 0 {
		n += 1 + sovPlan(uint64(m.Hi))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Alias)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Alg != 0 {
		n += 1 + sovPlan(uint64(m.Alg))
	}
	if m.Typ != nil {
		l = m.Typ.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Default != nil {
		l = m.Default.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Primary {
		n += 2
	}
	if m.Pkidx != 0 {
		n += 1 + sovPlan(uint64(m.Pkidx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IndexDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Typ != 0 {
		n += 1 + sovPlan(uint64(m.Typ))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.ColNames) > 0 {
		for _, s := range m.ColNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrimaryKeyDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Property) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PropertiesDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Properties) > 0 {
		for _, e := range m.Properties {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Alias)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Cols) > 0 {
		for _, e := range m.Cols {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Defs) > 0 {
		for _, e := range m.Defs {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableDef_DefType) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Def != nil {
		n += m.Def.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableDef_DefType_Pk) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pk != nil {
		l = m.Pk.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TableDef_DefType_Idx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Idx != nil {
		l = m.Idx.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TableDef_DefType_Properties) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Properties != nil {
		l = m.Properties.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Cost) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Card != 0 {
		n += 9
	}
	if m.Rowsize != 0 {
		n += 9
	}
	if m.Ndv != 0 {
		n += 9
	}
	if m.Start != 0 {
		n += 9
	}
	if m.Total != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColData) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RowCount != 0 {
		n += 1 + sovPlan(uint64(m.RowCount))
	}
	if m.NullCount != 0 {
		n += 1 + sovPlan(uint64(m.NullCount))
	}
	if len(m.Nulls) > 0 {
		n += 1 + sovPlan(uint64(len(m.Nulls))) + len(m.Nulls)*1
	}
	if len(m.I32) > 0 {
		l = 0
		for _, e := range m.I32 {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.I64) > 0 {
		l = 0
		for _, e := range m.I64 {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.F32) > 0 {
		n += 1 + sovPlan(uint64(len(m.F32)*4)) + len(m.F32)*4
	}
	if len(m.F64) > 0 {
		n += 1 + sovPlan(uint64(len(m.F64)*8)) + len(m.F64)*8
	}
	if len(m.S) > 0 {
		for _, s := range m.S {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RowsetData) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Schema != nil {
		l = m.Schema.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Cols) > 0 {
		for _, e := range m.Cols {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrderBySpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Collation)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Flag != 0 {
		n += 1 + sovPlan(uint64(m.Flag))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WindowSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PartitionBy) > 0 {
		for _, e := range m.PartitionBy {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OrderBy) > 0 {
		for _, e := range m.OrderBy {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Lead != 0 {
		n += 1 + sovPlan(uint64(m.Lead))
	}
	if m.Lag != 0 {
		n += 1 + sovPlan(uint64(m.Lag))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateList) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Node) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeType != 0 {
		n += 1 + sovPlan(uint64(m.NodeType))
	}
	if m.NodeId != 0 {
		n += 1 + sovPlan(uint64(m.NodeId))
	}
	if m.Cost != nil {
		l = m.Cost.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.ProjectList) > 0 {
		for _, e := range m.ProjectList {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Children) > 0 {
		l = 0
		for _, e := range m.Children {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.JoinType != 0 {
		n += 1 + sovPlan(uint64(m.JoinType))
	}
	if len(m.OnList) > 0 {
		for _, e := range m.OnList {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.WhereList) > 0 {
		for _, e := range m.WhereList {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.GroupBy) > 0 {
		for _, e := range m.GroupBy {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.GroupingSet) > 0 {
		for _, e := range m.GroupingSet {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.AggList) > 0 {
		for _, e := range m.AggList {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OrderBy) > 0 {
		for _, e := range m.OrderBy {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.UpdateList != nil {
		l = m.UpdateList.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.WinSpec != nil {
		l = m.WinSpec.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Limit != nil {
		l = m.Limit.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Offset != nil {
		l = m.Offset.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.ObjRef != nil {
		l = m.ObjRef.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.RowsetData != nil {
		l = m.RowsetData.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	l = len(m.ExtraOptions)
	if l > 0 {
		n += 2 + l + sovPlan(uint64(l))
	}
	l = len(m.UseDeleteKey)
	if l > 0 {
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Query) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StmtType != 0 {
		n += 1 + sovPlan(uint64(m.StmtType))
	}
	if len(m.Steps) > 0 {
		l = 0
		for _, e := range m.Steps {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Params) > 0 {
		for _, e := range m.Params {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransationControl) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TclType != 0 {
		n += 1 + sovPlan(uint64(m.TclType))
	}
	if m.Action != nil {
		n += m.Action.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransationControl_Begin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Begin != nil {
		l = m.Begin.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TransationControl_Commit) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TransationControl_Rollback) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rollback != nil {
		l = m.Rollback.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TransationBegin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovPlan(uint64(m.Mode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransationCommit) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompletionType != 0 {
		n += 1 + sovPlan(uint64(m.CompletionType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransationRollback) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompletionType != 0 {
		n += 1 + sovPlan(uint64(m.CompletionType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Plan) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Plan != nil {
		n += m.Plan.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Plan_Query) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Query != nil {
		l = m.Query.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Plan_Tcl) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tcl != nil {
		l = m.Tcl.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Plan_Ddl) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ddl != nil {
		l = m.Ddl.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DdlType != 0 {
		n += 1 + sovPlan(uint64(m.DdlType))
	}
	if m.Query != nil {
		l = m.Query.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Definition != nil {
		n += m.Definition.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataDefinition_CreateDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateDatabase != nil {
		l = m.CreateDatabase.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_AlterDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterDatabase != nil {
		l = m.AlterDatabase.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_DropDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropDatabase != nil {
		l = m.DropDatabase.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_CreateTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateTable != nil {
		l = m.CreateTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_AlterTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterTable != nil {
		l = m.AlterTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_DropTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropTable != nil {
		l = m.DropTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_CreateIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateIndex != nil {
		l = m.CreateIndex.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_AlterIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterIndex != nil {
		l = m.AlterIndex.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_DropIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropIndex != nil {
		l = m.DropIndex.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_TruncateTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TruncateTable != nil {
		l = m.TruncateTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_ShowVariables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowVariables != nil {
		l = m.ShowVariables.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *CreateDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfNotExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DropDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfNotExists {
		n += 2
	}
	if m.Temporary {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DropTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfNotExists {
		n += 2
	}
	l = len(m.Index)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Index)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DropIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfExists {
		n += 2
	}
	l = len(m.Index)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TruncateTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowVariables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Global {
		n += 2
	}
	if len(m.Where) > 0 {
		for _, e := range m.Where {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPlan(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPlan(x uint64) (n int) {
	return sovPlan(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Type) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= Type_TypeId(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nullable = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precision", wireType)
			}
			m.Precision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Precision |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size", wireType)
			}
			m.Size = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			m.Scale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scale |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Const) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Const: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Const: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isnull", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Isnull = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ival", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_Ival{v}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dval", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = &Const_Dval{float64(math.Float64frombits(v))}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &Const_Sval{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bval", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &Const_Bval{b}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParamRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParamRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParamRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VarRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VarRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VarRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelPos", wireType)
			}
			m.RelPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColPos", wireType)
			}
			m.ColPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CorrColRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CorrColRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CorrColRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColPos", wireType)
			}
			m.ColPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExprList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExprList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExprList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &Expr{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TargetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Typ == nil {
				m.Typ = &Type{}
			}
			if err := m.Typ.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCorrelated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCorrelated = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsScalar", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsScalar = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			m.Server = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Server |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Db", wireType)
			}
			m.Db = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Db |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			m.Schema = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Schema |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Obj", wireType)
			}
			m.Obj = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Obj |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Function) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Function: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Function: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Func", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Func == nil {
				m.Func = &ObjectRef{}
			}
			if err := m.Func.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, &Expr{})
			if err := m.Args[len(m.Args)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Expr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Typ == nil {
				m.Typ = &Type{}
			}
			if err := m.Typ.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field C", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Const{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_C{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ParamRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_P{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VarRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_V{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Col", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Col{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Function{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_F{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ExprList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_List{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sub", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SubQuery{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Sub{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Corr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CorrColRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Corr{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TargetType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_T{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefaultExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefaultExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefaultExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exist = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &ConstantValue{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNull", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNull = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConstantValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConstantValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConstantValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnknownV", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConstantValue = &ConstantValue_UnknownV{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64V", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConstantValue = &ConstantValue_Int64V{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimal64V", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConstantValue = &ConstantValue_Decimal64V{v}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimal128V", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Decimal128{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConstantValue = &ConstantValue_Decimal128V{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint64V", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConstantValue = &ConstantValue_Uint64V{v}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float32V", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ConstantValue = &ConstantValue_Float32V{float32(math.Float32frombits(v))}
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float64V", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ConstantValue = &ConstantValue_Float64V{float64(math.Float64frombits(v))}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateV", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConstantValue = &ConstantValue_DateV{v}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateTimeV", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConstantValue = &ConstantValue_DateTimeV{v}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStampV", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConstantValue = &ConstantValue_TimeStampV{v}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringV", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConstantValue = &ConstantValue_StringV{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Decimal128) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: decimal128: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: decimal128: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lo", wireType)
			}
			m.Lo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lo |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hi", wireType)
			}
			m.Hi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hi |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alias = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alg", wireType)
			}
			m.Alg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alg |= CompressType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Typ == nil {
				m.Typ = &Type{}
			}
			if err := m.Typ.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Default == nil {
				m.Default = &DefaultExpr{}
			}
			if err := m.Default.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Primary = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pkidx", wireType)
			}
			m.Pkidx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pkidx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			m.Typ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typ |= IndexDef_IndexType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColNames = append(m.ColNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimaryKeyDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimaryKeyDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimaryKeyDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Property) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Property: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Property: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropertiesDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropertiesDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropertiesDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = append(m.Properties, &Property{})
			if err := m.Properties[len(m.Properties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alias = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cols = append(m.Cols, &ColDef{})
			if err := m.Cols[len(m.Cols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Defs = append(m.Defs, &TableDef_DefType{})
			if err := m.Defs[len(m.Defs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDef_DefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PrimaryKeyDef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Def = &TableDef_DefType_Pk{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IndexDef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Def = &TableDef_DefType_Idx{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PropertiesDef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Def = &TableDef_DefType_Properties{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cost) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cost: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cost: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Card = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rowsize", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Rowsize = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ndv", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Ndv = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Start = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Total = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowCount", wireType)
			}
			m.RowCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullCount", wireType)
			}
			m.NullCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NullCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Nulls = append(m.Nulls, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.Nulls) == 0 {
					m.Nulls = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Nulls = append(m.Nulls, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Nulls", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.I32 = append(m.I32, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.I32) == 0 {
					m.I32 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.I32 = append(m.I32, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field I32", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.I64 = append(m.I64, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.I64) == 0 {
					m.I64 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.I64 = append(m.I64, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field I64", wireType)
			}
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.F32 = append(m.F32, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.F32) == 0 {
					m.F32 = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.F32 = append(m.F32, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field F32", wireType)
			}
		case 7:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.F64 = append(m.F64, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.F64) == 0 {
					m.F64 = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.F64 = append(m.F64, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field F64", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S = append(m.S, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowsetData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowsetData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowsetData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schema == nil {
				m.Schema = &TableDef{}
			}
			if err := m.Schema.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cols = append(m.Cols, &ColData{})
			if err := m.Cols[len(m.Cols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderBySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderBySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderBySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= OrderBySpec_OrderByFlag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionBy = append(m.PartitionBy, &Expr{})
			if err := m.PartitionBy[len(m.PartitionBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBy = append(m.OrderBy, &OrderBySpec{})
			if err := m.OrderBy[len(m.OrderBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lead", wireType)
			}
			m.Lead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lead |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lag", wireType)
			}
			m.Lag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &Expr{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &Expr{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeType", wireType)
			}
			m.NodeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeType |= Node_NodeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cost == nil {
				m.Cost = &Cost{}
			}
			if err := m.Cost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectList = append(m.ProjectList, &Expr{})
			if err := m.ProjectList[len(m.ProjectList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Children = append(m.Children, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Children) == 0 {
					m.Children = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Children = append(m.Children, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinType", wireType)
			}
			m.JoinType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinType |= Node_JoinFlag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnList = append(m.OnList, &Expr{})
			if err := m.OnList[len(m.OnList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WhereList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WhereList = append(m.WhereList, &Expr{})
			if err := m.WhereList[len(m.WhereList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = append(m.GroupBy, &Expr{})
			if err := m.GroupBy[len(m.GroupBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupingSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupingSet = append(m.GroupingSet, &Expr{})
			if err := m.GroupingSet[len(m.GroupingSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggList = append(m.AggList, &Expr{})
			if err := m.AggList[len(m.AggList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBy = append(m.OrderBy, &OrderBySpec{})
			if err := m.OrderBy[len(m.OrderBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateList == nil {
				m.UpdateList = &UpdateList{}
			}
			if err := m.UpdateList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WinSpec == nil {
				m.WinSpec = &WindowSpec{}
			}
			if err := m.WinSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limit == nil {
				m.Limit = &Expr{}
			}
			if err := m.Limit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Offset == nil {
				m.Offset = &Expr{}
			}
			if err := m.Offset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjRef == nil {
				m.ObjRef = &ObjectRef{}
			}
			if err := m.ObjRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowsetData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RowsetData == nil {
				m.RowsetData = &RowsetData{}
			}
			if err := m.RowsetData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraOptions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraOptions = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseDeleteKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UseDeleteKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Query) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Query: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Query: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StmtType", wireType)
			}
			m.StmtType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StmtType |= Query_StatementType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Steps = append(m.Steps, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Steps) == 0 {
					m.Steps = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Steps = append(m.Steps, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params, &Expr{})
			if err := m.Params[len(m.Params)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransationControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransationControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransationControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TclType", wireType)
			}
			m.TclType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TclType |= TransationControl_TclType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TransationBegin{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &TransationControl_Begin{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TransationCommit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &TransationControl_Commit{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rollback", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TransationRollback{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &TransationControl_Rollback{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransationBegin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransationBegin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransationBegin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= TransationBegin_TransationMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransationCommit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransationCommit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransationCommit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionType", wireType)
			}
			m.CompletionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletionType |= TransationCompletionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransationRollback) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransationRollback: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransationRollback: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionType", wireType)
			}
			m.CompletionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletionType |= TransationCompletionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Plan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Plan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Plan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Query{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Plan = &Plan_Query{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tcl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TransationControl{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Plan = &Plan_Tcl{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ddl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataDefinition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Plan = &Plan_Ddl{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DdlType", wireType)
			}
			m.DdlType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DdlType |= DataDefinition_DdlType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &Query{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateDatabase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateDatabase{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_CreateDatabase{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterDatabase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterDatabase{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_AlterDatabase{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropDatabase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DropDatabase{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_DropDatabase{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_CreateTable{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_AlterTable{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DropTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_DropTable{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_CreateIndex{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_AlterIndex{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DropIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_DropIndex{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TruncateTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TruncateTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_TruncateTable{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowVariables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShowVariables{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_ShowVariables{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateDatabase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateDatabase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateDatabase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfNotExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfNotExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterDatabase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterDatabase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterDatabase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropDatabase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropDatabase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropDatabase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfNotExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfNotExists = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temporary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Temporary = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfNotExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfNotExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TruncateTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TruncateTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TruncateTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowVariables) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowVariables: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowVariables: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Global = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Where = append(m.Where, &Expr{})
			if err := m.Where[len(m.Where)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPlan(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPlan
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthPlan
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPlan(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthPlan
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPlan = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPlan   = fmt.Errorf("proto: integer overflow")
)
