// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: plan.proto

package plan

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CompressType int32

const (
	CompressType_None CompressType = 0
	CompressType_Lz4  CompressType = 1
)

var CompressType_name = map[int32]string{
	0: "None",
	1: "Lz4",
}

var CompressType_value = map[string]int32{
	"None": 0,
	"Lz4":  1,
}

func (x CompressType) String() string {
	return proto.EnumName(CompressType_name, int32(x))
}

func (CompressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{0}
}

type PartitionType int32

const (
	PartitionType_KEY           PartitionType = 0
	PartitionType_LINEAR_KEY    PartitionType = 1
	PartitionType_HASH          PartitionType = 2
	PartitionType_LINEAR_HASH   PartitionType = 3
	PartitionType_RANGE         PartitionType = 4
	PartitionType_RANGE_COLUMNS PartitionType = 5
	PartitionType_LIST          PartitionType = 6
	PartitionType_LIST_COLUMNS  PartitionType = 7
)

var PartitionType_name = map[int32]string{
	0: "KEY",
	1: "LINEAR_KEY",
	2: "HASH",
	3: "LINEAR_HASH",
	4: "RANGE",
	5: "RANGE_COLUMNS",
	6: "LIST",
	7: "LIST_COLUMNS",
}

var PartitionType_value = map[string]int32{
	"KEY":           0,
	"LINEAR_KEY":    1,
	"HASH":          2,
	"LINEAR_HASH":   3,
	"RANGE":         4,
	"RANGE_COLUMNS": 5,
	"LIST":          6,
	"LIST_COLUMNS":  7,
}

func (x PartitionType) String() string {
	return proto.EnumName(PartitionType_name, int32(x))
}

func (PartitionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{1}
}

type ShuffleType int32

const (
	ShuffleType_Hash  ShuffleType = 0
	ShuffleType_Range ShuffleType = 1
)

var ShuffleType_name = map[int32]string{
	0: "Hash",
	1: "Range",
}

var ShuffleType_value = map[string]int32{
	"Hash":  0,
	"Range": 1,
}

func (x ShuffleType) String() string {
	return proto.EnumName(ShuffleType_name, int32(x))
}

func (ShuffleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{2}
}

type ShuffleMethod int32

const (
	ShuffleMethod_Normal    ShuffleMethod = 0
	ShuffleMethod_Reuse     ShuffleMethod = 1
	ShuffleMethod_Reshuffle ShuffleMethod = 2
)

var ShuffleMethod_name = map[int32]string{
	0: "Normal",
	1: "Reuse",
	2: "Reshuffle",
}

var ShuffleMethod_value = map[string]int32{
	"Normal":    0,
	"Reuse":     1,
	"Reshuffle": 2,
}

func (x ShuffleMethod) String() string {
	return proto.EnumName(ShuffleMethod_name, int32(x))
}

func (ShuffleMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{3}
}

type TransationCompletionType int32

const (
	TransationCompletionType_CHAIN    TransationCompletionType = 0
	TransationCompletionType_NO_CHAIN TransationCompletionType = 1
	TransationCompletionType_RELEASE  TransationCompletionType = 2
)

var TransationCompletionType_name = map[int32]string{
	0: "CHAIN",
	1: "NO_CHAIN",
	2: "RELEASE",
}

var TransationCompletionType_value = map[string]int32{
	"CHAIN":    0,
	"NO_CHAIN": 1,
	"RELEASE":  2,
}

func (x TransationCompletionType) String() string {
	return proto.EnumName(TransationCompletionType_name, int32(x))
}

func (TransationCompletionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{4}
}

type TableLockType int32

const (
	TableLockType_TableLockNone             TableLockType = 0
	TableLockType_TableLockRead             TableLockType = 1
	TableLockType_TableLockReadLocal        TableLockType = 2
	TableLockType_TableLockWrite            TableLockType = 3
	TableLockType_TableLockLowPriorityWrite TableLockType = 4
)

var TableLockType_name = map[int32]string{
	0: "TableLockNone",
	1: "TableLockRead",
	2: "TableLockReadLocal",
	3: "TableLockWrite",
	4: "TableLockLowPriorityWrite",
}

var TableLockType_value = map[string]int32{
	"TableLockNone":             0,
	"TableLockRead":             1,
	"TableLockReadLocal":        2,
	"TableLockWrite":            3,
	"TableLockLowPriorityWrite": 4,
}

func (x TableLockType) String() string {
	return proto.EnumName(TableLockType_name, int32(x))
}

func (TableLockType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{5}
}

type SubqueryRef_Type int32

const (
	SubqueryRef_SCALAR     SubqueryRef_Type = 0
	SubqueryRef_EXISTS     SubqueryRef_Type = 1
	SubqueryRef_NOT_EXISTS SubqueryRef_Type = 2
	SubqueryRef_IN         SubqueryRef_Type = 3
	SubqueryRef_NOT_IN     SubqueryRef_Type = 4
	SubqueryRef_ANY        SubqueryRef_Type = 5
	SubqueryRef_ALL        SubqueryRef_Type = 6
)

var SubqueryRef_Type_name = map[int32]string{
	0: "SCALAR",
	1: "EXISTS",
	2: "NOT_EXISTS",
	3: "IN",
	4: "NOT_IN",
	5: "ANY",
	6: "ALL",
}

var SubqueryRef_Type_value = map[string]int32{
	"SCALAR":     0,
	"EXISTS":     1,
	"NOT_EXISTS": 2,
	"IN":         3,
	"NOT_IN":     4,
	"ANY":        5,
	"ALL":        6,
}

func (x SubqueryRef_Type) String() string {
	return proto.EnumName(SubqueryRef_Type_name, int32(x))
}

func (SubqueryRef_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{10, 0}
}

// Function flags
type Function_FuncFlag int32

const (
	Function_NONE Function_FuncFlag = 0
	// Internal function is generated by system, cannot
	// by called by user.
	Function_INTERNAL Function_FuncFlag = 1
	// Function, by default is immutable.
	Function_STABLE   Function_FuncFlag = 2
	Function_VOLATILE Function_FuncFlag = 4
	// Nulls
	Function_STRICT          Function_FuncFlag = 8
	Function_PRODUCE_NULL    Function_FuncFlag = 16
	Function_PRODUCE_NO_NULL Function_FuncFlag = 32
	// Vararg, all trailing args must be of the same type.
	Function_VARARG Function_FuncFlag = 64
	// Window and Agg
	Function_AGG       Function_FuncFlag = 128
	Function_WIN_VALUE Function_FuncFlag = 256
	Function_WIN_ORDER Function_FuncFlag = 512
	// Monotonic function can filter by zonemap
	Function_MONOTONIC Function_FuncFlag = 1024
)

var Function_FuncFlag_name = map[int32]string{
	0:    "NONE",
	1:    "INTERNAL",
	2:    "STABLE",
	4:    "VOLATILE",
	8:    "STRICT",
	16:   "PRODUCE_NULL",
	32:   "PRODUCE_NO_NULL",
	64:   "VARARG",
	128:  "AGG",
	256:  "WIN_VALUE",
	512:  "WIN_ORDER",
	1024: "MONOTONIC",
}

var Function_FuncFlag_value = map[string]int32{
	"NONE":            0,
	"INTERNAL":        1,
	"STABLE":          2,
	"VOLATILE":        4,
	"STRICT":          8,
	"PRODUCE_NULL":    16,
	"PRODUCE_NO_NULL": 32,
	"VARARG":          64,
	"AGG":             128,
	"WIN_VALUE":       256,
	"WIN_ORDER":       512,
	"MONOTONIC":       1024,
}

func (x Function_FuncFlag) String() string {
	return proto.EnumName(Function_FuncFlag_name, int32(x))
}

func (Function_FuncFlag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{14, 0}
}

type ForeignKeyDef_RefAction int32

const (
	ForeignKeyDef_RESTRICT    ForeignKeyDef_RefAction = 0
	ForeignKeyDef_CASCADE     ForeignKeyDef_RefAction = 1
	ForeignKeyDef_SET_NULL    ForeignKeyDef_RefAction = 2
	ForeignKeyDef_SET_DEFAULT ForeignKeyDef_RefAction = 3
	ForeignKeyDef_NO_ACTION   ForeignKeyDef_RefAction = 4
)

var ForeignKeyDef_RefAction_name = map[int32]string{
	0: "RESTRICT",
	1: "CASCADE",
	2: "SET_NULL",
	3: "SET_DEFAULT",
	4: "NO_ACTION",
}

var ForeignKeyDef_RefAction_value = map[string]int32{
	"RESTRICT":    0,
	"CASCADE":     1,
	"SET_NULL":    2,
	"SET_DEFAULT": 3,
	"NO_ACTION":   4,
}

func (x ForeignKeyDef_RefAction) String() string {
	return proto.EnumName(ForeignKeyDef_RefAction_name, int32(x))
}

func (ForeignKeyDef_RefAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{25, 0}
}

type OrderBySpec_OrderByFlag int32

const (
	OrderBySpec_INTERNAL    OrderBySpec_OrderByFlag = 0
	OrderBySpec_ASC         OrderBySpec_OrderByFlag = 1
	OrderBySpec_DESC        OrderBySpec_OrderByFlag = 2
	OrderBySpec_NULLS_FIRST OrderBySpec_OrderByFlag = 4
	OrderBySpec_NULLS_LAST  OrderBySpec_OrderByFlag = 8
	OrderBySpec_UNIQUE      OrderBySpec_OrderByFlag = 16
)

var OrderBySpec_OrderByFlag_name = map[int32]string{
	0:  "INTERNAL",
	1:  "ASC",
	2:  "DESC",
	4:  "NULLS_FIRST",
	8:  "NULLS_LAST",
	16: "UNIQUE",
}

var OrderBySpec_OrderByFlag_value = map[string]int32{
	"INTERNAL":    0,
	"ASC":         1,
	"DESC":        2,
	"NULLS_FIRST": 4,
	"NULLS_LAST":  8,
	"UNIQUE":      16,
}

func (x OrderBySpec_OrderByFlag) String() string {
	return proto.EnumName(OrderBySpec_OrderByFlag_name, int32(x))
}

func (OrderBySpec_OrderByFlag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{43, 0}
}

type FrameClause_FrameType int32

const (
	FrameClause_ROWS  FrameClause_FrameType = 0
	FrameClause_RANGE FrameClause_FrameType = 1
)

var FrameClause_FrameType_name = map[int32]string{
	0: "ROWS",
	1: "RANGE",
}

var FrameClause_FrameType_value = map[string]int32{
	"ROWS":  0,
	"RANGE": 1,
}

func (x FrameClause_FrameType) String() string {
	return proto.EnumName(FrameClause_FrameType_name, int32(x))
}

func (FrameClause_FrameType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{45, 0}
}

type FrameBound_BoundType int32

const (
	FrameBound_FOLLOWING   FrameBound_BoundType = 0
	FrameBound_PRECEDING   FrameBound_BoundType = 1
	FrameBound_CURRENT_ROW FrameBound_BoundType = 2
)

var FrameBound_BoundType_name = map[int32]string{
	0: "FOLLOWING",
	1: "PRECEDING",
	2: "CURRENT_ROW",
}

var FrameBound_BoundType_value = map[string]int32{
	"FOLLOWING":   0,
	"PRECEDING":   1,
	"CURRENT_ROW": 2,
}

func (x FrameBound_BoundType) String() string {
	return proto.EnumName(FrameBound_BoundType_name, int32(x))
}

func (FrameBound_BoundType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{46, 0}
}

type Node_NodeType int32

const (
	Node_UNKNOWN Node_NodeType = 0
	// Scans
	Node_VALUE_SCAN    Node_NodeType = 1
	Node_TABLE_SCAN    Node_NodeType = 2
	Node_FUNCTION_SCAN Node_NodeType = 3
	Node_EXTERNAL_SCAN Node_NodeType = 4
	Node_MATERIAL_SCAN Node_NodeType = 5
	// Proj, for convenience
	Node_PROJECT Node_NodeType = 10
	// External function call (UDF)
	Node_EXTERNAL_FUNCTION Node_NodeType = 11
	// Material, CTE, etc.
	Node_MATERIAL       Node_NodeType = 20
	Node_RECURSIVE_CTE  Node_NodeType = 21
	Node_SINK           Node_NodeType = 22
	Node_SINK_SCAN      Node_NodeType = 23
	Node_RECURSIVE_SCAN Node_NodeType = 24
	// Proper Relational Operators
	Node_AGG       Node_NodeType = 30
	Node_DISTINCT  Node_NodeType = 31
	Node_FILTER    Node_NodeType = 32
	Node_JOIN      Node_NodeType = 33
	Node_SAMPLE    Node_NodeType = 34
	Node_SORT      Node_NodeType = 35
	Node_UNION     Node_NodeType = 36
	Node_UNION_ALL Node_NodeType = 37
	Node_UNIQUE    Node_NodeType = 38
	Node_WINDOW    Node_NodeType = 39
	// Physical tuple mover
	Node_BROADCAST Node_NodeType = 40
	Node_SPLIT     Node_NodeType = 41
	Node_GATHER    Node_NodeType = 42
	// Misc
	Node_ASSERT Node_NodeType = 50
	//
	Node_INSERT  Node_NodeType = 51
	Node_DELETE  Node_NodeType = 52
	Node_REPLACE Node_NodeType = 53
	//
	Node_LOCK_OP Node_NodeType = 54
	//
	Node_INTERSECT     Node_NodeType = 55
	Node_INTERSECT_ALL Node_NodeType = 56
	Node_MINUS         Node_NodeType = 57
	Node_MINUS_ALL     Node_NodeType = 58
	//
	Node_ON_DUPLICATE_KEY Node_NodeType = 59
	Node_PRE_INSERT       Node_NodeType = 60
	Node_PRE_DELETE       Node_NodeType = 61
	// the node which build insert batch for hidden table(unique key)
	Node_PRE_INSERT_UK Node_NodeType = 62
)

var Node_NodeType_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "VALUE_SCAN",
	2:  "TABLE_SCAN",
	3:  "FUNCTION_SCAN",
	4:  "EXTERNAL_SCAN",
	5:  "MATERIAL_SCAN",
	10: "PROJECT",
	11: "EXTERNAL_FUNCTION",
	20: "MATERIAL",
	21: "RECURSIVE_CTE",
	22: "SINK",
	23: "SINK_SCAN",
	24: "RECURSIVE_SCAN",
	30: "AGG",
	31: "DISTINCT",
	32: "FILTER",
	33: "JOIN",
	34: "SAMPLE",
	35: "SORT",
	36: "UNION",
	37: "UNION_ALL",
	38: "UNIQUE",
	39: "WINDOW",
	40: "BROADCAST",
	41: "SPLIT",
	42: "GATHER",
	50: "ASSERT",
	51: "INSERT",
	52: "DELETE",
	53: "REPLACE",
	54: "LOCK_OP",
	55: "INTERSECT",
	56: "INTERSECT_ALL",
	57: "MINUS",
	58: "MINUS_ALL",
	59: "ON_DUPLICATE_KEY",
	60: "PRE_INSERT",
	61: "PRE_DELETE",
	62: "PRE_INSERT_UK",
}

var Node_NodeType_value = map[string]int32{
	"UNKNOWN":           0,
	"VALUE_SCAN":        1,
	"TABLE_SCAN":        2,
	"FUNCTION_SCAN":     3,
	"EXTERNAL_SCAN":     4,
	"MATERIAL_SCAN":     5,
	"PROJECT":           10,
	"EXTERNAL_FUNCTION": 11,
	"MATERIAL":          20,
	"RECURSIVE_CTE":     21,
	"SINK":              22,
	"SINK_SCAN":         23,
	"RECURSIVE_SCAN":    24,
	"AGG":               30,
	"DISTINCT":          31,
	"FILTER":            32,
	"JOIN":              33,
	"SAMPLE":            34,
	"SORT":              35,
	"UNION":             36,
	"UNION_ALL":         37,
	"UNIQUE":            38,
	"WINDOW":            39,
	"BROADCAST":         40,
	"SPLIT":             41,
	"GATHER":            42,
	"ASSERT":            50,
	"INSERT":            51,
	"DELETE":            52,
	"REPLACE":           53,
	"LOCK_OP":           54,
	"INTERSECT":         55,
	"INTERSECT_ALL":     56,
	"MINUS":             57,
	"MINUS_ALL":         58,
	"ON_DUPLICATE_KEY":  59,
	"PRE_INSERT":        60,
	"PRE_DELETE":        61,
	"PRE_INSERT_UK":     62,
}

func (x Node_NodeType) String() string {
	return proto.EnumName(Node_NodeType_name, int32(x))
}

func (Node_NodeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{51, 0}
}

type Node_JoinType int32

const (
	Node_INNER  Node_JoinType = 0
	Node_LEFT   Node_JoinType = 1
	Node_RIGHT  Node_JoinType = 2
	Node_OUTER  Node_JoinType = 3
	Node_SEMI   Node_JoinType = 4
	Node_ANTI   Node_JoinType = 5
	Node_SINGLE Node_JoinType = 6
	Node_MARK   Node_JoinType = 7
	Node_APPLY  Node_JoinType = 8
)

var Node_JoinType_name = map[int32]string{
	0: "INNER",
	1: "LEFT",
	2: "RIGHT",
	3: "OUTER",
	4: "SEMI",
	5: "ANTI",
	6: "SINGLE",
	7: "MARK",
	8: "APPLY",
}

var Node_JoinType_value = map[string]int32{
	"INNER":  0,
	"LEFT":   1,
	"RIGHT":  2,
	"OUTER":  3,
	"SEMI":   4,
	"ANTI":   5,
	"SINGLE": 6,
	"MARK":   7,
	"APPLY":  8,
}

func (x Node_JoinType) String() string {
	return proto.EnumName(Node_JoinType_name, int32(x))
}

func (Node_JoinType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{51, 1}
}

type Node_AggMode int32

const (
	Node_FULL   Node_AggMode = 0
	Node_BOTTOM Node_AggMode = 1
	Node_TOP    Node_AggMode = 2
)

var Node_AggMode_name = map[int32]string{
	0: "FULL",
	1: "BOTTOM",
	2: "TOP",
}

var Node_AggMode_value = map[string]int32{
	"FULL":   0,
	"BOTTOM": 1,
	"TOP":    2,
}

func (x Node_AggMode) String() string {
	return proto.EnumName(Node_AggMode_name, int32(x))
}

func (Node_AggMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{51, 2}
}

type Query_StatementType int32

const (
	Query_UNKNOWN Query_StatementType = 0
	Query_SELECT  Query_StatementType = 1
	Query_INSERT  Query_StatementType = 2
	Query_REPLACE Query_StatementType = 3
	Query_DELETE  Query_StatementType = 4
	Query_UPDATE  Query_StatementType = 5
	Query_MERGE   Query_StatementType = 6
)

var Query_StatementType_name = map[int32]string{
	0: "UNKNOWN",
	1: "SELECT",
	2: "INSERT",
	3: "REPLACE",
	4: "DELETE",
	5: "UPDATE",
	6: "MERGE",
}

var Query_StatementType_value = map[string]int32{
	"UNKNOWN": 0,
	"SELECT":  1,
	"INSERT":  2,
	"REPLACE": 3,
	"DELETE":  4,
	"UPDATE":  5,
	"MERGE":   6,
}

func (x Query_StatementType) String() string {
	return proto.EnumName(Query_StatementType_name, int32(x))
}

func (Query_StatementType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{60, 0}
}

type TransationControl_TclType int32

const (
	TransationControl_BEGIN    TransationControl_TclType = 0
	TransationControl_COMMIT   TransationControl_TclType = 1
	TransationControl_ROLLBACK TransationControl_TclType = 2
)

var TransationControl_TclType_name = map[int32]string{
	0: "BEGIN",
	1: "COMMIT",
	2: "ROLLBACK",
}

var TransationControl_TclType_value = map[string]int32{
	"BEGIN":    0,
	"COMMIT":   1,
	"ROLLBACK": 2,
}

func (x TransationControl_TclType) String() string {
	return proto.EnumName(TransationControl_TclType_name, int32(x))
}

func (TransationControl_TclType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{61, 0}
}

type TransationBegin_TransationMode int32

const (
	TransationBegin_NONE       TransationBegin_TransationMode = 0
	TransationBegin_READ_ONLY  TransationBegin_TransationMode = 1
	TransationBegin_READ_WRITE TransationBegin_TransationMode = 2
)

var TransationBegin_TransationMode_name = map[int32]string{
	0: "NONE",
	1: "READ_ONLY",
	2: "READ_WRITE",
}

var TransationBegin_TransationMode_value = map[string]int32{
	"NONE":       0,
	"READ_ONLY":  1,
	"READ_WRITE": 2,
}

func (x TransationBegin_TransationMode) String() string {
	return proto.EnumName(TransationBegin_TransationMode_name, int32(x))
}

func (TransationBegin_TransationMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{62, 0}
}

type DataControl_DclType int32

const (
	DataControl_SET_VARIABLES DataControl_DclType = 0
	DataControl_GRANT         DataControl_DclType = 1
	DataControl_REVOKE        DataControl_DclType = 2
	DataControl_DENY          DataControl_DclType = 3
	DataControl_PREPARE       DataControl_DclType = 4
	DataControl_EXECUTE       DataControl_DclType = 5
	DataControl_DEALLOCATE    DataControl_DclType = 6
)

var DataControl_DclType_name = map[int32]string{
	0: "SET_VARIABLES",
	1: "GRANT",
	2: "REVOKE",
	3: "DENY",
	4: "PREPARE",
	5: "EXECUTE",
	6: "DEALLOCATE",
}

var DataControl_DclType_value = map[string]int32{
	"SET_VARIABLES": 0,
	"GRANT":         1,
	"REVOKE":        2,
	"DENY":          3,
	"PREPARE":       4,
	"EXECUTE":       5,
	"DEALLOCATE":    6,
}

func (x DataControl_DclType) String() string {
	return proto.EnumName(DataControl_DclType_name, int32(x))
}

func (DataControl_DclType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{67, 0}
}

type DataDefinition_DdlType int32

const (
	DataDefinition_CREATE_DATABASE     DataDefinition_DdlType = 0
	DataDefinition_ALTER_DATABASE      DataDefinition_DdlType = 1
	DataDefinition_DROP_DATABASE       DataDefinition_DdlType = 2
	DataDefinition_CREATE_TABLE        DataDefinition_DdlType = 3
	DataDefinition_ALTER_TABLE         DataDefinition_DdlType = 4
	DataDefinition_DROP_TABLE          DataDefinition_DdlType = 5
	DataDefinition_CREATE_INDEX        DataDefinition_DdlType = 6
	DataDefinition_ALTER_INDEX         DataDefinition_DdlType = 7
	DataDefinition_DROP_INDEX          DataDefinition_DdlType = 8
	DataDefinition_TRUNCATE_TABLE      DataDefinition_DdlType = 9
	DataDefinition_CREATE_VIEW         DataDefinition_DdlType = 10
	DataDefinition_ALTER_VIEW          DataDefinition_DdlType = 11
	DataDefinition_DROP_VIEW           DataDefinition_DdlType = 12
	DataDefinition_SHOW_CREATEDATABASE DataDefinition_DdlType = 13
	DataDefinition_SHOW_CREATETABLE    DataDefinition_DdlType = 14
	DataDefinition_SHOW_DATABASES      DataDefinition_DdlType = 15
	DataDefinition_SHOW_TABLES         DataDefinition_DdlType = 16
	DataDefinition_SHOW_COLUMNS        DataDefinition_DdlType = 17
	DataDefinition_SHOW_INDEX          DataDefinition_DdlType = 18
	DataDefinition_SHOW_VARIABLES      DataDefinition_DdlType = 19
	DataDefinition_SHOW_WARNINGS       DataDefinition_DdlType = 20
	DataDefinition_SHOW_ERRORS         DataDefinition_DdlType = 21
	DataDefinition_SHOW_STATUS         DataDefinition_DdlType = 22
	DataDefinition_SHOW_PROCESSLIST    DataDefinition_DdlType = 23
	DataDefinition_SHOW_TABLE_STATUS   DataDefinition_DdlType = 24
	DataDefinition_SHOW_TARGET         DataDefinition_DdlType = 25
	DataDefinition_SHOW_COLLATION      DataDefinition_DdlType = 26
	DataDefinition_LOCK_TABLES         DataDefinition_DdlType = 27
	DataDefinition_UNLOCK_TABLES       DataDefinition_DdlType = 28
	DataDefinition_CREATE_SEQUENCE     DataDefinition_DdlType = 29
	DataDefinition_ALTER_SEQUENCE      DataDefinition_DdlType = 30
	DataDefinition_DROP_SEQUENCE       DataDefinition_DdlType = 31
	DataDefinition_SHOW_SEQUENCES      DataDefinition_DdlType = 32
)

var DataDefinition_DdlType_name = map[int32]string{
	0:  "CREATE_DATABASE",
	1:  "ALTER_DATABASE",
	2:  "DROP_DATABASE",
	3:  "CREATE_TABLE",
	4:  "ALTER_TABLE",
	5:  "DROP_TABLE",
	6:  "CREATE_INDEX",
	7:  "ALTER_INDEX",
	8:  "DROP_INDEX",
	9:  "TRUNCATE_TABLE",
	10: "CREATE_VIEW",
	11: "ALTER_VIEW",
	12: "DROP_VIEW",
	13: "SHOW_CREATEDATABASE",
	14: "SHOW_CREATETABLE",
	15: "SHOW_DATABASES",
	16: "SHOW_TABLES",
	17: "SHOW_COLUMNS",
	18: "SHOW_INDEX",
	19: "SHOW_VARIABLES",
	20: "SHOW_WARNINGS",
	21: "SHOW_ERRORS",
	22: "SHOW_STATUS",
	23: "SHOW_PROCESSLIST",
	24: "SHOW_TABLE_STATUS",
	25: "SHOW_TARGET",
	26: "SHOW_COLLATION",
	27: "LOCK_TABLES",
	28: "UNLOCK_TABLES",
	29: "CREATE_SEQUENCE",
	30: "ALTER_SEQUENCE",
	31: "DROP_SEQUENCE",
	32: "SHOW_SEQUENCES",
}

var DataDefinition_DdlType_value = map[string]int32{
	"CREATE_DATABASE":     0,
	"ALTER_DATABASE":      1,
	"DROP_DATABASE":       2,
	"CREATE_TABLE":        3,
	"ALTER_TABLE":         4,
	"DROP_TABLE":          5,
	"CREATE_INDEX":        6,
	"ALTER_INDEX":         7,
	"DROP_INDEX":          8,
	"TRUNCATE_TABLE":      9,
	"CREATE_VIEW":         10,
	"ALTER_VIEW":          11,
	"DROP_VIEW":           12,
	"SHOW_CREATEDATABASE": 13,
	"SHOW_CREATETABLE":    14,
	"SHOW_DATABASES":      15,
	"SHOW_TABLES":         16,
	"SHOW_COLUMNS":        17,
	"SHOW_INDEX":          18,
	"SHOW_VARIABLES":      19,
	"SHOW_WARNINGS":       20,
	"SHOW_ERRORS":         21,
	"SHOW_STATUS":         22,
	"SHOW_PROCESSLIST":    23,
	"SHOW_TABLE_STATUS":   24,
	"SHOW_TARGET":         25,
	"SHOW_COLLATION":      26,
	"LOCK_TABLES":         27,
	"UNLOCK_TABLES":       28,
	"CREATE_SEQUENCE":     29,
	"ALTER_SEQUENCE":      30,
	"DROP_SEQUENCE":       31,
	"SHOW_SEQUENCES":      32,
}

func (x DataDefinition_DdlType) String() string {
	return proto.EnumName(DataDefinition_DdlType_name, int32(x))
}

func (DataDefinition_DdlType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{68, 0}
}

type AlterTableDrop_Typ int32

const (
	AlterTableDrop_COLUMN      AlterTableDrop_Typ = 0
	AlterTableDrop_INDEX       AlterTableDrop_Typ = 1
	AlterTableDrop_KEY         AlterTableDrop_Typ = 2
	AlterTableDrop_PRIMARY_KEY AlterTableDrop_Typ = 3
	AlterTableDrop_FOREIGN_KEY AlterTableDrop_Typ = 4
)

var AlterTableDrop_Typ_name = map[int32]string{
	0: "COLUMN",
	1: "INDEX",
	2: "KEY",
	3: "PRIMARY_KEY",
	4: "FOREIGN_KEY",
}

var AlterTableDrop_Typ_value = map[string]int32{
	"COLUMN":      0,
	"INDEX":       1,
	"KEY":         2,
	"PRIMARY_KEY": 3,
	"FOREIGN_KEY": 4,
}

func (x AlterTableDrop_Typ) String() string {
	return proto.EnumName(AlterTableDrop_Typ_name, int32(x))
}

func (AlterTableDrop_Typ) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{75, 0}
}

type AlterTable_AlgorithmType int32

const (
	AlterTable_DEFAULT AlterTable_AlgorithmType = 0
	AlterTable_COPY    AlterTable_AlgorithmType = 1
	AlterTable_INSTANT AlterTable_AlgorithmType = 2
	AlterTable_INPLACE AlterTable_AlgorithmType = 3
)

var AlterTable_AlgorithmType_name = map[int32]string{
	0: "DEFAULT",
	1: "COPY",
	2: "INSTANT",
	3: "INPLACE",
}

var AlterTable_AlgorithmType_value = map[string]int32{
	"DEFAULT": 0,
	"COPY":    1,
	"INSTANT": 2,
	"INPLACE": 3,
}

func (x AlterTable_AlgorithmType) String() string {
	return proto.EnumName(AlterTable_AlgorithmType_name, int32(x))
}

func (AlterTable_AlgorithmType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{84, 0}
}

type MetadataScanInfo_MetadataScanInfoType int32

const (
	MetadataScanInfo_COL_NAME      MetadataScanInfo_MetadataScanInfoType = 0
	MetadataScanInfo_BLOCK_ID      MetadataScanInfo_MetadataScanInfoType = 1
	MetadataScanInfo_OBJECT_NAME   MetadataScanInfo_MetadataScanInfoType = 2
	MetadataScanInfo_ENTRY_STATE   MetadataScanInfo_MetadataScanInfoType = 3
	MetadataScanInfo_SORTED        MetadataScanInfo_MetadataScanInfoType = 4
	MetadataScanInfo_IS_HIDDEN     MetadataScanInfo_MetadataScanInfoType = 5
	MetadataScanInfo_META_LOC      MetadataScanInfo_MetadataScanInfoType = 6
	MetadataScanInfo_DELTA_LOC     MetadataScanInfo_MetadataScanInfoType = 7
	MetadataScanInfo_COMMIT_TS     MetadataScanInfo_MetadataScanInfoType = 8
	MetadataScanInfo_CREATE_TS     MetadataScanInfo_MetadataScanInfoType = 9
	MetadataScanInfo_DELETE_TS     MetadataScanInfo_MetadataScanInfoType = 10
	MetadataScanInfo_SEG_ID        MetadataScanInfo_MetadataScanInfoType = 11
	MetadataScanInfo_ROWS_CNT      MetadataScanInfo_MetadataScanInfoType = 12
	MetadataScanInfo_NULL_CNT      MetadataScanInfo_MetadataScanInfoType = 13
	MetadataScanInfo_COMPRESS_SIZE MetadataScanInfo_MetadataScanInfoType = 14
	MetadataScanInfo_ORIGIN_SIZE   MetadataScanInfo_MetadataScanInfoType = 15
	MetadataScanInfo_MIN           MetadataScanInfo_MetadataScanInfoType = 16
	MetadataScanInfo_MAX           MetadataScanInfo_MetadataScanInfoType = 17
)

var MetadataScanInfo_MetadataScanInfoType_name = map[int32]string{
	0:  "COL_NAME",
	1:  "BLOCK_ID",
	2:  "OBJECT_NAME",
	3:  "ENTRY_STATE",
	4:  "SORTED",
	5:  "IS_HIDDEN",
	6:  "META_LOC",
	7:  "DELTA_LOC",
	8:  "COMMIT_TS",
	9:  "CREATE_TS",
	10: "DELETE_TS",
	11: "SEG_ID",
	12: "ROWS_CNT",
	13: "NULL_CNT",
	14: "COMPRESS_SIZE",
	15: "ORIGIN_SIZE",
	16: "MIN",
	17: "MAX",
}

var MetadataScanInfo_MetadataScanInfoType_value = map[string]int32{
	"COL_NAME":      0,
	"BLOCK_ID":      1,
	"OBJECT_NAME":   2,
	"ENTRY_STATE":   3,
	"SORTED":        4,
	"IS_HIDDEN":     5,
	"META_LOC":      6,
	"DELTA_LOC":     7,
	"COMMIT_TS":     8,
	"CREATE_TS":     9,
	"DELETE_TS":     10,
	"SEG_ID":        11,
	"ROWS_CNT":      12,
	"NULL_CNT":      13,
	"COMPRESS_SIZE": 14,
	"ORIGIN_SIZE":   15,
	"MIN":           16,
	"MAX":           17,
}

func (x MetadataScanInfo_MetadataScanInfoType) String() string {
	return proto.EnumName(MetadataScanInfo_MetadataScanInfoType_name, int32(x))
}

func (MetadataScanInfo_MetadataScanInfoType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{104, 0}
}

type Type struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	NotNullable          bool     `protobuf:"varint,2,opt,name=notNullable,proto3" json:"notNullable,omitempty"`
	AutoIncr             bool     `protobuf:"varint,3,opt,name=auto_incr,json=autoIncr,proto3" json:"auto_incr,omitempty"`
	Width                int32    `protobuf:"varint,4,opt,name=width,proto3" json:"width,omitempty"`
	Scale                int32    `protobuf:"varint,5,opt,name=scale,proto3" json:"scale,omitempty"`
	Table                string   `protobuf:"bytes,6,opt,name=table,proto3" json:"table,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Type) Reset()         { *m = Type{} }
func (m *Type) String() string { return proto.CompactTextString(m) }
func (*Type) ProtoMessage()    {}
func (*Type) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{0}
}
func (m *Type) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Type) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Type.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Type) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Type.Merge(m, src)
}
func (m *Type) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Type) XXX_DiscardUnknown() {
	xxx_messageInfo_Type.DiscardUnknown(m)
}

var xxx_messageInfo_Type proto.InternalMessageInfo

func (m *Type) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Type) GetNotNullable() bool {
	if m != nil {
		return m.NotNullable
	}
	return false
}

func (m *Type) GetAutoIncr() bool {
	if m != nil {
		return m.AutoIncr
	}
	return false
}

func (m *Type) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Type) GetScale() int32 {
	if m != nil {
		return m.Scale
	}
	return 0
}

func (m *Type) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

// Const: if a const value can be reprensented by int64 or
// double, use that, otherwise store a string representation.
type Const struct {
	Isnull bool `protobuf:"varint,1,opt,name=isnull,proto3" json:"isnull,omitempty"`
	// Types that are valid to be assigned to Value:
	//
	//	*Const_I8Val
	//	*Const_I16Val
	//	*Const_I32Val
	//	*Const_I64Val
	//	*Const_U8Val
	//	*Const_U16Val
	//	*Const_U32Val
	//	*Const_U64Val
	//	*Const_Dval
	//	*Const_Sval
	//	*Const_Bval
	//	*Const_Fval
	//	*Const_Dateval
	//	*Const_Timeval
	//	*Const_Datetimeval
	//	*Const_Decimal64Val
	//	*Const_Decimal128Val
	//	*Const_Timestampval
	//	*Const_Jsonval
	//	*Const_Defaultval
	//	*Const_UpdateVal
	Value                isConst_Value `protobuf_oneof:"value"`
	IsBin                bool          `protobuf:"varint,23,opt,name=isBin,proto3" json:"isBin,omitempty"`
	Src                  *Expr         `protobuf:"bytes,24,opt,name=src,proto3" json:"src,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Const) Reset()         { *m = Const{} }
func (m *Const) String() string { return proto.CompactTextString(m) }
func (*Const) ProtoMessage()    {}
func (*Const) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{1}
}
func (m *Const) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Const) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Const.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Const) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Const.Merge(m, src)
}
func (m *Const) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Const) XXX_DiscardUnknown() {
	xxx_messageInfo_Const.DiscardUnknown(m)
}

var xxx_messageInfo_Const proto.InternalMessageInfo

type isConst_Value interface {
	isConst_Value()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type Const_I8Val struct {
	I8Val int32 `protobuf:"varint,2,opt,name=i8val,proto3,oneof" json:"i8val,omitempty"`
}
type Const_I16Val struct {
	I16Val int32 `protobuf:"varint,3,opt,name=i16val,proto3,oneof" json:"i16val,omitempty"`
}
type Const_I32Val struct {
	I32Val int32 `protobuf:"varint,4,opt,name=i32val,proto3,oneof" json:"i32val,omitempty"`
}
type Const_I64Val struct {
	I64Val int64 `protobuf:"varint,5,opt,name=i64val,proto3,oneof" json:"i64val,omitempty"`
}
type Const_U8Val struct {
	U8Val uint32 `protobuf:"varint,6,opt,name=u8val,proto3,oneof" json:"u8val,omitempty"`
}
type Const_U16Val struct {
	U16Val uint32 `protobuf:"varint,7,opt,name=u16val,proto3,oneof" json:"u16val,omitempty"`
}
type Const_U32Val struct {
	U32Val uint32 `protobuf:"varint,8,opt,name=u32val,proto3,oneof" json:"u32val,omitempty"`
}
type Const_U64Val struct {
	U64Val uint64 `protobuf:"varint,9,opt,name=u64val,proto3,oneof" json:"u64val,omitempty"`
}
type Const_Dval struct {
	Dval float64 `protobuf:"fixed64,10,opt,name=dval,proto3,oneof" json:"dval,omitempty"`
}
type Const_Sval struct {
	Sval string `protobuf:"bytes,11,opt,name=sval,proto3,oneof" json:"sval,omitempty"`
}
type Const_Bval struct {
	Bval bool `protobuf:"varint,12,opt,name=bval,proto3,oneof" json:"bval,omitempty"`
}
type Const_Fval struct {
	Fval float32 `protobuf:"fixed32,13,opt,name=fval,proto3,oneof" json:"fval,omitempty"`
}
type Const_Dateval struct {
	Dateval int32 `protobuf:"varint,14,opt,name=dateval,proto3,oneof" json:"dateval,omitempty"`
}
type Const_Timeval struct {
	Timeval int64 `protobuf:"varint,15,opt,name=timeval,proto3,oneof" json:"timeval,omitempty"`
}
type Const_Datetimeval struct {
	Datetimeval int64 `protobuf:"varint,16,opt,name=datetimeval,proto3,oneof" json:"datetimeval,omitempty"`
}
type Const_Decimal64Val struct {
	Decimal64Val *Decimal64 `protobuf:"bytes,17,opt,name=decimal64val,proto3,oneof" json:"decimal64val,omitempty"`
}
type Const_Decimal128Val struct {
	Decimal128Val *Decimal128 `protobuf:"bytes,18,opt,name=decimal128val,proto3,oneof" json:"decimal128val,omitempty"`
}
type Const_Timestampval struct {
	Timestampval int64 `protobuf:"varint,19,opt,name=timestampval,proto3,oneof" json:"timestampval,omitempty"`
}
type Const_Jsonval struct {
	Jsonval string `protobuf:"bytes,20,opt,name=jsonval,proto3,oneof" json:"jsonval,omitempty"`
}
type Const_Defaultval struct {
	Defaultval bool `protobuf:"varint,21,opt,name=defaultval,proto3,oneof" json:"defaultval,omitempty"`
}
type Const_UpdateVal struct {
	UpdateVal bool `protobuf:"varint,22,opt,name=updateVal,proto3,oneof" json:"updateVal,omitempty"`
}

func (*Const_I8Val) isConst_Value()         {}
func (*Const_I16Val) isConst_Value()        {}
func (*Const_I32Val) isConst_Value()        {}
func (*Const_I64Val) isConst_Value()        {}
func (*Const_U8Val) isConst_Value()         {}
func (*Const_U16Val) isConst_Value()        {}
func (*Const_U32Val) isConst_Value()        {}
func (*Const_U64Val) isConst_Value()        {}
func (*Const_Dval) isConst_Value()          {}
func (*Const_Sval) isConst_Value()          {}
func (*Const_Bval) isConst_Value()          {}
func (*Const_Fval) isConst_Value()          {}
func (*Const_Dateval) isConst_Value()       {}
func (*Const_Timeval) isConst_Value()       {}
func (*Const_Datetimeval) isConst_Value()   {}
func (*Const_Decimal64Val) isConst_Value()  {}
func (*Const_Decimal128Val) isConst_Value() {}
func (*Const_Timestampval) isConst_Value()  {}
func (*Const_Jsonval) isConst_Value()       {}
func (*Const_Defaultval) isConst_Value()    {}
func (*Const_UpdateVal) isConst_Value()     {}

func (m *Const) GetValue() isConst_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Const) GetIsnull() bool {
	if m != nil {
		return m.Isnull
	}
	return false
}

func (m *Const) GetI8Val() int32 {
	if x, ok := m.GetValue().(*Const_I8Val); ok {
		return x.I8Val
	}
	return 0
}

func (m *Const) GetI16Val() int32 {
	if x, ok := m.GetValue().(*Const_I16Val); ok {
		return x.I16Val
	}
	return 0
}

func (m *Const) GetI32Val() int32 {
	if x, ok := m.GetValue().(*Const_I32Val); ok {
		return x.I32Val
	}
	return 0
}

func (m *Const) GetI64Val() int64 {
	if x, ok := m.GetValue().(*Const_I64Val); ok {
		return x.I64Val
	}
	return 0
}

func (m *Const) GetU8Val() uint32 {
	if x, ok := m.GetValue().(*Const_U8Val); ok {
		return x.U8Val
	}
	return 0
}

func (m *Const) GetU16Val() uint32 {
	if x, ok := m.GetValue().(*Const_U16Val); ok {
		return x.U16Val
	}
	return 0
}

func (m *Const) GetU32Val() uint32 {
	if x, ok := m.GetValue().(*Const_U32Val); ok {
		return x.U32Val
	}
	return 0
}

func (m *Const) GetU64Val() uint64 {
	if x, ok := m.GetValue().(*Const_U64Val); ok {
		return x.U64Val
	}
	return 0
}

func (m *Const) GetDval() float64 {
	if x, ok := m.GetValue().(*Const_Dval); ok {
		return x.Dval
	}
	return 0
}

func (m *Const) GetSval() string {
	if x, ok := m.GetValue().(*Const_Sval); ok {
		return x.Sval
	}
	return ""
}

func (m *Const) GetBval() bool {
	if x, ok := m.GetValue().(*Const_Bval); ok {
		return x.Bval
	}
	return false
}

func (m *Const) GetFval() float32 {
	if x, ok := m.GetValue().(*Const_Fval); ok {
		return x.Fval
	}
	return 0
}

func (m *Const) GetDateval() int32 {
	if x, ok := m.GetValue().(*Const_Dateval); ok {
		return x.Dateval
	}
	return 0
}

func (m *Const) GetTimeval() int64 {
	if x, ok := m.GetValue().(*Const_Timeval); ok {
		return x.Timeval
	}
	return 0
}

func (m *Const) GetDatetimeval() int64 {
	if x, ok := m.GetValue().(*Const_Datetimeval); ok {
		return x.Datetimeval
	}
	return 0
}

func (m *Const) GetDecimal64Val() *Decimal64 {
	if x, ok := m.GetValue().(*Const_Decimal64Val); ok {
		return x.Decimal64Val
	}
	return nil
}

func (m *Const) GetDecimal128Val() *Decimal128 {
	if x, ok := m.GetValue().(*Const_Decimal128Val); ok {
		return x.Decimal128Val
	}
	return nil
}

func (m *Const) GetTimestampval() int64 {
	if x, ok := m.GetValue().(*Const_Timestampval); ok {
		return x.Timestampval
	}
	return 0
}

func (m *Const) GetJsonval() string {
	if x, ok := m.GetValue().(*Const_Jsonval); ok {
		return x.Jsonval
	}
	return ""
}

func (m *Const) GetDefaultval() bool {
	if x, ok := m.GetValue().(*Const_Defaultval); ok {
		return x.Defaultval
	}
	return false
}

func (m *Const) GetUpdateVal() bool {
	if x, ok := m.GetValue().(*Const_UpdateVal); ok {
		return x.UpdateVal
	}
	return false
}

func (m *Const) GetIsBin() bool {
	if m != nil {
		return m.IsBin
	}
	return false
}

func (m *Const) GetSrc() *Expr {
	if m != nil {
		return m.Src
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Const) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Const_I8Val)(nil),
		(*Const_I16Val)(nil),
		(*Const_I32Val)(nil),
		(*Const_I64Val)(nil),
		(*Const_U8Val)(nil),
		(*Const_U16Val)(nil),
		(*Const_U32Val)(nil),
		(*Const_U64Val)(nil),
		(*Const_Dval)(nil),
		(*Const_Sval)(nil),
		(*Const_Bval)(nil),
		(*Const_Fval)(nil),
		(*Const_Dateval)(nil),
		(*Const_Timeval)(nil),
		(*Const_Datetimeval)(nil),
		(*Const_Decimal64Val)(nil),
		(*Const_Decimal128Val)(nil),
		(*Const_Timestampval)(nil),
		(*Const_Jsonval)(nil),
		(*Const_Defaultval)(nil),
		(*Const_UpdateVal)(nil),
	}
}

// Bounded param for prepared statement.  User fill on execution.
type ParamRef struct {
	Pos                  int32    `protobuf:"varint,1,opt,name=pos,proto3" json:"pos,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ParamRef) Reset()         { *m = ParamRef{} }
func (m *ParamRef) String() string { return proto.CompactTextString(m) }
func (*ParamRef) ProtoMessage()    {}
func (*ParamRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{2}
}
func (m *ParamRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParamRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParamRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParamRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParamRef.Merge(m, src)
}
func (m *ParamRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ParamRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ParamRef.DiscardUnknown(m)
}

var xxx_messageInfo_ParamRef proto.InternalMessageInfo

func (m *ParamRef) GetPos() int32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

// Session variable ref, compiler should fold.
type VarRef struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	System               bool     `protobuf:"varint,2,opt,name=system,proto3" json:"system,omitempty"`
	Global               bool     `protobuf:"varint,3,opt,name=global,proto3" json:"global,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VarRef) Reset()         { *m = VarRef{} }
func (m *VarRef) String() string { return proto.CompactTextString(m) }
func (*VarRef) ProtoMessage()    {}
func (*VarRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{3}
}
func (m *VarRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VarRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VarRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VarRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VarRef.Merge(m, src)
}
func (m *VarRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *VarRef) XXX_DiscardUnknown() {
	xxx_messageInfo_VarRef.DiscardUnknown(m)
}

var xxx_messageInfo_VarRef proto.InternalMessageInfo

func (m *VarRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VarRef) GetSystem() bool {
	if m != nil {
		return m.System
	}
	return false
}

func (m *VarRef) GetGlobal() bool {
	if m != nil {
		return m.Global
	}
	return false
}

// Reference a column in the proj list of a node.
type ColRef struct {
	RelPos               int32    `protobuf:"varint,1,opt,name=rel_pos,json=relPos,proto3" json:"rel_pos,omitempty"`
	ColPos               int32    `protobuf:"varint,2,opt,name=col_pos,json=colPos,proto3" json:"col_pos,omitempty"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ColRef) Reset()         { *m = ColRef{} }
func (m *ColRef) String() string { return proto.CompactTextString(m) }
func (*ColRef) ProtoMessage()    {}
func (*ColRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{4}
}
func (m *ColRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColRef.Merge(m, src)
}
func (m *ColRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ColRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ColRef.DiscardUnknown(m)
}

var xxx_messageInfo_ColRef proto.InternalMessageInfo

func (m *ColRef) GetRelPos() int32 {
	if m != nil {
		return m.RelPos
	}
	return 0
}

func (m *ColRef) GetColPos() int32 {
	if m != nil {
		return m.ColPos
	}
	return 0
}

func (m *ColRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Reference a column by its internal table id and column id
type RawColRef struct {
	TblId                uint64   `protobuf:"varint,1,opt,name=tbl_id,json=tblId,proto3" json:"tbl_id,omitempty"`
	ColId                uint64   `protobuf:"varint,2,opt,name=col_id,json=colId,proto3" json:"col_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RawColRef) Reset()         { *m = RawColRef{} }
func (m *RawColRef) String() string { return proto.CompactTextString(m) }
func (*RawColRef) ProtoMessage()    {}
func (*RawColRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{5}
}
func (m *RawColRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawColRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawColRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawColRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawColRef.Merge(m, src)
}
func (m *RawColRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RawColRef) XXX_DiscardUnknown() {
	xxx_messageInfo_RawColRef.DiscardUnknown(m)
}

var xxx_messageInfo_RawColRef proto.InternalMessageInfo

func (m *RawColRef) GetTblId() uint64 {
	if m != nil {
		return m.TblId
	}
	return 0
}

func (m *RawColRef) GetColId() uint64 {
	if m != nil {
		return m.ColId
	}
	return 0
}

// Reference a correlated column in the proj list of a node.
type CorrColRef struct {
	RelPos               int32    `protobuf:"varint,1,opt,name=rel_pos,json=relPos,proto3" json:"rel_pos,omitempty"`
	ColPos               int32    `protobuf:"varint,2,opt,name=col_pos,json=colPos,proto3" json:"col_pos,omitempty"`
	Depth                int32    `protobuf:"varint,3,opt,name=depth,proto3" json:"depth,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CorrColRef) Reset()         { *m = CorrColRef{} }
func (m *CorrColRef) String() string { return proto.CompactTextString(m) }
func (*CorrColRef) ProtoMessage()    {}
func (*CorrColRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{6}
}
func (m *CorrColRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CorrColRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CorrColRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CorrColRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CorrColRef.Merge(m, src)
}
func (m *CorrColRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CorrColRef) XXX_DiscardUnknown() {
	xxx_messageInfo_CorrColRef.DiscardUnknown(m)
}

var xxx_messageInfo_CorrColRef proto.InternalMessageInfo

func (m *CorrColRef) GetRelPos() int32 {
	if m != nil {
		return m.RelPos
	}
	return 0
}

func (m *CorrColRef) GetColPos() int32 {
	if m != nil {
		return m.ColPos
	}
	return 0
}

func (m *CorrColRef) GetDepth() int32 {
	if m != nil {
		return m.Depth
	}
	return 0
}

// ExprList is a type of Expr
type ExprList struct {
	List                 []*Expr  `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExprList) Reset()         { *m = ExprList{} }
func (m *ExprList) String() string { return proto.CompactTextString(m) }
func (*ExprList) ProtoMessage()    {}
func (*ExprList) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{7}
}
func (m *ExprList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExprList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExprList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExprList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExprList.Merge(m, src)
}
func (m *ExprList) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ExprList) XXX_DiscardUnknown() {
	xxx_messageInfo_ExprList.DiscardUnknown(m)
}

var xxx_messageInfo_ExprList proto.InternalMessageInfo

func (m *ExprList) GetList() []*Expr {
	if m != nil {
		return m.List
	}
	return nil
}

type MaxValue struct {
	Value                string   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MaxValue) Reset()         { *m = MaxValue{} }
func (m *MaxValue) String() string { return proto.CompactTextString(m) }
func (*MaxValue) ProtoMessage()    {}
func (*MaxValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{8}
}
func (m *MaxValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaxValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaxValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaxValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaxValue.Merge(m, src)
}
func (m *MaxValue) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MaxValue) XXX_DiscardUnknown() {
	xxx_messageInfo_MaxValue.DiscardUnknown(m)
}

var xxx_messageInfo_MaxValue proto.InternalMessageInfo

func (m *MaxValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// TargetType used in cast function as target type
type TargetType struct {
	Typ                  *Type    `protobuf:"bytes,1,opt,name=typ,proto3" json:"typ,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TargetType) Reset()         { *m = TargetType{} }
func (m *TargetType) String() string { return proto.CompactTextString(m) }
func (*TargetType) ProtoMessage()    {}
func (*TargetType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{9}
}
func (m *TargetType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TargetType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TargetType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TargetType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TargetType.Merge(m, src)
}
func (m *TargetType) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TargetType) XXX_DiscardUnknown() {
	xxx_messageInfo_TargetType.DiscardUnknown(m)
}

var xxx_messageInfo_TargetType proto.InternalMessageInfo

func (m *TargetType) GetTyp() *Type {
	if m != nil {
		return m.Typ
	}
	return nil
}

// Reference a subquery
type SubqueryRef struct {
	Typ                  SubqueryRef_Type `protobuf:"varint,1,opt,name=typ,proto3,enum=plan.SubqueryRef_Type" json:"typ,omitempty"`
	NodeId               int32            `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Op                   string           `protobuf:"bytes,3,opt,name=op,proto3" json:"op,omitempty"`
	Child                *Expr            `protobuf:"bytes,4,opt,name=child,proto3" json:"child,omitempty"`
	RowSize              int32            `protobuf:"varint,5,opt,name=row_size,json=rowSize,proto3" json:"row_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SubqueryRef) Reset()         { *m = SubqueryRef{} }
func (m *SubqueryRef) String() string { return proto.CompactTextString(m) }
func (*SubqueryRef) ProtoMessage()    {}
func (*SubqueryRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{10}
}
func (m *SubqueryRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubqueryRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubqueryRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubqueryRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubqueryRef.Merge(m, src)
}
func (m *SubqueryRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SubqueryRef) XXX_DiscardUnknown() {
	xxx_messageInfo_SubqueryRef.DiscardUnknown(m)
}

var xxx_messageInfo_SubqueryRef proto.InternalMessageInfo

func (m *SubqueryRef) GetTyp() SubqueryRef_Type {
	if m != nil {
		return m.Typ
	}
	return SubqueryRef_SCALAR
}

func (m *SubqueryRef) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *SubqueryRef) GetOp() string {
	if m != nil {
		return m.Op
	}
	return ""
}

func (m *SubqueryRef) GetChild() *Expr {
	if m != nil {
		return m.Child
	}
	return nil
}

func (m *SubqueryRef) GetRowSize() int32 {
	if m != nil {
		return m.RowSize
	}
	return 0
}

// Object ref, reference a object in database, 4 part name.
type ObjectRef struct {
	Server               int64    `protobuf:"varint,1,opt,name=server,proto3" json:"server,omitempty"`
	Db                   int64    `protobuf:"varint,2,opt,name=db,proto3" json:"db,omitempty"`
	Schema               int64    `protobuf:"varint,3,opt,name=schema,proto3" json:"schema,omitempty"`
	Obj                  int64    `protobuf:"varint,4,opt,name=obj,proto3" json:"obj,omitempty"`
	ServerName           string   `protobuf:"bytes,5,opt,name=server_name,json=serverName,proto3" json:"server_name,omitempty"`
	DbName               string   `protobuf:"bytes,6,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	SchemaName           string   `protobuf:"bytes,7,opt,name=schema_name,json=schemaName,proto3" json:"schema_name,omitempty"`
	ObjName              string   `protobuf:"bytes,8,opt,name=obj_name,json=objName,proto3" json:"obj_name,omitempty"`
	SubscriptionName     string   `protobuf:"bytes,9,opt,name=subscription_name,json=subscriptionName,proto3" json:"subscription_name,omitempty"`
	PubInfo              *PubInfo `protobuf:"bytes,10,opt,name=pub_info,json=pubInfo,proto3" json:"pub_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectRef) Reset()         { *m = ObjectRef{} }
func (m *ObjectRef) String() string { return proto.CompactTextString(m) }
func (*ObjectRef) ProtoMessage()    {}
func (*ObjectRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{11}
}
func (m *ObjectRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectRef.Merge(m, src)
}
func (m *ObjectRef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ObjectRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectRef.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectRef proto.InternalMessageInfo

func (m *ObjectRef) GetServer() int64 {
	if m != nil {
		return m.Server
	}
	return 0
}

func (m *ObjectRef) GetDb() int64 {
	if m != nil {
		return m.Db
	}
	return 0
}

func (m *ObjectRef) GetSchema() int64 {
	if m != nil {
		return m.Schema
	}
	return 0
}

func (m *ObjectRef) GetObj() int64 {
	if m != nil {
		return m.Obj
	}
	return 0
}

func (m *ObjectRef) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

func (m *ObjectRef) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *ObjectRef) GetSchemaName() string {
	if m != nil {
		return m.SchemaName
	}
	return ""
}

func (m *ObjectRef) GetObjName() string {
	if m != nil {
		return m.ObjName
	}
	return ""
}

func (m *ObjectRef) GetSubscriptionName() string {
	if m != nil {
		return m.SubscriptionName
	}
	return ""
}

func (m *ObjectRef) GetPubInfo() *PubInfo {
	if m != nil {
		return m.PubInfo
	}
	return nil
}

type PubInfo struct {
	TenantId             int32    `protobuf:"varint,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PubInfo) Reset()         { *m = PubInfo{} }
func (m *PubInfo) String() string { return proto.CompactTextString(m) }
func (*PubInfo) ProtoMessage()    {}
func (*PubInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{12}
}
func (m *PubInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PubInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PubInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PubInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PubInfo.Merge(m, src)
}
func (m *PubInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PubInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PubInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PubInfo proto.InternalMessageInfo

func (m *PubInfo) GetTenantId() int32 {
	if m != nil {
		return m.TenantId
	}
	return 0
}

type SubscriptionMeta struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	AccountId            int32    `protobuf:"varint,2,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
	DbName               string   `protobuf:"bytes,3,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	AccountName          string   `protobuf:"bytes,4,opt,name=account_name,json=accountName,proto3" json:"account_name,omitempty"`
	SubName              string   `protobuf:"bytes,5,opt,name=sub_name,json=subName,proto3" json:"sub_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscriptionMeta) Reset()         { *m = SubscriptionMeta{} }
func (m *SubscriptionMeta) String() string { return proto.CompactTextString(m) }
func (*SubscriptionMeta) ProtoMessage()    {}
func (*SubscriptionMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{13}
}
func (m *SubscriptionMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscriptionMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscriptionMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscriptionMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriptionMeta.Merge(m, src)
}
func (m *SubscriptionMeta) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SubscriptionMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriptionMeta.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriptionMeta proto.InternalMessageInfo

func (m *SubscriptionMeta) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SubscriptionMeta) GetAccountId() int32 {
	if m != nil {
		return m.AccountId
	}
	return 0
}

func (m *SubscriptionMeta) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *SubscriptionMeta) GetAccountName() string {
	if m != nil {
		return m.AccountName
	}
	return ""
}

func (m *SubscriptionMeta) GetSubName() string {
	if m != nil {
		return m.SubName
	}
	return ""
}

type Function struct {
	Func                 *ObjectRef `protobuf:"bytes,1,opt,name=func,proto3" json:"func,omitempty"`
	Args                 []*Expr    `protobuf:"bytes,2,rep,name=args,proto3" json:"args,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Function) Reset()         { *m = Function{} }
func (m *Function) String() string { return proto.CompactTextString(m) }
func (*Function) ProtoMessage()    {}
func (*Function) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{14}
}
func (m *Function) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Function) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Function.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Function) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Function.Merge(m, src)
}
func (m *Function) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Function) XXX_DiscardUnknown() {
	xxx_messageInfo_Function.DiscardUnknown(m)
}

var xxx_messageInfo_Function proto.InternalMessageInfo

func (m *Function) GetFunc() *ObjectRef {
	if m != nil {
		return m.Func
	}
	return nil
}

func (m *Function) GetArgs() []*Expr {
	if m != nil {
		return m.Args
	}
	return nil
}

type Expr struct {
	Typ *Type `protobuf:"bytes,1,opt,name=typ,proto3" json:"typ,omitempty"`
	// Types that are valid to be assigned to Expr:
	//
	//	*Expr_C
	//	*Expr_P
	//	*Expr_V
	//	*Expr_Col
	//	*Expr_Raw
	//	*Expr_F
	//	*Expr_W
	//	*Expr_Sub
	//	*Expr_Corr
	//	*Expr_T
	//	*Expr_List
	//	*Expr_Max
	Expr                 isExpr_Expr `protobuf_oneof:"expr"`
	AuxId                int32       `protobuf:"varint,14,opt,name=aux_id,json=auxId,proto3" json:"aux_id,omitempty"`
	Ndv                  float64     `protobuf:"fixed64,15,opt,name=ndv,proto3" json:"ndv,omitempty"`
	Selectivity          float64     `protobuf:"fixed64,16,opt,name=selectivity,proto3" json:"selectivity,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Expr) Reset()         { *m = Expr{} }
func (m *Expr) String() string { return proto.CompactTextString(m) }
func (*Expr) ProtoMessage()    {}
func (*Expr) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{15}
}
func (m *Expr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Expr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Expr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Expr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Expr.Merge(m, src)
}
func (m *Expr) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Expr) XXX_DiscardUnknown() {
	xxx_messageInfo_Expr.DiscardUnknown(m)
}

var xxx_messageInfo_Expr proto.InternalMessageInfo

type isExpr_Expr interface {
	isExpr_Expr()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type Expr_C struct {
	C *Const `protobuf:"bytes,2,opt,name=c,proto3,oneof" json:"c,omitempty"`
}
type Expr_P struct {
	P *ParamRef `protobuf:"bytes,3,opt,name=p,proto3,oneof" json:"p,omitempty"`
}
type Expr_V struct {
	V *VarRef `protobuf:"bytes,4,opt,name=v,proto3,oneof" json:"v,omitempty"`
}
type Expr_Col struct {
	Col *ColRef `protobuf:"bytes,5,opt,name=col,proto3,oneof" json:"col,omitempty"`
}
type Expr_Raw struct {
	Raw *RawColRef `protobuf:"bytes,6,opt,name=raw,proto3,oneof" json:"raw,omitempty"`
}
type Expr_F struct {
	F *Function `protobuf:"bytes,7,opt,name=f,proto3,oneof" json:"f,omitempty"`
}
type Expr_W struct {
	W *WindowSpec `protobuf:"bytes,8,opt,name=w,proto3,oneof" json:"w,omitempty"`
}
type Expr_Sub struct {
	Sub *SubqueryRef `protobuf:"bytes,9,opt,name=sub,proto3,oneof" json:"sub,omitempty"`
}
type Expr_Corr struct {
	Corr *CorrColRef `protobuf:"bytes,10,opt,name=corr,proto3,oneof" json:"corr,omitempty"`
}
type Expr_T struct {
	T *TargetType `protobuf:"bytes,11,opt,name=t,proto3,oneof" json:"t,omitempty"`
}
type Expr_List struct {
	List *ExprList `protobuf:"bytes,12,opt,name=list,proto3,oneof" json:"list,omitempty"`
}
type Expr_Max struct {
	Max *MaxValue `protobuf:"bytes,13,opt,name=max,proto3,oneof" json:"max,omitempty"`
}

func (*Expr_C) isExpr_Expr()    {}
func (*Expr_P) isExpr_Expr()    {}
func (*Expr_V) isExpr_Expr()    {}
func (*Expr_Col) isExpr_Expr()  {}
func (*Expr_Raw) isExpr_Expr()  {}
func (*Expr_F) isExpr_Expr()    {}
func (*Expr_W) isExpr_Expr()    {}
func (*Expr_Sub) isExpr_Expr()  {}
func (*Expr_Corr) isExpr_Expr() {}
func (*Expr_T) isExpr_Expr()    {}
func (*Expr_List) isExpr_Expr() {}
func (*Expr_Max) isExpr_Expr()  {}

func (m *Expr) GetExpr() isExpr_Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Expr) GetTyp() *Type {
	if m != nil {
		return m.Typ
	}
	return nil
}

func (m *Expr) GetC() *Const {
	if x, ok := m.GetExpr().(*Expr_C); ok {
		return x.C
	}
	return nil
}

func (m *Expr) GetP() *ParamRef {
	if x, ok := m.GetExpr().(*Expr_P); ok {
		return x.P
	}
	return nil
}

func (m *Expr) GetV() *VarRef {
	if x, ok := m.GetExpr().(*Expr_V); ok {
		return x.V
	}
	return nil
}

func (m *Expr) GetCol() *ColRef {
	if x, ok := m.GetExpr().(*Expr_Col); ok {
		return x.Col
	}
	return nil
}

func (m *Expr) GetRaw() *RawColRef {
	if x, ok := m.GetExpr().(*Expr_Raw); ok {
		return x.Raw
	}
	return nil
}

func (m *Expr) GetF() *Function {
	if x, ok := m.GetExpr().(*Expr_F); ok {
		return x.F
	}
	return nil
}

func (m *Expr) GetW() *WindowSpec {
	if x, ok := m.GetExpr().(*Expr_W); ok {
		return x.W
	}
	return nil
}

func (m *Expr) GetSub() *SubqueryRef {
	if x, ok := m.GetExpr().(*Expr_Sub); ok {
		return x.Sub
	}
	return nil
}

func (m *Expr) GetCorr() *CorrColRef {
	if x, ok := m.GetExpr().(*Expr_Corr); ok {
		return x.Corr
	}
	return nil
}

func (m *Expr) GetT() *TargetType {
	if x, ok := m.GetExpr().(*Expr_T); ok {
		return x.T
	}
	return nil
}

func (m *Expr) GetList() *ExprList {
	if x, ok := m.GetExpr().(*Expr_List); ok {
		return x.List
	}
	return nil
}

func (m *Expr) GetMax() *MaxValue {
	if x, ok := m.GetExpr().(*Expr_Max); ok {
		return x.Max
	}
	return nil
}

func (m *Expr) GetAuxId() int32 {
	if m != nil {
		return m.AuxId
	}
	return 0
}

func (m *Expr) GetNdv() float64 {
	if m != nil {
		return m.Ndv
	}
	return 0
}

func (m *Expr) GetSelectivity() float64 {
	if m != nil {
		return m.Selectivity
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Expr) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Expr_C)(nil),
		(*Expr_P)(nil),
		(*Expr_V)(nil),
		(*Expr_Col)(nil),
		(*Expr_Raw)(nil),
		(*Expr_F)(nil),
		(*Expr_W)(nil),
		(*Expr_Sub)(nil),
		(*Expr_Corr)(nil),
		(*Expr_T)(nil),
		(*Expr_List)(nil),
		(*Expr_Max)(nil),
	}
}

type Decimal64 struct {
	A                    int64    `protobuf:"varint,1,opt,name=a,proto3" json:"a,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Decimal64) Reset()         { *m = Decimal64{} }
func (m *Decimal64) String() string { return proto.CompactTextString(m) }
func (*Decimal64) ProtoMessage()    {}
func (*Decimal64) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{16}
}
func (m *Decimal64) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Decimal64) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Decimal64.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Decimal64) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Decimal64.Merge(m, src)
}
func (m *Decimal64) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Decimal64) XXX_DiscardUnknown() {
	xxx_messageInfo_Decimal64.DiscardUnknown(m)
}

var xxx_messageInfo_Decimal64 proto.InternalMessageInfo

func (m *Decimal64) GetA() int64 {
	if m != nil {
		return m.A
	}
	return 0
}

type Decimal128 struct {
	A                    int64    `protobuf:"varint,1,opt,name=a,proto3" json:"a,omitempty"`
	B                    int64    `protobuf:"varint,2,opt,name=b,proto3" json:"b,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Decimal128) Reset()         { *m = Decimal128{} }
func (m *Decimal128) String() string { return proto.CompactTextString(m) }
func (*Decimal128) ProtoMessage()    {}
func (*Decimal128) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{17}
}
func (m *Decimal128) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Decimal128) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Decimal128.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Decimal128) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Decimal128.Merge(m, src)
}
func (m *Decimal128) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Decimal128) XXX_DiscardUnknown() {
	xxx_messageInfo_Decimal128.DiscardUnknown(m)
}

var xxx_messageInfo_Decimal128 proto.InternalMessageInfo

func (m *Decimal128) GetA() int64 {
	if m != nil {
		return m.A
	}
	return 0
}

func (m *Decimal128) GetB() int64 {
	if m != nil {
		return m.B
	}
	return 0
}

type ResultColDef struct {
	ResultCols           []*ColDef `protobuf:"bytes,1,rep,name=ResultCols,proto3" json:"ResultCols,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ResultColDef) Reset()         { *m = ResultColDef{} }
func (m *ResultColDef) String() string { return proto.CompactTextString(m) }
func (*ResultColDef) ProtoMessage()    {}
func (*ResultColDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{18}
}
func (m *ResultColDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultColDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultColDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultColDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultColDef.Merge(m, src)
}
func (m *ResultColDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ResultColDef) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultColDef.DiscardUnknown(m)
}

var xxx_messageInfo_ResultColDef proto.InternalMessageInfo

func (m *ResultColDef) GetResultCols() []*ColDef {
	if m != nil {
		return m.ResultCols
	}
	return nil
}

type ColDef struct {
	ColId    uint64       `protobuf:"varint,1,opt,name=col_id,json=colId,proto3" json:"col_id,omitempty"`
	Name     string       `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Hidden   bool         `protobuf:"varint,3,opt,name=hidden,proto3" json:"hidden,omitempty"`
	Alg      CompressType `protobuf:"varint,4,opt,name=alg,proto3,enum=plan.CompressType" json:"alg,omitempty"`
	Typ      *Type        `protobuf:"bytes,5,opt,name=typ,proto3" json:"typ,omitempty"`
	NotNull  bool         `protobuf:"varint,6,opt,name=not_null,json=notNull,proto3" json:"not_null,omitempty"`
	Default  *Default     `protobuf:"bytes,7,opt,name=default,proto3" json:"default,omitempty"`
	Comment  string       `protobuf:"bytes,8,opt,name=comment,proto3" json:"comment,omitempty"`
	OnUpdate *OnUpdate    `protobuf:"bytes,9,opt,name=on_update,json=onUpdate,proto3" json:"on_update,omitempty"`
	LowCard  bool         `protobuf:"varint,10,opt,name=low_card,json=lowCard,proto3" json:"low_card,omitempty"`
	Seqnum   uint32       `protobuf:"varint,11,opt,name=seqnum,proto3" json:"seqnum,omitempty"`
	// XXX: Deprecated and to be removed soon.
	ClusterBy            bool     `protobuf:"varint,12,opt,name=clusterBy,proto3" json:"clusterBy,omitempty"`
	Primary              bool     `protobuf:"varint,13,opt,name=primary,proto3" json:"primary,omitempty"`
	Pkidx                int32    `protobuf:"varint,14,opt,name=pkidx,proto3" json:"pkidx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ColDef) Reset()         { *m = ColDef{} }
func (m *ColDef) String() string { return proto.CompactTextString(m) }
func (*ColDef) ProtoMessage()    {}
func (*ColDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{19}
}
func (m *ColDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColDef.Merge(m, src)
}
func (m *ColDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ColDef) XXX_DiscardUnknown() {
	xxx_messageInfo_ColDef.DiscardUnknown(m)
}

var xxx_messageInfo_ColDef proto.InternalMessageInfo

func (m *ColDef) GetColId() uint64 {
	if m != nil {
		return m.ColId
	}
	return 0
}

func (m *ColDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ColDef) GetHidden() bool {
	if m != nil {
		return m.Hidden
	}
	return false
}

func (m *ColDef) GetAlg() CompressType {
	if m != nil {
		return m.Alg
	}
	return CompressType_None
}

func (m *ColDef) GetTyp() *Type {
	if m != nil {
		return m.Typ
	}
	return nil
}

func (m *ColDef) GetNotNull() bool {
	if m != nil {
		return m.NotNull
	}
	return false
}

func (m *ColDef) GetDefault() *Default {
	if m != nil {
		return m.Default
	}
	return nil
}

func (m *ColDef) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *ColDef) GetOnUpdate() *OnUpdate {
	if m != nil {
		return m.OnUpdate
	}
	return nil
}

func (m *ColDef) GetLowCard() bool {
	if m != nil {
		return m.LowCard
	}
	return false
}

func (m *ColDef) GetSeqnum() uint32 {
	if m != nil {
		return m.Seqnum
	}
	return 0
}

func (m *ColDef) GetClusterBy() bool {
	if m != nil {
		return m.ClusterBy
	}
	return false
}

func (m *ColDef) GetPrimary() bool {
	if m != nil {
		return m.Primary
	}
	return false
}

func (m *ColDef) GetPkidx() int32 {
	if m != nil {
		return m.Pkidx
	}
	return 0
}

type Default struct {
	Expr         *Expr  `protobuf:"bytes,1,opt,name=expr,proto3" json:"expr,omitempty"`
	OriginString string `protobuf:"bytes,2,opt,name=origin_string,json=originString,proto3" json:"origin_string,omitempty"`
	// XXX: Deprecated and to be removed soon.
	NullAbility          bool     `protobuf:"varint,3,opt,name=null_ability,json=nullAbility,proto3" json:"null_ability,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Default) Reset()         { *m = Default{} }
func (m *Default) String() string { return proto.CompactTextString(m) }
func (*Default) ProtoMessage()    {}
func (*Default) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{20}
}
func (m *Default) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Default) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Default.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Default) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Default.Merge(m, src)
}
func (m *Default) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Default) XXX_DiscardUnknown() {
	xxx_messageInfo_Default.DiscardUnknown(m)
}

var xxx_messageInfo_Default proto.InternalMessageInfo

func (m *Default) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Default) GetOriginString() string {
	if m != nil {
		return m.OriginString
	}
	return ""
}

func (m *Default) GetNullAbility() bool {
	if m != nil {
		return m.NullAbility
	}
	return false
}

type OnUpdate struct {
	Expr                 *Expr    `protobuf:"bytes,1,opt,name=expr,proto3" json:"expr,omitempty"`
	OriginString         string   `protobuf:"bytes,2,opt,name=origin_string,json=originString,proto3" json:"origin_string,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OnUpdate) Reset()         { *m = OnUpdate{} }
func (m *OnUpdate) String() string { return proto.CompactTextString(m) }
func (*OnUpdate) ProtoMessage()    {}
func (*OnUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{21}
}
func (m *OnUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OnUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OnUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OnUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnUpdate.Merge(m, src)
}
func (m *OnUpdate) XXX_Size() int {
	return m.ProtoSize()
}
func (m *OnUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_OnUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_OnUpdate proto.InternalMessageInfo

func (m *OnUpdate) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *OnUpdate) GetOriginString() string {
	if m != nil {
		return m.OriginString
	}
	return ""
}

type IndexOption struct {
	CreateExtraTable     bool     `protobuf:"varint,1,opt,name=create_extra_table,json=createExtraTable,proto3" json:"create_extra_table,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IndexOption) Reset()         { *m = IndexOption{} }
func (m *IndexOption) String() string { return proto.CompactTextString(m) }
func (*IndexOption) ProtoMessage()    {}
func (*IndexOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{22}
}
func (m *IndexOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexOption.Merge(m, src)
}
func (m *IndexOption) XXX_Size() int {
	return m.ProtoSize()
}
func (m *IndexOption) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexOption.DiscardUnknown(m)
}

var xxx_messageInfo_IndexOption proto.InternalMessageInfo

func (m *IndexOption) GetCreateExtraTable() bool {
	if m != nil {
		return m.CreateExtraTable
	}
	return false
}

type PrimaryKeyDef struct {
	// currently not used
	Cols []uint64 `protobuf:"varint,1,rep,packed,name=cols,proto3" json:"cols,omitempty"`
	// currently not used
	PkeyColId uint64 `protobuf:"varint,2,opt,name=pkey_col_id,json=pkeyColId,proto3" json:"pkey_col_id,omitempty"`
	// currently not used
	Option *IndexOption `protobuf:"bytes,3,opt,name=option,proto3" json:"option,omitempty"`
	// Composed primary key column name: __mo_cpkey
	PkeyColName string `protobuf:"bytes,4,opt,name=pkey_col_name,json=pkeyColName,proto3" json:"pkey_col_name,omitempty"`
	// XXX: Deprecated and to be removed soon.
	Names []string `protobuf:"bytes,5,rep,name=names,proto3" json:"names,omitempty"`
	// Composite primary key column definition
	CompPkeyCol          *ColDef  `protobuf:"bytes,6,opt,name=comp_pkey_col,json=compPkeyCol,proto3" json:"comp_pkey_col,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PrimaryKeyDef) Reset()         { *m = PrimaryKeyDef{} }
func (m *PrimaryKeyDef) String() string { return proto.CompactTextString(m) }
func (*PrimaryKeyDef) ProtoMessage()    {}
func (*PrimaryKeyDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{23}
}
func (m *PrimaryKeyDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrimaryKeyDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrimaryKeyDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrimaryKeyDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrimaryKeyDef.Merge(m, src)
}
func (m *PrimaryKeyDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PrimaryKeyDef) XXX_DiscardUnknown() {
	xxx_messageInfo_PrimaryKeyDef.DiscardUnknown(m)
}

var xxx_messageInfo_PrimaryKeyDef proto.InternalMessageInfo

func (m *PrimaryKeyDef) GetCols() []uint64 {
	if m != nil {
		return m.Cols
	}
	return nil
}

func (m *PrimaryKeyDef) GetPkeyColId() uint64 {
	if m != nil {
		return m.PkeyColId
	}
	return 0
}

func (m *PrimaryKeyDef) GetOption() *IndexOption {
	if m != nil {
		return m.Option
	}
	return nil
}

func (m *PrimaryKeyDef) GetPkeyColName() string {
	if m != nil {
		return m.PkeyColName
	}
	return ""
}

func (m *PrimaryKeyDef) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

func (m *PrimaryKeyDef) GetCompPkeyCol() *ColDef {
	if m != nil {
		return m.CompPkeyCol
	}
	return nil
}

type IndexDef struct {
	// Generate UUID for each index, currently not used
	IdxId     string `protobuf:"bytes,1,opt,name=idx_id,json=idxId,proto3" json:"idx_id,omitempty"`
	IndexName string `protobuf:"bytes,2,opt,name=index_name,json=indexName,proto3" json:"index_name,omitempty"`
	// The constituent columns of the index
	Parts          []string `protobuf:"bytes,3,rep,name=parts,proto3" json:"parts,omitempty"`
	Unique         bool     `protobuf:"varint,4,opt,name=unique,proto3" json:"unique,omitempty"`
	IndexTableName string   `protobuf:"bytes,5,opt,name=index_table_name,json=indexTableName,proto3" json:"index_table_name,omitempty"`
	TableExist     bool     `protobuf:"varint,6,opt,name=table_exist,json=tableExist,proto3" json:"table_exist,omitempty"`
	Comment        string   `protobuf:"bytes,7,opt,name=comment,proto3" json:"comment,omitempty"`
	Visible        bool     `protobuf:"varint,8,opt,name=visible,proto3" json:"visible,omitempty"`
	// currently not used
	Option               *IndexOption `protobuf:"bytes,9,opt,name=option,proto3" json:"option,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *IndexDef) Reset()         { *m = IndexDef{} }
func (m *IndexDef) String() string { return proto.CompactTextString(m) }
func (*IndexDef) ProtoMessage()    {}
func (*IndexDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{24}
}
func (m *IndexDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexDef.Merge(m, src)
}
func (m *IndexDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *IndexDef) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexDef.DiscardUnknown(m)
}

var xxx_messageInfo_IndexDef proto.InternalMessageInfo

func (m *IndexDef) GetIdxId() string {
	if m != nil {
		return m.IdxId
	}
	return ""
}

func (m *IndexDef) GetIndexName() string {
	if m != nil {
		return m.IndexName
	}
	return ""
}

func (m *IndexDef) GetParts() []string {
	if m != nil {
		return m.Parts
	}
	return nil
}

func (m *IndexDef) GetUnique() bool {
	if m != nil {
		return m.Unique
	}
	return false
}

func (m *IndexDef) GetIndexTableName() string {
	if m != nil {
		return m.IndexTableName
	}
	return ""
}

func (m *IndexDef) GetTableExist() bool {
	if m != nil {
		return m.TableExist
	}
	return false
}

func (m *IndexDef) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *IndexDef) GetVisible() bool {
	if m != nil {
		return m.Visible
	}
	return false
}

func (m *IndexDef) GetOption() *IndexOption {
	if m != nil {
		return m.Option
	}
	return nil
}

type ForeignKeyDef struct {
	Name string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Cols []uint64 `protobuf:"varint,2,rep,packed,name=cols,proto3" json:"cols,omitempty"`
	// Foreign key parent table Id
	ForeignTbl uint64 `protobuf:"varint,3,opt,name=foreign_tbl,json=foreignTbl,proto3" json:"foreign_tbl,omitempty"`
	// Foreign key parent table dependent column colids
	ForeignCols          []uint64                `protobuf:"varint,4,rep,packed,name=foreign_cols,json=foreignCols,proto3" json:"foreign_cols,omitempty"`
	OnDelete             ForeignKeyDef_RefAction `protobuf:"varint,5,opt,name=on_delete,json=onDelete,proto3,enum=plan.ForeignKeyDef_RefAction" json:"on_delete,omitempty"`
	OnUpdate             ForeignKeyDef_RefAction `protobuf:"varint,6,opt,name=on_update,json=onUpdate,proto3,enum=plan.ForeignKeyDef_RefAction" json:"on_update,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *ForeignKeyDef) Reset()         { *m = ForeignKeyDef{} }
func (m *ForeignKeyDef) String() string { return proto.CompactTextString(m) }
func (*ForeignKeyDef) ProtoMessage()    {}
func (*ForeignKeyDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{25}
}
func (m *ForeignKeyDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForeignKeyDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ForeignKeyDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ForeignKeyDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForeignKeyDef.Merge(m, src)
}
func (m *ForeignKeyDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ForeignKeyDef) XXX_DiscardUnknown() {
	xxx_messageInfo_ForeignKeyDef.DiscardUnknown(m)
}

var xxx_messageInfo_ForeignKeyDef proto.InternalMessageInfo

func (m *ForeignKeyDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ForeignKeyDef) GetCols() []uint64 {
	if m != nil {
		return m.Cols
	}
	return nil
}

func (m *ForeignKeyDef) GetForeignTbl() uint64 {
	if m != nil {
		return m.ForeignTbl
	}
	return 0
}

func (m *ForeignKeyDef) GetForeignCols() []uint64 {
	if m != nil {
		return m.ForeignCols
	}
	return nil
}

func (m *ForeignKeyDef) GetOnDelete() ForeignKeyDef_RefAction {
	if m != nil {
		return m.OnDelete
	}
	return ForeignKeyDef_RESTRICT
}

func (m *ForeignKeyDef) GetOnUpdate() ForeignKeyDef_RefAction {
	if m != nil {
		return m.OnUpdate
	}
	return ForeignKeyDef_RESTRICT
}

type CheckDef struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Name for anonymous constraints, __mo_chk_[INDEX_ID]
	Check                *Expr    `protobuf:"bytes,2,opt,name=check,proto3" json:"check,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckDef) Reset()         { *m = CheckDef{} }
func (m *CheckDef) String() string { return proto.CompactTextString(m) }
func (*CheckDef) ProtoMessage()    {}
func (*CheckDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{26}
}
func (m *CheckDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckDef.Merge(m, src)
}
func (m *CheckDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CheckDef) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckDef.DiscardUnknown(m)
}

var xxx_messageInfo_CheckDef proto.InternalMessageInfo

func (m *CheckDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CheckDef) GetCheck() *Expr {
	if m != nil {
		return m.Check
	}
	return nil
}

type ClusterByDef struct {
	// XXX: Deprecated and to be removed soon.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Composite cluster by column definition
	CompCbkeyCol         *ColDef  `protobuf:"bytes,2,opt,name=comp_cbkey_col,json=compCbkeyCol,proto3" json:"comp_cbkey_col,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterByDef) Reset()         { *m = ClusterByDef{} }
func (m *ClusterByDef) String() string { return proto.CompactTextString(m) }
func (*ClusterByDef) ProtoMessage()    {}
func (*ClusterByDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{27}
}
func (m *ClusterByDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterByDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterByDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterByDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterByDef.Merge(m, src)
}
func (m *ClusterByDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ClusterByDef) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterByDef.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterByDef proto.InternalMessageInfo

func (m *ClusterByDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ClusterByDef) GetCompCbkeyCol() *ColDef {
	if m != nil {
		return m.CompCbkeyCol
	}
	return nil
}

type PropertyDef struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PropertyDef) Reset()         { *m = PropertyDef{} }
func (m *PropertyDef) String() string { return proto.CompactTextString(m) }
func (*PropertyDef) ProtoMessage()    {}
func (*PropertyDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{28}
}
func (m *PropertyDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropertyDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropertyDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropertyDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropertyDef.Merge(m, src)
}
func (m *PropertyDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PropertyDef) XXX_DiscardUnknown() {
	xxx_messageInfo_PropertyDef.DiscardUnknown(m)
}

var xxx_messageInfo_PropertyDef proto.InternalMessageInfo

func (m *PropertyDef) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *PropertyDef) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type Property struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Property) Reset()         { *m = Property{} }
func (m *Property) String() string { return proto.CompactTextString(m) }
func (*Property) ProtoMessage()    {}
func (*Property) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{29}
}
func (m *Property) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Property) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Property.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Property) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Property.Merge(m, src)
}
func (m *Property) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Property) XXX_DiscardUnknown() {
	xxx_messageInfo_Property.DiscardUnknown(m)
}

var xxx_messageInfo_Property proto.InternalMessageInfo

func (m *Property) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Property) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type PropertiesDef struct {
	Properties           []*Property `protobuf:"bytes,1,rep,name=properties,proto3" json:"properties,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *PropertiesDef) Reset()         { *m = PropertiesDef{} }
func (m *PropertiesDef) String() string { return proto.CompactTextString(m) }
func (*PropertiesDef) ProtoMessage()    {}
func (*PropertiesDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{30}
}
func (m *PropertiesDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropertiesDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropertiesDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropertiesDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropertiesDef.Merge(m, src)
}
func (m *PropertiesDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PropertiesDef) XXX_DiscardUnknown() {
	xxx_messageInfo_PropertiesDef.DiscardUnknown(m)
}

var xxx_messageInfo_PropertiesDef proto.InternalMessageInfo

func (m *PropertiesDef) GetProperties() []*Property {
	if m != nil {
		return m.Properties
	}
	return nil
}

type PartitionByDef struct {
	Type                 PartitionType     `protobuf:"varint,1,opt,name=type,proto3,enum=plan.PartitionType" json:"type,omitempty"`
	PartitionExpr        *PartitionExpr    `protobuf:"bytes,2,opt,name=partition_expr,json=partitionExpr,proto3" json:"partition_expr,omitempty"`
	PartitionExpression  *Expr             `protobuf:"bytes,3,opt,name=partition_expression,json=partitionExpression,proto3" json:"partition_expression,omitempty"`
	PartitionColumns     *PartitionColumns `protobuf:"bytes,4,opt,name=partition_columns,json=partitionColumns,proto3" json:"partition_columns,omitempty"`
	PartitionNum         uint64            `protobuf:"varint,5,opt,name=partitionNum,proto3" json:"partitionNum,omitempty"`
	Partitions           []*PartitionItem  `protobuf:"bytes,6,rep,name=partitions,proto3" json:"partitions,omitempty"`
	Algorithm            int64             `protobuf:"varint,7,opt,name=algorithm,proto3" json:"algorithm,omitempty"`
	IsSubPartition       bool              `protobuf:"varint,8,opt,name=is_sub_partition,json=isSubPartition,proto3" json:"is_sub_partition,omitempty"`
	PartitionMsg         string            `protobuf:"bytes,9,opt,name=partition_msg,json=partitionMsg,proto3" json:"partition_msg,omitempty"`
	PartitionTableNames  []string          `protobuf:"bytes,10,rep,name=partition_table_names,json=partitionTableNames,proto3" json:"partition_table_names,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *PartitionByDef) Reset()         { *m = PartitionByDef{} }
func (m *PartitionByDef) String() string { return proto.CompactTextString(m) }
func (*PartitionByDef) ProtoMessage()    {}
func (*PartitionByDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{31}
}
func (m *PartitionByDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionByDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionByDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionByDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionByDef.Merge(m, src)
}
func (m *PartitionByDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PartitionByDef) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionByDef.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionByDef proto.InternalMessageInfo

func (m *PartitionByDef) GetType() PartitionType {
	if m != nil {
		return m.Type
	}
	return PartitionType_KEY
}

func (m *PartitionByDef) GetPartitionExpr() *PartitionExpr {
	if m != nil {
		return m.PartitionExpr
	}
	return nil
}

func (m *PartitionByDef) GetPartitionExpression() *Expr {
	if m != nil {
		return m.PartitionExpression
	}
	return nil
}

func (m *PartitionByDef) GetPartitionColumns() *PartitionColumns {
	if m != nil {
		return m.PartitionColumns
	}
	return nil
}

func (m *PartitionByDef) GetPartitionNum() uint64 {
	if m != nil {
		return m.PartitionNum
	}
	return 0
}

func (m *PartitionByDef) GetPartitions() []*PartitionItem {
	if m != nil {
		return m.Partitions
	}
	return nil
}

func (m *PartitionByDef) GetAlgorithm() int64 {
	if m != nil {
		return m.Algorithm
	}
	return 0
}

func (m *PartitionByDef) GetIsSubPartition() bool {
	if m != nil {
		return m.IsSubPartition
	}
	return false
}

func (m *PartitionByDef) GetPartitionMsg() string {
	if m != nil {
		return m.PartitionMsg
	}
	return ""
}

func (m *PartitionByDef) GetPartitionTableNames() []string {
	if m != nil {
		return m.PartitionTableNames
	}
	return nil
}

type PartitionExpr struct {
	Expr                 *Expr    `protobuf:"bytes,1,opt,name=expr,proto3" json:"expr,omitempty"`
	ExprStr              string   `protobuf:"bytes,2,opt,name=expr_str,json=exprStr,proto3" json:"expr_str,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartitionExpr) Reset()         { *m = PartitionExpr{} }
func (m *PartitionExpr) String() string { return proto.CompactTextString(m) }
func (*PartitionExpr) ProtoMessage()    {}
func (*PartitionExpr) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{32}
}
func (m *PartitionExpr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionExpr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionExpr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionExpr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionExpr.Merge(m, src)
}
func (m *PartitionExpr) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PartitionExpr) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionExpr.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionExpr proto.InternalMessageInfo

func (m *PartitionExpr) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *PartitionExpr) GetExprStr() string {
	if m != nil {
		return m.ExprStr
	}
	return ""
}

type PartitionColumns struct {
	Columns              []*Expr  `protobuf:"bytes,1,rep,name=columns,proto3" json:"columns,omitempty"`
	PartitionColumns     []string `protobuf:"bytes,2,rep,name=partition_columns,json=partitionColumns,proto3" json:"partition_columns,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartitionColumns) Reset()         { *m = PartitionColumns{} }
func (m *PartitionColumns) String() string { return proto.CompactTextString(m) }
func (*PartitionColumns) ProtoMessage()    {}
func (*PartitionColumns) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{33}
}
func (m *PartitionColumns) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionColumns) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionColumns.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionColumns) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionColumns.Merge(m, src)
}
func (m *PartitionColumns) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PartitionColumns) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionColumns.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionColumns proto.InternalMessageInfo

func (m *PartitionColumns) GetColumns() []*Expr {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *PartitionColumns) GetPartitionColumns() []string {
	if m != nil {
		return m.PartitionColumns
	}
	return nil
}

type PartitionItem struct {
	PartitionName        string   `protobuf:"bytes,1,opt,name=partition_name,json=partitionName,proto3" json:"partition_name,omitempty"`
	OrdinalPosition      uint32   `protobuf:"varint,2,opt,name=ordinal_position,json=ordinalPosition,proto3" json:"ordinal_position,omitempty"`
	Description          string   `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Comment              string   `protobuf:"bytes,4,opt,name=comment,proto3" json:"comment,omitempty"`
	LessThan             []*Expr  `protobuf:"bytes,5,rep,name=less_than,json=lessThan,proto3" json:"less_than,omitempty"`
	InValues             []*Expr  `protobuf:"bytes,6,rep,name=in_values,json=inValues,proto3" json:"in_values,omitempty"`
	PartitionTableName   string   `protobuf:"bytes,7,opt,name=partition_table_name,json=partitionTableName,proto3" json:"partition_table_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartitionItem) Reset()         { *m = PartitionItem{} }
func (m *PartitionItem) String() string { return proto.CompactTextString(m) }
func (*PartitionItem) ProtoMessage()    {}
func (*PartitionItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{34}
}
func (m *PartitionItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionItem.Merge(m, src)
}
func (m *PartitionItem) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PartitionItem) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionItem.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionItem proto.InternalMessageInfo

func (m *PartitionItem) GetPartitionName() string {
	if m != nil {
		return m.PartitionName
	}
	return ""
}

func (m *PartitionItem) GetOrdinalPosition() uint32 {
	if m != nil {
		return m.OrdinalPosition
	}
	return 0
}

func (m *PartitionItem) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *PartitionItem) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *PartitionItem) GetLessThan() []*Expr {
	if m != nil {
		return m.LessThan
	}
	return nil
}

func (m *PartitionItem) GetInValues() []*Expr {
	if m != nil {
		return m.InValues
	}
	return nil
}

func (m *PartitionItem) GetPartitionTableName() string {
	if m != nil {
		return m.PartitionTableName
	}
	return ""
}

type ViewDef struct {
	View                 string   `protobuf:"bytes,1,opt,name=view,proto3" json:"view,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ViewDef) Reset()         { *m = ViewDef{} }
func (m *ViewDef) String() string { return proto.CompactTextString(m) }
func (*ViewDef) ProtoMessage()    {}
func (*ViewDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{35}
}
func (m *ViewDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewDef.Merge(m, src)
}
func (m *ViewDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ViewDef) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewDef.DiscardUnknown(m)
}

var xxx_messageInfo_ViewDef proto.InternalMessageInfo

func (m *ViewDef) GetView() string {
	if m != nil {
		return m.View
	}
	return ""
}

type TableDef struct {
	TblId        uint64           `protobuf:"varint,1,opt,name=tbl_id,json=tblId,proto3" json:"tbl_id,omitempty"`
	Name         string           `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Hidden       bool             `protobuf:"varint,3,opt,name=hidden,proto3" json:"hidden,omitempty"`
	Cols         []*ColDef        `protobuf:"bytes,4,rep,name=cols,proto3" json:"cols,omitempty"`
	TableType    string           `protobuf:"bytes,5,opt,name=table_type,json=tableType,proto3" json:"table_type,omitempty"`
	Createsql    string           `protobuf:"bytes,6,opt,name=createsql,proto3" json:"createsql,omitempty"`
	TblFunc      *TableFunction   `protobuf:"bytes,7,opt,name=tbl_func,json=tblFunc,proto3" json:"tbl_func,omitempty"`
	Version      uint32           `protobuf:"varint,8,opt,name=version,proto3" json:"version,omitempty"`
	Pkey         *PrimaryKeyDef   `protobuf:"bytes,11,opt,name=pkey,proto3" json:"pkey,omitempty"`
	Indexes      []*IndexDef      `protobuf:"bytes,12,rep,name=indexes,proto3" json:"indexes,omitempty"`
	Fkeys        []*ForeignKeyDef `protobuf:"bytes,13,rep,name=fkeys,proto3" json:"fkeys,omitempty"`
	RefChildTbls []uint64         `protobuf:"varint,14,rep,packed,name=ref_child_tbls,json=refChildTbls,proto3" json:"ref_child_tbls,omitempty"`
	Checks       []*CheckDef      `protobuf:"bytes,15,rep,name=checks,proto3" json:"checks,omitempty"`
	Partition    *PartitionByDef  `protobuf:"bytes,21,opt,name=partition,proto3" json:"partition,omitempty"`
	ClusterBy    *ClusterByDef    `protobuf:"bytes,22,opt,name=cluster_by,json=clusterBy,proto3" json:"cluster_by,omitempty"`
	Props        []*PropertyDef   `protobuf:"bytes,23,rep,name=props,proto3" json:"props,omitempty"`
	ViewSql      *ViewDef         `protobuf:"bytes,24,opt,name=view_sql,json=viewSql,proto3" json:"view_sql,omitempty"`
	// XXX: Deprecated and to be removed soon.
	Defs                 []*TableDef_DefType `protobuf:"bytes,25,rep,name=defs,proto3" json:"defs,omitempty"`
	Name2ColIndex        map[string]int32    `protobuf:"bytes,26,rep,name=name2col_index,json=name2colIndex,proto3" json:"name2col_index,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	IsLocked             bool                `protobuf:"varint,27,opt,name=isLocked,proto3" json:"isLocked,omitempty"`
	TableLockType        TableLockType       `protobuf:"varint,28,opt,name=tableLockType,proto3,enum=plan.TableLockType" json:"tableLockType,omitempty"`
	IsTemporary          bool                `protobuf:"varint,29,opt,name=is_temporary,json=isTemporary,proto3" json:"is_temporary,omitempty"`
	AutoIncrOffset       uint64              `protobuf:"varint,30,opt,name=auto_incr_offset,json=autoIncrOffset,proto3" json:"auto_incr_offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TableDef) Reset()         { *m = TableDef{} }
func (m *TableDef) String() string { return proto.CompactTextString(m) }
func (*TableDef) ProtoMessage()    {}
func (*TableDef) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{36}
}
func (m *TableDef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableDef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableDef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDef.Merge(m, src)
}
func (m *TableDef) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableDef) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDef.DiscardUnknown(m)
}

var xxx_messageInfo_TableDef proto.InternalMessageInfo

func (m *TableDef) GetTblId() uint64 {
	if m != nil {
		return m.TblId
	}
	return 0
}

func (m *TableDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TableDef) GetHidden() bool {
	if m != nil {
		return m.Hidden
	}
	return false
}

func (m *TableDef) GetCols() []*ColDef {
	if m != nil {
		return m.Cols
	}
	return nil
}

func (m *TableDef) GetTableType() string {
	if m != nil {
		return m.TableType
	}
	return ""
}

func (m *TableDef) GetCreatesql() string {
	if m != nil {
		return m.Createsql
	}
	return ""
}

func (m *TableDef) GetTblFunc() *TableFunction {
	if m != nil {
		return m.TblFunc
	}
	return nil
}

func (m *TableDef) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *TableDef) GetPkey() *PrimaryKeyDef {
	if m != nil {
		return m.Pkey
	}
	return nil
}

func (m *TableDef) GetIndexes() []*IndexDef {
	if m != nil {
		return m.Indexes
	}
	return nil
}

func (m *TableDef) GetFkeys() []*ForeignKeyDef {
	if m != nil {
		return m.Fkeys
	}
	return nil
}

func (m *TableDef) GetRefChildTbls() []uint64 {
	if m != nil {
		return m.RefChildTbls
	}
	return nil
}

func (m *TableDef) GetChecks() []*CheckDef {
	if m != nil {
		return m.Checks
	}
	return nil
}

func (m *TableDef) GetPartition() *PartitionByDef {
	if m != nil {
		return m.Partition
	}
	return nil
}

func (m *TableDef) GetClusterBy() *ClusterByDef {
	if m != nil {
		return m.ClusterBy
	}
	return nil
}

func (m *TableDef) GetProps() []*PropertyDef {
	if m != nil {
		return m.Props
	}
	return nil
}

func (m *TableDef) GetViewSql() *ViewDef {
	if m != nil {
		return m.ViewSql
	}
	return nil
}

func (m *TableDef) GetDefs() []*TableDef_DefType {
	if m != nil {
		return m.Defs
	}
	return nil
}

func (m *TableDef) GetName2ColIndex() map[string]int32 {
	if m != nil {
		return m.Name2ColIndex
	}
	return nil
}

func (m *TableDef) GetIsLocked() bool {
	if m != nil {
		return m.IsLocked
	}
	return false
}

func (m *TableDef) GetTableLockType() TableLockType {
	if m != nil {
		return m.TableLockType
	}
	return TableLockType_TableLockNone
}

func (m *TableDef) GetIsTemporary() bool {
	if m != nil {
		return m.IsTemporary
	}
	return false
}

func (m *TableDef) GetAutoIncrOffset() uint64 {
	if m != nil {
		return m.AutoIncrOffset
	}
	return 0
}

// XXX: Deprecated and to be removed soon.
type TableDef_DefType struct {
	// Types that are valid to be assigned to Def:
	//
	//	*TableDef_DefType_Properties
	Def                  isTableDef_DefType_Def `protobuf_oneof:"def"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *TableDef_DefType) Reset()         { *m = TableDef_DefType{} }
func (m *TableDef_DefType) String() string { return proto.CompactTextString(m) }
func (*TableDef_DefType) ProtoMessage()    {}
func (*TableDef_DefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{36, 0}
}
func (m *TableDef_DefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDef_DefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableDef_DefType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableDef_DefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDef_DefType.Merge(m, src)
}
func (m *TableDef_DefType) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableDef_DefType) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDef_DefType.DiscardUnknown(m)
}

var xxx_messageInfo_TableDef_DefType proto.InternalMessageInfo

type isTableDef_DefType_Def interface {
	isTableDef_DefType_Def()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type TableDef_DefType_Properties struct {
	Properties *PropertiesDef `protobuf:"bytes,1,opt,name=properties,proto3,oneof" json:"properties,omitempty"`
}

func (*TableDef_DefType_Properties) isTableDef_DefType_Def() {}

func (m *TableDef_DefType) GetDef() isTableDef_DefType_Def {
	if m != nil {
		return m.Def
	}
	return nil
}

func (m *TableDef_DefType) GetProperties() *PropertiesDef {
	if x, ok := m.GetDef().(*TableDef_DefType_Properties); ok {
		return x.Properties
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TableDef_DefType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TableDef_DefType_Properties)(nil),
	}
}

type TableFunction struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Param                []byte   `protobuf:"bytes,2,opt,name=param,proto3" json:"param,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TableFunction) Reset()         { *m = TableFunction{} }
func (m *TableFunction) String() string { return proto.CompactTextString(m) }
func (*TableFunction) ProtoMessage()    {}
func (*TableFunction) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{37}
}
func (m *TableFunction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableFunction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableFunction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableFunction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableFunction.Merge(m, src)
}
func (m *TableFunction) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableFunction) XXX_DiscardUnknown() {
	xxx_messageInfo_TableFunction.DiscardUnknown(m)
}

var xxx_messageInfo_TableFunction proto.InternalMessageInfo

func (m *TableFunction) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TableFunction) GetParam() []byte {
	if m != nil {
		return m.Param
	}
	return nil
}

type HashMapStats struct {
	// hashmap size for nodes which build a hashmap
	HashmapSize float64 `protobuf:"fixed64,1,opt,name=hashmap_size,json=hashmapSize,proto3" json:"hashmap_size,omitempty"`
	HashOnPK    bool    `protobuf:"varint,2,opt,name=hashOnPK,proto3" json:"hashOnPK,omitempty"`
	// for group by and join node with big hashmap, use shuffle
	// shuffle on which column. choose a column with max ndv
	Shuffle       bool  `protobuf:"varint,3,opt,name=shuffle,proto3" json:"shuffle,omitempty"`
	ShuffleColIdx int32 `protobuf:"varint,4,opt,name=shuffleColIdx,proto3" json:"shuffleColIdx,omitempty"`
	// shuffle type
	ShuffleType ShuffleType `protobuf:"varint,5,opt,name=shuffleType,proto3,enum=plan.ShuffleType" json:"shuffleType,omitempty"`
	// for range shuffle on integer column, need to know its min and max value
	ShuffleColMin        int64         `protobuf:"varint,6,opt,name=shuffleColMin,proto3" json:"shuffleColMin,omitempty"`
	ShuffleColMax        int64         `protobuf:"varint,7,opt,name=shuffleColMax,proto3" json:"shuffleColMax,omitempty"`
	ShuffleMethod        ShuffleMethod `protobuf:"varint,8,opt,name=shuffleMethod,proto3,enum=plan.ShuffleMethod" json:"shuffleMethod,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *HashMapStats) Reset()         { *m = HashMapStats{} }
func (m *HashMapStats) String() string { return proto.CompactTextString(m) }
func (*HashMapStats) ProtoMessage()    {}
func (*HashMapStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{38}
}
func (m *HashMapStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HashMapStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HashMapStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HashMapStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HashMapStats.Merge(m, src)
}
func (m *HashMapStats) XXX_Size() int {
	return m.ProtoSize()
}
func (m *HashMapStats) XXX_DiscardUnknown() {
	xxx_messageInfo_HashMapStats.DiscardUnknown(m)
}

var xxx_messageInfo_HashMapStats proto.InternalMessageInfo

func (m *HashMapStats) GetHashmapSize() float64 {
	if m != nil {
		return m.HashmapSize
	}
	return 0
}

func (m *HashMapStats) GetHashOnPK() bool {
	if m != nil {
		return m.HashOnPK
	}
	return false
}

func (m *HashMapStats) GetShuffle() bool {
	if m != nil {
		return m.Shuffle
	}
	return false
}

func (m *HashMapStats) GetShuffleColIdx() int32 {
	if m != nil {
		return m.ShuffleColIdx
	}
	return 0
}

func (m *HashMapStats) GetShuffleType() ShuffleType {
	if m != nil {
		return m.ShuffleType
	}
	return ShuffleType_Hash
}

func (m *HashMapStats) GetShuffleColMin() int64 {
	if m != nil {
		return m.ShuffleColMin
	}
	return 0
}

func (m *HashMapStats) GetShuffleColMax() int64 {
	if m != nil {
		return m.ShuffleColMax
	}
	return 0
}

func (m *HashMapStats) GetShuffleMethod() ShuffleMethod {
	if m != nil {
		return m.ShuffleMethod
	}
	return ShuffleMethod_Normal
}

type Stats struct {
	// for scan, number of blocks to read from S3
	BlockNum int32 `protobuf:"varint,1,opt,name=block_num,json=blockNum,proto3" json:"block_num,omitempty"`
	// for scan, cost of reading from S3, basically the read lines
	// for other nodes, it means the estimated cost of current node
	Cost float64 `protobuf:"fixed64,2,opt,name=cost,proto3" json:"cost,omitempty"`
	// number of output lines
	Outcnt float64 `protobuf:"fixed64,3,opt,name=outcnt,proto3" json:"outcnt,omitempty"`
	// average size of one row, currently not used
	Rowsize float64 `protobuf:"fixed64,4,opt,name=rowsize,proto3" json:"rowsize,omitempty"`
	// for scan, this means total count of all table, before filtering
	TableCnt float64 `protobuf:"fixed64,5,opt,name=table_cnt,json=tableCnt,proto3" json:"table_cnt,omitempty"`
	// for scan, selectivity means outcnt divide total count
	Selectivity          float64       `protobuf:"fixed64,6,opt,name=selectivity,proto3" json:"selectivity,omitempty"`
	HashmapStats         *HashMapStats `protobuf:"bytes,7,opt,name=hashmapStats,proto3" json:"hashmapStats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Stats) Reset()         { *m = Stats{} }
func (m *Stats) String() string { return proto.CompactTextString(m) }
func (*Stats) ProtoMessage()    {}
func (*Stats) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{39}
}
func (m *Stats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Stats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Stats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Stats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Stats.Merge(m, src)
}
func (m *Stats) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Stats) XXX_DiscardUnknown() {
	xxx_messageInfo_Stats.DiscardUnknown(m)
}

var xxx_messageInfo_Stats proto.InternalMessageInfo

func (m *Stats) GetBlockNum() int32 {
	if m != nil {
		return m.BlockNum
	}
	return 0
}

func (m *Stats) GetCost() float64 {
	if m != nil {
		return m.Cost
	}
	return 0
}

func (m *Stats) GetOutcnt() float64 {
	if m != nil {
		return m.Outcnt
	}
	return 0
}

func (m *Stats) GetRowsize() float64 {
	if m != nil {
		return m.Rowsize
	}
	return 0
}

func (m *Stats) GetTableCnt() float64 {
	if m != nil {
		return m.TableCnt
	}
	return 0
}

func (m *Stats) GetSelectivity() float64 {
	if m != nil {
		return m.Selectivity
	}
	return 0
}

func (m *Stats) GetHashmapStats() *HashMapStats {
	if m != nil {
		return m.HashmapStats
	}
	return nil
}

type RowsetExpr struct {
	RowPos               int32    `protobuf:"varint,1,opt,name=row_pos,json=rowPos,proto3" json:"row_pos,omitempty"`
	Pos                  int32    `protobuf:"varint,2,opt,name=pos,proto3" json:"pos,omitempty"`
	Expr                 *Expr    `protobuf:"bytes,3,opt,name=expr,proto3" json:"expr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RowsetExpr) Reset()         { *m = RowsetExpr{} }
func (m *RowsetExpr) String() string { return proto.CompactTextString(m) }
func (*RowsetExpr) ProtoMessage()    {}
func (*RowsetExpr) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{40}
}
func (m *RowsetExpr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowsetExpr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RowsetExpr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RowsetExpr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowsetExpr.Merge(m, src)
}
func (m *RowsetExpr) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RowsetExpr) XXX_DiscardUnknown() {
	xxx_messageInfo_RowsetExpr.DiscardUnknown(m)
}

var xxx_messageInfo_RowsetExpr proto.InternalMessageInfo

func (m *RowsetExpr) GetRowPos() int32 {
	if m != nil {
		return m.RowPos
	}
	return 0
}

func (m *RowsetExpr) GetPos() int32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

func (m *RowsetExpr) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

type ColData struct {
	Data                 []*RowsetExpr `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ColData) Reset()         { *m = ColData{} }
func (m *ColData) String() string { return proto.CompactTextString(m) }
func (*ColData) ProtoMessage()    {}
func (*ColData) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{41}
}
func (m *ColData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColData.Merge(m, src)
}
func (m *ColData) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ColData) XXX_DiscardUnknown() {
	xxx_messageInfo_ColData.DiscardUnknown(m)
}

var xxx_messageInfo_ColData proto.InternalMessageInfo

func (m *ColData) GetData() []*RowsetExpr {
	if m != nil {
		return m.Data
	}
	return nil
}

type RowsetData struct {
	Cols                 []*ColData `protobuf:"bytes,1,rep,name=cols,proto3" json:"cols,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RowsetData) Reset()         { *m = RowsetData{} }
func (m *RowsetData) String() string { return proto.CompactTextString(m) }
func (*RowsetData) ProtoMessage()    {}
func (*RowsetData) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{42}
}
func (m *RowsetData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowsetData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RowsetData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RowsetData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowsetData.Merge(m, src)
}
func (m *RowsetData) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RowsetData) XXX_DiscardUnknown() {
	xxx_messageInfo_RowsetData.DiscardUnknown(m)
}

var xxx_messageInfo_RowsetData proto.InternalMessageInfo

func (m *RowsetData) GetCols() []*ColData {
	if m != nil {
		return m.Cols
	}
	return nil
}

type OrderBySpec struct {
	Expr                 *Expr                   `protobuf:"bytes,1,opt,name=expr,proto3" json:"expr,omitempty"`
	Collation            string                  `protobuf:"bytes,2,opt,name=collation,proto3" json:"collation,omitempty"`
	Flag                 OrderBySpec_OrderByFlag `protobuf:"varint,3,opt,name=flag,proto3,enum=plan.OrderBySpec_OrderByFlag" json:"flag,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *OrderBySpec) Reset()         { *m = OrderBySpec{} }
func (m *OrderBySpec) String() string { return proto.CompactTextString(m) }
func (*OrderBySpec) ProtoMessage()    {}
func (*OrderBySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{43}
}
func (m *OrderBySpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderBySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderBySpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderBySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderBySpec.Merge(m, src)
}
func (m *OrderBySpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *OrderBySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderBySpec.DiscardUnknown(m)
}

var xxx_messageInfo_OrderBySpec proto.InternalMessageInfo

func (m *OrderBySpec) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *OrderBySpec) GetCollation() string {
	if m != nil {
		return m.Collation
	}
	return ""
}

func (m *OrderBySpec) GetFlag() OrderBySpec_OrderByFlag {
	if m != nil {
		return m.Flag
	}
	return OrderBySpec_INTERNAL
}

type WindowSpec struct {
	WindowFunc           *Expr          `protobuf:"bytes,1,opt,name=window_func,json=windowFunc,proto3" json:"window_func,omitempty"`
	PartitionBy          []*Expr        `protobuf:"bytes,2,rep,name=partition_by,json=partitionBy,proto3" json:"partition_by,omitempty"`
	OrderBy              []*OrderBySpec `protobuf:"bytes,3,rep,name=order_by,json=orderBy,proto3" json:"order_by,omitempty"`
	Frame                *FrameClause   `protobuf:"bytes,4,opt,name=frame,proto3" json:"frame,omitempty"`
	Name                 string         `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *WindowSpec) Reset()         { *m = WindowSpec{} }
func (m *WindowSpec) String() string { return proto.CompactTextString(m) }
func (*WindowSpec) ProtoMessage()    {}
func (*WindowSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{44}
}
func (m *WindowSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WindowSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WindowSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowSpec.Merge(m, src)
}
func (m *WindowSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *WindowSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowSpec.DiscardUnknown(m)
}

var xxx_messageInfo_WindowSpec proto.InternalMessageInfo

func (m *WindowSpec) GetWindowFunc() *Expr {
	if m != nil {
		return m.WindowFunc
	}
	return nil
}

func (m *WindowSpec) GetPartitionBy() []*Expr {
	if m != nil {
		return m.PartitionBy
	}
	return nil
}

func (m *WindowSpec) GetOrderBy() []*OrderBySpec {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *WindowSpec) GetFrame() *FrameClause {
	if m != nil {
		return m.Frame
	}
	return nil
}

func (m *WindowSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type FrameClause struct {
	Type                 FrameClause_FrameType `protobuf:"varint,1,opt,name=type,proto3,enum=plan.FrameClause_FrameType" json:"type,omitempty"`
	Start                *FrameBound           `protobuf:"bytes,2,opt,name=start,proto3" json:"start,omitempty"`
	End                  *FrameBound           `protobuf:"bytes,3,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *FrameClause) Reset()         { *m = FrameClause{} }
func (m *FrameClause) String() string { return proto.CompactTextString(m) }
func (*FrameClause) ProtoMessage()    {}
func (*FrameClause) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{45}
}
func (m *FrameClause) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FrameClause) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FrameClause.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FrameClause) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FrameClause.Merge(m, src)
}
func (m *FrameClause) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FrameClause) XXX_DiscardUnknown() {
	xxx_messageInfo_FrameClause.DiscardUnknown(m)
}

var xxx_messageInfo_FrameClause proto.InternalMessageInfo

func (m *FrameClause) GetType() FrameClause_FrameType {
	if m != nil {
		return m.Type
	}
	return FrameClause_ROWS
}

func (m *FrameClause) GetStart() *FrameBound {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *FrameClause) GetEnd() *FrameBound {
	if m != nil {
		return m.End
	}
	return nil
}

type FrameBound struct {
	Type                 FrameBound_BoundType `protobuf:"varint,1,opt,name=type,proto3,enum=plan.FrameBound_BoundType" json:"type,omitempty"`
	UnBounded            bool                 `protobuf:"varint,2,opt,name=unBounded,proto3" json:"unBounded,omitempty"`
	Val                  *Expr                `protobuf:"bytes,3,opt,name=val,proto3" json:"val,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *FrameBound) Reset()         { *m = FrameBound{} }
func (m *FrameBound) String() string { return proto.CompactTextString(m) }
func (*FrameBound) ProtoMessage()    {}
func (*FrameBound) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{46}
}
func (m *FrameBound) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FrameBound) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FrameBound.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FrameBound) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FrameBound.Merge(m, src)
}
func (m *FrameBound) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FrameBound) XXX_DiscardUnknown() {
	xxx_messageInfo_FrameBound.DiscardUnknown(m)
}

var xxx_messageInfo_FrameBound proto.InternalMessageInfo

func (m *FrameBound) GetType() FrameBound_BoundType {
	if m != nil {
		return m.Type
	}
	return FrameBound_FOLLOWING
}

func (m *FrameBound) GetUnBounded() bool {
	if m != nil {
		return m.UnBounded
	}
	return false
}

func (m *FrameBound) GetVal() *Expr {
	if m != nil {
		return m.Val
	}
	return nil
}

type OnDuplicateKeyCtx struct {
	TableDef             *TableDef        `protobuf:"bytes,1,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	OnDuplicateIdx       []int32          `protobuf:"varint,2,rep,packed,name=on_duplicate_idx,json=onDuplicateIdx,proto3" json:"on_duplicate_idx,omitempty"`
	OnDuplicateExpr      map[string]*Expr `protobuf:"bytes,3,rep,name=on_duplicate_expr,json=onDuplicateExpr,proto3" json:"on_duplicate_expr,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *OnDuplicateKeyCtx) Reset()         { *m = OnDuplicateKeyCtx{} }
func (m *OnDuplicateKeyCtx) String() string { return proto.CompactTextString(m) }
func (*OnDuplicateKeyCtx) ProtoMessage()    {}
func (*OnDuplicateKeyCtx) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{47}
}
func (m *OnDuplicateKeyCtx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OnDuplicateKeyCtx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OnDuplicateKeyCtx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OnDuplicateKeyCtx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnDuplicateKeyCtx.Merge(m, src)
}
func (m *OnDuplicateKeyCtx) XXX_Size() int {
	return m.ProtoSize()
}
func (m *OnDuplicateKeyCtx) XXX_DiscardUnknown() {
	xxx_messageInfo_OnDuplicateKeyCtx.DiscardUnknown(m)
}

var xxx_messageInfo_OnDuplicateKeyCtx proto.InternalMessageInfo

func (m *OnDuplicateKeyCtx) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *OnDuplicateKeyCtx) GetOnDuplicateIdx() []int32 {
	if m != nil {
		return m.OnDuplicateIdx
	}
	return nil
}

func (m *OnDuplicateKeyCtx) GetOnDuplicateExpr() map[string]*Expr {
	if m != nil {
		return m.OnDuplicateExpr
	}
	return nil
}

type InsertCtx struct {
	Ref             *ObjectRef `protobuf:"bytes,1,opt,name=ref,proto3" json:"ref,omitempty"`
	AddAffectedRows bool       `protobuf:"varint,2,opt,name=add_affected_rows,json=addAffectedRows,proto3" json:"add_affected_rows,omitempty"`
	IsClusterTable  bool       `protobuf:"varint,3,opt,name=is_cluster_table,json=isClusterTable,proto3" json:"is_cluster_table,omitempty"`
	TableDef        *TableDef  `protobuf:"bytes,4,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	// Align array index with the partition number
	PartitionTableIds    []uint64 `protobuf:"varint,5,rep,packed,name=partition_table_ids,json=partitionTableIds,proto3" json:"partition_table_ids,omitempty"`
	PartitionTableNames  []string `protobuf:"bytes,6,rep,name=partition_table_names,json=partitionTableNames,proto3" json:"partition_table_names,omitempty"`
	PartitionIdx         int32    `protobuf:"varint,7,opt,name=partition_idx,json=partitionIdx,proto3" json:"partition_idx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InsertCtx) Reset()         { *m = InsertCtx{} }
func (m *InsertCtx) String() string { return proto.CompactTextString(m) }
func (*InsertCtx) ProtoMessage()    {}
func (*InsertCtx) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{48}
}
func (m *InsertCtx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InsertCtx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InsertCtx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InsertCtx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InsertCtx.Merge(m, src)
}
func (m *InsertCtx) XXX_Size() int {
	return m.ProtoSize()
}
func (m *InsertCtx) XXX_DiscardUnknown() {
	xxx_messageInfo_InsertCtx.DiscardUnknown(m)
}

var xxx_messageInfo_InsertCtx proto.InternalMessageInfo

func (m *InsertCtx) GetRef() *ObjectRef {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *InsertCtx) GetAddAffectedRows() bool {
	if m != nil {
		return m.AddAffectedRows
	}
	return false
}

func (m *InsertCtx) GetIsClusterTable() bool {
	if m != nil {
		return m.IsClusterTable
	}
	return false
}

func (m *InsertCtx) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *InsertCtx) GetPartitionTableIds() []uint64 {
	if m != nil {
		return m.PartitionTableIds
	}
	return nil
}

func (m *InsertCtx) GetPartitionTableNames() []string {
	if m != nil {
		return m.PartitionTableNames
	}
	return nil
}

func (m *InsertCtx) GetPartitionIdx() int32 {
	if m != nil {
		return m.PartitionIdx
	}
	return 0
}

type ReplaceCtx struct {
	Ref             *ObjectRef `protobuf:"bytes,1,opt,name=ref,proto3" json:"ref,omitempty"`
	AddAffectedRows bool       `protobuf:"varint,2,opt,name=add_affected_rows,json=addAffectedRows,proto3" json:"add_affected_rows,omitempty"`
	IsClusterTable  bool       `protobuf:"varint,3,opt,name=is_cluster_table,json=isClusterTable,proto3" json:"is_cluster_table,omitempty"`
	TableDef        *TableDef  `protobuf:"bytes,4,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	DeleteCond      string     `protobuf:"bytes,5,opt,name=delete_cond,json=deleteCond,proto3" json:"delete_cond,omitempty"`
	// Align array index with the partition number
	PartitionTableIds    []uint64 `protobuf:"varint,6,rep,packed,name=partition_table_ids,json=partitionTableIds,proto3" json:"partition_table_ids,omitempty"`
	PartitionTableNames  []string `protobuf:"bytes,7,rep,name=partition_table_names,json=partitionTableNames,proto3" json:"partition_table_names,omitempty"`
	PartitionIdx         int32    `protobuf:"varint,8,opt,name=partition_idx,json=partitionIdx,proto3" json:"partition_idx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReplaceCtx) Reset()         { *m = ReplaceCtx{} }
func (m *ReplaceCtx) String() string { return proto.CompactTextString(m) }
func (*ReplaceCtx) ProtoMessage()    {}
func (*ReplaceCtx) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{49}
}
func (m *ReplaceCtx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceCtx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplaceCtx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplaceCtx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceCtx.Merge(m, src)
}
func (m *ReplaceCtx) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ReplaceCtx) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceCtx.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceCtx proto.InternalMessageInfo

func (m *ReplaceCtx) GetRef() *ObjectRef {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *ReplaceCtx) GetAddAffectedRows() bool {
	if m != nil {
		return m.AddAffectedRows
	}
	return false
}

func (m *ReplaceCtx) GetIsClusterTable() bool {
	if m != nil {
		return m.IsClusterTable
	}
	return false
}

func (m *ReplaceCtx) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *ReplaceCtx) GetDeleteCond() string {
	if m != nil {
		return m.DeleteCond
	}
	return ""
}

func (m *ReplaceCtx) GetPartitionTableIds() []uint64 {
	if m != nil {
		return m.PartitionTableIds
	}
	return nil
}

func (m *ReplaceCtx) GetPartitionTableNames() []string {
	if m != nil {
		return m.PartitionTableNames
	}
	return nil
}

func (m *ReplaceCtx) GetPartitionIdx() int32 {
	if m != nil {
		return m.PartitionIdx
	}
	return 0
}

type AnalyzeInfo struct {
	InputRows            int64    `protobuf:"varint,1,opt,name=input_rows,json=inputRows,proto3" json:"input_rows,omitempty"`
	OutputRows           int64    `protobuf:"varint,2,opt,name=output_rows,json=outputRows,proto3" json:"output_rows,omitempty"`
	InputSize            int64    `protobuf:"varint,3,opt,name=input_size,json=inputSize,proto3" json:"input_size,omitempty"`
	OutputSize           int64    `protobuf:"varint,4,opt,name=output_size,json=outputSize,proto3" json:"output_size,omitempty"`
	TimeConsumed         int64    `protobuf:"varint,5,opt,name=time_consumed,json=timeConsumed,proto3" json:"time_consumed,omitempty"`
	MemorySize           int64    `protobuf:"varint,6,opt,name=memory_size,json=memorySize,proto3" json:"memory_size,omitempty"`
	WaitTimeConsumed     int64    `protobuf:"varint,7,opt,name=wait_time_consumed,json=waitTimeConsumed,proto3" json:"wait_time_consumed,omitempty"`
	DiskIO               int64    `protobuf:"varint,8,opt,name=diskIO,proto3" json:"diskIO,omitempty"`
	S3IOByte             int64    `protobuf:"varint,9,opt,name=s3IO_byte,json=s3IOByte,proto3" json:"s3IO_byte,omitempty"`
	S3IOInputCount       int64    `protobuf:"varint,10,opt,name=s3IO_input_count,json=s3IOInputCount,proto3" json:"s3IO_input_count,omitempty"`
	S3IOOutputCount      int64    `protobuf:"varint,11,opt,name=s3IO_output_count,json=s3IOOutputCount,proto3" json:"s3IO_output_count,omitempty"`
	NetworkIO            int64    `protobuf:"varint,12,opt,name=networkIO,proto3" json:"networkIO,omitempty"`
	ScanTime             int64    `protobuf:"varint,13,opt,name=scanTime,proto3" json:"scanTime,omitempty"`
	InsertTime           int64    `protobuf:"varint,14,opt,name=insertTime,proto3" json:"insertTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AnalyzeInfo) Reset()         { *m = AnalyzeInfo{} }
func (m *AnalyzeInfo) String() string { return proto.CompactTextString(m) }
func (*AnalyzeInfo) ProtoMessage()    {}
func (*AnalyzeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{50}
}
func (m *AnalyzeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnalyzeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnalyzeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AnalyzeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnalyzeInfo.Merge(m, src)
}
func (m *AnalyzeInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AnalyzeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AnalyzeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AnalyzeInfo proto.InternalMessageInfo

func (m *AnalyzeInfo) GetInputRows() int64 {
	if m != nil {
		return m.InputRows
	}
	return 0
}

func (m *AnalyzeInfo) GetOutputRows() int64 {
	if m != nil {
		return m.OutputRows
	}
	return 0
}

func (m *AnalyzeInfo) GetInputSize() int64 {
	if m != nil {
		return m.InputSize
	}
	return 0
}

func (m *AnalyzeInfo) GetOutputSize() int64 {
	if m != nil {
		return m.OutputSize
	}
	return 0
}

func (m *AnalyzeInfo) GetTimeConsumed() int64 {
	if m != nil {
		return m.TimeConsumed
	}
	return 0
}

func (m *AnalyzeInfo) GetMemorySize() int64 {
	if m != nil {
		return m.MemorySize
	}
	return 0
}

func (m *AnalyzeInfo) GetWaitTimeConsumed() int64 {
	if m != nil {
		return m.WaitTimeConsumed
	}
	return 0
}

func (m *AnalyzeInfo) GetDiskIO() int64 {
	if m != nil {
		return m.DiskIO
	}
	return 0
}

func (m *AnalyzeInfo) GetS3IOByte() int64 {
	if m != nil {
		return m.S3IOByte
	}
	return 0
}

func (m *AnalyzeInfo) GetS3IOInputCount() int64 {
	if m != nil {
		return m.S3IOInputCount
	}
	return 0
}

func (m *AnalyzeInfo) GetS3IOOutputCount() int64 {
	if m != nil {
		return m.S3IOOutputCount
	}
	return 0
}

func (m *AnalyzeInfo) GetNetworkIO() int64 {
	if m != nil {
		return m.NetworkIO
	}
	return 0
}

func (m *AnalyzeInfo) GetScanTime() int64 {
	if m != nil {
		return m.ScanTime
	}
	return 0
}

func (m *AnalyzeInfo) GetInsertTime() int64 {
	if m != nil {
		return m.InsertTime
	}
	return 0
}

type Node struct {
	NodeType Node_NodeType `protobuf:"varint,1,opt,name=node_type,json=nodeType,proto3,enum=plan.Node_NodeType" json:"node_type,omitempty"`
	NodeId   int32         `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Stats    *Stats        `protobuf:"bytes,3,opt,name=stats,proto3" json:"stats,omitempty"`
	Children []int32       `protobuf:"varint,4,rep,packed,name=children,proto3" json:"children,omitempty"`
	// PROJECT
	ProjectList []*Expr `protobuf:"bytes,5,rep,name=project_list,json=projectList,proto3" json:"project_list,omitempty"`
	// JOIN
	JoinType    Node_JoinType `protobuf:"varint,6,opt,name=join_type,json=joinType,proto3,enum=plan.Node_JoinType" json:"join_type,omitempty"`
	OnList      []*Expr       `protobuf:"bytes,7,rep,name=on_list,json=onList,proto3" json:"on_list,omitempty"`
	BuildOnLeft bool          `protobuf:"varint,8,opt,name=build_on_left,json=buildOnLeft,proto3" json:"build_on_left,omitempty"`
	// FILTER
	FilterList []*Expr `protobuf:"bytes,9,rep,name=filter_list,json=filterList,proto3" json:"filter_list,omitempty"`
	// AGG
	GroupBy     []*Expr `protobuf:"bytes,10,rep,name=group_by,json=groupBy,proto3" json:"group_by,omitempty"`
	GroupingSet []*Expr `protobuf:"bytes,11,rep,name=grouping_set,json=groupingSet,proto3" json:"grouping_set,omitempty"`
	AggList     []*Expr `protobuf:"bytes,12,rep,name=agg_list,json=aggList,proto3" json:"agg_list,omitempty"`
	// WINDOW
	WinSpecList []*Expr `protobuf:"bytes,13,rep,name=win_spec_list,json=winSpecList,proto3" json:"win_spec_list,omitempty"`
	// SORT
	OrderBy []*OrderBySpec `protobuf:"bytes,14,rep,name=order_by,json=orderBy,proto3" json:"order_by,omitempty"`
	// LIMIT
	Limit           *Expr         `protobuf:"bytes,15,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset          *Expr         `protobuf:"bytes,16,opt,name=offset,proto3" json:"offset,omitempty"`
	TableDef        *TableDef     `protobuf:"bytes,18,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	TableDefVec     []*TableDef   `protobuf:"bytes,19,rep,name=table_def_vec,json=tableDefVec,proto3" json:"table_def_vec,omitempty"`
	ObjRef          *ObjectRef    `protobuf:"bytes,20,opt,name=obj_ref,json=objRef,proto3" json:"obj_ref,omitempty"`
	RowsetData      *RowsetData   `protobuf:"bytes,21,opt,name=rowset_data,json=rowsetData,proto3" json:"rowset_data,omitempty"`
	ExtraOptions    string        `protobuf:"bytes,22,opt,name=extra_options,json=extraOptions,proto3" json:"extra_options,omitempty"`
	DeleteCtx       *DeleteCtx    `protobuf:"bytes,23,opt,name=delete_ctx,json=deleteCtx,proto3" json:"delete_ctx,omitempty"`
	BindingTags     []int32       `protobuf:"varint,24,rep,packed,name=binding_tags,json=bindingTags,proto3" json:"binding_tags,omitempty"`
	AnalyzeInfo     *AnalyzeInfo  `protobuf:"bytes,25,opt,name=analyze_info,json=analyzeInfo,proto3" json:"analyze_info,omitempty"`
	TblFuncExprList []*Expr       `protobuf:"bytes,26,rep,name=tbl_func_expr_list,json=tblFuncExprList,proto3" json:"tbl_func_expr_list,omitempty"`
	ClusterTable    *ClusterTable `protobuf:"bytes,28,opt,name=cluster_table,json=clusterTable,proto3" json:"cluster_table,omitempty"`
	NotCacheable    bool          `protobuf:"varint,29,opt,name=not_cacheable,json=notCacheable,proto3" json:"not_cacheable,omitempty"`
	InsertCtx       *InsertCtx    `protobuf:"bytes,30,opt,name=insert_ctx,json=insertCtx,proto3" json:"insert_ctx,omitempty"`
	ReplaceCtx      *ReplaceCtx   `protobuf:"bytes,31,opt,name=replace_ctx,json=replaceCtx,proto3" json:"replace_ctx,omitempty"`
	// used to connect two plans[steps]
	SourceStep   []int32       `protobuf:"varint,32,rep,packed,name=source_step,json=sourceStep,proto3" json:"source_step,omitempty"`
	PreDeleteCtx *PreDeleteCtx `protobuf:"bytes,33,opt,name=pre_delete_ctx,json=preDeleteCtx,proto3" json:"pre_delete_ctx,omitempty"`
	PreInsertCtx *PreInsertCtx `protobuf:"bytes,34,opt,name=pre_insert_ctx,json=preInsertCtx,proto3" json:"pre_insert_ctx,omitempty"`
	// build unique key batch before insert into hidden table which keep the unique key
	PreInsertUkCtx  *PreInsertUkCtx    `protobuf:"bytes,35,opt,name=pre_insert_uk_ctx,json=preInsertUkCtx,proto3" json:"pre_insert_uk_ctx,omitempty"`
	OnDuplicateKey  *OnDuplicateKeyCtx `protobuf:"bytes,36,opt,name=on_duplicate_key,json=onDuplicateKey,proto3" json:"on_duplicate_key,omitempty"`
	IsEnd           bool               `protobuf:"varint,37,opt,name=IsEnd,proto3" json:"IsEnd,omitempty"`
	LockTargets     []*LockTarget      `protobuf:"bytes,38,rep,name=lock_targets,json=lockTargets,proto3" json:"lock_targets,omitempty"`
	BlockFilterList []*Expr            `protobuf:"bytes,39,rep,name=block_filter_list,json=blockFilterList,proto3" json:"block_filter_list,omitempty"`
	// Runtime filters
	RuntimeFilterProbeList []*RuntimeFilterSpec `protobuf:"bytes,40,rep,name=runtime_filter_probe_list,json=runtimeFilterProbeList,proto3" json:"runtime_filter_probe_list,omitempty"`
	RuntimeFilterBuildList []*RuntimeFilterSpec `protobuf:"bytes,41,rep,name=runtime_filter_build_list,json=runtimeFilterBuildList,proto3" json:"runtime_filter_build_list,omitempty"`
	Uuid                   []byte               `protobuf:"bytes,42,opt,name=uuid,proto3" json:"uuid,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}             `json:"-"`
	XXX_unrecognized       []byte               `json:"-"`
	XXX_sizecache          int32                `json:"-"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{51}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetNodeType() Node_NodeType {
	if m != nil {
		return m.NodeType
	}
	return Node_UNKNOWN
}

func (m *Node) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *Node) GetStats() *Stats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *Node) GetChildren() []int32 {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *Node) GetProjectList() []*Expr {
	if m != nil {
		return m.ProjectList
	}
	return nil
}

func (m *Node) GetJoinType() Node_JoinType {
	if m != nil {
		return m.JoinType
	}
	return Node_INNER
}

func (m *Node) GetOnList() []*Expr {
	if m != nil {
		return m.OnList
	}
	return nil
}

func (m *Node) GetBuildOnLeft() bool {
	if m != nil {
		return m.BuildOnLeft
	}
	return false
}

func (m *Node) GetFilterList() []*Expr {
	if m != nil {
		return m.FilterList
	}
	return nil
}

func (m *Node) GetGroupBy() []*Expr {
	if m != nil {
		return m.GroupBy
	}
	return nil
}

func (m *Node) GetGroupingSet() []*Expr {
	if m != nil {
		return m.GroupingSet
	}
	return nil
}

func (m *Node) GetAggList() []*Expr {
	if m != nil {
		return m.AggList
	}
	return nil
}

func (m *Node) GetWinSpecList() []*Expr {
	if m != nil {
		return m.WinSpecList
	}
	return nil
}

func (m *Node) GetOrderBy() []*OrderBySpec {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *Node) GetLimit() *Expr {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *Node) GetOffset() *Expr {
	if m != nil {
		return m.Offset
	}
	return nil
}

func (m *Node) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *Node) GetTableDefVec() []*TableDef {
	if m != nil {
		return m.TableDefVec
	}
	return nil
}

func (m *Node) GetObjRef() *ObjectRef {
	if m != nil {
		return m.ObjRef
	}
	return nil
}

func (m *Node) GetRowsetData() *RowsetData {
	if m != nil {
		return m.RowsetData
	}
	return nil
}

func (m *Node) GetExtraOptions() string {
	if m != nil {
		return m.ExtraOptions
	}
	return ""
}

func (m *Node) GetDeleteCtx() *DeleteCtx {
	if m != nil {
		return m.DeleteCtx
	}
	return nil
}

func (m *Node) GetBindingTags() []int32 {
	if m != nil {
		return m.BindingTags
	}
	return nil
}

func (m *Node) GetAnalyzeInfo() *AnalyzeInfo {
	if m != nil {
		return m.AnalyzeInfo
	}
	return nil
}

func (m *Node) GetTblFuncExprList() []*Expr {
	if m != nil {
		return m.TblFuncExprList
	}
	return nil
}

func (m *Node) GetClusterTable() *ClusterTable {
	if m != nil {
		return m.ClusterTable
	}
	return nil
}

func (m *Node) GetNotCacheable() bool {
	if m != nil {
		return m.NotCacheable
	}
	return false
}

func (m *Node) GetInsertCtx() *InsertCtx {
	if m != nil {
		return m.InsertCtx
	}
	return nil
}

func (m *Node) GetReplaceCtx() *ReplaceCtx {
	if m != nil {
		return m.ReplaceCtx
	}
	return nil
}

func (m *Node) GetSourceStep() []int32 {
	if m != nil {
		return m.SourceStep
	}
	return nil
}

func (m *Node) GetPreDeleteCtx() *PreDeleteCtx {
	if m != nil {
		return m.PreDeleteCtx
	}
	return nil
}

func (m *Node) GetPreInsertCtx() *PreInsertCtx {
	if m != nil {
		return m.PreInsertCtx
	}
	return nil
}

func (m *Node) GetPreInsertUkCtx() *PreInsertUkCtx {
	if m != nil {
		return m.PreInsertUkCtx
	}
	return nil
}

func (m *Node) GetOnDuplicateKey() *OnDuplicateKeyCtx {
	if m != nil {
		return m.OnDuplicateKey
	}
	return nil
}

func (m *Node) GetIsEnd() bool {
	if m != nil {
		return m.IsEnd
	}
	return false
}

func (m *Node) GetLockTargets() []*LockTarget {
	if m != nil {
		return m.LockTargets
	}
	return nil
}

func (m *Node) GetBlockFilterList() []*Expr {
	if m != nil {
		return m.BlockFilterList
	}
	return nil
}

func (m *Node) GetRuntimeFilterProbeList() []*RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterProbeList
	}
	return nil
}

func (m *Node) GetRuntimeFilterBuildList() []*RuntimeFilterSpec {
	if m != nil {
		return m.RuntimeFilterBuildList
	}
	return nil
}

func (m *Node) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

type LockTarget struct {
	TableId              uint64   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	PrimaryColIdxInBat   int32    `protobuf:"varint,2,opt,name=primary_col_idx_in_bat,json=primaryColIdxInBat,proto3" json:"primary_col_idx_in_bat,omitempty"`
	PrimaryColTyp        *Type    `protobuf:"bytes,3,opt,name=primary_col_typ,json=primaryColTyp,proto3" json:"primary_col_typ,omitempty"`
	RefreshTsIdxInBat    int32    `protobuf:"varint,4,opt,name=refresh_ts_idx_in_bat,json=refreshTsIdxInBat,proto3" json:"refresh_ts_idx_in_bat,omitempty"`
	FilterColIdxInBat    int32    `protobuf:"varint,5,opt,name=filter_col_idx_in_bat,json=filterColIdxInBat,proto3" json:"filter_col_idx_in_bat,omitempty"`
	LockTable            bool     `protobuf:"varint,6,opt,name=lock_table,json=lockTable,proto3" json:"lock_table,omitempty"`
	IsPartitionTable     bool     `protobuf:"varint,7,opt,name=is_partition_table,json=isPartitionTable,proto3" json:"is_partition_table,omitempty"`
	PartitionTableIds    []uint64 `protobuf:"varint,8,rep,packed,name=partition_table_ids,json=partitionTableIds,proto3" json:"partition_table_ids,omitempty"`
	Block                bool     `protobuf:"varint,9,opt,name=block,proto3" json:"block,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LockTarget) Reset()         { *m = LockTarget{} }
func (m *LockTarget) String() string { return proto.CompactTextString(m) }
func (*LockTarget) ProtoMessage()    {}
func (*LockTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{52}
}
func (m *LockTarget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockTarget.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LockTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockTarget.Merge(m, src)
}
func (m *LockTarget) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LockTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_LockTarget.DiscardUnknown(m)
}

var xxx_messageInfo_LockTarget proto.InternalMessageInfo

func (m *LockTarget) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *LockTarget) GetPrimaryColIdxInBat() int32 {
	if m != nil {
		return m.PrimaryColIdxInBat
	}
	return 0
}

func (m *LockTarget) GetPrimaryColTyp() *Type {
	if m != nil {
		return m.PrimaryColTyp
	}
	return nil
}

func (m *LockTarget) GetRefreshTsIdxInBat() int32 {
	if m != nil {
		return m.RefreshTsIdxInBat
	}
	return 0
}

func (m *LockTarget) GetFilterColIdxInBat() int32 {
	if m != nil {
		return m.FilterColIdxInBat
	}
	return 0
}

func (m *LockTarget) GetLockTable() bool {
	if m != nil {
		return m.LockTable
	}
	return false
}

func (m *LockTarget) GetIsPartitionTable() bool {
	if m != nil {
		return m.IsPartitionTable
	}
	return false
}

func (m *LockTarget) GetPartitionTableIds() []uint64 {
	if m != nil {
		return m.PartitionTableIds
	}
	return nil
}

func (m *LockTarget) GetBlock() bool {
	if m != nil {
		return m.Block
	}
	return false
}

type PreInsertUkCtx struct {
	// index of columns(parts of unique key) in pre batch
	Columns              []int32   `protobuf:"varint,1,rep,packed,name=columns,proto3" json:"columns,omitempty"`
	PkColumn             int32     `protobuf:"varint,2,opt,name=pk_column,json=pkColumn,proto3" json:"pk_column,omitempty"`
	PkType               *Type     `protobuf:"bytes,3,opt,name=pk_type,json=pkType,proto3" json:"pk_type,omitempty"`
	UkType               *Type     `protobuf:"bytes,4,opt,name=uk_type,json=ukType,proto3" json:"uk_type,omitempty"`
	TableDef             *TableDef `protobuf:"bytes,5,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *PreInsertUkCtx) Reset()         { *m = PreInsertUkCtx{} }
func (m *PreInsertUkCtx) String() string { return proto.CompactTextString(m) }
func (*PreInsertUkCtx) ProtoMessage()    {}
func (*PreInsertUkCtx) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{53}
}
func (m *PreInsertUkCtx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreInsertUkCtx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PreInsertUkCtx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PreInsertUkCtx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreInsertUkCtx.Merge(m, src)
}
func (m *PreInsertUkCtx) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PreInsertUkCtx) XXX_DiscardUnknown() {
	xxx_messageInfo_PreInsertUkCtx.DiscardUnknown(m)
}

var xxx_messageInfo_PreInsertUkCtx proto.InternalMessageInfo

func (m *PreInsertUkCtx) GetColumns() []int32 {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *PreInsertUkCtx) GetPkColumn() int32 {
	if m != nil {
		return m.PkColumn
	}
	return 0
}

func (m *PreInsertUkCtx) GetPkType() *Type {
	if m != nil {
		return m.PkType
	}
	return nil
}

func (m *PreInsertUkCtx) GetUkType() *Type {
	if m != nil {
		return m.UkType
	}
	return nil
}

func (m *PreInsertUkCtx) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

type PreDeleteCtx struct {
	// the indexes of row_id&pk column in the batch
	Idx                  []int32  `protobuf:"varint,1,rep,packed,name=idx,proto3" json:"idx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PreDeleteCtx) Reset()         { *m = PreDeleteCtx{} }
func (m *PreDeleteCtx) String() string { return proto.CompactTextString(m) }
func (*PreDeleteCtx) ProtoMessage()    {}
func (*PreDeleteCtx) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{54}
}
func (m *PreDeleteCtx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreDeleteCtx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PreDeleteCtx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PreDeleteCtx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreDeleteCtx.Merge(m, src)
}
func (m *PreDeleteCtx) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PreDeleteCtx) XXX_DiscardUnknown() {
	xxx_messageInfo_PreDeleteCtx.DiscardUnknown(m)
}

var xxx_messageInfo_PreDeleteCtx proto.InternalMessageInfo

func (m *PreDeleteCtx) GetIdx() []int32 {
	if m != nil {
		return m.Idx
	}
	return nil
}

type PreInsertCtx struct {
	Ref                  *ObjectRef `protobuf:"bytes,1,opt,name=ref,proto3" json:"ref,omitempty"`
	TableDef             *TableDef  `protobuf:"bytes,2,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	HasAutoCol           bool       `protobuf:"varint,3,opt,name=has_auto_col,json=hasAutoCol,proto3" json:"has_auto_col,omitempty"`
	IsUpdate             bool       `protobuf:"varint,4,opt,name=is_update,json=isUpdate,proto3" json:"is_update,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *PreInsertCtx) Reset()         { *m = PreInsertCtx{} }
func (m *PreInsertCtx) String() string { return proto.CompactTextString(m) }
func (*PreInsertCtx) ProtoMessage()    {}
func (*PreInsertCtx) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{55}
}
func (m *PreInsertCtx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreInsertCtx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PreInsertCtx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PreInsertCtx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreInsertCtx.Merge(m, src)
}
func (m *PreInsertCtx) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PreInsertCtx) XXX_DiscardUnknown() {
	xxx_messageInfo_PreInsertCtx.DiscardUnknown(m)
}

var xxx_messageInfo_PreInsertCtx proto.InternalMessageInfo

func (m *PreInsertCtx) GetRef() *ObjectRef {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *PreInsertCtx) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *PreInsertCtx) GetHasAutoCol() bool {
	if m != nil {
		return m.HasAutoCol
	}
	return false
}

func (m *PreInsertCtx) GetIsUpdate() bool {
	if m != nil {
		return m.IsUpdate
	}
	return false
}

type RuntimeFilterSpec struct {
	Tag                  int32    `protobuf:"varint,1,opt,name=tag,proto3" json:"tag,omitempty"`
	Expr                 *Expr    `protobuf:"bytes,2,opt,name=expr,proto3" json:"expr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RuntimeFilterSpec) Reset()         { *m = RuntimeFilterSpec{} }
func (m *RuntimeFilterSpec) String() string { return proto.CompactTextString(m) }
func (*RuntimeFilterSpec) ProtoMessage()    {}
func (*RuntimeFilterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{56}
}
func (m *RuntimeFilterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuntimeFilterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RuntimeFilterSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RuntimeFilterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuntimeFilterSpec.Merge(m, src)
}
func (m *RuntimeFilterSpec) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RuntimeFilterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RuntimeFilterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RuntimeFilterSpec proto.InternalMessageInfo

func (m *RuntimeFilterSpec) GetTag() int32 {
	if m != nil {
		return m.Tag
	}
	return 0
}

func (m *RuntimeFilterSpec) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

type IdList struct {
	List                 []int64  `protobuf:"varint,1,rep,packed,name=list,proto3" json:"list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IdList) Reset()         { *m = IdList{} }
func (m *IdList) String() string { return proto.CompactTextString(m) }
func (*IdList) ProtoMessage()    {}
func (*IdList) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{57}
}
func (m *IdList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IdList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IdList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IdList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IdList.Merge(m, src)
}
func (m *IdList) XXX_Size() int {
	return m.ProtoSize()
}
func (m *IdList) XXX_DiscardUnknown() {
	xxx_messageInfo_IdList.DiscardUnknown(m)
}

var xxx_messageInfo_IdList proto.InternalMessageInfo

func (m *IdList) GetList() []int64 {
	if m != nil {
		return m.List
	}
	return nil
}

type ColPosMap struct {
	Map                  map[string]int32 `protobuf:"bytes,1,rep,name=map,proto3" json:"map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ColPosMap) Reset()         { *m = ColPosMap{} }
func (m *ColPosMap) String() string { return proto.CompactTextString(m) }
func (*ColPosMap) ProtoMessage()    {}
func (*ColPosMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{58}
}
func (m *ColPosMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColPosMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColPosMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColPosMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColPosMap.Merge(m, src)
}
func (m *ColPosMap) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ColPosMap) XXX_DiscardUnknown() {
	xxx_messageInfo_ColPosMap.DiscardUnknown(m)
}

var xxx_messageInfo_ColPosMap proto.InternalMessageInfo

func (m *ColPosMap) GetMap() map[string]int32 {
	if m != nil {
		return m.Map
	}
	return nil
}

type DeleteCtx struct {
	CanTruncate     bool       `protobuf:"varint,1,opt,name=can_truncate,json=canTruncate,proto3" json:"can_truncate,omitempty"`
	Ref             *ObjectRef `protobuf:"bytes,2,opt,name=ref,proto3" json:"ref,omitempty"`
	RowIdIdx        int32      `protobuf:"varint,3,opt,name=row_id_idx,json=rowIdIdx,proto3" json:"row_id_idx,omitempty"`
	AddAffectedRows bool       `protobuf:"varint,4,opt,name=add_affected_rows,json=addAffectedRows,proto3" json:"add_affected_rows,omitempty"`
	IsClusterTable  bool       `protobuf:"varint,5,opt,name=is_cluster_table,json=isClusterTable,proto3" json:"is_cluster_table,omitempty"`
	// Align array index with the partition number
	PartitionTableIds    []uint64 `protobuf:"varint,6,rep,packed,name=partition_table_ids,json=partitionTableIds,proto3" json:"partition_table_ids,omitempty"`
	PartitionTableNames  []string `protobuf:"bytes,7,rep,name=partition_table_names,json=partitionTableNames,proto3" json:"partition_table_names,omitempty"`
	PartitionIdx         int32    `protobuf:"varint,8,opt,name=partition_idx,json=partitionIdx,proto3" json:"partition_idx,omitempty"`
	PrimaryKeyIdx        int32    `protobuf:"varint,9,opt,name=primary_key_idx,json=primaryKeyIdx,proto3" json:"primary_key_idx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteCtx) Reset()         { *m = DeleteCtx{} }
func (m *DeleteCtx) String() string { return proto.CompactTextString(m) }
func (*DeleteCtx) ProtoMessage()    {}
func (*DeleteCtx) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{59}
}
func (m *DeleteCtx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteCtx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteCtx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteCtx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteCtx.Merge(m, src)
}
func (m *DeleteCtx) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeleteCtx) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteCtx.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteCtx proto.InternalMessageInfo

func (m *DeleteCtx) GetCanTruncate() bool {
	if m != nil {
		return m.CanTruncate
	}
	return false
}

func (m *DeleteCtx) GetRef() *ObjectRef {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *DeleteCtx) GetRowIdIdx() int32 {
	if m != nil {
		return m.RowIdIdx
	}
	return 0
}

func (m *DeleteCtx) GetAddAffectedRows() bool {
	if m != nil {
		return m.AddAffectedRows
	}
	return false
}

func (m *DeleteCtx) GetIsClusterTable() bool {
	if m != nil {
		return m.IsClusterTable
	}
	return false
}

func (m *DeleteCtx) GetPartitionTableIds() []uint64 {
	if m != nil {
		return m.PartitionTableIds
	}
	return nil
}

func (m *DeleteCtx) GetPartitionTableNames() []string {
	if m != nil {
		return m.PartitionTableNames
	}
	return nil
}

func (m *DeleteCtx) GetPartitionIdx() int32 {
	if m != nil {
		return m.PartitionIdx
	}
	return 0
}

func (m *DeleteCtx) GetPrimaryKeyIdx() int32 {
	if m != nil {
		return m.PrimaryKeyIdx
	}
	return 0
}

type Query struct {
	StmtType Query_StatementType `protobuf:"varint,1,opt,name=stmt_type,json=stmtType,proto3,enum=plan.Query_StatementType" json:"stmt_type,omitempty"`
	// Each step is simply a root node.  Root node refers to other
	// node as children and the whole step is a DAG.
	Steps []int32 `protobuf:"varint,2,rep,packed,name=steps,proto3" json:"steps,omitempty"`
	// All the nodes.  It is OK to have dangle nodes, we only excute nodes
	// reachable from step roots.
	Nodes []*Node `protobuf:"bytes,3,rep,name=nodes,proto3" json:"nodes,omitempty"`
	// Bound Parameter for the query.
	Params []*Expr `protobuf:"bytes,4,rep,name=params,proto3" json:"params,omitempty"`
	// return head
	Headings []string `protobuf:"bytes,5,rep,name=headings,proto3" json:"headings,omitempty"`
	// load Tag
	LoadTag              bool     `protobuf:"varint,6,opt,name=loadTag,proto3" json:"loadTag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Query) Reset()         { *m = Query{} }
func (m *Query) String() string { return proto.CompactTextString(m) }
func (*Query) ProtoMessage()    {}
func (*Query) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{60}
}
func (m *Query) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Query) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Query.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Query) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Query.Merge(m, src)
}
func (m *Query) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Query) XXX_DiscardUnknown() {
	xxx_messageInfo_Query.DiscardUnknown(m)
}

var xxx_messageInfo_Query proto.InternalMessageInfo

func (m *Query) GetStmtType() Query_StatementType {
	if m != nil {
		return m.StmtType
	}
	return Query_UNKNOWN
}

func (m *Query) GetSteps() []int32 {
	if m != nil {
		return m.Steps
	}
	return nil
}

func (m *Query) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *Query) GetParams() []*Expr {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *Query) GetHeadings() []string {
	if m != nil {
		return m.Headings
	}
	return nil
}

func (m *Query) GetLoadTag() bool {
	if m != nil {
		return m.LoadTag
	}
	return false
}

type TransationControl struct {
	// TransationControl type
	TclType TransationControl_TclType `protobuf:"varint,1,opt,name=tcl_type,json=tclType,proto3,enum=plan.TransationControl_TclType" json:"tcl_type,omitempty"`
	// Types that are valid to be assigned to Action:
	//
	//	*TransationControl_Begin
	//	*TransationControl_Commit
	//	*TransationControl_Rollback
	Action               isTransationControl_Action `protobuf_oneof:"action"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *TransationControl) Reset()         { *m = TransationControl{} }
func (m *TransationControl) String() string { return proto.CompactTextString(m) }
func (*TransationControl) ProtoMessage()    {}
func (*TransationControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{61}
}
func (m *TransationControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransationControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransationControl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransationControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransationControl.Merge(m, src)
}
func (m *TransationControl) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransationControl) XXX_DiscardUnknown() {
	xxx_messageInfo_TransationControl.DiscardUnknown(m)
}

var xxx_messageInfo_TransationControl proto.InternalMessageInfo

type isTransationControl_Action interface {
	isTransationControl_Action()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type TransationControl_Begin struct {
	Begin *TransationBegin `protobuf:"bytes,2,opt,name=begin,proto3,oneof" json:"begin,omitempty"`
}
type TransationControl_Commit struct {
	Commit *TransationCommit `protobuf:"bytes,3,opt,name=commit,proto3,oneof" json:"commit,omitempty"`
}
type TransationControl_Rollback struct {
	Rollback *TransationRollback `protobuf:"bytes,4,opt,name=rollback,proto3,oneof" json:"rollback,omitempty"`
}

func (*TransationControl_Begin) isTransationControl_Action()    {}
func (*TransationControl_Commit) isTransationControl_Action()   {}
func (*TransationControl_Rollback) isTransationControl_Action() {}

func (m *TransationControl) GetAction() isTransationControl_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *TransationControl) GetTclType() TransationControl_TclType {
	if m != nil {
		return m.TclType
	}
	return TransationControl_BEGIN
}

func (m *TransationControl) GetBegin() *TransationBegin {
	if x, ok := m.GetAction().(*TransationControl_Begin); ok {
		return x.Begin
	}
	return nil
}

func (m *TransationControl) GetCommit() *TransationCommit {
	if x, ok := m.GetAction().(*TransationControl_Commit); ok {
		return x.Commit
	}
	return nil
}

func (m *TransationControl) GetRollback() *TransationRollback {
	if x, ok := m.GetAction().(*TransationControl_Rollback); ok {
		return x.Rollback
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TransationControl) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TransationControl_Begin)(nil),
		(*TransationControl_Commit)(nil),
		(*TransationControl_Rollback)(nil),
	}
}

type TransationBegin struct {
	Mode                 TransationBegin_TransationMode `protobuf:"varint,1,opt,name=mode,proto3,enum=plan.TransationBegin_TransationMode" json:"mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *TransationBegin) Reset()         { *m = TransationBegin{} }
func (m *TransationBegin) String() string { return proto.CompactTextString(m) }
func (*TransationBegin) ProtoMessage()    {}
func (*TransationBegin) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{62}
}
func (m *TransationBegin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransationBegin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransationBegin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransationBegin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransationBegin.Merge(m, src)
}
func (m *TransationBegin) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransationBegin) XXX_DiscardUnknown() {
	xxx_messageInfo_TransationBegin.DiscardUnknown(m)
}

var xxx_messageInfo_TransationBegin proto.InternalMessageInfo

func (m *TransationBegin) GetMode() TransationBegin_TransationMode {
	if m != nil {
		return m.Mode
	}
	return TransationBegin_NONE
}

type TransationCommit struct {
	CompletionType       TransationCompletionType `protobuf:"varint,1,opt,name=completion_type,json=completionType,proto3,enum=plan.TransationCompletionType" json:"completion_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *TransationCommit) Reset()         { *m = TransationCommit{} }
func (m *TransationCommit) String() string { return proto.CompactTextString(m) }
func (*TransationCommit) ProtoMessage()    {}
func (*TransationCommit) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{63}
}
func (m *TransationCommit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransationCommit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransationCommit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransationCommit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransationCommit.Merge(m, src)
}
func (m *TransationCommit) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransationCommit) XXX_DiscardUnknown() {
	xxx_messageInfo_TransationCommit.DiscardUnknown(m)
}

var xxx_messageInfo_TransationCommit proto.InternalMessageInfo

func (m *TransationCommit) GetCompletionType() TransationCompletionType {
	if m != nil {
		return m.CompletionType
	}
	return TransationCompletionType_CHAIN
}

type TransationRollback struct {
	CompletionType       TransationCompletionType `protobuf:"varint,1,opt,name=completion_type,json=completionType,proto3,enum=plan.TransationCompletionType" json:"completion_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *TransationRollback) Reset()         { *m = TransationRollback{} }
func (m *TransationRollback) String() string { return proto.CompactTextString(m) }
func (*TransationRollback) ProtoMessage()    {}
func (*TransationRollback) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{64}
}
func (m *TransationRollback) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransationRollback) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransationRollback.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransationRollback) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransationRollback.Merge(m, src)
}
func (m *TransationRollback) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TransationRollback) XXX_DiscardUnknown() {
	xxx_messageInfo_TransationRollback.DiscardUnknown(m)
}

var xxx_messageInfo_TransationRollback proto.InternalMessageInfo

func (m *TransationRollback) GetCompletionType() TransationCompletionType {
	if m != nil {
		return m.CompletionType
	}
	return TransationCompletionType_CHAIN
}

type Plan struct {
	// Types that are valid to be assigned to Plan:
	//
	//	*Plan_Query
	//	*Plan_Tcl
	//	*Plan_Ddl
	//	*Plan_Dcl
	Plan                 isPlan_Plan `protobuf_oneof:"plan"`
	TryRunTimes          int32       `protobuf:"varint,5,opt,name=try_run_times,json=tryRunTimes,proto3" json:"try_run_times,omitempty"`
	IsPrepare            bool        `protobuf:"varint,6,opt,name=is_prepare,json=isPrepare,proto3" json:"is_prepare,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Plan) Reset()         { *m = Plan{} }
func (m *Plan) String() string { return proto.CompactTextString(m) }
func (*Plan) ProtoMessage()    {}
func (*Plan) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{65}
}
func (m *Plan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Plan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Plan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Plan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Plan.Merge(m, src)
}
func (m *Plan) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Plan) XXX_DiscardUnknown() {
	xxx_messageInfo_Plan.DiscardUnknown(m)
}

var xxx_messageInfo_Plan proto.InternalMessageInfo

type isPlan_Plan interface {
	isPlan_Plan()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type Plan_Query struct {
	Query *Query `protobuf:"bytes,1,opt,name=query,proto3,oneof" json:"query,omitempty"`
}
type Plan_Tcl struct {
	Tcl *TransationControl `protobuf:"bytes,2,opt,name=tcl,proto3,oneof" json:"tcl,omitempty"`
}
type Plan_Ddl struct {
	Ddl *DataDefinition `protobuf:"bytes,3,opt,name=ddl,proto3,oneof" json:"ddl,omitempty"`
}
type Plan_Dcl struct {
	Dcl *DataControl `protobuf:"bytes,4,opt,name=dcl,proto3,oneof" json:"dcl,omitempty"`
}

func (*Plan_Query) isPlan_Plan() {}
func (*Plan_Tcl) isPlan_Plan()   {}
func (*Plan_Ddl) isPlan_Plan()   {}
func (*Plan_Dcl) isPlan_Plan()   {}

func (m *Plan) GetPlan() isPlan_Plan {
	if m != nil {
		return m.Plan
	}
	return nil
}

func (m *Plan) GetQuery() *Query {
	if x, ok := m.GetPlan().(*Plan_Query); ok {
		return x.Query
	}
	return nil
}

func (m *Plan) GetTcl() *TransationControl {
	if x, ok := m.GetPlan().(*Plan_Tcl); ok {
		return x.Tcl
	}
	return nil
}

func (m *Plan) GetDdl() *DataDefinition {
	if x, ok := m.GetPlan().(*Plan_Ddl); ok {
		return x.Ddl
	}
	return nil
}

func (m *Plan) GetDcl() *DataControl {
	if x, ok := m.GetPlan().(*Plan_Dcl); ok {
		return x.Dcl
	}
	return nil
}

func (m *Plan) GetTryRunTimes() int32 {
	if m != nil {
		return m.TryRunTimes
	}
	return 0
}

func (m *Plan) GetIsPrepare() bool {
	if m != nil {
		return m.IsPrepare
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Plan) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Plan_Query)(nil),
		(*Plan_Tcl)(nil),
		(*Plan_Ddl)(nil),
		(*Plan_Dcl)(nil),
	}
}

type Column struct {
	Column               []*Expr  `protobuf:"bytes,1,rep,name=column,proto3" json:"column,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Column) Reset()         { *m = Column{} }
func (m *Column) String() string { return proto.CompactTextString(m) }
func (*Column) ProtoMessage()    {}
func (*Column) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{66}
}
func (m *Column) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Column) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Column.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Column) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Column.Merge(m, src)
}
func (m *Column) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Column) XXX_DiscardUnknown() {
	xxx_messageInfo_Column.DiscardUnknown(m)
}

var xxx_messageInfo_Column proto.InternalMessageInfo

func (m *Column) GetColumn() []*Expr {
	if m != nil {
		return m.Column
	}
	return nil
}

type DataControl struct {
	// DataDefinition type
	DclType DataControl_DclType `protobuf:"varint,1,opt,name=dcl_type,json=dclType,proto3,enum=plan.DataControl_DclType" json:"dcl_type,omitempty"`
	// Types that are valid to be assigned to Control:
	//
	//	*DataControl_SetVariables
	//	*DataControl_Prepare
	//	*DataControl_Execute
	//	*DataControl_Deallocate
	Control              isDataControl_Control `protobuf_oneof:"control"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *DataControl) Reset()         { *m = DataControl{} }
func (m *DataControl) String() string { return proto.CompactTextString(m) }
func (*DataControl) ProtoMessage()    {}
func (*DataControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{67}
}
func (m *DataControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataControl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataControl.Merge(m, src)
}
func (m *DataControl) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DataControl) XXX_DiscardUnknown() {
	xxx_messageInfo_DataControl.DiscardUnknown(m)
}

var xxx_messageInfo_DataControl proto.InternalMessageInfo

type isDataControl_Control interface {
	isDataControl_Control()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type DataControl_SetVariables struct {
	SetVariables *SetVariables `protobuf:"bytes,2,opt,name=set_variables,json=setVariables,proto3,oneof" json:"set_variables,omitempty"`
}
type DataControl_Prepare struct {
	Prepare *Prepare `protobuf:"bytes,3,opt,name=prepare,proto3,oneof" json:"prepare,omitempty"`
}
type DataControl_Execute struct {
	Execute *Execute `protobuf:"bytes,4,opt,name=execute,proto3,oneof" json:"execute,omitempty"`
}
type DataControl_Deallocate struct {
	Deallocate *Deallocate `protobuf:"bytes,5,opt,name=deallocate,proto3,oneof" json:"deallocate,omitempty"`
}

func (*DataControl_SetVariables) isDataControl_Control() {}
func (*DataControl_Prepare) isDataControl_Control()      {}
func (*DataControl_Execute) isDataControl_Control()      {}
func (*DataControl_Deallocate) isDataControl_Control()   {}

func (m *DataControl) GetControl() isDataControl_Control {
	if m != nil {
		return m.Control
	}
	return nil
}

func (m *DataControl) GetDclType() DataControl_DclType {
	if m != nil {
		return m.DclType
	}
	return DataControl_SET_VARIABLES
}

func (m *DataControl) GetSetVariables() *SetVariables {
	if x, ok := m.GetControl().(*DataControl_SetVariables); ok {
		return x.SetVariables
	}
	return nil
}

func (m *DataControl) GetPrepare() *Prepare {
	if x, ok := m.GetControl().(*DataControl_Prepare); ok {
		return x.Prepare
	}
	return nil
}

func (m *DataControl) GetExecute() *Execute {
	if x, ok := m.GetControl().(*DataControl_Execute); ok {
		return x.Execute
	}
	return nil
}

func (m *DataControl) GetDeallocate() *Deallocate {
	if x, ok := m.GetControl().(*DataControl_Deallocate); ok {
		return x.Deallocate
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DataControl) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DataControl_SetVariables)(nil),
		(*DataControl_Prepare)(nil),
		(*DataControl_Execute)(nil),
		(*DataControl_Deallocate)(nil),
	}
}

type DataDefinition struct {
	// DataDefinition type
	DdlType DataDefinition_DdlType `protobuf:"varint,1,opt,name=ddl_type,json=ddlType,proto3,enum=plan.DataDefinition_DdlType" json:"ddl_type,omitempty"`
	// other show statement we will rewrite to a select statement
	// then we will get a Query
	// eg: 'show databases' will rewrite to 'select md.datname as `Database` from mo_database md'
	Query *Query `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// Types that are valid to be assigned to Definition:
	//
	//	*DataDefinition_CreateDatabase
	//	*DataDefinition_AlterDatabase
	//	*DataDefinition_DropDatabase
	//	*DataDefinition_CreateTable
	//	*DataDefinition_AlterTable
	//	*DataDefinition_DropTable
	//	*DataDefinition_CreateIndex
	//	*DataDefinition_AlterIndex
	//	*DataDefinition_DropIndex
	//	*DataDefinition_TruncateTable
	//	*DataDefinition_ShowVariables
	//	*DataDefinition_AlterView
	//	*DataDefinition_LockTables
	//	*DataDefinition_UnlockTables
	//	*DataDefinition_CreateSequence
	//	*DataDefinition_DropSequence
	//	*DataDefinition_AlterSequence
	Definition           isDataDefinition_Definition `protobuf_oneof:"definition"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *DataDefinition) Reset()         { *m = DataDefinition{} }
func (m *DataDefinition) String() string { return proto.CompactTextString(m) }
func (*DataDefinition) ProtoMessage()    {}
func (*DataDefinition) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{68}
}
func (m *DataDefinition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataDefinition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataDefinition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataDefinition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataDefinition.Merge(m, src)
}
func (m *DataDefinition) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DataDefinition) XXX_DiscardUnknown() {
	xxx_messageInfo_DataDefinition.DiscardUnknown(m)
}

var xxx_messageInfo_DataDefinition proto.InternalMessageInfo

type isDataDefinition_Definition interface {
	isDataDefinition_Definition()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type DataDefinition_CreateDatabase struct {
	CreateDatabase *CreateDatabase `protobuf:"bytes,3,opt,name=create_database,json=createDatabase,proto3,oneof" json:"create_database,omitempty"`
}
type DataDefinition_AlterDatabase struct {
	AlterDatabase *AlterDatabase `protobuf:"bytes,4,opt,name=alter_database,json=alterDatabase,proto3,oneof" json:"alter_database,omitempty"`
}
type DataDefinition_DropDatabase struct {
	DropDatabase *DropDatabase `protobuf:"bytes,5,opt,name=drop_database,json=dropDatabase,proto3,oneof" json:"drop_database,omitempty"`
}
type DataDefinition_CreateTable struct {
	CreateTable *CreateTable `protobuf:"bytes,6,opt,name=create_table,json=createTable,proto3,oneof" json:"create_table,omitempty"`
}
type DataDefinition_AlterTable struct {
	AlterTable *AlterTable `protobuf:"bytes,7,opt,name=alter_table,json=alterTable,proto3,oneof" json:"alter_table,omitempty"`
}
type DataDefinition_DropTable struct {
	DropTable *DropTable `protobuf:"bytes,8,opt,name=drop_table,json=dropTable,proto3,oneof" json:"drop_table,omitempty"`
}
type DataDefinition_CreateIndex struct {
	CreateIndex *CreateIndex `protobuf:"bytes,9,opt,name=create_index,json=createIndex,proto3,oneof" json:"create_index,omitempty"`
}
type DataDefinition_AlterIndex struct {
	AlterIndex *AlterIndex `protobuf:"bytes,10,opt,name=alter_index,json=alterIndex,proto3,oneof" json:"alter_index,omitempty"`
}
type DataDefinition_DropIndex struct {
	DropIndex *DropIndex `protobuf:"bytes,11,opt,name=drop_index,json=dropIndex,proto3,oneof" json:"drop_index,omitempty"`
}
type DataDefinition_TruncateTable struct {
	TruncateTable *TruncateTable `protobuf:"bytes,12,opt,name=truncate_table,json=truncateTable,proto3,oneof" json:"truncate_table,omitempty"`
}
type DataDefinition_ShowVariables struct {
	ShowVariables *ShowVariables `protobuf:"bytes,13,opt,name=show_variables,json=showVariables,proto3,oneof" json:"show_variables,omitempty"`
}
type DataDefinition_AlterView struct {
	AlterView *AlterView `protobuf:"bytes,14,opt,name=alter_view,json=alterView,proto3,oneof" json:"alter_view,omitempty"`
}
type DataDefinition_LockTables struct {
	LockTables *LockTables `protobuf:"bytes,15,opt,name=lock_tables,json=lockTables,proto3,oneof" json:"lock_tables,omitempty"`
}
type DataDefinition_UnlockTables struct {
	UnlockTables *UnLockTables `protobuf:"bytes,16,opt,name=unlock_tables,json=unlockTables,proto3,oneof" json:"unlock_tables,omitempty"`
}
type DataDefinition_CreateSequence struct {
	CreateSequence *CreateSequence `protobuf:"bytes,17,opt,name=create_sequence,json=createSequence,proto3,oneof" json:"create_sequence,omitempty"`
}
type DataDefinition_DropSequence struct {
	DropSequence *DropSequence `protobuf:"bytes,18,opt,name=drop_sequence,json=dropSequence,proto3,oneof" json:"drop_sequence,omitempty"`
}
type DataDefinition_AlterSequence struct {
	AlterSequence *AlterSequence `protobuf:"bytes,19,opt,name=alter_sequence,json=alterSequence,proto3,oneof" json:"alter_sequence,omitempty"`
}

func (*DataDefinition_CreateDatabase) isDataDefinition_Definition() {}
func (*DataDefinition_AlterDatabase) isDataDefinition_Definition()  {}
func (*DataDefinition_DropDatabase) isDataDefinition_Definition()   {}
func (*DataDefinition_CreateTable) isDataDefinition_Definition()    {}
func (*DataDefinition_AlterTable) isDataDefinition_Definition()     {}
func (*DataDefinition_DropTable) isDataDefinition_Definition()      {}
func (*DataDefinition_CreateIndex) isDataDefinition_Definition()    {}
func (*DataDefinition_AlterIndex) isDataDefinition_Definition()     {}
func (*DataDefinition_DropIndex) isDataDefinition_Definition()      {}
func (*DataDefinition_TruncateTable) isDataDefinition_Definition()  {}
func (*DataDefinition_ShowVariables) isDataDefinition_Definition()  {}
func (*DataDefinition_AlterView) isDataDefinition_Definition()      {}
func (*DataDefinition_LockTables) isDataDefinition_Definition()     {}
func (*DataDefinition_UnlockTables) isDataDefinition_Definition()   {}
func (*DataDefinition_CreateSequence) isDataDefinition_Definition() {}
func (*DataDefinition_DropSequence) isDataDefinition_Definition()   {}
func (*DataDefinition_AlterSequence) isDataDefinition_Definition()  {}

func (m *DataDefinition) GetDefinition() isDataDefinition_Definition {
	if m != nil {
		return m.Definition
	}
	return nil
}

func (m *DataDefinition) GetDdlType() DataDefinition_DdlType {
	if m != nil {
		return m.DdlType
	}
	return DataDefinition_CREATE_DATABASE
}

func (m *DataDefinition) GetQuery() *Query {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *DataDefinition) GetCreateDatabase() *CreateDatabase {
	if x, ok := m.GetDefinition().(*DataDefinition_CreateDatabase); ok {
		return x.CreateDatabase
	}
	return nil
}

func (m *DataDefinition) GetAlterDatabase() *AlterDatabase {
	if x, ok := m.GetDefinition().(*DataDefinition_AlterDatabase); ok {
		return x.AlterDatabase
	}
	return nil
}

func (m *DataDefinition) GetDropDatabase() *DropDatabase {
	if x, ok := m.GetDefinition().(*DataDefinition_DropDatabase); ok {
		return x.DropDatabase
	}
	return nil
}

func (m *DataDefinition) GetCreateTable() *CreateTable {
	if x, ok := m.GetDefinition().(*DataDefinition_CreateTable); ok {
		return x.CreateTable
	}
	return nil
}

func (m *DataDefinition) GetAlterTable() *AlterTable {
	if x, ok := m.GetDefinition().(*DataDefinition_AlterTable); ok {
		return x.AlterTable
	}
	return nil
}

func (m *DataDefinition) GetDropTable() *DropTable {
	if x, ok := m.GetDefinition().(*DataDefinition_DropTable); ok {
		return x.DropTable
	}
	return nil
}

func (m *DataDefinition) GetCreateIndex() *CreateIndex {
	if x, ok := m.GetDefinition().(*DataDefinition_CreateIndex); ok {
		return x.CreateIndex
	}
	return nil
}

func (m *DataDefinition) GetAlterIndex() *AlterIndex {
	if x, ok := m.GetDefinition().(*DataDefinition_AlterIndex); ok {
		return x.AlterIndex
	}
	return nil
}

func (m *DataDefinition) GetDropIndex() *DropIndex {
	if x, ok := m.GetDefinition().(*DataDefinition_DropIndex); ok {
		return x.DropIndex
	}
	return nil
}

func (m *DataDefinition) GetTruncateTable() *TruncateTable {
	if x, ok := m.GetDefinition().(*DataDefinition_TruncateTable); ok {
		return x.TruncateTable
	}
	return nil
}

func (m *DataDefinition) GetShowVariables() *ShowVariables {
	if x, ok := m.GetDefinition().(*DataDefinition_ShowVariables); ok {
		return x.ShowVariables
	}
	return nil
}

func (m *DataDefinition) GetAlterView() *AlterView {
	if x, ok := m.GetDefinition().(*DataDefinition_AlterView); ok {
		return x.AlterView
	}
	return nil
}

func (m *DataDefinition) GetLockTables() *LockTables {
	if x, ok := m.GetDefinition().(*DataDefinition_LockTables); ok {
		return x.LockTables
	}
	return nil
}

func (m *DataDefinition) GetUnlockTables() *UnLockTables {
	if x, ok := m.GetDefinition().(*DataDefinition_UnlockTables); ok {
		return x.UnlockTables
	}
	return nil
}

func (m *DataDefinition) GetCreateSequence() *CreateSequence {
	if x, ok := m.GetDefinition().(*DataDefinition_CreateSequence); ok {
		return x.CreateSequence
	}
	return nil
}

func (m *DataDefinition) GetDropSequence() *DropSequence {
	if x, ok := m.GetDefinition().(*DataDefinition_DropSequence); ok {
		return x.DropSequence
	}
	return nil
}

func (m *DataDefinition) GetAlterSequence() *AlterSequence {
	if x, ok := m.GetDefinition().(*DataDefinition_AlterSequence); ok {
		return x.AlterSequence
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DataDefinition) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DataDefinition_CreateDatabase)(nil),
		(*DataDefinition_AlterDatabase)(nil),
		(*DataDefinition_DropDatabase)(nil),
		(*DataDefinition_CreateTable)(nil),
		(*DataDefinition_AlterTable)(nil),
		(*DataDefinition_DropTable)(nil),
		(*DataDefinition_CreateIndex)(nil),
		(*DataDefinition_AlterIndex)(nil),
		(*DataDefinition_DropIndex)(nil),
		(*DataDefinition_TruncateTable)(nil),
		(*DataDefinition_ShowVariables)(nil),
		(*DataDefinition_AlterView)(nil),
		(*DataDefinition_LockTables)(nil),
		(*DataDefinition_UnlockTables)(nil),
		(*DataDefinition_CreateSequence)(nil),
		(*DataDefinition_DropSequence)(nil),
		(*DataDefinition_AlterSequence)(nil),
	}
}

type SubscriptionOption struct {
	From                 string   `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	Publication          string   `protobuf:"bytes,2,opt,name=publication,proto3" json:"publication,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscriptionOption) Reset()         { *m = SubscriptionOption{} }
func (m *SubscriptionOption) String() string { return proto.CompactTextString(m) }
func (*SubscriptionOption) ProtoMessage()    {}
func (*SubscriptionOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{69}
}
func (m *SubscriptionOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscriptionOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscriptionOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscriptionOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriptionOption.Merge(m, src)
}
func (m *SubscriptionOption) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SubscriptionOption) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriptionOption.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriptionOption proto.InternalMessageInfo

func (m *SubscriptionOption) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *SubscriptionOption) GetPublication() string {
	if m != nil {
		return m.Publication
	}
	return ""
}

type CreateDatabase struct {
	IfNotExists          bool                `protobuf:"varint,1,opt,name=if_not_exists,json=ifNotExists,proto3" json:"if_not_exists,omitempty"`
	Database             string              `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	SubscriptionOption   *SubscriptionOption `protobuf:"bytes,3,opt,name=subscription_option,json=subscriptionOption,proto3" json:"subscription_option,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *CreateDatabase) Reset()         { *m = CreateDatabase{} }
func (m *CreateDatabase) String() string { return proto.CompactTextString(m) }
func (*CreateDatabase) ProtoMessage()    {}
func (*CreateDatabase) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{70}
}
func (m *CreateDatabase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateDatabase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateDatabase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateDatabase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateDatabase.Merge(m, src)
}
func (m *CreateDatabase) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CreateDatabase) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateDatabase.DiscardUnknown(m)
}

var xxx_messageInfo_CreateDatabase proto.InternalMessageInfo

func (m *CreateDatabase) GetIfNotExists() bool {
	if m != nil {
		return m.IfNotExists
	}
	return false
}

func (m *CreateDatabase) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *CreateDatabase) GetSubscriptionOption() *SubscriptionOption {
	if m != nil {
		return m.SubscriptionOption
	}
	return nil
}

type AlterDatabase struct {
	IfExists             bool     `protobuf:"varint,1,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	Database             string   `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterDatabase) Reset()         { *m = AlterDatabase{} }
func (m *AlterDatabase) String() string { return proto.CompactTextString(m) }
func (*AlterDatabase) ProtoMessage()    {}
func (*AlterDatabase) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{71}
}
func (m *AlterDatabase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterDatabase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterDatabase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterDatabase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterDatabase.Merge(m, src)
}
func (m *AlterDatabase) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterDatabase) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterDatabase.DiscardUnknown(m)
}

var xxx_messageInfo_AlterDatabase proto.InternalMessageInfo

func (m *AlterDatabase) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

func (m *AlterDatabase) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

type DropDatabase struct {
	IfExists             bool     `protobuf:"varint,1,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	Database             string   `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	DatabaseId           uint64   `protobuf:"varint,3,opt,name=database_id,json=databaseId,proto3" json:"database_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DropDatabase) Reset()         { *m = DropDatabase{} }
func (m *DropDatabase) String() string { return proto.CompactTextString(m) }
func (*DropDatabase) ProtoMessage()    {}
func (*DropDatabase) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{72}
}
func (m *DropDatabase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropDatabase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropDatabase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropDatabase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropDatabase.Merge(m, src)
}
func (m *DropDatabase) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DropDatabase) XXX_DiscardUnknown() {
	xxx_messageInfo_DropDatabase.DiscardUnknown(m)
}

var xxx_messageInfo_DropDatabase proto.InternalMessageInfo

func (m *DropDatabase) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

func (m *DropDatabase) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *DropDatabase) GetDatabaseId() uint64 {
	if m != nil {
		return m.DatabaseId
	}
	return 0
}

type FkColName struct {
	Cols                 []string `protobuf:"bytes,1,rep,name=cols,proto3" json:"cols,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FkColName) Reset()         { *m = FkColName{} }
func (m *FkColName) String() string { return proto.CompactTextString(m) }
func (*FkColName) ProtoMessage()    {}
func (*FkColName) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{73}
}
func (m *FkColName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FkColName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FkColName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FkColName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FkColName.Merge(m, src)
}
func (m *FkColName) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FkColName) XXX_DiscardUnknown() {
	xxx_messageInfo_FkColName.DiscardUnknown(m)
}

var xxx_messageInfo_FkColName proto.InternalMessageInfo

func (m *FkColName) GetCols() []string {
	if m != nil {
		return m.Cols
	}
	return nil
}

type CreateTable struct {
	IfNotExists bool        `protobuf:"varint,1,opt,name=if_not_exists,json=ifNotExists,proto3" json:"if_not_exists,omitempty"`
	Temporary   bool        `protobuf:"varint,2,opt,name=temporary,proto3" json:"temporary,omitempty"`
	Database    string      `protobuf:"bytes,3,opt,name=database,proto3" json:"database,omitempty"`
	TableDef    *TableDef   `protobuf:"bytes,4,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	IndexTables []*TableDef `protobuf:"bytes,5,rep,name=index_tables,json=indexTables,proto3" json:"index_tables,omitempty"`
	// we need the db/table name of foreign key when create table. but we don't need it in ForeignKeyDef
	FkDbs    []string `protobuf:"bytes,6,rep,name=fk_dbs,json=fkDbs,proto3" json:"fk_dbs,omitempty"`
	FkTables []string `protobuf:"bytes,7,rep,name=fk_tables,json=fkTables,proto3" json:"fk_tables,omitempty"`
	// we need column name when create table, but not in ForeignKeyDef
	FkCols               []*FkColName `protobuf:"bytes,8,rep,name=fk_cols,json=fkCols,proto3" json:"fk_cols,omitempty"`
	PartitionTables      []*TableDef  `protobuf:"bytes,9,rep,name=partition_tables,json=partitionTables,proto3" json:"partition_tables,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *CreateTable) Reset()         { *m = CreateTable{} }
func (m *CreateTable) String() string { return proto.CompactTextString(m) }
func (*CreateTable) ProtoMessage()    {}
func (*CreateTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{74}
}
func (m *CreateTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateTable.Merge(m, src)
}
func (m *CreateTable) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CreateTable) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateTable.DiscardUnknown(m)
}

var xxx_messageInfo_CreateTable proto.InternalMessageInfo

func (m *CreateTable) GetIfNotExists() bool {
	if m != nil {
		return m.IfNotExists
	}
	return false
}

func (m *CreateTable) GetTemporary() bool {
	if m != nil {
		return m.Temporary
	}
	return false
}

func (m *CreateTable) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *CreateTable) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *CreateTable) GetIndexTables() []*TableDef {
	if m != nil {
		return m.IndexTables
	}
	return nil
}

func (m *CreateTable) GetFkDbs() []string {
	if m != nil {
		return m.FkDbs
	}
	return nil
}

func (m *CreateTable) GetFkTables() []string {
	if m != nil {
		return m.FkTables
	}
	return nil
}

func (m *CreateTable) GetFkCols() []*FkColName {
	if m != nil {
		return m.FkCols
	}
	return nil
}

func (m *CreateTable) GetPartitionTables() []*TableDef {
	if m != nil {
		return m.PartitionTables
	}
	return nil
}

type AlterTableDrop struct {
	Typ                  AlterTableDrop_Typ `protobuf:"varint,1,opt,name=typ,proto3,enum=plan.AlterTableDrop_Typ" json:"typ,omitempty"`
	Name                 string             `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	IndexTableName       string             `protobuf:"bytes,3,opt,name=index_table_name,json=indexTableName,proto3" json:"index_table_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *AlterTableDrop) Reset()         { *m = AlterTableDrop{} }
func (m *AlterTableDrop) String() string { return proto.CompactTextString(m) }
func (*AlterTableDrop) ProtoMessage()    {}
func (*AlterTableDrop) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{75}
}
func (m *AlterTableDrop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTableDrop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTableDrop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTableDrop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTableDrop.Merge(m, src)
}
func (m *AlterTableDrop) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTableDrop) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTableDrop.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTableDrop proto.InternalMessageInfo

func (m *AlterTableDrop) GetTyp() AlterTableDrop_Typ {
	if m != nil {
		return m.Typ
	}
	return AlterTableDrop_COLUMN
}

func (m *AlterTableDrop) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AlterTableDrop) GetIndexTableName() string {
	if m != nil {
		return m.IndexTableName
	}
	return ""
}

type AlterTableAddFk struct {
	DbName               string         `protobuf:"bytes,1,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	TableName            string         `protobuf:"bytes,2,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	Cols                 []string       `protobuf:"bytes,3,rep,name=cols,proto3" json:"cols,omitempty"`
	Fkey                 *ForeignKeyDef `protobuf:"bytes,4,opt,name=fkey,proto3" json:"fkey,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *AlterTableAddFk) Reset()         { *m = AlterTableAddFk{} }
func (m *AlterTableAddFk) String() string { return proto.CompactTextString(m) }
func (*AlterTableAddFk) ProtoMessage()    {}
func (*AlterTableAddFk) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{76}
}
func (m *AlterTableAddFk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTableAddFk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTableAddFk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTableAddFk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTableAddFk.Merge(m, src)
}
func (m *AlterTableAddFk) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTableAddFk) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTableAddFk.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTableAddFk proto.InternalMessageInfo

func (m *AlterTableAddFk) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *AlterTableAddFk) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *AlterTableAddFk) GetCols() []string {
	if m != nil {
		return m.Cols
	}
	return nil
}

func (m *AlterTableAddFk) GetFkey() *ForeignKeyDef {
	if m != nil {
		return m.Fkey
	}
	return nil
}

type AlterTableAddIndex struct {
	DbName                string       `protobuf:"bytes,1,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	TableName             string       `protobuf:"bytes,2,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	OriginTablePrimaryKey string       `protobuf:"bytes,3,opt,name=origin_table_primary_key,json=originTablePrimaryKey,proto3" json:"origin_table_primary_key,omitempty"`
	IndexInfo             *CreateTable `protobuf:"bytes,4,opt,name=indexInfo,proto3" json:"indexInfo,omitempty"`
	IndexTableExist       bool         `protobuf:"varint,5,opt,name=index_table_exist,json=indexTableExist,proto3" json:"index_table_exist,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}     `json:"-"`
	XXX_unrecognized      []byte       `json:"-"`
	XXX_sizecache         int32        `json:"-"`
}

func (m *AlterTableAddIndex) Reset()         { *m = AlterTableAddIndex{} }
func (m *AlterTableAddIndex) String() string { return proto.CompactTextString(m) }
func (*AlterTableAddIndex) ProtoMessage()    {}
func (*AlterTableAddIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{77}
}
func (m *AlterTableAddIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTableAddIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTableAddIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTableAddIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTableAddIndex.Merge(m, src)
}
func (m *AlterTableAddIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTableAddIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTableAddIndex.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTableAddIndex proto.InternalMessageInfo

func (m *AlterTableAddIndex) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *AlterTableAddIndex) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *AlterTableAddIndex) GetOriginTablePrimaryKey() string {
	if m != nil {
		return m.OriginTablePrimaryKey
	}
	return ""
}

func (m *AlterTableAddIndex) GetIndexInfo() *CreateTable {
	if m != nil {
		return m.IndexInfo
	}
	return nil
}

func (m *AlterTableAddIndex) GetIndexTableExist() bool {
	if m != nil {
		return m.IndexTableExist
	}
	return false
}

type AlterTableDropIndex struct {
	DbName               string   `protobuf:"bytes,1,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	TableName            string   `protobuf:"bytes,2,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	IndexName            string   `protobuf:"bytes,3,opt,name=index_name,json=indexName,proto3" json:"index_name,omitempty"`
	IndexTableName       string   `protobuf:"bytes,4,opt,name=index_table_name,json=indexTableName,proto3" json:"index_table_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterTableDropIndex) Reset()         { *m = AlterTableDropIndex{} }
func (m *AlterTableDropIndex) String() string { return proto.CompactTextString(m) }
func (*AlterTableDropIndex) ProtoMessage()    {}
func (*AlterTableDropIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{78}
}
func (m *AlterTableDropIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTableDropIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTableDropIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTableDropIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTableDropIndex.Merge(m, src)
}
func (m *AlterTableDropIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTableDropIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTableDropIndex.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTableDropIndex proto.InternalMessageInfo

func (m *AlterTableDropIndex) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *AlterTableDropIndex) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *AlterTableDropIndex) GetIndexName() string {
	if m != nil {
		return m.IndexName
	}
	return ""
}

func (m *AlterTableDropIndex) GetIndexTableName() string {
	if m != nil {
		return m.IndexTableName
	}
	return ""
}

type AlterTableAlterIndex struct {
	DbName               string   `protobuf:"bytes,1,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	TableName            string   `protobuf:"bytes,2,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	IndexName            string   `protobuf:"bytes,3,opt,name=index_name,json=indexName,proto3" json:"index_name,omitempty"`
	Visible              bool     `protobuf:"varint,4,opt,name=visible,proto3" json:"visible,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterTableAlterIndex) Reset()         { *m = AlterTableAlterIndex{} }
func (m *AlterTableAlterIndex) String() string { return proto.CompactTextString(m) }
func (*AlterTableAlterIndex) ProtoMessage()    {}
func (*AlterTableAlterIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{79}
}
func (m *AlterTableAlterIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTableAlterIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTableAlterIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTableAlterIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTableAlterIndex.Merge(m, src)
}
func (m *AlterTableAlterIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTableAlterIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTableAlterIndex.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTableAlterIndex proto.InternalMessageInfo

func (m *AlterTableAlterIndex) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *AlterTableAlterIndex) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *AlterTableAlterIndex) GetIndexName() string {
	if m != nil {
		return m.IndexName
	}
	return ""
}

func (m *AlterTableAlterIndex) GetVisible() bool {
	if m != nil {
		return m.Visible
	}
	return false
}

type AlterTableComment struct {
	NewComment           string   `protobuf:"bytes,1,opt,name=new_comment,json=newComment,proto3" json:"new_comment,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterTableComment) Reset()         { *m = AlterTableComment{} }
func (m *AlterTableComment) String() string { return proto.CompactTextString(m) }
func (*AlterTableComment) ProtoMessage()    {}
func (*AlterTableComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{80}
}
func (m *AlterTableComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTableComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTableComment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTableComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTableComment.Merge(m, src)
}
func (m *AlterTableComment) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTableComment) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTableComment.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTableComment proto.InternalMessageInfo

func (m *AlterTableComment) GetNewComment() string {
	if m != nil {
		return m.NewComment
	}
	return ""
}

type AlterTableName struct {
	OldName              string   `protobuf:"bytes,1,opt,name=old_name,json=oldName,proto3" json:"old_name,omitempty"`
	NewName              string   `protobuf:"bytes,2,opt,name=new_name,json=newName,proto3" json:"new_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterTableName) Reset()         { *m = AlterTableName{} }
func (m *AlterTableName) String() string { return proto.CompactTextString(m) }
func (*AlterTableName) ProtoMessage()    {}
func (*AlterTableName) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{81}
}
func (m *AlterTableName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTableName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTableName.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTableName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTableName.Merge(m, src)
}
func (m *AlterTableName) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTableName) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTableName.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTableName proto.InternalMessageInfo

func (m *AlterTableName) GetOldName() string {
	if m != nil {
		return m.OldName
	}
	return ""
}

func (m *AlterTableName) GetNewName() string {
	if m != nil {
		return m.NewName
	}
	return ""
}

type AlterAddCol struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	PreName              string   `protobuf:"bytes,2,opt,name=pre_name,json=preName,proto3" json:"pre_name,omitempty"`
	Type                 *Type    `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	Pos                  int32    `protobuf:"varint,4,opt,name=pos,proto3" json:"pos,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterAddCol) Reset()         { *m = AlterAddCol{} }
func (m *AlterAddCol) String() string { return proto.CompactTextString(m) }
func (*AlterAddCol) ProtoMessage()    {}
func (*AlterAddCol) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{82}
}
func (m *AlterAddCol) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterAddCol) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterAddCol.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterAddCol) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterAddCol.Merge(m, src)
}
func (m *AlterAddCol) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterAddCol) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterAddCol.DiscardUnknown(m)
}

var xxx_messageInfo_AlterAddCol proto.InternalMessageInfo

func (m *AlterAddCol) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AlterAddCol) GetPreName() string {
	if m != nil {
		return m.PreName
	}
	return ""
}

func (m *AlterAddCol) GetType() *Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *AlterAddCol) GetPos() int32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

type AlterDropCol struct {
	Idx                  uint32   `protobuf:"varint,1,opt,name=idx,proto3" json:"idx,omitempty"`
	Seq                  uint32   `protobuf:"varint,2,opt,name=seq,proto3" json:"seq,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterDropCol) Reset()         { *m = AlterDropCol{} }
func (m *AlterDropCol) String() string { return proto.CompactTextString(m) }
func (*AlterDropCol) ProtoMessage()    {}
func (*AlterDropCol) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{83}
}
func (m *AlterDropCol) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterDropCol) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterDropCol.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterDropCol) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterDropCol.Merge(m, src)
}
func (m *AlterDropCol) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterDropCol) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterDropCol.DiscardUnknown(m)
}

var xxx_messageInfo_AlterDropCol proto.InternalMessageInfo

func (m *AlterDropCol) GetIdx() uint32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *AlterDropCol) GetSeq() uint32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

type AlterTable struct {
	Database             string                   `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	TableDef             *TableDef                `protobuf:"bytes,2,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	CopyTableDef         *TableDef                `protobuf:"bytes,3,opt,name=copy_table_def,json=copyTableDef,proto3" json:"copy_table_def,omitempty"`
	IsClusterTable       bool                     `protobuf:"varint,4,opt,name=is_cluster_table,json=isClusterTable,proto3" json:"is_cluster_table,omitempty"`
	Actions              []*AlterTable_Action     `protobuf:"bytes,5,rep,name=actions,proto3" json:"actions,omitempty"`
	AlgorithmType        AlterTable_AlgorithmType `protobuf:"varint,6,opt,name=algorithm_type,json=algorithmType,proto3,enum=plan.AlterTable_AlgorithmType" json:"algorithm_type,omitempty"`
	CreateTableSql       string                   `protobuf:"bytes,7,opt,name=create_table_sql,json=createTableSql,proto3" json:"create_table_sql,omitempty"`
	InsertDataSql        string                   `protobuf:"bytes,8,opt,name=insert_data_sql,json=insertDataSql,proto3" json:"insert_data_sql,omitempty"`
	ChangeTblColIdMap    map[uint64]*ColDef       `protobuf:"bytes,9,rep,name=change_tbl_colId_map,json=changeTblColIdMap,proto3" json:"change_tbl_colId_map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *AlterTable) Reset()         { *m = AlterTable{} }
func (m *AlterTable) String() string { return proto.CompactTextString(m) }
func (*AlterTable) ProtoMessage()    {}
func (*AlterTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{84}
}
func (m *AlterTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTable.Merge(m, src)
}
func (m *AlterTable) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTable) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTable.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTable proto.InternalMessageInfo

func (m *AlterTable) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *AlterTable) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *AlterTable) GetCopyTableDef() *TableDef {
	if m != nil {
		return m.CopyTableDef
	}
	return nil
}

func (m *AlterTable) GetIsClusterTable() bool {
	if m != nil {
		return m.IsClusterTable
	}
	return false
}

func (m *AlterTable) GetActions() []*AlterTable_Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *AlterTable) GetAlgorithmType() AlterTable_AlgorithmType {
	if m != nil {
		return m.AlgorithmType
	}
	return AlterTable_DEFAULT
}

func (m *AlterTable) GetCreateTableSql() string {
	if m != nil {
		return m.CreateTableSql
	}
	return ""
}

func (m *AlterTable) GetInsertDataSql() string {
	if m != nil {
		return m.InsertDataSql
	}
	return ""
}

func (m *AlterTable) GetChangeTblColIdMap() map[uint64]*ColDef {
	if m != nil {
		return m.ChangeTblColIdMap
	}
	return nil
}

type AlterTable_Action struct {
	// Types that are valid to be assigned to Action:
	//
	//	*AlterTable_Action_Drop
	//	*AlterTable_Action_AddFk
	//	*AlterTable_Action_AddIndex
	//	*AlterTable_Action_AlterIndex
	//	*AlterTable_Action_AlterComment
	//	*AlterTable_Action_AlterName
	//	*AlterTable_Action_AddCol
	//	*AlterTable_Action_DropCol
	Action               isAlterTable_Action_Action `protobuf_oneof:"action"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *AlterTable_Action) Reset()         { *m = AlterTable_Action{} }
func (m *AlterTable_Action) String() string { return proto.CompactTextString(m) }
func (*AlterTable_Action) ProtoMessage()    {}
func (*AlterTable_Action) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{84, 0}
}
func (m *AlterTable_Action) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterTable_Action) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterTable_Action.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterTable_Action) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterTable_Action.Merge(m, src)
}
func (m *AlterTable_Action) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterTable_Action) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterTable_Action.DiscardUnknown(m)
}

var xxx_messageInfo_AlterTable_Action proto.InternalMessageInfo

type isAlterTable_Action_Action interface {
	isAlterTable_Action_Action()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type AlterTable_Action_Drop struct {
	Drop *AlterTableDrop `protobuf:"bytes,1,opt,name=drop,proto3,oneof" json:"drop,omitempty"`
}
type AlterTable_Action_AddFk struct {
	AddFk *AlterTableAddFk `protobuf:"bytes,2,opt,name=add_fk,json=addFk,proto3,oneof" json:"add_fk,omitempty"`
}
type AlterTable_Action_AddIndex struct {
	AddIndex *AlterTableAddIndex `protobuf:"bytes,3,opt,name=add_index,json=addIndex,proto3,oneof" json:"add_index,omitempty"`
}
type AlterTable_Action_AlterIndex struct {
	AlterIndex *AlterTableAlterIndex `protobuf:"bytes,4,opt,name=alter_index,json=alterIndex,proto3,oneof" json:"alter_index,omitempty"`
}
type AlterTable_Action_AlterComment struct {
	AlterComment *AlterTableComment `protobuf:"bytes,5,opt,name=alter_comment,json=alterComment,proto3,oneof" json:"alter_comment,omitempty"`
}
type AlterTable_Action_AlterName struct {
	AlterName *AlterTableName `protobuf:"bytes,6,opt,name=alter_name,json=alterName,proto3,oneof" json:"alter_name,omitempty"`
}
type AlterTable_Action_AddCol struct {
	AddCol *AlterAddCol `protobuf:"bytes,7,opt,name=add_col,json=addCol,proto3,oneof" json:"add_col,omitempty"`
}
type AlterTable_Action_DropCol struct {
	DropCol *AlterDropCol `protobuf:"bytes,8,opt,name=drop_col,json=dropCol,proto3,oneof" json:"drop_col,omitempty"`
}

func (*AlterTable_Action_Drop) isAlterTable_Action_Action()         {}
func (*AlterTable_Action_AddFk) isAlterTable_Action_Action()        {}
func (*AlterTable_Action_AddIndex) isAlterTable_Action_Action()     {}
func (*AlterTable_Action_AlterIndex) isAlterTable_Action_Action()   {}
func (*AlterTable_Action_AlterComment) isAlterTable_Action_Action() {}
func (*AlterTable_Action_AlterName) isAlterTable_Action_Action()    {}
func (*AlterTable_Action_AddCol) isAlterTable_Action_Action()       {}
func (*AlterTable_Action_DropCol) isAlterTable_Action_Action()      {}

func (m *AlterTable_Action) GetAction() isAlterTable_Action_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *AlterTable_Action) GetDrop() *AlterTableDrop {
	if x, ok := m.GetAction().(*AlterTable_Action_Drop); ok {
		return x.Drop
	}
	return nil
}

func (m *AlterTable_Action) GetAddFk() *AlterTableAddFk {
	if x, ok := m.GetAction().(*AlterTable_Action_AddFk); ok {
		return x.AddFk
	}
	return nil
}

func (m *AlterTable_Action) GetAddIndex() *AlterTableAddIndex {
	if x, ok := m.GetAction().(*AlterTable_Action_AddIndex); ok {
		return x.AddIndex
	}
	return nil
}

func (m *AlterTable_Action) GetAlterIndex() *AlterTableAlterIndex {
	if x, ok := m.GetAction().(*AlterTable_Action_AlterIndex); ok {
		return x.AlterIndex
	}
	return nil
}

func (m *AlterTable_Action) GetAlterComment() *AlterTableComment {
	if x, ok := m.GetAction().(*AlterTable_Action_AlterComment); ok {
		return x.AlterComment
	}
	return nil
}

func (m *AlterTable_Action) GetAlterName() *AlterTableName {
	if x, ok := m.GetAction().(*AlterTable_Action_AlterName); ok {
		return x.AlterName
	}
	return nil
}

func (m *AlterTable_Action) GetAddCol() *AlterAddCol {
	if x, ok := m.GetAction().(*AlterTable_Action_AddCol); ok {
		return x.AddCol
	}
	return nil
}

func (m *AlterTable_Action) GetDropCol() *AlterDropCol {
	if x, ok := m.GetAction().(*AlterTable_Action_DropCol); ok {
		return x.DropCol
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AlterTable_Action) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AlterTable_Action_Drop)(nil),
		(*AlterTable_Action_AddFk)(nil),
		(*AlterTable_Action_AddIndex)(nil),
		(*AlterTable_Action_AlterIndex)(nil),
		(*AlterTable_Action_AlterComment)(nil),
		(*AlterTable_Action_AlterName)(nil),
		(*AlterTable_Action_AddCol)(nil),
		(*AlterTable_Action_DropCol)(nil),
	}
}

type DropTable struct {
	IfExists             bool          `protobuf:"varint,1,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	Database             string        `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	Table                string        `protobuf:"bytes,3,opt,name=table,proto3" json:"table,omitempty"`
	IndexTableNames      []string      `protobuf:"bytes,4,rep,name=index_table_names,json=indexTableNames,proto3" json:"index_table_names,omitempty"`
	ClusterTable         *ClusterTable `protobuf:"bytes,5,opt,name=cluster_table,json=clusterTable,proto3" json:"cluster_table,omitempty"`
	TableId              uint64        `protobuf:"varint,6,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	ForeignTbl           []uint64      `protobuf:"varint,7,rep,packed,name=foreign_tbl,json=foreignTbl,proto3" json:"foreign_tbl,omitempty"`
	PartitionTableNames  []string      `protobuf:"bytes,8,rep,name=partition_table_names,json=partitionTableNames,proto3" json:"partition_table_names,omitempty"`
	IsView               bool          `protobuf:"varint,9,opt,name=isView,proto3" json:"isView,omitempty"`
	TableDef             *TableDef     `protobuf:"bytes,10,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *DropTable) Reset()         { *m = DropTable{} }
func (m *DropTable) String() string { return proto.CompactTextString(m) }
func (*DropTable) ProtoMessage()    {}
func (*DropTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{85}
}
func (m *DropTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropTable.Merge(m, src)
}
func (m *DropTable) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DropTable) XXX_DiscardUnknown() {
	xxx_messageInfo_DropTable.DiscardUnknown(m)
}

var xxx_messageInfo_DropTable proto.InternalMessageInfo

func (m *DropTable) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

func (m *DropTable) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *DropTable) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *DropTable) GetIndexTableNames() []string {
	if m != nil {
		return m.IndexTableNames
	}
	return nil
}

func (m *DropTable) GetClusterTable() *ClusterTable {
	if m != nil {
		return m.ClusterTable
	}
	return nil
}

func (m *DropTable) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *DropTable) GetForeignTbl() []uint64 {
	if m != nil {
		return m.ForeignTbl
	}
	return nil
}

func (m *DropTable) GetPartitionTableNames() []string {
	if m != nil {
		return m.PartitionTableNames
	}
	return nil
}

func (m *DropTable) GetIsView() bool {
	if m != nil {
		return m.IsView
	}
	return false
}

func (m *DropTable) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

type AlterView struct {
	IfExists             bool      `protobuf:"varint,1,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	Database             string    `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	TableDef             *TableDef `protobuf:"bytes,4,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *AlterView) Reset()         { *m = AlterView{} }
func (m *AlterView) String() string { return proto.CompactTextString(m) }
func (*AlterView) ProtoMessage()    {}
func (*AlterView) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{86}
}
func (m *AlterView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterView.Merge(m, src)
}
func (m *AlterView) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterView) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterView.DiscardUnknown(m)
}

var xxx_messageInfo_AlterView proto.InternalMessageInfo

func (m *AlterView) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

func (m *AlterView) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *AlterView) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

type CreateSequence struct {
	IfNotExists          bool      `protobuf:"varint,1,opt,name=if_not_exists,json=ifNotExists,proto3" json:"if_not_exists,omitempty"`
	Database             string    `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	TableDef             *TableDef `protobuf:"bytes,3,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *CreateSequence) Reset()         { *m = CreateSequence{} }
func (m *CreateSequence) String() string { return proto.CompactTextString(m) }
func (*CreateSequence) ProtoMessage()    {}
func (*CreateSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{87}
}
func (m *CreateSequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateSequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSequence.Merge(m, src)
}
func (m *CreateSequence) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CreateSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSequence.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSequence proto.InternalMessageInfo

func (m *CreateSequence) GetIfNotExists() bool {
	if m != nil {
		return m.IfNotExists
	}
	return false
}

func (m *CreateSequence) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *CreateSequence) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

type DropSequence struct {
	IfExists             bool     `protobuf:"varint,1,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	Database             string   `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	Table                string   `protobuf:"bytes,3,opt,name=table,proto3" json:"table,omitempty"`
	TableId              uint64   `protobuf:"varint,4,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DropSequence) Reset()         { *m = DropSequence{} }
func (m *DropSequence) String() string { return proto.CompactTextString(m) }
func (*DropSequence) ProtoMessage()    {}
func (*DropSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{88}
}
func (m *DropSequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropSequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropSequence.Merge(m, src)
}
func (m *DropSequence) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DropSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_DropSequence.DiscardUnknown(m)
}

var xxx_messageInfo_DropSequence proto.InternalMessageInfo

func (m *DropSequence) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

func (m *DropSequence) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *DropSequence) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *DropSequence) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

type AlterSequence struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterSequence) Reset()         { *m = AlterSequence{} }
func (m *AlterSequence) String() string { return proto.CompactTextString(m) }
func (*AlterSequence) ProtoMessage()    {}
func (*AlterSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{89}
}
func (m *AlterSequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterSequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterSequence.Merge(m, src)
}
func (m *AlterSequence) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterSequence.DiscardUnknown(m)
}

var xxx_messageInfo_AlterSequence proto.InternalMessageInfo

type CreateIndex struct {
	Database              string       `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	Table                 string       `protobuf:"bytes,2,opt,name=table,proto3" json:"table,omitempty"`
	TableDef              *TableDef    `protobuf:"bytes,3,opt,name=table_def,json=tableDef,proto3" json:"table_def,omitempty"`
	OriginTablePrimaryKey string       `protobuf:"bytes,4,opt,name=origin_table_primary_key,json=originTablePrimaryKey,proto3" json:"origin_table_primary_key,omitempty"`
	Index                 *CreateTable `protobuf:"bytes,5,opt,name=index,proto3" json:"index,omitempty"`
	TableExist            bool         `protobuf:"varint,6,opt,name=table_exist,json=tableExist,proto3" json:"table_exist,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}     `json:"-"`
	XXX_unrecognized      []byte       `json:"-"`
	XXX_sizecache         int32        `json:"-"`
}

func (m *CreateIndex) Reset()         { *m = CreateIndex{} }
func (m *CreateIndex) String() string { return proto.CompactTextString(m) }
func (*CreateIndex) ProtoMessage()    {}
func (*CreateIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{90}
}
func (m *CreateIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateIndex.Merge(m, src)
}
func (m *CreateIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CreateIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateIndex.DiscardUnknown(m)
}

var xxx_messageInfo_CreateIndex proto.InternalMessageInfo

func (m *CreateIndex) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *CreateIndex) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *CreateIndex) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

func (m *CreateIndex) GetOriginTablePrimaryKey() string {
	if m != nil {
		return m.OriginTablePrimaryKey
	}
	return ""
}

func (m *CreateIndex) GetIndex() *CreateTable {
	if m != nil {
		return m.Index
	}
	return nil
}

func (m *CreateIndex) GetTableExist() bool {
	if m != nil {
		return m.TableExist
	}
	return false
}

type AlterIndex struct {
	Index                string   `protobuf:"bytes,1,opt,name=index,proto3" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlterIndex) Reset()         { *m = AlterIndex{} }
func (m *AlterIndex) String() string { return proto.CompactTextString(m) }
func (*AlterIndex) ProtoMessage()    {}
func (*AlterIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{91}
}
func (m *AlterIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlterIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlterIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlterIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlterIndex.Merge(m, src)
}
func (m *AlterIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AlterIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_AlterIndex.DiscardUnknown(m)
}

var xxx_messageInfo_AlterIndex proto.InternalMessageInfo

func (m *AlterIndex) GetIndex() string {
	if m != nil {
		return m.Index
	}
	return ""
}

type DropIndex struct {
	Database             string   `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	Table                string   `protobuf:"bytes,2,opt,name=table,proto3" json:"table,omitempty"`
	IndexName            string   `protobuf:"bytes,3,opt,name=index_name,json=indexName,proto3" json:"index_name,omitempty"`
	IndexTableName       string   `protobuf:"bytes,4,opt,name=index_table_name,json=indexTableName,proto3" json:"index_table_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DropIndex) Reset()         { *m = DropIndex{} }
func (m *DropIndex) String() string { return proto.CompactTextString(m) }
func (*DropIndex) ProtoMessage()    {}
func (*DropIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{92}
}
func (m *DropIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropIndex.Merge(m, src)
}
func (m *DropIndex) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DropIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_DropIndex.DiscardUnknown(m)
}

var xxx_messageInfo_DropIndex proto.InternalMessageInfo

func (m *DropIndex) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *DropIndex) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *DropIndex) GetIndexName() string {
	if m != nil {
		return m.IndexName
	}
	return ""
}

func (m *DropIndex) GetIndexTableName() string {
	if m != nil {
		return m.IndexTableName
	}
	return ""
}

type TruncateTable struct {
	Database             string        `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	Table                string        `protobuf:"bytes,2,opt,name=table,proto3" json:"table,omitempty"`
	IndexTableNames      []string      `protobuf:"bytes,3,rep,name=index_table_names,json=indexTableNames,proto3" json:"index_table_names,omitempty"`
	PartitionTableNames  []string      `protobuf:"bytes,4,rep,name=partition_table_names,json=partitionTableNames,proto3" json:"partition_table_names,omitempty"`
	ClusterTable         *ClusterTable `protobuf:"bytes,5,opt,name=cluster_table,json=clusterTable,proto3" json:"cluster_table,omitempty"`
	TableId              uint64        `protobuf:"varint,6,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	ForeignTbl           []uint64      `protobuf:"varint,7,rep,packed,name=foreign_tbl,json=foreignTbl,proto3" json:"foreign_tbl,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TruncateTable) Reset()         { *m = TruncateTable{} }
func (m *TruncateTable) String() string { return proto.CompactTextString(m) }
func (*TruncateTable) ProtoMessage()    {}
func (*TruncateTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{93}
}
func (m *TruncateTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TruncateTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TruncateTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TruncateTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TruncateTable.Merge(m, src)
}
func (m *TruncateTable) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TruncateTable) XXX_DiscardUnknown() {
	xxx_messageInfo_TruncateTable.DiscardUnknown(m)
}

var xxx_messageInfo_TruncateTable proto.InternalMessageInfo

func (m *TruncateTable) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *TruncateTable) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *TruncateTable) GetIndexTableNames() []string {
	if m != nil {
		return m.IndexTableNames
	}
	return nil
}

func (m *TruncateTable) GetPartitionTableNames() []string {
	if m != nil {
		return m.PartitionTableNames
	}
	return nil
}

func (m *TruncateTable) GetClusterTable() *ClusterTable {
	if m != nil {
		return m.ClusterTable
	}
	return nil
}

func (m *TruncateTable) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *TruncateTable) GetForeignTbl() []uint64 {
	if m != nil {
		return m.ForeignTbl
	}
	return nil
}

type ClusterTable struct {
	IsClusterTable         bool     `protobuf:"varint,1,opt,name=is_cluster_table,json=isClusterTable,proto3" json:"is_cluster_table,omitempty"`
	AccountIDs             []uint32 `protobuf:"varint,2,rep,packed,name=accountIDs,proto3" json:"accountIDs,omitempty"`
	ColumnIndexOfAccountId int32    `protobuf:"varint,3,opt,name=column_index_of_accountId,json=columnIndexOfAccountId,proto3" json:"column_index_of_accountId,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *ClusterTable) Reset()         { *m = ClusterTable{} }
func (m *ClusterTable) String() string { return proto.CompactTextString(m) }
func (*ClusterTable) ProtoMessage()    {}
func (*ClusterTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{94}
}
func (m *ClusterTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterTable.Merge(m, src)
}
func (m *ClusterTable) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ClusterTable) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterTable.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterTable proto.InternalMessageInfo

func (m *ClusterTable) GetIsClusterTable() bool {
	if m != nil {
		return m.IsClusterTable
	}
	return false
}

func (m *ClusterTable) GetAccountIDs() []uint32 {
	if m != nil {
		return m.AccountIDs
	}
	return nil
}

func (m *ClusterTable) GetColumnIndexOfAccountId() int32 {
	if m != nil {
		return m.ColumnIndexOfAccountId
	}
	return 0
}

type ShowVariables struct {
	Global               bool     `protobuf:"varint,1,opt,name=global,proto3" json:"global,omitempty"`
	Where                []*Expr  `protobuf:"bytes,2,rep,name=where,proto3" json:"where,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShowVariables) Reset()         { *m = ShowVariables{} }
func (m *ShowVariables) String() string { return proto.CompactTextString(m) }
func (*ShowVariables) ProtoMessage()    {}
func (*ShowVariables) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{95}
}
func (m *ShowVariables) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowVariables) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowVariables.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowVariables) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowVariables.Merge(m, src)
}
func (m *ShowVariables) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ShowVariables) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowVariables.DiscardUnknown(m)
}

var xxx_messageInfo_ShowVariables proto.InternalMessageInfo

func (m *ShowVariables) GetGlobal() bool {
	if m != nil {
		return m.Global
	}
	return false
}

func (m *ShowVariables) GetWhere() []*Expr {
	if m != nil {
		return m.Where
	}
	return nil
}

type SetVariables struct {
	Items                []*SetVariablesItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *SetVariables) Reset()         { *m = SetVariables{} }
func (m *SetVariables) String() string { return proto.CompactTextString(m) }
func (*SetVariables) ProtoMessage()    {}
func (*SetVariables) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{96}
}
func (m *SetVariables) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetVariables) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetVariables.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetVariables) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetVariables.Merge(m, src)
}
func (m *SetVariables) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SetVariables) XXX_DiscardUnknown() {
	xxx_messageInfo_SetVariables.DiscardUnknown(m)
}

var xxx_messageInfo_SetVariables proto.InternalMessageInfo

func (m *SetVariables) GetItems() []*SetVariablesItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type SetVariablesItem struct {
	System               bool     `protobuf:"varint,1,opt,name=system,proto3" json:"system,omitempty"`
	Global               bool     `protobuf:"varint,2,opt,name=global,proto3" json:"global,omitempty"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Value                *Expr    `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`
	Reserved             *Expr    `protobuf:"bytes,5,opt,name=reserved,proto3" json:"reserved,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetVariablesItem) Reset()         { *m = SetVariablesItem{} }
func (m *SetVariablesItem) String() string { return proto.CompactTextString(m) }
func (*SetVariablesItem) ProtoMessage()    {}
func (*SetVariablesItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{97}
}
func (m *SetVariablesItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetVariablesItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetVariablesItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetVariablesItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetVariablesItem.Merge(m, src)
}
func (m *SetVariablesItem) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SetVariablesItem) XXX_DiscardUnknown() {
	xxx_messageInfo_SetVariablesItem.DiscardUnknown(m)
}

var xxx_messageInfo_SetVariablesItem proto.InternalMessageInfo

func (m *SetVariablesItem) GetSystem() bool {
	if m != nil {
		return m.System
	}
	return false
}

func (m *SetVariablesItem) GetGlobal() bool {
	if m != nil {
		return m.Global
	}
	return false
}

func (m *SetVariablesItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SetVariablesItem) GetValue() *Expr {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *SetVariablesItem) GetReserved() *Expr {
	if m != nil {
		return m.Reserved
	}
	return nil
}

type Prepare struct {
	Name                 string       `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Schemas              []*ObjectRef `protobuf:"bytes,2,rep,name=schemas,proto3" json:"schemas,omitempty"`
	Plan                 *Plan        `protobuf:"bytes,3,opt,name=plan,proto3" json:"plan,omitempty"`
	ParamTypes           []int32      `protobuf:"varint,4,rep,packed,name=param_types,json=paramTypes,proto3" json:"param_types,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Prepare) Reset()         { *m = Prepare{} }
func (m *Prepare) String() string { return proto.CompactTextString(m) }
func (*Prepare) ProtoMessage()    {}
func (*Prepare) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{98}
}
func (m *Prepare) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Prepare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Prepare.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Prepare) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Prepare.Merge(m, src)
}
func (m *Prepare) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Prepare) XXX_DiscardUnknown() {
	xxx_messageInfo_Prepare.DiscardUnknown(m)
}

var xxx_messageInfo_Prepare proto.InternalMessageInfo

func (m *Prepare) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Prepare) GetSchemas() []*ObjectRef {
	if m != nil {
		return m.Schemas
	}
	return nil
}

func (m *Prepare) GetPlan() *Plan {
	if m != nil {
		return m.Plan
	}
	return nil
}

func (m *Prepare) GetParamTypes() []int32 {
	if m != nil {
		return m.ParamTypes
	}
	return nil
}

type Execute struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Args                 []*Expr  `protobuf:"bytes,2,rep,name=args,proto3" json:"args,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Execute) Reset()         { *m = Execute{} }
func (m *Execute) String() string { return proto.CompactTextString(m) }
func (*Execute) ProtoMessage()    {}
func (*Execute) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{99}
}
func (m *Execute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Execute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Execute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Execute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Execute.Merge(m, src)
}
func (m *Execute) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Execute) XXX_DiscardUnknown() {
	xxx_messageInfo_Execute.DiscardUnknown(m)
}

var xxx_messageInfo_Execute proto.InternalMessageInfo

func (m *Execute) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Execute) GetArgs() []*Expr {
	if m != nil {
		return m.Args
	}
	return nil
}

type Deallocate struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Deallocate) Reset()         { *m = Deallocate{} }
func (m *Deallocate) String() string { return proto.CompactTextString(m) }
func (*Deallocate) ProtoMessage()    {}
func (*Deallocate) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{100}
}
func (m *Deallocate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deallocate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deallocate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deallocate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deallocate.Merge(m, src)
}
func (m *Deallocate) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Deallocate) XXX_DiscardUnknown() {
	xxx_messageInfo_Deallocate.DiscardUnknown(m)
}

var xxx_messageInfo_Deallocate proto.InternalMessageInfo

func (m *Deallocate) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type TableLockInfo struct {
	LockType             TableLockType `protobuf:"varint,1,opt,name=lockType,proto3,enum=plan.TableLockType" json:"lockType,omitempty"`
	TableDef             *TableDef     `protobuf:"bytes,2,opt,name=tableDef,proto3" json:"tableDef,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TableLockInfo) Reset()         { *m = TableLockInfo{} }
func (m *TableLockInfo) String() string { return proto.CompactTextString(m) }
func (*TableLockInfo) ProtoMessage()    {}
func (*TableLockInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{101}
}
func (m *TableLockInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableLockInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableLockInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableLockInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableLockInfo.Merge(m, src)
}
func (m *TableLockInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TableLockInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TableLockInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TableLockInfo proto.InternalMessageInfo

func (m *TableLockInfo) GetLockType() TableLockType {
	if m != nil {
		return m.LockType
	}
	return TableLockType_TableLockNone
}

func (m *TableLockInfo) GetTableDef() *TableDef {
	if m != nil {
		return m.TableDef
	}
	return nil
}

type LockTables struct {
	TableLocks           []*TableLockInfo `protobuf:"bytes,1,rep,name=tableLocks,proto3" json:"tableLocks,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *LockTables) Reset()         { *m = LockTables{} }
func (m *LockTables) String() string { return proto.CompactTextString(m) }
func (*LockTables) ProtoMessage()    {}
func (*LockTables) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{102}
}
func (m *LockTables) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockTables) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockTables.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LockTables) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockTables.Merge(m, src)
}
func (m *LockTables) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LockTables) XXX_DiscardUnknown() {
	xxx_messageInfo_LockTables.DiscardUnknown(m)
}

var xxx_messageInfo_LockTables proto.InternalMessageInfo

func (m *LockTables) GetTableLocks() []*TableLockInfo {
	if m != nil {
		return m.TableLocks
	}
	return nil
}

type UnLockTables struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnLockTables) Reset()         { *m = UnLockTables{} }
func (m *UnLockTables) String() string { return proto.CompactTextString(m) }
func (*UnLockTables) ProtoMessage()    {}
func (*UnLockTables) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{103}
}
func (m *UnLockTables) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnLockTables) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnLockTables.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnLockTables) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnLockTables.Merge(m, src)
}
func (m *UnLockTables) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnLockTables) XXX_DiscardUnknown() {
	xxx_messageInfo_UnLockTables.DiscardUnknown(m)
}

var xxx_messageInfo_UnLockTables proto.InternalMessageInfo

type MetadataScanInfo struct {
	ColName              string   `protobuf:"bytes,1,opt,name=ColName,proto3" json:"ColName,omitempty"`
	BlockId              []byte   `protobuf:"bytes,2,opt,name=BlockId,proto3" json:"BlockId,omitempty"`
	ObjectName           string   `protobuf:"bytes,3,opt,name=ObjectName,proto3" json:"ObjectName,omitempty"`
	EntryState           bool     `protobuf:"varint,4,opt,name=EntryState,proto3" json:"EntryState,omitempty"`
	Sorted               bool     `protobuf:"varint,5,opt,name=Sorted,proto3" json:"Sorted,omitempty"`
	IsHidden             bool     `protobuf:"varint,6,opt,name=IsHidden,proto3" json:"IsHidden,omitempty"`
	MetaLoc              []byte   `protobuf:"bytes,7,opt,name=MetaLoc,proto3" json:"MetaLoc,omitempty"`
	DelLoc               []byte   `protobuf:"bytes,8,opt,name=DelLoc,proto3" json:"DelLoc,omitempty"`
	CommitTs             []byte   `protobuf:"bytes,9,opt,name=CommitTs,proto3" json:"CommitTs,omitempty"`
	CreateTs             []byte   `protobuf:"bytes,10,opt,name=CreateTs,proto3" json:"CreateTs,omitempty"`
	DeleteTs             []byte   `protobuf:"bytes,11,opt,name=DeleteTs,proto3" json:"DeleteTs,omitempty"`
	SegId                []byte   `protobuf:"bytes,12,opt,name=SegId,proto3" json:"SegId,omitempty"`
	RowCnt               int64    `protobuf:"varint,13,opt,name=RowCnt,proto3" json:"RowCnt,omitempty"`
	NullCnt              int64    `protobuf:"varint,14,opt,name=NullCnt,proto3" json:"NullCnt,omitempty"`
	CompressSize         int64    `protobuf:"varint,15,opt,name=CompressSize,proto3" json:"CompressSize,omitempty"`
	OriginSize           int64    `protobuf:"varint,16,opt,name=OriginSize,proto3" json:"OriginSize,omitempty"`
	Min                  []byte   `protobuf:"bytes,17,opt,name=Min,proto3" json:"Min,omitempty"`
	Max                  []byte   `protobuf:"bytes,18,opt,name=Max,proto3" json:"Max,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MetadataScanInfo) Reset()         { *m = MetadataScanInfo{} }
func (m *MetadataScanInfo) String() string { return proto.CompactTextString(m) }
func (*MetadataScanInfo) ProtoMessage()    {}
func (*MetadataScanInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d655ab2f7683c23, []int{104}
}
func (m *MetadataScanInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetadataScanInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetadataScanInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetadataScanInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetadataScanInfo.Merge(m, src)
}
func (m *MetadataScanInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MetadataScanInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MetadataScanInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MetadataScanInfo proto.InternalMessageInfo

func (m *MetadataScanInfo) GetColName() string {
	if m != nil {
		return m.ColName
	}
	return ""
}

func (m *MetadataScanInfo) GetBlockId() []byte {
	if m != nil {
		return m.BlockId
	}
	return nil
}

func (m *MetadataScanInfo) GetObjectName() string {
	if m != nil {
		return m.ObjectName
	}
	return ""
}

func (m *MetadataScanInfo) GetEntryState() bool {
	if m != nil {
		return m.EntryState
	}
	return false
}

func (m *MetadataScanInfo) GetSorted() bool {
	if m != nil {
		return m.Sorted
	}
	return false
}

func (m *MetadataScanInfo) GetIsHidden() bool {
	if m != nil {
		return m.IsHidden
	}
	return false
}

func (m *MetadataScanInfo) GetMetaLoc() []byte {
	if m != nil {
		return m.MetaLoc
	}
	return nil
}

func (m *MetadataScanInfo) GetDelLoc() []byte {
	if m != nil {
		return m.DelLoc
	}
	return nil
}

func (m *MetadataScanInfo) GetCommitTs() []byte {
	if m != nil {
		return m.CommitTs
	}
	return nil
}

func (m *MetadataScanInfo) GetCreateTs() []byte {
	if m != nil {
		return m.CreateTs
	}
	return nil
}

func (m *MetadataScanInfo) GetDeleteTs() []byte {
	if m != nil {
		return m.DeleteTs
	}
	return nil
}

func (m *MetadataScanInfo) GetSegId() []byte {
	if m != nil {
		return m.SegId
	}
	return nil
}

func (m *MetadataScanInfo) GetRowCnt() int64 {
	if m != nil {
		return m.RowCnt
	}
	return 0
}

func (m *MetadataScanInfo) GetNullCnt() int64 {
	if m != nil {
		return m.NullCnt
	}
	return 0
}

func (m *MetadataScanInfo) GetCompressSize() int64 {
	if m != nil {
		return m.CompressSize
	}
	return 0
}

func (m *MetadataScanInfo) GetOriginSize() int64 {
	if m != nil {
		return m.OriginSize
	}
	return 0
}

func (m *MetadataScanInfo) GetMin() []byte {
	if m != nil {
		return m.Min
	}
	return nil
}

func (m *MetadataScanInfo) GetMax() []byte {
	if m != nil {
		return m.Max
	}
	return nil
}

func init() {
	proto.RegisterEnum("plan.CompressType", CompressType_name, CompressType_value)
	proto.RegisterEnum("plan.PartitionType", PartitionType_name, PartitionType_value)
	proto.RegisterEnum("plan.ShuffleType", ShuffleType_name, ShuffleType_value)
	proto.RegisterEnum("plan.ShuffleMethod", ShuffleMethod_name, ShuffleMethod_value)
	proto.RegisterEnum("plan.TransationCompletionType", TransationCompletionType_name, TransationCompletionType_value)
	proto.RegisterEnum("plan.TableLockType", TableLockType_name, TableLockType_value)
	proto.RegisterEnum("plan.SubqueryRef_Type", SubqueryRef_Type_name, SubqueryRef_Type_value)
	proto.RegisterEnum("plan.Function_FuncFlag", Function_FuncFlag_name, Function_FuncFlag_value)
	proto.RegisterEnum("plan.ForeignKeyDef_RefAction", ForeignKeyDef_RefAction_name, ForeignKeyDef_RefAction_value)
	proto.RegisterEnum("plan.OrderBySpec_OrderByFlag", OrderBySpec_OrderByFlag_name, OrderBySpec_OrderByFlag_value)
	proto.RegisterEnum("plan.FrameClause_FrameType", FrameClause_FrameType_name, FrameClause_FrameType_value)
	proto.RegisterEnum("plan.FrameBound_BoundType", FrameBound_BoundType_name, FrameBound_BoundType_value)
	proto.RegisterEnum("plan.Node_NodeType", Node_NodeType_name, Node_NodeType_value)
	proto.RegisterEnum("plan.Node_JoinType", Node_JoinType_name, Node_JoinType_value)
	proto.RegisterEnum("plan.Node_AggMode", Node_AggMode_name, Node_AggMode_value)
	proto.RegisterEnum("plan.Query_StatementType", Query_StatementType_name, Query_StatementType_value)
	proto.RegisterEnum("plan.TransationControl_TclType", TransationControl_TclType_name, TransationControl_TclType_value)
	proto.RegisterEnum("plan.TransationBegin_TransationMode", TransationBegin_TransationMode_name, TransationBegin_TransationMode_value)
	proto.RegisterEnum("plan.DataControl_DclType", DataControl_DclType_name, DataControl_DclType_value)
	proto.RegisterEnum("plan.DataDefinition_DdlType", DataDefinition_DdlType_name, DataDefinition_DdlType_value)
	proto.RegisterEnum("plan.AlterTableDrop_Typ", AlterTableDrop_Typ_name, AlterTableDrop_Typ_value)
	proto.RegisterEnum("plan.AlterTable_AlgorithmType", AlterTable_AlgorithmType_name, AlterTable_AlgorithmType_value)
	proto.RegisterEnum("plan.MetadataScanInfo_MetadataScanInfoType", MetadataScanInfo_MetadataScanInfoType_name, MetadataScanInfo_MetadataScanInfoType_value)
	proto.RegisterType((*Type)(nil), "plan.Type")
	proto.RegisterType((*Const)(nil), "plan.Const")
	proto.RegisterType((*ParamRef)(nil), "plan.ParamRef")
	proto.RegisterType((*VarRef)(nil), "plan.VarRef")
	proto.RegisterType((*ColRef)(nil), "plan.ColRef")
	proto.RegisterType((*RawColRef)(nil), "plan.RawColRef")
	proto.RegisterType((*CorrColRef)(nil), "plan.CorrColRef")
	proto.RegisterType((*ExprList)(nil), "plan.ExprList")
	proto.RegisterType((*MaxValue)(nil), "plan.MaxValue")
	proto.RegisterType((*TargetType)(nil), "plan.TargetType")
	proto.RegisterType((*SubqueryRef)(nil), "plan.SubqueryRef")
	proto.RegisterType((*ObjectRef)(nil), "plan.ObjectRef")
	proto.RegisterType((*PubInfo)(nil), "plan.PubInfo")
	proto.RegisterType((*SubscriptionMeta)(nil), "plan.SubscriptionMeta")
	proto.RegisterType((*Function)(nil), "plan.Function")
	proto.RegisterType((*Expr)(nil), "plan.Expr")
	proto.RegisterType((*Decimal64)(nil), "plan.decimal64")
	proto.RegisterType((*Decimal128)(nil), "plan.decimal128")
	proto.RegisterType((*ResultColDef)(nil), "plan.ResultColDef")
	proto.RegisterType((*ColDef)(nil), "plan.ColDef")
	proto.RegisterType((*Default)(nil), "plan.Default")
	proto.RegisterType((*OnUpdate)(nil), "plan.OnUpdate")
	proto.RegisterType((*IndexOption)(nil), "plan.IndexOption")
	proto.RegisterType((*PrimaryKeyDef)(nil), "plan.PrimaryKeyDef")
	proto.RegisterType((*IndexDef)(nil), "plan.IndexDef")
	proto.RegisterType((*ForeignKeyDef)(nil), "plan.ForeignKeyDef")
	proto.RegisterType((*CheckDef)(nil), "plan.CheckDef")
	proto.RegisterType((*ClusterByDef)(nil), "plan.ClusterByDef")
	proto.RegisterType((*PropertyDef)(nil), "plan.PropertyDef")
	proto.RegisterType((*Property)(nil), "plan.Property")
	proto.RegisterType((*PropertiesDef)(nil), "plan.PropertiesDef")
	proto.RegisterType((*PartitionByDef)(nil), "plan.PartitionByDef")
	proto.RegisterType((*PartitionExpr)(nil), "plan.PartitionExpr")
	proto.RegisterType((*PartitionColumns)(nil), "plan.PartitionColumns")
	proto.RegisterType((*PartitionItem)(nil), "plan.PartitionItem")
	proto.RegisterType((*ViewDef)(nil), "plan.ViewDef")
	proto.RegisterType((*TableDef)(nil), "plan.TableDef")
	proto.RegisterMapType((map[string]int32)(nil), "plan.TableDef.Name2colIndexEntry")
	proto.RegisterType((*TableDef_DefType)(nil), "plan.TableDef.DefType")
	proto.RegisterType((*TableFunction)(nil), "plan.TableFunction")
	proto.RegisterType((*HashMapStats)(nil), "plan.HashMapStats")
	proto.RegisterType((*Stats)(nil), "plan.Stats")
	proto.RegisterType((*RowsetExpr)(nil), "plan.RowsetExpr")
	proto.RegisterType((*ColData)(nil), "plan.ColData")
	proto.RegisterType((*RowsetData)(nil), "plan.RowsetData")
	proto.RegisterType((*OrderBySpec)(nil), "plan.OrderBySpec")
	proto.RegisterType((*WindowSpec)(nil), "plan.WindowSpec")
	proto.RegisterType((*FrameClause)(nil), "plan.FrameClause")
	proto.RegisterType((*FrameBound)(nil), "plan.FrameBound")
	proto.RegisterType((*OnDuplicateKeyCtx)(nil), "plan.OnDuplicateKeyCtx")
	proto.RegisterMapType((map[string]*Expr)(nil), "plan.OnDuplicateKeyCtx.OnDuplicateExprEntry")
	proto.RegisterType((*InsertCtx)(nil), "plan.InsertCtx")
	proto.RegisterType((*ReplaceCtx)(nil), "plan.ReplaceCtx")
	proto.RegisterType((*AnalyzeInfo)(nil), "plan.AnalyzeInfo")
	proto.RegisterType((*Node)(nil), "plan.Node")
	proto.RegisterType((*LockTarget)(nil), "plan.LockTarget")
	proto.RegisterType((*PreInsertUkCtx)(nil), "plan.PreInsertUkCtx")
	proto.RegisterType((*PreDeleteCtx)(nil), "plan.PreDeleteCtx")
	proto.RegisterType((*PreInsertCtx)(nil), "plan.PreInsertCtx")
	proto.RegisterType((*RuntimeFilterSpec)(nil), "plan.RuntimeFilterSpec")
	proto.RegisterType((*IdList)(nil), "plan.IdList")
	proto.RegisterType((*ColPosMap)(nil), "plan.ColPosMap")
	proto.RegisterMapType((map[string]int32)(nil), "plan.ColPosMap.MapEntry")
	proto.RegisterType((*DeleteCtx)(nil), "plan.DeleteCtx")
	proto.RegisterType((*Query)(nil), "plan.Query")
	proto.RegisterType((*TransationControl)(nil), "plan.TransationControl")
	proto.RegisterType((*TransationBegin)(nil), "plan.TransationBegin")
	proto.RegisterType((*TransationCommit)(nil), "plan.TransationCommit")
	proto.RegisterType((*TransationRollback)(nil), "plan.TransationRollback")
	proto.RegisterType((*Plan)(nil), "plan.Plan")
	proto.RegisterType((*Column)(nil), "plan.column")
	proto.RegisterType((*DataControl)(nil), "plan.DataControl")
	proto.RegisterType((*DataDefinition)(nil), "plan.DataDefinition")
	proto.RegisterType((*SubscriptionOption)(nil), "plan.SubscriptionOption")
	proto.RegisterType((*CreateDatabase)(nil), "plan.CreateDatabase")
	proto.RegisterType((*AlterDatabase)(nil), "plan.AlterDatabase")
	proto.RegisterType((*DropDatabase)(nil), "plan.DropDatabase")
	proto.RegisterType((*FkColName)(nil), "plan.FkColName")
	proto.RegisterType((*CreateTable)(nil), "plan.CreateTable")
	proto.RegisterType((*AlterTableDrop)(nil), "plan.AlterTableDrop")
	proto.RegisterType((*AlterTableAddFk)(nil), "plan.AlterTableAddFk")
	proto.RegisterType((*AlterTableAddIndex)(nil), "plan.AlterTableAddIndex")
	proto.RegisterType((*AlterTableDropIndex)(nil), "plan.AlterTableDropIndex")
	proto.RegisterType((*AlterTableAlterIndex)(nil), "plan.AlterTableAlterIndex")
	proto.RegisterType((*AlterTableComment)(nil), "plan.AlterTableComment")
	proto.RegisterType((*AlterTableName)(nil), "plan.AlterTableName")
	proto.RegisterType((*AlterAddCol)(nil), "plan.AlterAddCol")
	proto.RegisterType((*AlterDropCol)(nil), "plan.AlterDropCol")
	proto.RegisterType((*AlterTable)(nil), "plan.AlterTable")
	proto.RegisterMapType((map[uint64]*ColDef)(nil), "plan.AlterTable.ChangeTblColIdMapEntry")
	proto.RegisterType((*AlterTable_Action)(nil), "plan.AlterTable.Action")
	proto.RegisterType((*DropTable)(nil), "plan.DropTable")
	proto.RegisterType((*AlterView)(nil), "plan.AlterView")
	proto.RegisterType((*CreateSequence)(nil), "plan.CreateSequence")
	proto.RegisterType((*DropSequence)(nil), "plan.DropSequence")
	proto.RegisterType((*AlterSequence)(nil), "plan.AlterSequence")
	proto.RegisterType((*CreateIndex)(nil), "plan.CreateIndex")
	proto.RegisterType((*AlterIndex)(nil), "plan.AlterIndex")
	proto.RegisterType((*DropIndex)(nil), "plan.DropIndex")
	proto.RegisterType((*TruncateTable)(nil), "plan.TruncateTable")
	proto.RegisterType((*ClusterTable)(nil), "plan.ClusterTable")
	proto.RegisterType((*ShowVariables)(nil), "plan.ShowVariables")
	proto.RegisterType((*SetVariables)(nil), "plan.SetVariables")
	proto.RegisterType((*SetVariablesItem)(nil), "plan.SetVariablesItem")
	proto.RegisterType((*Prepare)(nil), "plan.Prepare")
	proto.RegisterType((*Execute)(nil), "plan.Execute")
	proto.RegisterType((*Deallocate)(nil), "plan.Deallocate")
	proto.RegisterType((*TableLockInfo)(nil), "plan.TableLockInfo")
	proto.RegisterType((*LockTables)(nil), "plan.LockTables")
	proto.RegisterType((*UnLockTables)(nil), "plan.UnLockTables")
	proto.RegisterType((*MetadataScanInfo)(nil), "plan.MetadataScanInfo")
}

func init() { proto.RegisterFile("plan.proto", fileDescriptor_2d655ab2f7683c23) }

var fileDescriptor_2d655ab2f7683c23 = []byte{
	// 9039 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0xbc, 0x4b, 0x6c, 0x23, 0x49,
	0x9a, 0x18, 0x2c, 0xbe, 0xc9, 0x8f, 0x0f, 0xa5, 0xa2, 0x54, 0x55, 0xac, 0xea, 0xea, 0x2a, 0x75,
	0xf6, 0xab, 0xba, 0xa6, 0xa7, 0xaa, 0x5b, 0xfd, 0xee, 0x9d, 0xd9, 0x19, 0x8a, 0x62, 0x95, 0xd8,
	0x45, 0x91, 0x9a, 0x20, 0x55, 0xd5, 0xbd, 0x8b, 0x1f, 0x89, 0x24, 0x33, 0x29, 0x65, 0x8b, 0xca,
	0x64, 0x67, 0x26, 0x4b, 0x52, 0x03, 0x0b, 0xcc, 0x69, 0x17, 0xbf, 0xaf, 0x36, 0x66, 0x0d, 0xac,
	0x0d, 0xef, 0xfa, 0x68, 0xf8, 0xe0, 0x83, 0x0d, 0x03, 0x86, 0x61, 0xd8, 0xf0, 0xc5, 0xbe, 0xd9,
	0xf0, 0xcd, 0xf6, 0xc1, 0x1e, 0x1b, 0xbe, 0xfa, 0xb0, 0x03, 0x9f, 0x7c, 0x30, 0xbe, 0x2f, 0x22,
	0x33, 0x23, 0x49, 0xa9, 0x6b, 0xba, 0x77, 0x0c, 0xdb, 0x17, 0x29, 0xbf, 0x47, 0x44, 0x7c, 0xf1,
	0xfa, 0x5e, 0x11, 0x41, 0x80, 0xf9, 0xcc, 0x74, 0x1f, 0xce, 0x7d, 0x2f, 0xf4, 0x58, 0x1e, 0xbf,
	0x6f, 0xff, 0xf8, 0xc8, 0x09, 0x8f, 0x17, 0xe3, 0x87, 0x13, 0xef, 0xf4, 0xd1, 0x91, 0x77, 0xe4,
	0x3d, 0x22, 0xe2, 0x78, 0x31, 0x25, 0x88, 0x00, 0xfa, 0x12, 0x85, 0xf4, 0x3f, 0xcd, 0x40, 0x7e,
	0x74, 0x31, 0xb7, 0x59, 0x03, 0xb2, 0x8e, 0xd5, 0xcc, 0x6c, 0x65, 0xee, 0x17, 0x78, 0xd6, 0xb1,
	0xd8, 0x16, 0x54, 0x5d, 0x2f, 0xec, 0x2f, 0x66, 0x33, 0x73, 0x3c, 0xb3, 0x9b, 0xd9, 0xad, 0xcc,
	0xfd, 0x32, 0x57, 0x51, 0xec, 0x15, 0xa8, 0x98, 0x8b, 0xd0, 0x33, 0x1c, 0x77, 0xe2, 0x37, 0x73,
	0x44, 0x2f, 0x23, 0xa2, 0xeb, 0x4e, 0x7c, 0xb6, 0x09, 0x85, 0x33, 0xc7, 0x0a, 0x8f, 0x9b, 0x79,
	0xaa, 0x51, 0x00, 0x88, 0x0d, 0x26, 0xe6, 0xcc, 0x6e, 0x16, 0x04, 0x96, 0x00, 0xc4, 0x86, 0xd4,
	0x48, 0x71, 0x2b, 0x73, 0xbf, 0xc2, 0x05, 0xa0, 0xff, 0xdb, 0x02, 0x14, 0xda, 0x9e, 0x1b, 0x84,
	0xec, 0x06, 0x14, 0x9d, 0xc0, 0x5d, 0xcc, 0x66, 0x24, 0x5e, 0x99, 0x4b, 0x88, 0xdd, 0x80, 0x82,
	0xf3, 0xe9, 0x0b, 0x73, 0x46, 0xc2, 0x15, 0xf6, 0xd6, 0xb8, 0x00, 0x59, 0x13, 0x8a, 0xce, 0xfb,
	0x1f, 0x23, 0x21, 0x27, 0x09, 0x12, 0x26, 0xca, 0x07, 0xdb, 0x48, 0xc9, 0xc7, 0x14, 0x82, 0x89,
	0xf2, 0xf1, 0x87, 0x48, 0x41, 0xd1, 0x72, 0x44, 0x21, 0x18, 0x5b, 0x59, 0x50, 0x2b, 0x28, 0x5d,
	0x1d, 0x5b, 0x59, 0x44, 0xad, 0x2c, 0x44, 0x2b, 0x25, 0x49, 0x90, 0x30, 0x51, 0x44, 0x2b, 0xe5,
	0x98, 0x12, 0xb7, 0xb2, 0x10, 0xad, 0x54, 0xb6, 0x32, 0xf7, 0xf3, 0x44, 0x11, 0xad, 0x6c, 0x42,
	0xde, 0x42, 0x3c, 0x6c, 0x65, 0xee, 0x67, 0xf6, 0xd6, 0x38, 0x41, 0x88, 0x0d, 0x10, 0x5b, 0xc5,
	0x81, 0x41, 0x6c, 0x20, 0xb1, 0x63, 0xc4, 0xd6, 0x70, 0x34, 0x10, 0x3b, 0x96, 0xd8, 0x29, 0x62,
	0xeb, 0x5b, 0x99, 0xfb, 0x59, 0xc4, 0x22, 0xc4, 0x6e, 0x43, 0xc9, 0x32, 0x43, 0x1b, 0x09, 0x0d,
	0xd9, 0xe5, 0x08, 0x81, 0xb4, 0xd0, 0x39, 0x25, 0xda, 0xba, 0xec, 0x74, 0x84, 0x60, 0x3a, 0x54,
	0x91, 0x2d, 0xa2, 0x6b, 0x92, 0xae, 0x22, 0xd9, 0x47, 0x50, 0xb3, 0xec, 0x89, 0x73, 0x6a, 0xce,
	0x44, 0x9f, 0x36, 0xb6, 0x32, 0xf7, 0xab, 0xdb, 0xeb, 0x0f, 0x69, 0x4d, 0xc6, 0x94, 0xbd, 0x35,
	0x9e, 0x62, 0x63, 0x9f, 0x42, 0x5d, 0xc2, 0xef, 0x6f, 0xd3, 0xc0, 0x32, 0x2a, 0xa7, 0xa5, 0xca,
	0xbd, 0xbf, 0xfd, 0xe9, 0xde, 0x1a, 0x4f, 0x33, 0xb2, 0x37, 0xa0, 0x86, 0x6d, 0x07, 0xa1, 0x79,
	0x3a, 0xc7, 0x82, 0xd7, 0xa4, 0x54, 0x29, 0x2c, 0x76, 0xeb, 0xeb, 0xc0, 0x73, 0x91, 0x61, 0x53,
	0x8e, 0x5b, 0x84, 0x60, 0x5b, 0x00, 0x96, 0x3d, 0x35, 0x17, 0xb3, 0x10, 0xc9, 0xd7, 0xe5, 0x00,
	0x2a, 0x38, 0x76, 0x17, 0x2a, 0x8b, 0x39, 0xf6, 0xf2, 0x99, 0x39, 0x6b, 0xde, 0x90, 0x0c, 0x09,
	0x0a, 0x17, 0xab, 0x13, 0xec, 0x38, 0x6e, 0xf3, 0x26, 0xad, 0x45, 0x01, 0xb0, 0x3b, 0x90, 0x0b,
	0xfc, 0x49, 0xb3, 0x49, 0x3d, 0x01, 0xd1, 0x93, 0xce, 0xf9, 0xdc, 0xe7, 0x88, 0xde, 0x29, 0x41,
	0xe1, 0x85, 0x39, 0x5b, 0xd8, 0xfa, 0x1d, 0x28, 0x1f, 0x98, 0xbe, 0x79, 0xca, 0xed, 0x29, 0xd3,
	0x20, 0x37, 0xf7, 0x02, 0xb9, 0xe3, 0xf0, 0x53, 0xef, 0x41, 0xf1, 0x99, 0xe9, 0x23, 0x8d, 0x41,
	0xde, 0x35, 0x4f, 0x6d, 0x22, 0x56, 0x38, 0x7d, 0xe3, 0x2e, 0x08, 0x2e, 0x82, 0xd0, 0x3e, 0x95,
	0x7b, 0x51, 0x42, 0x88, 0x3f, 0x9a, 0x79, 0x63, 0xb9, 0xda, 0xcb, 0x5c, 0x42, 0x7a, 0x1f, 0x8a,
	0x6d, 0x6f, 0x86, 0xb5, 0xdd, 0x84, 0x92, 0x6f, 0xcf, 0x8c, 0xa4, 0xb5, 0xa2, 0x6f, 0xcf, 0x0e,
	0xbc, 0x00, 0x09, 0x13, 0x4f, 0x10, 0xb2, 0x82, 0x30, 0xf1, 0x88, 0x10, 0xb5, 0x9f, 0x4b, 0xda,
	0xd7, 0x3f, 0x83, 0x0a, 0x37, 0xcf, 0x64, 0x95, 0xd7, 0xa1, 0x18, 0x8e, 0x67, 0x86, 0xd4, 0x18,
	0x79, 0x5e, 0x08, 0xc7, 0xb3, 0xae, 0x85, 0x68, 0xac, 0xd0, 0xb1, 0xa8, 0xbe, 0x3c, 0x2f, 0x4c,
	0xbc, 0x59, 0xd7, 0xd2, 0x47, 0x00, 0x6d, 0xcf, 0xf7, 0x7f, 0xb0, 0x38, 0x9b, 0x50, 0xb0, 0xec,
	0x79, 0x78, 0x2c, 0xf6, 0x33, 0x17, 0x80, 0xfe, 0x00, 0xca, 0x38, 0xc4, 0x3d, 0x27, 0x08, 0xd9,
	0x5d, 0xc8, 0xcf, 0x9c, 0x20, 0x6c, 0x66, 0xb6, 0x72, 0x4b, 0x13, 0x40, 0x78, 0x7d, 0x0b, 0xca,
	0xfb, 0xe6, 0xf9, 0x33, 0x9c, 0x04, 0xac, 0x8d, 0x66, 0x43, 0x8e, 0xae, 0x9c, 0x9a, 0x07, 0x00,
	0x23, 0xd3, 0x3f, 0xb2, 0x43, 0xd2, 0x86, 0x77, 0x20, 0x17, 0x5e, 0xcc, 0x89, 0x23, 0xae, 0x0e,
	0x09, 0x1c, 0xd1, 0xfa, 0x5f, 0x66, 0xa0, 0x3a, 0x5c, 0x8c, 0xbf, 0x59, 0xd8, 0xfe, 0x05, 0xf6,
	0xe8, 0x7e, 0xc2, 0xdd, 0xd8, 0xbe, 0x21, 0xb8, 0x15, 0x7a, 0x52, 0x12, 0xbb, 0xe8, 0x7a, 0x96,
	0x1d, 0x8d, 0x50, 0x81, 0x17, 0x11, 0xec, 0x5a, 0xa8, 0x7e, 0xbd, 0xb9, 0x1c, 0xef, 0xac, 0x37,
	0x67, 0x5b, 0x50, 0x98, 0x1c, 0x3b, 0x33, 0x8b, 0x14, 0x55, 0xba, 0x47, 0x82, 0xc0, 0x6e, 0x41,
	0xd9, 0xf7, 0xce, 0x8c, 0xc0, 0xf9, 0x36, 0x52, 0xa7, 0x25, 0xdf, 0x3b, 0x1b, 0x3a, 0xdf, 0xda,
	0xfa, 0x48, 0xea, 0x74, 0x80, 0xe2, 0xb0, 0xdd, 0xea, 0xb5, 0xb8, 0xb6, 0x86, 0xdf, 0x9d, 0x2f,
	0xbb, 0xc3, 0xd1, 0x50, 0xcb, 0xb0, 0x06, 0x40, 0x7f, 0x30, 0x32, 0x24, 0x9c, 0x65, 0x45, 0xc8,
	0x76, 0xfb, 0x5a, 0x0e, 0x79, 0x10, 0xdf, 0xed, 0x6b, 0x79, 0x56, 0x82, 0x5c, 0xab, 0xff, 0x95,
	0x56, 0xa0, 0x8f, 0x5e, 0x4f, 0x2b, 0xea, 0x7f, 0x2f, 0x0b, 0x95, 0xc1, 0xf8, 0x6b, 0x7b, 0x12,
	0x62, 0x9f, 0x71, 0x39, 0xda, 0xfe, 0x0b, 0xdb, 0xa7, 0x6e, 0xe7, 0xb8, 0x84, 0xb0, 0x23, 0xd6,
	0x98, 0x3a, 0x97, 0xe3, 0x59, 0x6b, 0x4c, 0x7c, 0x93, 0x63, 0xfb, 0xd4, 0xa4, 0xce, 0x21, 0x1f,
	0x41, 0xb8, 0xfc, 0xbd, 0xf1, 0xd7, 0xd4, 0xbd, 0x1c, 0xc7, 0x4f, 0x76, 0x0f, 0xaa, 0xa2, 0x0e,
	0x83, 0xd6, 0x5e, 0x81, 0xc6, 0x02, 0x04, 0xaa, 0x8f, 0x3b, 0xe0, 0x26, 0x94, 0xac, 0xb1, 0x20,
	0x0a, 0x4b, 0x51, 0xb4, 0xc6, 0x44, 0xc0, 0x92, 0x54, 0xab, 0x20, 0x96, 0x64, 0x49, 0x42, 0x11,
	0xc3, 0x2d, 0x28, 0x7b, 0xe3, 0xaf, 0x05, 0xb5, 0x4c, 0xd4, 0x92, 0x37, 0xfe, 0x9a, 0x48, 0x3f,
	0x82, 0x8d, 0x60, 0x31, 0x0e, 0x26, 0xbe, 0x33, 0x0f, 0x1d, 0xcf, 0x15, 0x3c, 0x15, 0xe2, 0xd1,
	0x54, 0x02, 0x31, 0xdf, 0x87, 0xf2, 0x7c, 0x31, 0x36, 0x1c, 0x77, 0xea, 0x91, 0xa6, 0xae, 0x6e,
	0xd7, 0xc5, 0xc4, 0x1c, 0x2c, 0xc6, 0x5d, 0x77, 0xea, 0xf1, 0xd2, 0x5c, 0x7c, 0xe8, 0x6f, 0x41,
	0x49, 0xe2, 0xd0, 0x4e, 0x86, 0xb6, 0x6b, 0xba, 0xa1, 0x11, 0x1b, 0xd8, 0xb2, 0x40, 0x74, 0x2d,
	0xfd, 0x6f, 0x65, 0x40, 0x1b, 0x2a, 0xcd, 0xec, 0xdb, 0xa1, 0x79, 0xe9, 0xf6, 0x7f, 0x15, 0xc0,
	0x9c, 0x4c, 0xbc, 0x85, 0xa8, 0x46, 0x2c, 0x9e, 0x8a, 0xc4, 0x74, 0x2d, 0x75, 0x6c, 0x72, 0xa9,
	0xb1, 0x79, 0x0d, 0x6a, 0x51, 0x39, 0xa2, 0xe6, 0x89, 0x5a, 0x95, 0xb8, 0x68, 0x74, 0x82, 0xc5,
	0x58, 0x1d, 0xf5, 0x52, 0xb0, 0xa0, 0xd2, 0xfa, 0x9f, 0x64, 0xa1, 0xfc, 0x78, 0xe1, 0x4e, 0x50,
	0x34, 0xf6, 0x3a, 0xe4, 0xa7, 0x0b, 0x77, 0x22, 0x77, 0x85, 0xd4, 0xf3, 0xf1, 0x8a, 0xe0, 0x44,
	0xc4, 0x9d, 0x68, 0xfa, 0x47, 0xb8, 0x83, 0x57, 0x76, 0x22, 0xe2, 0xf5, 0x7f, 0x94, 0x11, 0x35,
	0x3e, 0x9e, 0x99, 0x47, 0xac, 0x0c, 0xf9, 0xfe, 0xa0, 0xdf, 0xd1, 0xd6, 0x58, 0x0d, 0xca, 0xdd,
	0xfe, 0xa8, 0xc3, 0xfb, 0xad, 0x9e, 0x96, 0xa1, 0x85, 0x3b, 0x6a, 0xed, 0xf4, 0x3a, 0x5a, 0x16,
	0x29, 0xcf, 0x06, 0xbd, 0xd6, 0xa8, 0xdb, 0xeb, 0x68, 0x79, 0x41, 0xe1, 0xdd, 0xf6, 0x48, 0x2b,
	0x33, 0x0d, 0x6a, 0x07, 0x7c, 0xb0, 0x7b, 0xd8, 0xee, 0x18, 0xfd, 0xc3, 0x5e, 0x4f, 0xd3, 0xd8,
	0x35, 0x58, 0x8f, 0x31, 0x03, 0x81, 0xdc, 0xc2, 0x22, 0xcf, 0x5a, 0xbc, 0xc5, 0x9f, 0x68, 0x3f,
	0x67, 0x65, 0xc8, 0xb5, 0x9e, 0x3c, 0xd1, 0x7e, 0x89, 0x7b, 0xa0, 0xf2, 0xbc, 0xdb, 0x37, 0x9e,
	0xb5, 0x7a, 0x87, 0x1d, 0xed, 0x97, 0xd9, 0x08, 0x1e, 0xf0, 0xdd, 0x0e, 0xd7, 0x7e, 0x99, 0x47,
	0x78, 0x7f, 0xd0, 0x1f, 0x8c, 0x06, 0xfd, 0x6e, 0x5b, 0xfb, 0x65, 0x59, 0xff, 0x55, 0x1e, 0xf2,
	0xd8, 0x8d, 0xef, 0x56, 0x0d, 0xec, 0x15, 0xc8, 0x4c, 0x68, 0x76, 0xaa, 0xdb, 0x55, 0x41, 0x23,
	0x1f, 0x66, 0x6f, 0x8d, 0x67, 0x70, 0x6c, 0x32, 0x62, 0x8f, 0x57, 0xb7, 0x1b, 0x72, 0xdd, 0x48,
	0x6b, 0x80, 0xf4, 0x39, 0xbb, 0x03, 0x99, 0x17, 0x72, 0xc3, 0xd7, 0x04, 0x5d, 0xd8, 0x03, 0xa4,
	0xbe, 0x60, 0x5b, 0x90, 0x9b, 0x78, 0xc2, 0x3f, 0x89, 0xe9, 0x42, 0xa5, 0xee, 0xad, 0x71, 0x24,
	0xb1, 0xd7, 0x21, 0xe7, 0x9b, 0x67, 0xb4, 0x39, 0xe2, 0xf9, 0x89, 0x75, 0x36, 0x32, 0xf9, 0xe6,
	0x19, 0x0a, 0x31, 0xa5, 0x2d, 0x12, 0x0b, 0x11, 0x4d, 0x30, 0x36, 0x33, 0x65, 0x5b, 0x90, 0x39,
	0xa3, 0x4d, 0x12, 0x9b, 0xe4, 0xe7, 0x8e, 0x6b, 0x79, 0x67, 0xc3, 0xb9, 0x3d, 0x41, 0x8e, 0x33,
	0xf6, 0x26, 0xe4, 0x82, 0xc5, 0x98, 0x36, 0x49, 0x75, 0x7b, 0x63, 0x45, 0xdd, 0x61, 0x43, 0xc1,
	0x62, 0xcc, 0xde, 0x82, 0xfc, 0xc4, 0xf3, 0x7d, 0xb9, 0x51, 0xb4, 0x48, 0xe0, 0xc8, 0x0e, 0xa0,
	0x8b, 0x82, 0x74, 0x6c, 0x30, 0x24, 0x0f, 0x27, 0x66, 0x4a, 0x14, 0x31, 0x36, 0x18, 0xb2, 0x37,
	0xa4, 0x76, 0xaf, 0xa9, 0x52, 0x47, 0xba, 0x1f, 0xeb, 0x41, 0x2a, 0xd3, 0x21, 0x77, 0x6a, 0x9e,
	0x93, 0xff, 0x13, 0x33, 0x45, 0x4a, 0x1f, 0x65, 0x3a, 0x35, 0xcf, 0xd1, 0x40, 0x99, 0x8b, 0x73,
	0xdc, 0x41, 0x0d, 0x61, 0x4a, 0xcc, 0xc5, 0x79, 0xd7, 0x42, 0x65, 0xe4, 0x5a, 0x2f, 0xc8, 0x0b,
	0xca, 0x70, 0xfc, 0x44, 0xf7, 0x37, 0xb0, 0x67, 0xf6, 0x24, 0x74, 0x5e, 0x38, 0xe1, 0x05, 0xf9,
	0x3f, 0x19, 0xae, 0xa2, 0x76, 0x8a, 0x90, 0xb7, 0xcf, 0xe7, 0xbe, 0x7e, 0x0b, 0x2a, 0xb1, 0x7b,
	0xc3, 0x6a, 0x90, 0x31, 0xa5, 0x42, 0xcc, 0x98, 0xfa, 0x7d, 0xf4, 0x36, 0x22, 0x07, 0x26, 0x4d,
	0x43, 0x28, 0x52, 0x93, 0x99, 0xb1, 0xfe, 0x13, 0xa8, 0x71, 0x3b, 0x58, 0xcc, 0xc2, 0xb6, 0x37,
	0xdb, 0xb5, 0xa7, 0xec, 0x5d, 0x80, 0x18, 0x0e, 0xa4, 0x55, 0x4b, 0xa6, 0x7c, 0xd7, 0x9e, 0x72,
	0x85, 0xae, 0xff, 0x59, 0x8e, 0x6c, 0xfd, 0xae, 0x30, 0xcc, 0xd2, 0x02, 0x67, 0x14, 0x0b, 0x1c,
	0x6b, 0x94, 0x6c, 0xda, 0xa1, 0x38, 0x76, 0x2c, 0xcb, 0x76, 0x23, 0xc7, 0x41, 0x40, 0xec, 0x0d,
	0xc8, 0x99, 0xb3, 0x23, 0x5a, 0x87, 0x8d, 0x6d, 0x16, 0x35, 0x7a, 0x3a, 0xf7, 0xed, 0x20, 0x10,
	0x0b, 0xdd, 0x9c, 0x1d, 0x45, 0xdb, 0xa0, 0x70, 0xf9, 0x36, 0xb8, 0x05, 0x65, 0xd7, 0x0b, 0x0d,
	0x72, 0xda, 0x8b, 0x54, 0x7b, 0x49, 0x86, 0x0e, 0xec, 0x6d, 0x28, 0x49, 0x77, 0x4b, 0xae, 0x42,
	0xa9, 0x42, 0x77, 0x05, 0x92, 0x47, 0x54, 0xd6, 0x44, 0x77, 0xe0, 0xf4, 0xd4, 0x76, 0xc3, 0x48,
	0x67, 0x4b, 0x90, 0xfd, 0x08, 0x2a, 0x9e, 0x6b, 0x08, 0x9f, 0x4c, 0x2e, 0x43, 0x39, 0xdf, 0x03,
	0xf7, 0x90, 0xb0, 0xbc, 0xec, 0xc9, 0x2f, 0x14, 0x65, 0xe6, 0x9d, 0x19, 0x13, 0xd3, 0xb7, 0x68,
	0x29, 0x96, 0x79, 0x69, 0xe6, 0x9d, 0xb5, 0x4d, 0xdf, 0x12, 0x36, 0xec, 0x1b, 0x77, 0x71, 0x4a,
	0xcb, 0xaf, 0xce, 0x25, 0xc4, 0xee, 0x40, 0x65, 0x32, 0x5b, 0x04, 0xa1, 0xed, 0xef, 0x5c, 0x08,
	0x2f, 0x9b, 0x27, 0x08, 0x94, 0x6b, 0xee, 0x3b, 0xa7, 0xa6, 0x7f, 0x41, 0x6b, 0xad, 0xcc, 0x23,
	0x10, 0x3d, 0x8b, 0xf9, 0x89, 0x63, 0x9d, 0x47, 0x8b, 0x8b, 0x00, 0xfd, 0x1b, 0x28, 0xc9, 0xbe,
	0xa1, 0x72, 0xc4, 0x35, 0x93, 0x56, 0x1e, 0x42, 0x39, 0x22, 0x9e, 0xbd, 0x0e, 0x75, 0xcf, 0x77,
	0x8e, 0x1c, 0xd7, 0x08, 0x42, 0xdf, 0x71, 0x8f, 0xe4, 0x7c, 0xd5, 0x04, 0x72, 0x48, 0x38, 0xd4,
	0xe8, 0x38, 0xae, 0x86, 0x39, 0x76, 0x66, 0xb8, 0x36, 0x73, 0x32, 0x34, 0x5b, 0xcc, 0x66, 0x2d,
	0x81, 0xd2, 0x07, 0x50, 0x8e, 0x46, 0xe2, 0x77, 0xd2, 0xa6, 0xfe, 0x7b, 0x50, 0xed, 0xba, 0x96,
	0x7d, 0x3e, 0x20, 0x23, 0xc5, 0xde, 0x05, 0x36, 0xf1, 0x6d, 0x33, 0xb4, 0x0d, 0xfb, 0x3c, 0xf4,
	0x4d, 0x43, 0x84, 0x6f, 0x22, 0x3a, 0xd3, 0x04, 0xa5, 0x83, 0x84, 0x11, 0x45, 0x72, 0xff, 0x3e,
	0x03, 0xf5, 0x03, 0x31, 0x44, 0x4f, 0xed, 0x8b, 0x5d, 0xe1, 0xdf, 0x4e, 0xa2, 0x85, 0x9d, 0xe7,
	0xf4, 0xcd, 0xee, 0x42, 0x75, 0x7e, 0x62, 0x5f, 0x18, 0x29, 0x07, 0xb2, 0x82, 0xa8, 0x36, 0x2d,
	0xe1, 0x77, 0xa0, 0xe8, 0x51, 0xeb, 0x52, 0x83, 0x4a, 0xc5, 0xa3, 0x88, 0xc5, 0x25, 0x03, 0xd3,
	0xa1, 0x1e, 0x57, 0xa5, 0x1a, 0x3d, 0x59, 0x19, 0x19, 0xbd, 0x4d, 0x28, 0x20, 0x29, 0x68, 0x16,
	0xb6, 0x72, 0xe8, 0x05, 0x12, 0xc0, 0xde, 0x83, 0xfa, 0xc4, 0x3b, 0x9d, 0x1b, 0x51, 0x71, 0xa9,
	0x4b, 0xd3, 0x5b, 0xaf, 0x8a, 0x2c, 0x07, 0xa2, 0x2e, 0xfd, 0x6f, 0x66, 0xa1, 0x4c, 0x32, 0xc8,
	0xdd, 0xe7, 0x58, 0xe7, 0xd1, 0xee, 0xab, 0xf0, 0x82, 0x63, 0xa1, 0x7a, 0x79, 0x15, 0xc0, 0x41,
	0x16, 0x43, 0xd9, 0x83, 0x15, 0xc2, 0x44, 0xa2, 0xcc, 0x4d, 0x3f, 0x0c, 0x9a, 0x39, 0x21, 0x0a,
	0x01, 0xb8, 0x38, 0x17, 0xae, 0xf3, 0xcd, 0x42, 0x48, 0x5f, 0xe6, 0x12, 0x62, 0xf7, 0x41, 0x13,
	0x95, 0xd1, 0xa0, 0xab, 0x56, 0xbb, 0x41, 0x78, 0x1a, 0xf3, 0xc8, 0x2d, 0x12, 0x3c, 0xf6, 0x39,
	0x6a, 0x4f, 0xb1, 0x0f, 0x81, 0x50, 0x1d, 0xc4, 0xa8, 0x3b, 0xac, 0x94, 0xde, 0x61, 0x4d, 0x28,
	0xbd, 0x70, 0x02, 0x07, 0x67, 0xb5, 0x2c, 0xd6, 0xb8, 0x04, 0x95, 0x69, 0xa8, 0xbc, 0x64, 0x1a,
	0xf4, 0x7f, 0x9d, 0x85, 0xfa, 0x63, 0xcf, 0xb7, 0x9d, 0x23, 0x37, 0x99, 0xf7, 0x15, 0xc7, 0x26,
	0x5a, 0x0b, 0x59, 0x65, 0x2d, 0xdc, 0x83, 0xea, 0x54, 0x14, 0x34, 0xc2, 0xb1, 0x08, 0x6c, 0xf2,
	0x1c, 0x24, 0x6a, 0x34, 0x9e, 0xe1, 0x1e, 0x88, 0x18, 0xa8, 0x70, 0x9e, 0x0a, 0x47, 0x85, 0x50,
	0x29, 0xb2, 0xcf, 0x49, 0x49, 0x58, 0xf6, 0xcc, 0x0e, 0xc5, 0x00, 0x35, 0xb6, 0x5f, 0x95, 0xf6,
	0x4e, 0x95, 0xe9, 0x21, 0xb7, 0xa7, 0x2d, 0x32, 0x7f, 0xa8, 0x33, 0x76, 0x89, 0x5d, 0x96, 0x95,
	0x0a, 0xa6, 0xf8, 0x5b, 0x96, 0x15, 0xfb, 0x4d, 0x1f, 0x41, 0x25, 0x46, 0xa3, 0xf3, 0xc2, 0x3b,
	0xd2, 0x61, 0x59, 0x63, 0x55, 0x28, 0xb5, 0x5b, 0xc3, 0x76, 0x6b, 0xb7, 0xa3, 0x65, 0x90, 0x34,
	0xec, 0x8c, 0x84, 0x93, 0x92, 0x65, 0xeb, 0x50, 0x45, 0x68, 0xb7, 0xf3, 0xb8, 0x75, 0xd8, 0x1b,
	0x69, 0x39, 0x56, 0x87, 0x4a, 0x7f, 0x60, 0xb4, 0xda, 0xa3, 0xee, 0xa0, 0xaf, 0xe5, 0xf5, 0x9f,
	0x43, 0xb9, 0x7d, 0x6c, 0x4f, 0x4e, 0xae, 0x1a, 0x45, 0x8a, 0x17, 0xec, 0xc9, 0x89, 0xf4, 0x3d,
	0x96, 0xe2, 0x05, 0x7b, 0x72, 0xa2, 0x3f, 0x83, 0x5a, 0x3b, 0xd2, 0x61, 0x57, 0xd5, 0xb2, 0x0d,
	0x0d, 0x5a, 0xfe, 0x93, 0x71, 0xb4, 0xfe, 0xb3, 0x97, 0xac, 0xff, 0x1a, 0xf2, 0xb4, 0xc7, 0x72,
	0x03, 0x7c, 0x04, 0xd5, 0x03, 0xdf, 0x9b, 0xdb, 0x7e, 0x48, 0xd5, 0x6a, 0x90, 0x3b, 0xb1, 0x2f,
	0x64, 0xad, 0xf8, 0x99, 0xc4, 0x5b, 0x59, 0x35, 0xde, 0xda, 0x86, 0x72, 0x54, 0xec, 0xb7, 0x2e,
	0xf3, 0x33, 0xd4, 0x23, 0x54, 0xc6, 0xb1, 0x03, 0x6c, 0xec, 0x21, 0xc0, 0x3c, 0x46, 0x48, 0x33,
	0x19, 0x79, 0x56, 0xb2, 0x72, 0xae, 0x70, 0xe8, 0x7f, 0x99, 0x83, 0xc6, 0x81, 0xe9, 0x87, 0x0e,
	0x4e, 0x8e, 0x18, 0x86, 0xb7, 0x21, 0x1f, 0x5e, 0xcc, 0x6d, 0x19, 0xbc, 0x5d, 0x8b, 0xdd, 0x32,
	0xc1, 0x43, 0x16, 0x8d, 0x18, 0xd8, 0xe7, 0xd0, 0x98, 0x47, 0x68, 0x83, 0x34, 0xaa, 0x18, 0x9b,
	0xe5, 0x22, 0x34, 0xe6, 0xf5, 0xb9, 0x0a, 0xb2, 0x9f, 0xc2, 0x66, 0xba, 0xac, 0x1d, 0x04, 0x89,
	0x26, 0x53, 0x27, 0xeb, 0x5a, 0xaa, 0xa0, 0x60, 0x63, 0x6d, 0xd8, 0x48, 0x8a, 0x4f, 0xbc, 0xd9,
	0xe2, 0xd4, 0x0d, 0xa4, 0x9f, 0x78, 0x63, 0xa9, 0xf5, 0xb6, 0xa0, 0x72, 0x6d, 0xbe, 0x84, 0x61,
	0x3a, 0xd4, 0x62, 0x5c, 0x7f, 0x71, 0x4a, 0x5b, 0x22, 0xcf, 0x53, 0x38, 0xf6, 0x01, 0x40, 0x0c,
	0x07, 0xcd, 0x22, 0x8d, 0xe7, 0x72, 0xff, 0xba, 0xa1, 0x7d, 0xca, 0x15, 0x36, 0xb4, 0x96, 0xe6,
	0xec, 0xc8, 0xf3, 0x9d, 0xf0, 0xf8, 0x94, 0xf4, 0x48, 0x8e, 0x27, 0x08, 0x52, 0x57, 0x81, 0x81,
	0xf1, 0x45, 0x5c, 0x44, 0xaa, 0x94, 0x86, 0x13, 0x0c, 0x17, 0xe3, 0xb8, 0x5e, 0x34, 0x44, 0x49,
	0x2f, 0x4f, 0x83, 0x23, 0x19, 0x85, 0x25, 0x12, 0xee, 0x07, 0x47, 0x6c, 0x1b, 0xae, 0x27, 0x4c,
	0x89, 0x06, 0x0c, 0x9a, 0x40, 0xba, 0x33, 0x19, 0xbe, 0x58, 0x0d, 0x06, 0xfa, 0x17, 0x50, 0x4f,
	0xcd, 0xce, 0x4b, 0x4d, 0xe2, 0x2d, 0x28, 0xe3, 0x7f, 0x34, 0x88, 0x72, 0x01, 0x96, 0x10, 0x1e,
	0x86, 0xbe, 0x6e, 0x83, 0xb6, 0x3c, 0xd6, 0xec, 0x0d, 0xca, 0x5b, 0xd0, 0xa4, 0xac, 0xe6, 0x1f,
	0x22, 0x12, 0x06, 0x9a, 0xab, 0x93, 0x98, 0x25, 0xa9, 0x57, 0x26, 0x4b, 0xff, 0x8b, 0xac, 0x22,
	0x33, 0x8e, 0x38, 0x7b, 0x53, 0x5d, 0x7e, 0xca, 0xc6, 0x4d, 0xc6, 0x8c, 0x74, 0xfe, 0x3b, 0xa0,
	0x79, 0xbe, 0xe5, 0xb8, 0x26, 0xe5, 0x51, 0xc4, 0x70, 0x67, 0xc9, 0xb9, 0x59, 0x97, 0xf8, 0x03,
	0x89, 0x46, 0x17, 0xd7, 0xb2, 0xe3, 0xc0, 0x53, 0x86, 0x8d, 0x2a, 0x4a, 0xb5, 0x0f, 0xf9, 0xb4,
	0x7d, 0x78, 0x1b, 0x2a, 0x33, 0x3b, 0x08, 0x8c, 0xf0, 0xd8, 0x74, 0xc9, 0x82, 0xa6, 0x3b, 0x5d,
	0x46, 0xe2, 0xe8, 0xd8, 0x74, 0x91, 0xd1, 0x71, 0x0d, 0xda, 0xbe, 0xd1, 0x82, 0x4a, 0x31, 0x3a,
	0x2e, 0xf9, 0xe7, 0x68, 0x79, 0x37, 0x2f, 0x9b, 0x58, 0x69, 0x98, 0xd8, 0xea, 0xbc, 0xea, 0xaf,
	0x42, 0xe9, 0x99, 0x63, 0x9f, 0x49, 0x5d, 0xf6, 0xc2, 0xb1, 0xcf, 0x22, 0x5d, 0x86, 0xdf, 0xfa,
	0x5f, 0x94, 0xa1, 0x4c, 0xcc, 0xbb, 0x57, 0xe7, 0xab, 0xbe, 0x8f, 0x5b, 0xbc, 0x25, 0xed, 0x54,
	0xfe, 0x12, 0x67, 0x5c, 0x58, 0xad, 0x57, 0x41, 0x18, 0x57, 0x83, 0x14, 0x8a, 0xb0, 0xc9, 0x15,
	0xc2, 0xc8, 0x9c, 0x52, 0x45, 0xb8, 0x46, 0xc1, 0x37, 0x33, 0x99, 0xc0, 0x48, 0x10, 0xec, 0x21,
	0x94, 0x51, 0x42, 0x0a, 0xb0, 0x4b, 0xaa, 0x62, 0xa1, 0x3e, 0x44, 0x21, 0x1a, 0x2f, 0x85, 0xe3,
	0x19, 0x02, 0x64, 0xa1, 0x6d, 0x3f, 0x88, 0xb6, 0x53, 0x9d, 0x47, 0x20, 0x6a, 0x34, 0x74, 0x5f,
	0x64, 0x48, 0x15, 0x6d, 0x5f, 0xd5, 0xff, 0xe2, 0xc4, 0xc0, 0xee, 0x43, 0x89, 0x3c, 0x06, 0x3b,
	0x68, 0xd6, 0x54, 0xd5, 0x19, 0xb9, 0x33, 0x3c, 0x22, 0xb3, 0x77, 0xa0, 0x30, 0x3d, 0xb1, 0x2f,
	0x82, 0x66, 0x5d, 0x55, 0x09, 0x29, 0x5b, 0xc8, 0x05, 0x07, 0x7b, 0x03, 0x1a, 0xbe, 0x3d, 0x35,
	0x28, 0x47, 0x85, 0xc6, 0x3b, 0x68, 0x36, 0xc8, 0x36, 0xd7, 0x7c, 0x7b, 0xda, 0x46, 0xe4, 0x68,
	0x3c, 0x0b, 0xd8, 0x5b, 0x50, 0x24, 0xab, 0x14, 0x34, 0xd7, 0xd5, 0x96, 0x23, 0x13, 0xc7, 0x25,
	0x95, 0x6d, 0x43, 0x25, 0x51, 0x1b, 0xd7, 0xa9, 0x43, 0x9b, 0x4b, 0xfa, 0x88, 0xd4, 0x38, 0x4f,
	0xd8, 0xd8, 0xfb, 0x00, 0xd2, 0x59, 0x37, 0xc6, 0x17, 0x94, 0xc2, 0xad, 0xc6, 0x61, 0x8c, 0x62,
	0x00, 0x55, 0x97, 0xfe, 0x6d, 0x28, 0xa0, 0x95, 0x08, 0x9a, 0x37, 0x49, 0x9a, 0x8d, 0xb4, 0x09,
	0xa1, 0xde, 0x11, 0x9d, 0xdd, 0x87, 0x32, 0x2e, 0x2e, 0x03, 0xa7, 0xb0, 0xa9, 0x46, 0x2f, 0x72,
	0x25, 0xa2, 0x9f, 0x64, 0x9f, 0x0d, 0xbf, 0x99, 0xb1, 0x07, 0x90, 0xb7, 0xec, 0x69, 0xd0, 0xbc,
	0x45, 0x35, 0xde, 0x50, 0xe6, 0x12, 0x1d, 0x87, 0x5d, 0x7b, 0x2a, 0x4c, 0x0b, 0xf2, 0xb0, 0x3d,
	0x68, 0xe0, 0xd2, 0xdb, 0x26, 0xd7, 0x17, 0x87, 0xbc, 0x79, 0x9b, 0x4a, 0xbd, 0xb6, 0x54, 0xaa,
	0x2f, 0x99, 0x68, 0x82, 0x3a, 0x6e, 0xe8, 0x5f, 0xf0, 0xba, 0xab, 0xe2, 0xd8, 0x6d, 0x28, 0x3b,
	0x41, 0xcf, 0x9b, 0x9c, 0xd8, 0x56, 0xf3, 0x15, 0x71, 0x24, 0x13, 0xc1, 0xec, 0x33, 0xa8, 0xd3,
	0x62, 0x44, 0x10, 0x1b, 0x6f, 0xde, 0x51, 0x4d, 0xde, 0x48, 0x25, 0xf1, 0x34, 0x27, 0xba, 0x5b,
	0x4e, 0x60, 0x84, 0xf6, 0xe9, 0xdc, 0xf3, 0x31, 0xee, 0x79, 0x55, 0x84, 0x1c, 0x4e, 0x30, 0x8a,
	0x50, 0xa8, 0xe7, 0xe3, 0xd3, 0x20, 0xc3, 0x9b, 0x4e, 0x03, 0x3b, 0x6c, 0xde, 0xa5, 0xbd, 0xd6,
	0x88, 0x0e, 0x85, 0x06, 0x84, 0xbd, 0xfd, 0x84, 0xe2, 0x21, 0xaa, 0xf7, 0xa3, 0x25, 0xfb, 0x9d,
	0x5a, 0xb0, 0x8a, 0xa1, 0xdf, 0x5b, 0x53, 0xcd, 0xf8, 0x4e, 0x01, 0x72, 0x96, 0x3d, 0xbd, 0xfd,
	0x73, 0x60, 0xab, 0x23, 0xf2, 0x32, 0x67, 0xa2, 0x20, 0x9d, 0x89, 0xcf, 0xb3, 0x9f, 0x66, 0xf4,
	0xcf, 0xa0, 0x9e, 0xda, 0x5e, 0x97, 0x3a, 0x45, 0xc2, 0x3d, 0x37, 0x45, 0xde, 0xbd, 0xc6, 0x05,
	0x80, 0xce, 0x6d, 0x6d, 0xcf, 0x0c, 0x8e, 0xf7, 0xcd, 0xf9, 0x30, 0x34, 0xc3, 0x00, 0xc7, 0xe8,
	0xd8, 0x0c, 0x8e, 0x4f, 0xcd, 0xb9, 0xc8, 0xc9, 0x66, 0x44, 0xca, 0x40, 0xe2, 0x86, 0xce, 0xb7,
	0x36, 0xce, 0x0e, 0x82, 0x03, 0xf7, 0xe0, 0xa9, 0x4c, 0xe2, 0xc7, 0x30, 0xee, 0xe7, 0xe0, 0x78,
	0x31, 0x9d, 0xce, 0x6c, 0xa9, 0x77, 0x22, 0x90, 0xbd, 0x01, 0x75, 0xf9, 0x49, 0x81, 0xd0, 0xb9,
	0x3c, 0x52, 0x4b, 0x23, 0xd9, 0x07, 0x50, 0x95, 0x88, 0x51, 0xa4, 0x7d, 0x1a, 0x71, 0x72, 0x26,
	0x21, 0x70, 0x95, 0x2b, 0x5d, 0xf5, 0xbe, 0xe3, 0x92, 0x5a, 0xca, 0xf1, 0x34, 0x72, 0x89, 0xcb,
	0x3c, 0x97, 0x46, 0x3e, 0x8d, 0xc4, 0xe5, 0x25, 0x11, 0xfb, 0x76, 0x78, 0xec, 0x59, 0xa4, 0x96,
	0xe2, 0xe5, 0x35, 0x54, 0x49, 0x3c, 0xcd, 0xa9, 0xff, 0xe7, 0x0c, 0x14, 0xc4, 0x20, 0xbe, 0x02,
	0x95, 0xf1, 0xcc, 0x9b, 0x9c, 0x18, 0x18, 0x94, 0xcb, 0x5c, 0x29, 0x21, 0xd0, 0x3b, 0xa1, 0x48,
	0x21, 0x08, 0x69, 0xe8, 0x32, 0x9c, 0xbe, 0x51, 0x5b, 0x7b, 0x8b, 0x70, 0xe2, 0x86, 0x34, 0x6a,
	0x19, 0x2e, 0x21, 0x1c, 0x4e, 0xdf, 0x3b, 0xa3, 0x89, 0xc8, 0x13, 0x21, 0x02, 0x29, 0x1d, 0x4b,
	0x5a, 0x1a, 0x0b, 0x15, 0x88, 0x56, 0x26, 0x44, 0xdb, 0x0d, 0x97, 0xd3, 0x3e, 0xc5, 0x95, 0xb4,
	0x0f, 0xfb, 0x38, 0x9e, 0x66, 0x92, 0x58, 0xea, 0x6a, 0xa9, 0x5f, 0xd4, 0x05, 0xc1, 0x53, 0x7c,
	0xfa, 0x73, 0x00, 0xee, 0x9d, 0x05, 0x76, 0x48, 0x1e, 0xc8, 0x4d, 0x12, 0x2f, 0x75, 0x06, 0xe2,
	0x9d, 0x1d, 0x78, 0x41, 0x74, 0x2a, 0x94, 0x8d, 0x4f, 0x85, 0x62, 0x67, 0x25, 0x77, 0xb9, 0xb3,
	0xa2, 0x3f, 0x82, 0x12, 0x5a, 0x21, 0x33, 0x34, 0xd9, 0x1b, 0x90, 0xb7, 0xcc, 0xd0, 0x94, 0x5e,
	0x88, 0x4c, 0xa6, 0x25, 0xad, 0x72, 0xa2, 0xea, 0x8f, 0x22, 0x49, 0xa8, 0xcc, 0x6b, 0x4a, 0x28,
	0x1e, 0x6b, 0x33, 0x59, 0xa1, 0xb0, 0x6b, 0xfa, 0x7f, 0xc8, 0x40, 0x75, 0xe0, 0x5b, 0xa8, 0x29,
	0x87, 0x73, 0x7b, 0xf2, 0x52, 0xf7, 0x09, 0x0d, 0x9d, 0x37, 0x9b, 0x99, 0xb1, 0xf3, 0x81, 0x86,
	0x2e, 0x42, 0xb0, 0xf7, 0x21, 0x3f, 0x9d, 0x99, 0x47, 0xd4, 0x9f, 0x38, 0xac, 0x52, 0xaa, 0x8f,
	0xbe, 0x1f, 0xcf, 0xcc, 0x23, 0x4e, 0xac, 0xfa, 0x1f, 0xc6, 0xed, 0x53, 0xd6, 0x58, 0xcd, 0x15,
	0xaf, 0xd1, 0xf9, 0xc4, 0xb0, 0xad, 0x65, 0x58, 0x19, 0xf2, 0xbb, 0x9d, 0x61, 0x5b, 0x04, 0x53,
	0x18, 0x56, 0x0d, 0x8d, 0xc7, 0x5d, 0x3e, 0x1c, 0x69, 0x79, 0x3a, 0xf0, 0x20, 0x44, 0xaf, 0x35,
	0x1c, 0x69, 0x65, 0x06, 0x50, 0x3c, 0xec, 0x77, 0x7f, 0x71, 0xd8, 0xd1, 0x34, 0xfd, 0xdf, 0x65,
	0x00, 0x92, 0x0c, 0x27, 0xfb, 0x11, 0x54, 0xcf, 0x08, 0x32, 0x94, 0x5c, 0xb7, 0xda, 0x47, 0x10,
	0x64, 0x32, 0xc2, 0x3f, 0x56, 0x7c, 0x6a, 0x34, 0x36, 0xab, 0x49, 0xef, 0xea, 0x3c, 0xb1, 0x53,
	0xec, 0x5d, 0x28, 0x7b, 0xd8, 0x0f, 0x64, 0xcd, 0xa9, 0x96, 0x46, 0xe9, 0x3e, 0x2f, 0x79, 0x02,
	0x40, 0xa3, 0x34, 0xf5, 0xa3, 0xec, 0x45, 0xcc, 0xfa, 0x18, 0x51, 0xed, 0x99, 0xb9, 0x08, 0x6c,
	0x2e, 0xe8, 0xb1, 0xd2, 0x2a, 0x28, 0xa7, 0x75, 0x7f, 0x3f, 0x03, 0x55, 0x85, 0x95, 0x3d, 0x4a,
	0x85, 0x39, 0xaf, 0xac, 0xd4, 0x25, 0xbe, 0x95, 0x70, 0xe7, 0x2d, 0x28, 0x04, 0xa1, 0xe9, 0x87,
	0x32, 0xca, 0xd1, 0x94, 0x12, 0x3b, 0xde, 0xc2, 0xb5, 0xb8, 0x20, 0x33, 0x1d, 0x72, 0xb6, 0x6b,
	0xc9, 0xd5, 0xb9, 0xca, 0x85, 0x44, 0x7d, 0x0b, 0x2a, 0x71, 0xf5, 0x38, 0x4d, 0x7c, 0xf0, 0x7c,
	0xa8, 0xad, 0xb1, 0x0a, 0x14, 0x78, 0xab, 0xff, 0xa4, 0xa3, 0x65, 0xf4, 0x7f, 0x98, 0x01, 0x48,
	0x4a, 0xb1, 0x87, 0x29, 0x69, 0x6f, 0x2f, 0xd7, 0xfa, 0x90, 0xfe, 0x2a, 0xc2, 0xde, 0x81, 0xca,
	0xc2, 0x25, 0xa4, 0x6d, 0x49, 0xcd, 0x9a, 0x20, 0xd8, 0x1d, 0xc8, 0x45, 0x97, 0x01, 0x96, 0x0e,
	0x67, 0x5f, 0x98, 0x33, 0xfd, 0x73, 0xa8, 0xc4, 0xd5, 0x61, 0xd4, 0xfd, 0x78, 0xd0, 0xeb, 0x0d,
	0x9e, 0x77, 0xfb, 0x4f, 0xb4, 0x35, 0x04, 0x0f, 0x78, 0xa7, 0xdd, 0xd9, 0x45, 0x30, 0x83, 0xeb,
	0xaa, 0x7d, 0xc8, 0x79, 0xa7, 0x3f, 0x32, 0xf8, 0xe0, 0xb9, 0x96, 0xd5, 0xff, 0x46, 0x16, 0x36,
	0x06, 0xee, 0xee, 0x62, 0x3e, 0x73, 0x26, 0x66, 0x68, 0x3f, 0xb5, 0x2f, 0xda, 0xe1, 0x39, 0xfb,
	0x51, 0xa4, 0x61, 0x2c, 0x7b, 0x2a, 0x17, 0x50, 0x23, 0x6d, 0xc9, 0xa5, 0xc6, 0xd9, 0xa5, 0xb3,
	0x43, 0xcd, 0x73, 0x0d, 0x2b, 0xaa, 0xc2, 0x70, 0xac, 0x73, 0x5a, 0x46, 0x05, 0xde, 0xf0, 0x92,
	0x9a, 0x51, 0xc3, 0x7f, 0x09, 0x1b, 0x29, 0x4e, 0xa9, 0x15, 0x70, 0x19, 0xbd, 0x1b, 0x65, 0x3f,
	0x97, 0x44, 0x51, 0x31, 0xd8, 0x63, 0xe1, 0x33, 0xac, 0x7b, 0x69, 0xec, 0xed, 0x3e, 0x6c, 0x5e,
	0xc6, 0x78, 0x89, 0x29, 0xdd, 0x52, 0x4d, 0xe9, 0x52, 0x9a, 0x21, 0x31, 0xab, 0xff, 0x24, 0x0b,
	0x95, 0xae, 0x1b, 0xd8, 0x7e, 0x88, 0xc3, 0xf1, 0x1a, 0xe4, 0xfc, 0x78, 0x20, 0x56, 0x4e, 0x8d,
	0x90, 0xc6, 0x1e, 0xc0, 0x86, 0x69, 0x59, 0x86, 0x39, 0x9d, 0xda, 0x93, 0xd0, 0xb6, 0x0c, 0xd4,
	0xd5, 0x72, 0x1e, 0xd7, 0x4d, 0xcb, 0x6a, 0x49, 0x3c, 0xaa, 0x2d, 0x19, 0x50, 0x46, 0x1e, 0x9e,
	0xc8, 0x3c, 0xe6, 0xa2, 0x80, 0x52, 0x3a, 0x78, 0x34, 0xce, 0xe9, 0x79, 0xc8, 0xbf, 0x64, 0x1e,
	0x1e, 0xc2, 0xb5, 0xe5, 0xf8, 0xc3, 0xb1, 0x44, 0x76, 0x30, 0xcf, 0x37, 0xd2, 0xe1, 0x47, 0xd7,
	0x0a, 0xae, 0x0e, 0x44, 0x8b, 0x57, 0x06, 0xa2, 0xe9, 0x08, 0x17, 0x27, 0xba, 0x44, 0x6a, 0x3e,
	0xd1, 0x21, 0x5d, 0xeb, 0x5c, 0xff, 0x8f, 0x59, 0x00, 0x6e, 0xcf, 0x67, 0xe6, 0xc4, 0xfe, 0x7f,
	0x67, 0xf4, 0xee, 0x61, 0x2c, 0x39, 0xb3, 0x43, 0xdb, 0x98, 0x78, 0xae, 0x15, 0x9d, 0xdd, 0x0a,
	0x54, 0xdb, 0xa3, 0x1d, 0x7d, 0xe9, 0xf0, 0x16, 0xbf, 0xf7, 0xf0, 0x96, 0xbe, 0xc7, 0xf0, 0x96,
	0x2f, 0x19, 0xde, 0xff, 0x96, 0x83, 0x6a, 0xcb, 0x35, 0x67, 0x17, 0xdf, 0xda, 0x74, 0x3a, 0x4b,
	0xb9, 0xd9, 0xf9, 0x22, 0x14, 0xa3, 0x26, 0x8e, 0x67, 0x2a, 0x84, 0xa1, 0xf1, 0xba, 0x07, 0x55,
	0x6f, 0x11, 0xc6, 0x74, 0x71, 0x60, 0x03, 0x02, 0x45, 0x0c, 0x71, 0x79, 0xf2, 0x35, 0x72, 0x4a,
	0x79, 0x72, 0xf9, 0x92, 0xf2, 0xb1, 0x2f, 0x12, 0x97, 0x27, 0x86, 0xd7, 0xa1, 0x1e, 0x3a, 0xa7,
	0x34, 0x6e, 0xc1, 0xe2, 0xd4, 0x16, 0x63, 0x97, 0x13, 0x57, 0x5a, 0xda, 0x12, 0x87, 0xb5, 0x9c,
	0xda, 0xa7, 0x9e, 0x7f, 0x21, 0x6a, 0x11, 0x5e, 0x1a, 0x08, 0x14, 0xd5, 0xf2, 0x2e, 0xb0, 0x33,
	0xd3, 0x09, 0x8d, 0x74, 0x55, 0xc2, 0x4f, 0xd3, 0x90, 0x32, 0x52, 0xab, 0xbb, 0x01, 0x45, 0xcb,
	0x09, 0x4e, 0xba, 0x03, 0x1a, 0xa1, 0x1c, 0x97, 0x10, 0xba, 0x46, 0xc1, 0x07, 0xdd, 0x81, 0x31,
	0xbe, 0x90, 0xe7, 0x2a, 0x39, 0x5e, 0x46, 0xc4, 0xce, 0x45, 0x48, 0x79, 0x67, 0x22, 0x8a, 0xde,
	0xd2, 0xe9, 0x31, 0x9d, 0xa7, 0xe4, 0x78, 0x03, 0xf1, 0x5d, 0x44, 0xb7, 0x11, 0x8b, 0xeb, 0x91,
	0x38, 0x65, 0xc7, 0x05, 0x6b, 0x95, 0x58, 0xd7, 0x91, 0x30, 0x20, 0xbc, 0xe0, 0xbd, 0x03, 0x15,
	0xd7, 0x0e, 0xcf, 0x3c, 0x1f, 0xa5, 0xa9, 0x89, 0xd1, 0x8b, 0x11, 0xe8, 0x30, 0x07, 0x13, 0xd3,
	0x45, 0xe1, 0xe9, 0xac, 0x05, 0xe5, 0x91, 0x30, 0xbb, 0x8b, 0x03, 0x8f, 0x3a, 0x86, 0xa8, 0x0d,
	0x31, 0x24, 0x09, 0x46, 0xff, 0x3b, 0x9b, 0x90, 0xef, 0x7b, 0x96, 0xcd, 0xde, 0x83, 0x0a, 0xdd,
	0xb9, 0x58, 0x4d, 0xf3, 0x21, 0x99, 0xfe, 0x90, 0x29, 0x29, 0xbb, 0xf2, 0xeb, 0xea, 0x5b, 0x1a,
	0xaf, 0x91, 0x51, 0xa4, 0x4c, 0xbd, 0x72, 0xc2, 0x2b, 0xdc, 0x3d, 0x41, 0x41, 0x91, 0x29, 0xf6,
	0xf5, 0x6d, 0x97, 0x52, 0x05, 0x05, 0x1e, 0xc3, 0xe4, 0x2e, 0xf8, 0x1e, 0xee, 0x5d, 0x83, 0xce,
	0x33, 0x0b, 0x97, 0xb8, 0x0b, 0x82, 0x4e, 0x97, 0x5a, 0xde, 0x83, 0xca, 0xd7, 0x9e, 0xe3, 0x0a,
	0xc1, 0x8b, 0x2b, 0x82, 0x7f, 0xe1, 0x39, 0x22, 0x3f, 0x59, 0xfe, 0x5a, 0x7e, 0xb1, 0xd7, 0xa1,
	0xe4, 0xb9, 0xa2, 0xee, 0xd2, 0x4a, 0xdd, 0x45, 0xcf, 0xed, 0x89, 0x73, 0xd2, 0xfa, 0x78, 0x81,
	0xd1, 0x39, 0xb2, 0xda, 0xd3, 0x50, 0xa6, 0xe3, 0xaa, 0x84, 0x1c, 0xb8, 0x3d, 0x7b, 0x1a, 0xa2,
	0x17, 0x34, 0x75, 0x66, 0xa8, 0x22, 0xa8, 0xb2, 0xca, 0x4a, 0x65, 0x20, 0xc8, 0x54, 0xe1, 0x9b,
	0x50, 0x3e, 0xf2, 0xbd, 0xc5, 0x1c, 0xdd, 0x1a, 0x58, 0x4d, 0x80, 0x11, 0x6d, 0xe7, 0x02, 0x7b,
	0x4f, 0x9f, 0x8e, 0x7b, 0x64, 0x60, 0x74, 0x58, 0x5d, 0xed, 0x7d, 0x44, 0x1f, 0xda, 0x54, 0xab,
	0x79, 0x74, 0x64, 0xc8, 0x83, 0xdf, 0x95, 0x5a, 0xcd, 0xa3, 0x23, 0x6a, 0xfc, 0x21, 0xd4, 0xcf,
	0x1c, 0xd7, 0x08, 0xe6, 0xf6, 0x44, 0xf0, 0xd6, 0x57, 0xab, 0x3d, 0x73, 0x5c, 0x74, 0xad, 0x88,
	0x5f, 0xf5, 0xc1, 0x1a, 0x2f, 0xf5, 0xc1, 0xb6, 0xa0, 0x30, 0x73, 0x4e, 0x9d, 0x90, 0x8e, 0x86,
	0x97, 0xec, 0x1d, 0x11, 0x98, 0x0e, 0x45, 0x19, 0xed, 0x6a, 0x2b, 0x2c, 0x92, 0x92, 0x56, 0xa5,
	0xec, 0x25, 0xaa, 0x74, 0x5b, 0x86, 0xe9, 0xc8, 0x6c, 0xbc, 0xb0, 0x27, 0xcd, 0x6b, 0x6a, 0x86,
	0x24, 0x2e, 0x50, 0x8d, 0x0a, 0x3c, 0xb3, 0x27, 0xec, 0x3e, 0x94, 0xbc, 0xf1, 0xd7, 0x06, 0x1a,
	0x8a, 0xcd, 0xcb, 0x0d, 0x45, 0xd1, 0x1b, 0x7f, 0xcd, 0xed, 0x29, 0x7b, 0x1f, 0xaa, 0x3e, 0x39,
	0xff, 0x06, 0x45, 0x0a, 0xd7, 0x55, 0xb7, 0x2d, 0x89, 0x0a, 0x38, 0xf8, 0x49, 0x84, 0xf0, 0x3a,
	0xd4, 0xc5, 0x29, 0x9f, 0x38, 0xd6, 0x09, 0x28, 0xa5, 0x52, 0xe1, 0x35, 0x42, 0x8a, 0x23, 0x9f,
	0x80, 0x3d, 0x04, 0x88, 0x0c, 0x40, 0x78, 0x4e, 0x77, 0xe3, 0x62, 0x21, 0xc4, 0x99, 0x4a, 0x3b,
	0x3c, 0xe7, 0x15, 0x2b, 0xfa, 0xc4, 0x68, 0x79, 0xec, 0xb8, 0x16, 0xae, 0x85, 0xd0, 0x3c, 0x0a,
	0x9a, 0x4d, 0xda, 0x2a, 0x55, 0x89, 0x1b, 0x99, 0x47, 0x01, 0xfb, 0x10, 0x6a, 0xa6, 0x50, 0xd4,
	0xe2, 0xc2, 0xcd, 0x2d, 0xd5, 0x0d, 0x56, 0x54, 0x38, 0xaf, 0x9a, 0x8a, 0x3e, 0xff, 0x04, 0x58,
	0x94, 0x47, 0x23, 0x0f, 0x49, 0x2c, 0x8a, 0xdb, 0x2b, 0x8b, 0x62, 0x5d, 0x26, 0xd2, 0xe2, 0x2b,
	0x64, 0x9f, 0x40, 0x3d, 0x6d, 0x16, 0xef, 0x5c, 0x92, 0x39, 0xa2, 0xe1, 0xe7, 0xb5, 0x89, 0x6a,
	0x28, 0x5f, 0x87, 0xba, 0xeb, 0x85, 0xc6, 0xc4, 0x9c, 0x1c, 0xdb, 0x54, 0x50, 0x64, 0x47, 0x6a,
	0xae, 0x17, 0xb6, 0x23, 0x1c, 0x8e, 0x8f, 0xd0, 0x4d, 0x34, 0x3e, 0x77, 0xd5, 0xf1, 0x89, 0x3d,
	0x25, 0xb4, 0x1b, 0x91, 0xd3, 0x84, 0xf3, 0x24, 0x9c, 0x00, 0x2a, 0x70, 0x2f, 0x35, 0x4f, 0xb1,
	0x77, 0xc0, 0xc1, 0x4f, 0x3c, 0x85, 0x7b, 0x50, 0x0d, 0xbc, 0x85, 0x3f, 0xb1, 0x8d, 0x20, 0xb4,
	0xe7, 0xcd, 0x2d, 0x1a, 0x51, 0x10, 0xa8, 0x61, 0x68, 0xcf, 0xd9, 0xa7, 0xd0, 0x98, 0xfb, 0xb6,
	0xa1, 0xcc, 0xd3, 0x6b, 0x6a, 0x17, 0x0f, 0x7c, 0x3b, 0x99, 0xaa, 0xda, 0x5c, 0x81, 0xa2, 0x92,
	0x4a, 0x0f, 0xf4, 0xa5, 0x92, 0x49, 0x27, 0xb0, 0x64, 0xe2, 0xfc, 0xfd, 0x0c, 0x36, 0x94, 0x92,
	0x8b, 0x13, 0x2a, 0xfc, 0x7a, 0x2a, 0x91, 0x17, 0xb1, 0x1f, 0x9e, 0x60, 0xf1, 0xc6, 0x3c, 0x05,
	0xb3, 0xd6, 0x92, 0x7f, 0x8c, 0x0e, 0xe9, 0x1b, 0x54, 0xfe, 0xe6, 0x15, 0x4e, 0x6f, 0xca, 0x71,
	0x7e, 0x2a, 0xf2, 0x3f, 0xdd, 0xa0, 0xe3, 0x5a, 0xcd, 0x37, 0xc5, 0x95, 0x4d, 0x02, 0xd8, 0x07,
	0x50, 0xa3, 0x4c, 0x43, 0x48, 0x97, 0x4d, 0x82, 0xe6, 0x5b, 0x6a, 0xd0, 0x4c, 0x99, 0x2f, 0x22,
	0xf0, 0xea, 0x2c, 0xfe, 0x0e, 0xd8, 0xc7, 0xb0, 0x21, 0xf2, 0x13, 0xaa, 0x76, 0x7c, 0x7b, 0x75,
	0x71, 0x11, 0xd3, 0xe3, 0x44, 0x45, 0x72, 0xb8, 0xe5, 0x2f, 0x5c, 0xb2, 0xce, 0xb2, 0xe4, 0xdc,
	0xf7, 0xc6, 0xb6, 0x28, 0x7f, 0x9f, 0xca, 0xcb, 0xee, 0x70, 0xc1, 0x26, 0xca, 0x92, 0x32, 0xba,
	0xe1, 0xab, 0xa8, 0x03, 0x2c, 0x77, 0x45, 0x9d, 0x42, 0xad, 0x53, 0x9d, 0xef, 0x7c, 0x9f, 0x3a,
	0x77, 0xb0, 0x1c, 0xd5, 0xc9, 0x20, 0xbf, 0x58, 0x38, 0x56, 0xf3, 0x01, 0xa5, 0xba, 0xe8, 0x5b,
	0xff, 0xe7, 0x79, 0x28, 0x47, 0x46, 0x92, 0x55, 0xa1, 0x74, 0xd8, 0x7f, 0xda, 0x1f, 0x3c, 0xef,
	0x6b, 0x6b, 0x18, 0x56, 0xd3, 0xfd, 0x29, 0x63, 0xd8, 0x6e, 0xf5, 0xc5, 0xbd, 0x42, 0xba, 0xb5,
	0x25, 0xe0, 0x2c, 0xdb, 0x80, 0xfa, 0xe3, 0xc3, 0x3e, 0x1d, 0x61, 0x0a, 0x54, 0x0e, 0x51, 0x9d,
	0x2f, 0x45, 0xec, 0x2e, 0x50, 0x79, 0x44, 0xed, 0xb7, 0x46, 0x1d, 0xde, 0x8d, 0x50, 0x05, 0x6c,
	0xe5, 0x80, 0x0f, 0xbe, 0xe8, 0xb4, 0x47, 0x1a, 0xb0, 0xeb, 0xb0, 0x11, 0x17, 0x89, 0xaa, 0xd3,
	0xaa, 0xac, 0x06, 0xe5, 0xa8, 0x98, 0xb6, 0x89, 0x95, 0xf0, 0x4e, 0xfb, 0x90, 0x0f, 0xbb, 0xcf,
	0x3a, 0x46, 0x7b, 0xd4, 0xd1, 0xae, 0x63, 0xa0, 0x39, 0xec, 0xf6, 0x9f, 0x6a, 0x37, 0x30, 0x8c,
	0xc3, 0x2f, 0x51, 0xfb, 0x4d, 0xc6, 0xa0, 0x91, 0xf0, 0x12, 0xae, 0x49, 0x59, 0x84, 0x27, 0x4f,
	0xb4, 0xbb, 0x58, 0xed, 0x6e, 0x77, 0x38, 0xea, 0xf6, 0xdb, 0x23, 0xed, 0x1e, 0x03, 0x28, 0x3e,
	0xee, 0xf6, 0x46, 0x1d, 0xae, 0x6d, 0x61, 0x7d, 0x5f, 0x0c, 0xba, 0x7d, 0xed, 0x35, 0xba, 0x84,
	0xd6, 0xda, 0x3f, 0xe8, 0x75, 0x34, 0x9d, 0x5a, 0x19, 0xf0, 0x91, 0xf6, 0x3a, 0x86, 0xb3, 0x87,
	0x7d, 0x94, 0xed, 0x0d, 0x6c, 0x90, 0x3e, 0x8d, 0x56, 0xaf, 0xa7, 0xbd, 0xa9, 0xa4, 0x1b, 0xde,
	0xc2, 0xef, 0xe7, 0xdd, 0xfe, 0xee, 0xe0, 0xb9, 0xf6, 0x36, 0xb2, 0xed, 0xf0, 0x41, 0x6b, 0xb7,
	0xdd, 0x1a, 0x8e, 0xb4, 0xfb, 0x58, 0xc1, 0xf0, 0xa0, 0xd7, 0x1d, 0x69, 0xef, 0x20, 0xd7, 0x93,
	0xd6, 0x68, 0xaf, 0xc3, 0xb5, 0x07, 0xf8, 0xdd, 0x1a, 0x0e, 0x3b, 0x7c, 0xa4, 0x6d, 0xe3, 0x77,
	0xb7, 0x4f, 0xdf, 0x1f, 0xe0, 0xf7, 0x6e, 0xa7, 0xd7, 0x19, 0x75, 0xb4, 0x0f, 0x71, 0xc0, 0x78,
	0xe7, 0xa0, 0xd7, 0x6a, 0x77, 0xb4, 0x8f, 0x10, 0xe8, 0x0d, 0xda, 0x4f, 0x8d, 0xc1, 0x81, 0xf6,
	0x31, 0xb6, 0x41, 0xc9, 0x92, 0x21, 0x0e, 0xe6, 0x27, 0x38, 0x4e, 0x31, 0x48, 0xd2, 0x7d, 0x8a,
	0xcd, 0xee, 0x77, 0xfb, 0x87, 0x43, 0xed, 0x33, 0x64, 0xa6, 0x4f, 0xa2, 0x7c, 0xce, 0x36, 0x41,
	0x1b, 0xf4, 0x8d, 0xdd, 0xc3, 0x83, 0x5e, 0xb7, 0xdd, 0x1a, 0x75, 0x8c, 0xa7, 0x9d, 0xaf, 0xb4,
	0xdf, 0xc3, 0x59, 0x3e, 0xe0, 0x1d, 0x43, 0xca, 0xf1, 0x93, 0x08, 0x96, 0xb2, 0xfc, 0x14, 0x9b,
	0x48, 0xe8, 0xc6, 0xe1, 0x53, 0xed, 0xf7, 0xf5, 0xaf, 0xa1, 0x1c, 0x79, 0x2b, 0xd8, 0x5c, 0xb7,
	0xdf, 0xef, 0x70, 0x6d, 0x0d, 0xc7, 0xae, 0xd7, 0x79, 0x3c, 0xd2, 0x32, 0x94, 0x0a, 0xe8, 0x3e,
	0xd9, 0x1b, 0x69, 0x59, 0xfc, 0x1c, 0x1c, 0xe2, 0x88, 0xe7, 0x68, 0x6c, 0x3b, 0xfb, 0x5d, 0x2d,
	0x8f, 0x5f, 0xad, 0xfe, 0xa8, 0xab, 0x15, 0x68, 0xec, 0xbb, 0xfd, 0x27, 0xbd, 0x8e, 0x56, 0x44,
	0xec, 0x7e, 0x8b, 0x3f, 0xd5, 0x4a, 0x58, 0xa8, 0x75, 0x70, 0xd0, 0xfb, 0x4a, 0x2b, 0xeb, 0xf7,
	0xa1, 0xd4, 0x3a, 0x3a, 0xda, 0x47, 0xcf, 0xaf, 0x0c, 0xf9, 0xc7, 0x87, 0xbd, 0x9e, 0xb8, 0xfd,
	0xba, 0x33, 0x18, 0x8d, 0x06, 0xfb, 0x5a, 0x06, 0xa7, 0x7a, 0x34, 0x38, 0xd0, 0xb2, 0xfa, 0x1f,
	0xe7, 0x00, 0x92, 0x8d, 0xce, 0x6e, 0x41, 0x39, 0x0a, 0x4c, 0xe4, 0x29, 0x51, 0x29, 0x14, 0xe1,
	0x08, 0xdb, 0x86, 0x1b, 0xf2, 0x8e, 0x8f, 0xbc, 0x9e, 0x72, 0x6e, 0x38, 0xae, 0x31, 0x36, 0x43,
	0xe9, 0x1f, 0x32, 0x49, 0x15, 0xb9, 0xd8, 0xae, 0xbb, 0x63, 0x86, 0x6c, 0x1b, 0xd6, 0xd5, 0x32,
	0xe1, 0xc5, 0x3c, 0x9d, 0x81, 0x10, 0x79, 0xf6, 0xa4, 0xe0, 0xe8, 0x62, 0xce, 0xde, 0x83, 0xeb,
	0xbe, 0x3d, 0xf5, 0xed, 0xe0, 0xd8, 0x08, 0x03, 0xb5, 0x19, 0x91, 0xf2, 0xdd, 0x90, 0xc4, 0x51,
	0x10, 0xb7, 0xf2, 0x1e, 0x5c, 0x97, 0x9b, 0x7f, 0x49, 0x30, 0x71, 0x25, 0x78, 0x43, 0x10, 0x55,
	0xb9, 0x5e, 0x05, 0x90, 0x7a, 0x2f, 0x7a, 0x72, 0x51, 0xe6, 0x15, 0xa1, 0xe3, 0xd0, 0x50, 0xbd,
	0x0b, 0xcc, 0x09, 0x8c, 0xa5, 0xd8, 0x8b, 0x22, 0x89, 0x32, 0xd7, 0x9c, 0xe0, 0x20, 0x15, 0x77,
	0x5d, 0x15, 0xd6, 0x95, 0xaf, 0x0a, 0xeb, 0x36, 0xa1, 0x40, 0xaa, 0x91, 0xa2, 0x8b, 0x32, 0x17,
	0x80, 0xfe, 0xcf, 0x32, 0xd0, 0x48, 0x9b, 0x01, 0x71, 0xf4, 0x98, 0x9c, 0xa9, 0x16, 0x92, 0x73,
	0xd4, 0x57, 0xa0, 0x32, 0x3f, 0x91, 0x07, 0xa8, 0x72, 0xf8, 0xcb, 0xf3, 0x13, 0x71, 0x70, 0x8a,
	0x0e, 0xf0, 0xfc, 0x44, 0x38, 0xcc, 0xab, 0x83, 0x5d, 0x9c, 0x9f, 0x44, 0x5e, 0xf2, 0x42, 0x32,
	0xe5, 0x57, 0x99, 0x16, 0x82, 0x29, 0xe5, 0xb3, 0x15, 0xbe, 0xdb, 0x67, 0xd3, 0xb7, 0xa0, 0xa6,
	0x5a, 0x4f, 0xa6, 0x41, 0x0e, 0xe3, 0x4f, 0x21, 0x39, 0x7e, 0xea, 0x7f, 0x3b, 0x43, 0x2c, 0xdf,
	0x2b, 0x2b, 0x92, 0x12, 0x21, 0xfb, 0x12, 0xb7, 0x71, 0x8b, 0xf2, 0xd2, 0x06, 0x9d, 0xc1, 0x4c,
	0xbc, 0xe8, 0x31, 0x00, 0x1c, 0x9b, 0x41, 0x6b, 0x11, 0x7a, 0x6d, 0x6f, 0x86, 0x03, 0xe7, 0x04,
	0xd1, 0xa5, 0x96, 0x7c, 0x74, 0x38, 0x24, 0x6f, 0xad, 0x74, 0x60, 0x63, 0xc5, 0x4a, 0x60, 0x37,
	0x42, 0xf3, 0x28, 0x7a, 0xa2, 0x10, 0x9a, 0x47, 0x71, 0xea, 0x37, 0x7b, 0x45, 0x32, 0xfa, 0x0e,
	0x14, 0xbb, 0xb1, 0x25, 0x89, 0x6f, 0xe4, 0xe7, 0xe4, 0x2d, 0x7c, 0x0f, 0x2a, 0x6d, 0xba, 0xd1,
	0xbf, 0x6f, 0xce, 0xd9, 0x03, 0xc8, 0x9d, 0x9a, 0x73, 0x99, 0x77, 0x6e, 0xc6, 0x79, 0x67, 0x41,
	0x7d, 0xb8, 0x6f, 0xce, 0x45, 0xb2, 0x0a, 0x99, 0x6e, 0x7f, 0x0c, 0xe5, 0x08, 0xf1, 0xbd, 0xce,
	0x77, 0xfe, 0x47, 0x16, 0x2a, 0xbb, 0xaa, 0xcf, 0x39, 0x31, 0x5d, 0x23, 0xf4, 0x17, 0x2e, 0xba,
	0x06, 0xf2, 0xbe, 0x5a, 0x15, 0x03, 0x4a, 0x89, 0x8a, 0x66, 0x25, 0xfb, 0x1d, 0xb3, 0x72, 0x07,
	0xd0, 0x39, 0x36, 0x1c, 0x8b, 0x52, 0x0c, 0xe2, 0x45, 0x42, 0xd9, 0xf7, 0xce, 0xba, 0x56, 0xd7,
	0x3a, 0xbf, 0x3c, 0x17, 0x93, 0xff, 0xed, 0x73, 0x31, 0x85, 0x4b, 0x73, 0x31, 0xff, 0xb7, 0x64,
	0x4f, 0xd8, 0x5b, 0x89, 0x52, 0x3b, 0xb1, 0x2f, 0x88, 0xad, 0x22, 0x4e, 0xa3, 0xe6, 0xf1, 0x01,
	0x73, 0xd7, 0x3a, 0xd7, 0xff, 0x71, 0x16, 0x0a, 0xbf, 0x58, 0xd8, 0xfe, 0x05, 0xfb, 0x18, 0x2a,
	0x41, 0x78, 0x1a, 0xaa, 0xd1, 0xf7, 0x2d, 0x31, 0xae, 0x44, 0xa7, 0xe0, 0xd9, 0x3e, 0xb5, 0xdd,
	0x50, 0x84, 0xb2, 0xc8, 0x4b, 0xfb, 0x6f, 0x13, 0x43, 0x6d, 0x7b, 0x1e, 0xc8, 0x64, 0xa8, 0x00,
	0x30, 0x1e, 0xc3, 0x50, 0x3c, 0x90, 0x79, 0x4f, 0x48, 0xc2, 0x61, 0x2e, 0x08, 0x18, 0x8f, 0xd1,
	0x01, 0x5d, 0x74, 0x50, 0x9f, 0x8a, 0xc7, 0x04, 0x85, 0xce, 0xe1, 0x6c, 0x13, 0x03, 0x8d, 0xe8,
	0xfa, 0x5f, 0x0c, 0xa3, 0xe2, 0x99, 0x79, 0xa6, 0x35, 0x32, 0x8f, 0xa2, 0x8b, 0xab, 0x12, 0xd4,
	0x2d, 0xa8, 0xa7, 0x84, 0x4d, 0xfb, 0x42, 0x68, 0x97, 0x3a, 0x3d, 0x34, 0xb2, 0x19, 0xc5, 0x4a,
	0x67, 0x55, 0xcb, 0x9c, 0x53, 0x4c, 0x36, 0xdd, 0x64, 0x3f, 0x3c, 0xd8, 0x6d, 0x8d, 0x3a, 0x5a,
	0x81, 0x4c, 0x70, 0x87, 0x3f, 0xe9, 0x68, 0x45, 0xfd, 0xef, 0x66, 0x61, 0x63, 0xe4, 0x9b, 0x6e,
	0x60, 0x8a, 0xfb, 0x20, 0x6e, 0xe8, 0x7b, 0x33, 0xf6, 0x39, 0x94, 0xc3, 0xc9, 0x4c, 0x1d, 0xc4,
	0x7b, 0x52, 0x13, 0x2c, 0xb3, 0x3e, 0x1c, 0x4d, 0x66, 0x34, 0x94, 0xa5, 0x50, 0x7c, 0xb0, 0x1f,
	0x43, 0x61, 0x6c, 0x1f, 0x39, 0xae, 0x5c, 0xd5, 0xd7, 0x97, 0x0b, 0xee, 0x20, 0x71, 0x6f, 0x8d,
	0x0b, 0x2e, 0xf6, 0x1e, 0x14, 0x27, 0xde, 0x29, 0xc6, 0xbc, 0x39, 0xf5, 0x86, 0x91, 0xda, 0x10,
	0x52, 0xf7, 0xd6, 0xb8, 0xe4, 0x63, 0x1f, 0x43, 0xd9, 0xf7, 0x66, 0xb3, 0xb1, 0x39, 0x39, 0x91,
	0x0a, 0xb5, 0xb9, 0x5c, 0x86, 0x4b, 0xfa, 0xde, 0x1a, 0x8f, 0x79, 0xf5, 0x87, 0x50, 0x92, 0xc2,
	0xe2, 0x00, 0xec, 0x74, 0x9e, 0x74, 0xe5, 0x40, 0xb6, 0x07, 0xfb, 0xfb, 0xdd, 0x91, 0xb8, 0x23,
	0xc7, 0x07, 0xbd, 0xde, 0x4e, 0xab, 0xfd, 0x54, 0xcb, 0xee, 0x94, 0xa1, 0x68, 0xd2, 0x31, 0xad,
	0xfe, 0xc7, 0x19, 0x58, 0x5f, 0xea, 0x00, 0xfb, 0x14, 0xf2, 0xa7, 0x9e, 0x15, 0x0d, 0xcf, 0x1b,
	0x97, 0xf6, 0x52, 0x81, 0xd1, 0x41, 0xe0, 0x54, 0x42, 0xff, 0x0c, 0x1a, 0x69, 0xbc, 0xf2, 0x2e,
	0xa1, 0x0e, 0x15, 0xde, 0x69, 0xed, 0x1a, 0x83, 0x7e, 0xef, 0x2b, 0xe1, 0xe1, 0x12, 0xf8, 0x9c,
	0x77, 0x47, 0x1d, 0x2d, 0xab, 0xff, 0x21, 0x68, 0xcb, 0x03, 0xc3, 0x9e, 0xc0, 0xfa, 0xc4, 0x3b,
	0x9d, 0xcf, 0x6c, 0xb1, 0xfb, 0x92, 0x29, 0xbb, 0x7b, 0xc9, 0x48, 0x4a, 0x36, 0x9a, 0xb1, 0xc6,
	0x24, 0x05, 0xeb, 0xff, 0x1f, 0xb0, 0xd5, 0x11, 0xfc, 0xdd, 0x55, 0xff, 0x9b, 0x0c, 0xe4, 0x0f,
	0x66, 0x26, 0x1a, 0xcd, 0x02, 0xdd, 0xdd, 0x97, 0xc6, 0xa8, 0xaa, 0x6c, 0x4f, 0x5c, 0x16, 0x44,
	0x63, 0x3f, 0x82, 0x5c, 0x38, 0x89, 0xee, 0x03, 0xde, 0xbc, 0x62, 0xf1, 0xed, 0xad, 0x71, 0xe4,
	0x62, 0xf7, 0x21, 0x67, 0x59, 0xd1, 0x89, 0x8b, 0x8c, 0xf3, 0x76, 0xcd, 0xd0, 0xdc, 0xb5, 0xa7,
	0x8e, 0xeb, 0xc8, 0xb7, 0x06, 0xc8, 0xc2, 0xde, 0x84, 0x9c, 0x35, 0x99, 0xa5, 0x8f, 0xb8, 0x90,
	0x53, 0xa9, 0xd0, 0x9a, 0xcc, 0x98, 0x0e, 0xf5, 0xd0, 0xbf, 0x30, 0xfc, 0x85, 0x4b, 0x29, 0xce,
	0x40, 0xba, 0x37, 0x55, 0xb4, 0x10, 0x0b, 0xca, 0x07, 0x8a, 0x4c, 0x6c, 0x60, 0xcc, 0x7d, 0x7b,
	0x6e, 0xfa, 0xb1, 0x63, 0xe3, 0x04, 0x07, 0x02, 0xb1, 0x53, 0x04, 0x7a, 0x20, 0xab, 0xbf, 0x4b,
	0x37, 0xe4, 0xd1, 0x59, 0xd0, 0xa3, 0xaf, 0x4b, 0xae, 0x6d, 0x49, 0x8a, 0xfe, 0x3f, 0xb3, 0x50,
	0x55, 0xe4, 0x61, 0x1f, 0x42, 0xd9, 0x4a, 0x6f, 0xc4, 0x5b, 0x2b, 0x42, 0x3f, 0xdc, 0x8d, 0xb6,
	0xa0, 0x25, 0x97, 0xf7, 0x67, 0x50, 0x0f, 0xec, 0xd0, 0x78, 0x61, 0xfa, 0x0e, 0x2a, 0xdc, 0x40,
	0x0e, 0xa3, 0x0c, 0x9f, 0x87, 0x76, 0xf8, 0x2c, 0xa2, 0xec, 0xad, 0xf1, 0x5a, 0xa0, 0xc0, 0xec,
	0x1d, 0x28, 0x45, 0x5d, 0xca, 0xa5, 0x5e, 0x1c, 0x09, 0xe4, 0xde, 0x1a, 0x8f, 0xe8, 0xc8, 0x6a,
	0x9f, 0xdb, 0x93, 0x45, 0x18, 0xf9, 0x35, 0xf5, 0xa8, 0x43, 0x84, 0x44, 0x56, 0x49, 0x67, 0xdb,
	0x00, 0x96, 0x6d, 0xce, 0x66, 0x1e, 0x19, 0xc2, 0x82, 0x9a, 0x5d, 0xd8, 0x8d, 0xf1, 0xe2, 0x65,
	0x64, 0x04, 0xe9, 0x47, 0x50, 0x92, 0x1d, 0x43, 0x17, 0x7f, 0xd8, 0x19, 0x19, 0xcf, 0x5a, 0xbc,
	0x8b, 0xf1, 0x9e, 0x3c, 0xcc, 0x7b, 0xc2, 0x5b, 0x7d, 0xa9, 0xfe, 0x78, 0xe7, 0xd9, 0xe0, 0x69,
	0x47, 0xcb, 0x8a, 0x43, 0xd9, 0xfe, 0x57, 0x5a, 0x4e, 0xc4, 0x74, 0x9d, 0x83, 0x16, 0x47, 0xe5,
	0x57, 0x85, 0x52, 0xe7, 0xcb, 0x4e, 0xfb, 0x90, 0xb4, 0x5f, 0x03, 0x60, 0xb7, 0xd3, 0xea, 0xf5,
	0x06, 0x18, 0x64, 0x68, 0xc5, 0x9d, 0x0a, 0xfa, 0x7e, 0x34, 0x92, 0xfa, 0xbf, 0xa8, 0x43, 0x23,
	0xbd, 0x70, 0xd8, 0x27, 0x50, 0xb6, 0xac, 0xd4, 0x0c, 0xdc, 0xb9, 0x6c, 0x81, 0x3d, 0xdc, 0xb5,
	0xa2, 0x49, 0x10, 0x1f, 0xec, 0xb5, 0x68, 0x99, 0x67, 0x57, 0x96, 0x79, 0xb4, 0xc8, 0x7f, 0x06,
	0xeb, 0xf2, 0x5e, 0xbb, 0x65, 0x86, 0xe6, 0xd8, 0x0c, 0xec, 0xf4, 0x1a, 0x6e, 0x13, 0x71, 0x57,
	0xd2, 0xf6, 0xd6, 0x78, 0x63, 0x92, 0xc2, 0xb0, 0x9f, 0x40, 0xc3, 0x24, 0x6f, 0x3c, 0x2e, 0x9f,
	0x57, 0x2f, 0xb5, 0xb4, 0x90, 0xa6, 0x14, 0xaf, 0x9b, 0x2a, 0x02, 0x97, 0x89, 0xe5, 0x7b, 0xf3,
	0xa4, 0x70, 0x41, 0x5d, 0x26, 0xbb, 0xbe, 0x37, 0x57, 0xca, 0xd6, 0x2c, 0x05, 0x66, 0x1f, 0x43,
	0x4d, 0x4a, 0x9e, 0xf8, 0xf5, 0xf1, 0x86, 0x12, 0x62, 0x93, 0xad, 0xdf, 0x5b, 0xe3, 0xd5, 0x49,
	0x02, 0xb2, 0x0f, 0xa0, 0x2a, 0x04, 0x4e, 0xfc, 0xfc, 0x78, 0x25, 0x90, 0xb4, 0x51, 0x29, 0x30,
	0x63, 0x88, 0xbd, 0x07, 0x40, 0x72, 0x8a, 0x32, 0xe5, 0x54, 0xb2, 0xcf, 0xf7, 0xe6, 0x51, 0x91,
	0x8a, 0x15, 0x01, 0x8a, 0x78, 0xe2, 0x7e, 0x53, 0x65, 0x55, 0x3c, 0xba, 0xc2, 0x93, 0x88, 0x27,
	0xee, 0x33, 0xc5, 0xe2, 0x89, 0x62, 0xb0, 0x22, 0x5e, 0x54, 0x4a, 0x88, 0x27, 0x0a, 0x45, 0xe2,
	0x89, 0x32, 0xd5, 0x65, 0xf1, 0xa2, 0x22, 0x24, 0x9e, 0x28, 0xf1, 0x13, 0x68, 0x44, 0x5e, 0xa1,
	0xec, 0x54, 0x2d, 0x75, 0x05, 0x4f, 0xd2, 0xa2, 0x8e, 0xd5, 0x43, 0x15, 0x81, 0xa5, 0x83, 0x63,
	0xef, 0x4c, 0xd9, 0xde, 0x75, 0xb5, 0xf4, 0xf0, 0xd8, 0x3b, 0x53, 0xf7, 0x77, 0x3d, 0x50, 0x11,
	0x28, 0xad, 0xe8, 0x22, 0xdd, 0x60, 0x6c, 0xa8, 0xd2, 0x52, 0x0f, 0x9f, 0x39, 0xf6, 0x19, 0x4a,
	0x6b, 0x46, 0x00, 0x0e, 0x4a, 0x12, 0xc1, 0x05, 0x32, 0x35, 0x9d, 0x4a, 0x5c, 0xc9, 0x96, 0x20,
	0x0e, 0xeb, 0x02, 0x5c, 0x5b, 0x0b, 0x57, 0x2d, 0xa6, 0xa9, 0x6b, 0xeb, 0xd0, 0x4d, 0x15, 0xac,
	0x09, 0x56, 0x59, 0x34, 0xd9, 0x15, 0x81, 0xfd, 0xcd, 0xc2, 0x76, 0x27, 0xb6, 0x7c, 0xea, 0x9d,
	0xda, 0x15, 0x43, 0x49, 0x4b, 0x76, 0x45, 0x84, 0x89, 0xd7, 0x75, 0x5c, 0x9c, 0x2d, 0xaf, 0x6b,
	0xa5, 0x30, 0xad, 0xeb, 0xb8, 0x68, 0xbc, 0xa1, 0xe2, 0xb2, 0xd7, 0x56, 0x36, 0x94, 0x52, 0x58,
	0x6c, 0xa8, 0x08, 0xa1, 0xff, 0x26, 0x0f, 0x25, 0xa9, 0x07, 0xd8, 0x35, 0x58, 0x6f, 0xf3, 0x4e,
	0x6b, 0xd4, 0x31, 0x76, 0x5b, 0xa3, 0xd6, 0x4e, 0x6b, 0x88, 0xe6, 0x9d, 0x41, 0xa3, 0xd5, 0x1b,
	0x75, 0x78, 0x82, 0xcb, 0xa0, 0x72, 0xdb, 0xe5, 0x83, 0x83, 0x04, 0x95, 0x65, 0x1a, 0xd4, 0x64,
	0x59, 0xf1, 0x2a, 0x31, 0xc7, 0xd6, 0xa1, 0x2a, 0x0a, 0x0a, 0x04, 0x5d, 0x31, 0xa1, 0x52, 0x02,
	0x2e, 0x28, 0x45, 0xba, 0xfd, 0xdd, 0xce, 0x97, 0x5a, 0x31, 0x29, 0x22, 0x10, 0xa5, 0xb8, 0x88,
	0x80, 0xcb, 0x28, 0xcc, 0x88, 0x1f, 0xf6, 0xdb, 0x49, 0x3b, 0x15, 0xba, 0x72, 0x20, 0xaa, 0x79,
	0xd6, 0xed, 0x3c, 0xd7, 0x00, 0x0b, 0x89, 0x5a, 0x08, 0xae, 0xa2, 0x83, 0x42, 0x95, 0x10, 0x58,
	0x63, 0x37, 0xe1, 0xda, 0x70, 0x6f, 0xf0, 0xdc, 0x10, 0x85, 0xe2, 0x2e, 0xd4, 0xd9, 0x26, 0x68,
	0x0a, 0x41, 0x54, 0xdf, 0xc0, 0x26, 0x09, 0x1b, 0x31, 0x0e, 0xb5, 0x75, 0x7a, 0x8a, 0x80, 0xb8,
	0x91, 0x50, 0xed, 0x1a, 0x76, 0x45, 0x14, 0x1d, 0xf4, 0x0e, 0xf7, 0xfb, 0x43, 0x6d, 0x03, 0x85,
	0x20, 0x8c, 0x90, 0x9c, 0xc5, 0xd5, 0x24, 0x06, 0xe1, 0x1a, 0xd9, 0x08, 0xc4, 0x3d, 0x6f, 0xf1,
	0x7e, 0xb7, 0xff, 0x64, 0xa8, 0x6d, 0xc6, 0x35, 0x77, 0x38, 0x1f, 0xf0, 0xa1, 0x76, 0x3d, 0x46,
	0x0c, 0x47, 0xad, 0xd1, 0xe1, 0x50, 0xbb, 0x11, 0x4b, 0x79, 0xc0, 0x07, 0xed, 0xce, 0x70, 0xd8,
	0xeb, 0x0e, 0x47, 0xda, 0x4d, 0x76, 0x1d, 0x36, 0x12, 0x89, 0x22, 0xe6, 0xa6, 0x22, 0x28, 0x7f,
	0xd2, 0x19, 0x69, 0xb7, 0x62, 0x31, 0xda, 0x83, 0x5e, 0xaf, 0x45, 0x69, 0xc2, 0xdb, 0xc8, 0x44,
	0xc9, 0x30, 0xd9, 0x9b, 0x57, 0x50, 0xae, 0xc3, 0xbe, 0x8a, 0xba, 0xa3, 0x2c, 0x8d, 0x61, 0xe7,
	0x17, 0x87, 0x9d, 0x7e, 0xbb, 0xa3, 0xbd, 0x9a, 0x2c, 0x8d, 0x18, 0x77, 0x37, 0x5e, 0x1a, 0x31,
	0xea, 0x5e, 0xdc, 0x66, 0x84, 0x1a, 0x6a, 0x5b, 0x3b, 0x35, 0xfa, 0x95, 0x01, 0x69, 0x88, 0xf4,
	0x2f, 0x80, 0xa9, 0x2f, 0x7c, 0xe5, 0x13, 0x2a, 0x06, 0xf9, 0xa9, 0xef, 0x9d, 0x46, 0x37, 0x0d,
	0xf1, 0x9b, 0x6d, 0x41, 0x75, 0xbe, 0x18, 0x53, 0xe2, 0x3a, 0xb9, 0x3a, 0xa5, 0xa2, 0xf4, 0x3f,
	0xcb, 0x40, 0x23, 0x6d, 0x84, 0xd0, 0x35, 0x72, 0xa6, 0x86, 0xeb, 0x85, 0xe2, 0x99, 0x4f, 0x10,
	0x85, 0xb5, 0xce, 0xb4, 0xef, 0x85, 0xf4, 0xce, 0x87, 0x02, 0x9e, 0xd8, 0xa6, 0x88, 0x5a, 0x63,
	0x98, 0x75, 0xe1, 0x5a, 0xea, 0x01, 0x74, 0xea, 0x91, 0x55, 0x33, 0x7e, 0xdd, 0xb9, 0x24, 0x3f,
	0x67, 0xc1, 0x0a, 0x4e, 0xdf, 0x83, 0x7a, 0xca, 0xc2, 0x51, 0xca, 0x61, 0x9a, 0x96, 0xab, 0xec,
	0x4c, 0x5f, 0x2e, 0x94, 0x7e, 0x0c, 0x35, 0xd5, 0xdc, 0xfd, 0xe0, 0x8a, 0xe8, 0x62, 0x82, 0xfc,
	0x36, 0x1c, 0x2b, 0x7a, 0x49, 0x14, 0xa1, 0xba, 0x96, 0x7e, 0x0f, 0x2a, 0x8f, 0x4f, 0xa2, 0x47,
	0x61, 0xea, 0xbb, 0xb4, 0x8a, 0xbc, 0xfd, 0xf6, 0x5f, 0xb3, 0x50, 0x55, 0x0c, 0xe8, 0x6f, 0x35,
	0xde, 0x77, 0xa0, 0x92, 0x5c, 0x96, 0x95, 0xf7, 0x91, 0x62, 0x44, 0x4a, 0xde, 0xdc, 0x92, 0xbc,
	0xdf, 0xeb, 0xd6, 0xc5, 0xfb, 0x50, 0x53, 0x9e, 0x82, 0x05, 0xf2, 0x3c, 0x79, 0xe5, 0xa4, 0x30,
	0x79, 0x16, 0x16, 0xb0, 0xeb, 0x50, 0x9c, 0x9e, 0x18, 0xd6, 0x38, 0xba, 0xa7, 0x52, 0x98, 0x9e,
	0xec, 0x8e, 0x29, 0xa9, 0x36, 0x8d, 0x2d, 0x83, 0x48, 0x12, 0x94, 0xa7, 0x91, 0xfe, 0xbf, 0x0f,
	0xa5, 0xe9, 0x89, 0x78, 0x67, 0x55, 0xa6, 0x16, 0xa4, 0x79, 0x8a, 0xc7, 0x8d, 0x17, 0xa7, 0x27,
	0xf4, 0xe6, 0xea, 0x33, 0xd0, 0x96, 0xf2, 0x0e, 0x81, 0x3c, 0x3b, 0x5e, 0x16, 0x6a, 0x3d, 0x9d,
	0x82, 0x08, 0xf4, 0x7f, 0x99, 0x81, 0x46, 0xe2, 0x70, 0xe0, 0xe4, 0xb3, 0x07, 0xea, 0xcf, 0x2a,
	0x34, 0x97, 0x7d, 0x12, 0x64, 0x79, 0x38, 0xba, 0x98, 0x8b, 0x07, 0xa7, 0x97, 0xdd, 0xe4, 0xbf,
	0xec, 0xa5, 0x5c, 0xee, 0xb2, 0x97, 0x72, 0xfa, 0x13, 0xc8, 0x8d, 0x2e, 0xe6, 0x22, 0xf4, 0x44,
	0x1d, 0x27, 0xfc, 0x59, 0xa1, 0xdd, 0x28, 0x61, 0xfc, 0xb4, 0xf3, 0x95, 0xb8, 0x57, 0x78, 0xc0,
	0xbb, 0xfb, 0x2d, 0xfe, 0x15, 0xa5, 0xc2, 0xc9, 0x0a, 0x3c, 0x1e, 0xf0, 0x4e, 0xf7, 0x49, 0x9f,
	0x10, 0x79, 0x0a, 0x4c, 0x13, 0x11, 0x5b, 0x96, 0xf5, 0xf8, 0x44, 0x7d, 0x9a, 0x9f, 0x49, 0x3d,
	0xcd, 0x8f, 0xdf, 0x0b, 0xa8, 0xcf, 0x02, 0xc3, 0xf8, 0xf9, 0x5e, 0xb4, 0x18, 0x73, 0xc9, 0x62,
	0x64, 0x6f, 0x43, 0x7e, 0x7a, 0x62, 0x5f, 0xa4, 0xbd, 0xca, 0xf4, 0x3d, 0x7c, 0x62, 0xd0, 0x7f,
	0x9d, 0x01, 0x96, 0x12, 0x44, 0x38, 0x3a, 0x3f, 0x54, 0x96, 0x4f, 0xa0, 0x29, 0x1f, 0x89, 0x0a,
	0x2e, 0x25, 0x09, 0x24, 0x87, 0xf4, 0xba, 0xa0, 0x53, 0x73, 0xc9, 0x63, 0x03, 0xf6, 0x08, 0xc4,
	0x43, 0xc7, 0xae, 0x3b, 0xf5, 0xd2, 0x51, 0x9e, 0xb2, 0xa7, 0x78, 0xc2, 0xc3, 0x1e, 0xc0, 0x86,
	0x3a, 0x69, 0xe2, 0xe9, 0xa2, 0xc8, 0x8a, 0xad, 0x27, 0xb3, 0x46, 0xfb, 0x4c, 0xff, 0x55, 0x06,
	0xae, 0xa5, 0x17, 0xc4, 0x5f, 0xad, 0x97, 0xe9, 0x77, 0x9a, 0xb9, 0xe5, 0x77, 0x9a, 0x97, 0xad,
	0xa7, 0xfc, 0xa5, 0xeb, 0xe9, 0x4f, 0x32, 0xb0, 0xa9, 0x8c, 0x7e, 0xe2, 0x9a, 0xfe, 0x6f, 0x92,
	0x4c, 0x79, 0xae, 0x99, 0x4f, 0x3d, 0xd7, 0xd4, 0x3f, 0x84, 0x8d, 0x44, 0x90, 0xb6, 0x7c, 0xbd,
	0x73, 0x0f, 0xaa, 0xae, 0x7d, 0x66, 0x44, 0x6f, 0x7b, 0x84, 0x24, 0xe0, 0xda, 0x67, 0x92, 0x41,
	0x7f, 0xac, 0xee, 0xc5, 0xf8, 0x17, 0x34, 0x66, 0x96, 0x2a, 0x79, 0xc9, 0x9b, 0x59, 0x11, 0x09,
	0x6b, 0x53, 0x04, 0x2f, 0xb9, 0xf6, 0x19, 0x8d, 0x83, 0x0b, 0x55, 0xaa, 0xa7, 0x65, 0x59, 0x6d,
	0x6f, 0x76, 0xe9, 0xed, 0xfa, 0x5b, 0x50, 0x9e, 0xfb, 0xa9, 0x6e, 0x63, 0x3c, 0x4b, 0x15, 0xdf,
	0x95, 0xb7, 0x40, 0x57, 0x33, 0xf9, 0xe2, 0xd6, 0xa7, 0xbc, 0x2b, 0x9d, 0x4f, 0x7e, 0x41, 0x67,
	0x1b, 0x6a, 0xc2, 0x00, 0xf9, 0xde, 0x1c, 0x1b, 0x8c, 0xf3, 0xf0, 0x99, 0xfb, 0x75, 0xca, 0xc3,
	0x23, 0x26, 0xb0, 0xbf, 0x91, 0x4f, 0xa2, 0xf0, 0x53, 0xff, 0x07, 0x65, 0x80, 0xa4, 0xb3, 0x29,
	0xe5, 0x9c, 0xf9, 0x2e, 0xe5, 0xfc, 0xb2, 0x84, 0xfc, 0x87, 0xd0, 0x98, 0x78, 0xf3, 0x0b, 0x23,
	0x29, 0x91, 0xbb, 0xb4, 0x44, 0x0d, 0xb9, 0x46, 0xca, 0x75, 0xd0, 0x95, 0x9c, 0x70, 0xfe, 0xd2,
	0x9c, 0xf0, 0xfb, 0x50, 0x12, 0xd9, 0xb0, 0x48, 0xef, 0xdf, 0x5c, 0xd6, 0x90, 0x0f, 0xe5, 0xdb,
	0xd4, 0x88, 0x8f, 0x75, 0xd0, 0x99, 0x96, 0x0f, 0xf3, 0xd4, 0x5b, 0x45, 0x77, 0x57, 0x4b, 0x46,
	0x6c, 0xe2, 0x94, 0xca, 0x54, 0x41, 0x94, 0x51, 0x8d, 0x35, 0xe9, 0x31, 0x8c, 0x78, 0xa6, 0xd5,
	0x50, 0x42, 0xcb, 0xe1, 0x37, 0x33, 0xf6, 0x16, 0xac, 0xcb, 0x93, 0x7f, 0x1c, 0x43, 0x62, 0x14,
	0x4f, 0xf9, 0xeb, 0x02, 0x8d, 0xf6, 0x1d, 0xf9, 0xbe, 0x84, 0xcd, 0xc9, 0xb1, 0xe9, 0x1e, 0xd9,
	0x46, 0x38, 0x9e, 0x19, 0xf4, 0x93, 0x05, 0xc6, 0xa9, 0x39, 0x97, 0xb6, 0xe3, 0xed, 0x15, 0xf1,
	0xda, 0xc4, 0x3c, 0x1a, 0xcf, 0xe8, 0x60, 0x2b, 0x3e, 0x2b, 0xd8, 0x98, 0x2c, 0xe3, 0x6f, 0xff,
	0xd3, 0x1c, 0x14, 0xe5, 0x5b, 0xdc, 0x07, 0x90, 0xc7, 0xd0, 0x42, 0x66, 0xb9, 0x36, 0x2f, 0xb3,
	0x27, 0xf4, 0xc3, 0x5b, 0x68, 0x7a, 0x1e, 0x42, 0xd1, 0xb4, 0x2c, 0x63, 0x7a, 0x92, 0x4e, 0x9a,
	0x2e, 0xa9, 0xf6, 0xbd, 0x35, 0x5e, 0x30, 0x49, 0xc7, 0x7f, 0x02, 0x15, 0xe4, 0x17, 0x11, 0x67,
	0xca, 0x75, 0x5a, 0x55, 0xc2, 0x7b, 0x6b, 0xbc, 0x6c, 0x46, 0x0a, 0xf9, 0xa7, 0xe9, 0x00, 0x57,
	0x68, 0xc8, 0xdb, 0x2b, 0x45, 0xaf, 0x0a, 0x75, 0x7f, 0x1f, 0x44, 0xc4, 0x13, 0xef, 0xe5, 0x82,
	0x9a, 0x9f, 0x5b, 0xd9, 0xf9, 0x18, 0x5e, 0x99, 0xe2, 0x40, 0x50, 0x68, 0x82, 0x8f, 0xa2, 0xe0,
	0x33, 0xfe, 0x55, 0x9d, 0x4b, 0x46, 0x06, 0x37, 0x63, 0x1c, 0x81, 0xd2, 0xce, 0x7c, 0x17, 0x4a,
	0xd8, 0xdd, 0x89, 0x37, 0x93, 0x19, 0x83, 0x0d, 0xa5, 0x8c, 0xd8, 0xec, 0x7b, 0x6b, 0x1c, 0x87,
	0x10, 0x77, 0xe1, 0x23, 0x28, 0x53, 0xf8, 0x87, 0xec, 0x65, 0x35, 0xf2, 0x53, 0xf7, 0x2a, 0xfd,
	0x30, 0x99, 0xf8, 0x4c, 0x12, 0xbd, 0xb7, 0x39, 0xdc, 0xb8, 0x7c, 0xae, 0xd5, 0x63, 0xa0, 0xbc,
	0x38, 0x06, 0xd2, 0xd3, 0x77, 0x93, 0xd3, 0x2f, 0xf4, 0x94, 0x43, 0xa1, 0x9f, 0xa3, 0x97, 0xaa,
	0xae, 0xe7, 0x2a, 0x94, 0xa2, 0x77, 0xd7, 0x74, 0x26, 0xdd, 0x1e, 0x1c, 0x7c, 0xa5, 0x65, 0x10,
	0xdd, 0xed, 0x0f, 0x47, 0xad, 0xbe, 0x4c, 0xe3, 0x77, 0xfb, 0x32, 0x8d, 0xaf, 0xff, 0x26, 0x0b,
	0x95, 0x38, 0xd1, 0xf1, 0xc3, 0x7d, 0xd3, 0xf8, 0x77, 0xef, 0x72, 0xca, 0xef, 0xde, 0x2d, 0x1b,
	0x40, 0x71, 0x6e, 0x93, 0x27, 0x1f, 0x60, 0x3d, 0x6d, 0x66, 0x82, 0xd5, 0x3b, 0x4b, 0x85, 0xdf,
	0xf2, 0xce, 0x92, 0x7a, 0xd6, 0x5d, 0x4c, 0x9f, 0x75, 0x2f, 0xbd, 0xbd, 0x2f, 0xd1, 0x19, 0x93,
	0xfa, 0xf6, 0xfe, 0xca, 0xc3, 0xa5, 0xf2, 0xd5, 0x87, 0x4b, 0xf4, 0x13, 0x7e, 0xcf, 0x1c, 0xfb,
	0x4c, 0x1e, 0xfc, 0x4a, 0x28, 0xad, 0x51, 0xe1, 0x25, 0xa7, 0xac, 0xdf, 0x40, 0x25, 0xce, 0x88,
	0xfc, 0xf0, 0x51, 0xff, 0x3e, 0x1e, 0xb6, 0xfe, 0x47, 0x51, 0xb8, 0x15, 0x27, 0x24, 0xfe, 0xaa,
	0xe1, 0x56, 0xaa, 0xf9, 0xdc, 0x4b, 0x9a, 0x3f, 0x17, 0x61, 0x50, 0xdc, 0xf8, 0xef, 0x78, 0xa9,
	0xa9, 0xab, 0x20, 0x9f, 0x5a, 0x05, 0xfa, 0xba, 0x0c, 0xe5, 0xe2, 0x54, 0xca, 0x7f, 0xcf, 0x44,
	0x61, 0x50, 0xfc, 0xd2, 0xf0, 0x4a, 0x3b, 0x19, 0xb7, 0x96, 0x55, 0x5b, 0xfb, 0x3e, 0x3d, 0xff,
	0x4e, 0x87, 0x33, 0xff, 0x5d, 0x0e, 0xe7, 0xdb, 0x50, 0x10, 0xaa, 0xb4, 0x70, 0x95, 0xb3, 0x29,
	0xe8, 0x2f, 0xfd, 0x75, 0x0c, 0x5d, 0x97, 0x7e, 0x81, 0xe8, 0xef, 0x66, 0x54, 0x6f, 0xf4, 0xcb,
	0x1e, 0x08, 0xa0, 0xbf, 0x5f, 0x49, 0xfc, 0xce, 0xef, 0x3f, 0x26, 0xbf, 0x33, 0x8f, 0xf3, 0x57,
	0x59, 0xa8, 0xa7, 0xd2, 0x94, 0x3f, 0x40, 0x98, 0x4b, 0x35, 0x4f, 0xee, 0x72, 0xcd, 0x73, 0xa5,
	0x12, 0xc8, 0x5f, 0xad, 0x04, 0xfe, 0x4f, 0x68, 0x2b, 0xfd, 0xaf, 0x67, 0xe2, 0xdf, 0xbd, 0x10,
	0x95, 0x5d, 0xe6, 0x61, 0x65, 0x2e, 0xf5, 0xb0, 0xee, 0xc6, 0x3f, 0xb9, 0xd6, 0xdd, 0x15, 0xe7,
	0xd0, 0x75, 0xae, 0x60, 0xd8, 0x67, 0x70, 0x4b, 0x9c, 0x12, 0x09, 0xe3, 0x6d, 0x78, 0x53, 0x23,
	0xfe, 0x41, 0x36, 0x79, 0x31, 0xe0, 0x86, 0x60, 0x10, 0xbf, 0x8e, 0x32, 0x6d, 0x45, 0x54, 0xbd,
	0x0b, 0xf5, 0x54, 0x5a, 0x58, 0xf9, 0x15, 0xc7, 0x8c, 0xfa, 0x2b, 0x8e, 0x6c, 0x0b, 0x0a, 0x67,
	0xc7, 0xb6, 0x6f, 0x5f, 0xf2, 0xb4, 0x4c, 0x10, 0xf4, 0x9f, 0x40, 0x4d, 0x3d, 0x40, 0x62, 0xef,
	0x42, 0xc1, 0x09, 0xed, 0xd3, 0xe8, 0x45, 0xdf, 0x8d, 0xd5, 0x33, 0x26, 0xfa, 0x05, 0x07, 0xc1,
	0xa4, 0xff, 0x79, 0x06, 0xb4, 0x65, 0x9a, 0xf2, 0x53, 0x93, 0x99, 0x2b, 0x7e, 0x6a, 0x32, 0x9b,
	0x12, 0xf2, 0x92, 0x9f, 0x8b, 0x4c, 0x5e, 0x0a, 0xe5, 0xaf, 0x78, 0x29, 0xc4, 0xde, 0x82, 0xb2,
	0x6f, 0xd3, 0xcf, 0xfb, 0x59, 0xe9, 0x9f, 0x91, 0x12, 0xbf, 0x0c, 0x10, 0xd1, 0xf4, 0xff, 0x3f,
	0x03, 0x25, 0x79, 0xda, 0x75, 0x69, 0x04, 0xf1, 0x0e, 0x94, 0xc4, 0x4f, 0xfd, 0x45, 0x3f, 0x3a,
	0xb7, 0x72, 0x6f, 0x23, 0xa2, 0x63, 0x44, 0x81, 0xa4, 0x74, 0x44, 0x71, 0x30, 0x33, 0x5d, 0x4e,
	0x78, 0x5c, 0x4d, 0x74, 0x45, 0x80, 0x9c, 0xe3, 0x40, 0xde, 0xdf, 0x07, 0x42, 0xa1, 0xa7, 0x10,
	0xe8, 0x3f, 0x85, 0x92, 0x3c, 0x4d, 0xbb, 0x54, 0x94, 0x97, 0xfd, 0xf8, 0xdd, 0x16, 0x40, 0x72,
	0xbc, 0x76, 0x59, 0x0d, 0xfa, 0x4c, 0xbe, 0x48, 0xee, 0x79, 0x93, 0x13, 0x8a, 0x87, 0x1f, 0x41,
	0x79, 0x16, 0x3d, 0xd8, 0xce, 0x5c, 0xfd, 0x60, 0x3b, 0x66, 0x62, 0x0f, 0x20, 0xd6, 0xa2, 0x2f,
	0x8b, 0x51, 0xf4, 0x56, 0x74, 0x01, 0x8e, 0x56, 0xce, 0x07, 0x32, 0x06, 0x45, 0x54, 0xb4, 0x7c,
	0x96, 0x1b, 0xa3, 0x0b, 0xd7, 0x0a, 0x9b, 0xde, 0x80, 0x9a, 0x7a, 0x78, 0xa0, 0xff, 0xb5, 0x22,
	0x68, 0xfb, 0x76, 0x68, 0xa2, 0xae, 0x19, 0x4e, 0x4c, 0x97, 0x3a, 0xd1, 0xa4, 0x37, 0xaa, 0x7d,
	0x25, 0x78, 0x8c, 0x32, 0x6e, 0x4d, 0x28, 0xed, 0xa0, 0xe8, 0x5d, 0x4b, 0x3e, 0xaf, 0x8e, 0x40,
	0xdc, 0x7d, 0x62, 0x06, 0xfb, 0xc9, 0xd2, 0x52, 0x30, 0x48, 0x27, 0x4f, 0x90, 0xee, 0x64, 0xc8,
	0x18, 0x49, 0xc1, 0xe0, 0x62, 0x1d, 0x7a, 0x7e, 0x28, 0x17, 0x57, 0x99, 0x4b, 0x08, 0xf5, 0x62,
	0x37, 0xd8, 0x13, 0xbf, 0xf0, 0x20, 0x94, 0x7e, 0x0c, 0xa3, 0x34, 0x28, 0x7b, 0xcf, 0x13, 0xbf,
	0xc1, 0x50, 0xe3, 0x11, 0x88, 0xb5, 0xed, 0xda, 0x33, 0x24, 0x94, 0x89, 0x20, 0x21, 0xac, 0x4d,
	0x1c, 0xfb, 0x8f, 0x02, 0x72, 0x6d, 0x6a, 0x3c, 0x86, 0x89, 0x26, 0xec, 0x4e, 0x40, 0xbe, 0x0d,
	0xd2, 0x24, 0x8c, 0x34, 0x71, 0x31, 0x69, 0x14, 0xd0, 0x09, 0x55, 0x8d, 0xc7, 0x30, 0x6a, 0xe7,
	0xa1, 0x7d, 0xd4, 0xb5, 0xe8, 0x10, 0xaa, 0xc6, 0x05, 0x80, 0x12, 0x70, 0xef, 0xac, 0xed, 0x86,
	0xf2, 0x25, 0x8c, 0x84, 0x50, 0xe6, 0xfe, 0x62, 0x36, 0x43, 0x82, 0x78, 0x04, 0x13, 0x81, 0x4c,
	0x87, 0x5a, 0xf4, 0xbb, 0x6d, 0x43, 0xe7, 0x5b, 0x5b, 0xfc, 0xc8, 0x2f, 0x4f, 0xe1, 0x68, 0x94,
	0xc5, 0x0f, 0x7d, 0x21, 0x87, 0x26, 0x5e, 0xd1, 0x24, 0x18, 0x74, 0xb3, 0xf7, 0x1d, 0x97, 0xce,
	0x7b, 0x6a, 0x1c, 0x3f, 0x09, 0x63, 0x9e, 0xd3, 0x11, 0x0e, 0x62, 0xcc, 0x73, 0xfd, 0x4f, 0xb3,
	0xb0, 0xb9, 0x3c, 0xe5, 0xb4, 0x14, 0x6b, 0x50, 0x6e, 0x0f, 0x7a, 0x46, 0xbf, 0xb5, 0x2f, 0x7f,
	0xe2, 0x71, 0x87, 0xf2, 0xee, 0xdd, 0x5d, 0xf1, 0x96, 0x72, 0xb0, 0xf3, 0x45, 0xa7, 0x3d, 0x12,
	0x64, 0x4a, 0xae, 0x75, 0xfa, 0x23, 0xfe, 0x15, 0xe5, 0xf7, 0xe5, 0x65, 0x99, 0xe1, 0x80, 0x8f,
	0x3a, 0xbb, 0x5a, 0x9e, 0x6e, 0xb1, 0x0e, 0x8d, 0xbd, 0xee, 0xee, 0x6e, 0xa7, 0xaf, 0x15, 0xe8,
	0xee, 0x6f, 0x67, 0xd4, 0x32, 0x7a, 0x83, 0xb6, 0x56, 0xa4, 0x23, 0x90, 0x4e, 0x4f, 0x82, 0x25,
	0x04, 0xc5, 0x05, 0x12, 0x63, 0x34, 0xd4, 0xca, 0x04, 0xca, 0xb3, 0x9b, 0xa1, 0x56, 0x91, 0xcc,
	0x1d, 0x01, 0x82, 0xb8, 0xb6, 0xf3, 0x04, 0x45, 0xaa, 0x8a, 0xdb, 0x26, 0xcf, 0x87, 0x46, 0xbb,
	0x3f, 0xd2, 0x6a, 0x08, 0xf5, 0x0f, 0x7b, 0x3d, 0x82, 0xea, 0x6c, 0x03, 0xea, 0xed, 0xc1, 0xfe,
	0x01, 0xef, 0x0c, 0x87, 0xc6, 0xb0, 0xfb, 0x07, 0x1d, 0xad, 0x41, 0x3d, 0xe0, 0xdd, 0x27, 0xdd,
	0xbe, 0x40, 0xac, 0xb3, 0x12, 0xe4, 0xf6, 0xbb, 0x7d, 0x4d, 0xa3, 0x8f, 0xd6, 0x97, 0xda, 0xc6,
	0x83, 0xd7, 0x92, 0x19, 0x88, 0xde, 0xbe, 0xf6, 0x3d, 0xd7, 0x16, 0xaf, 0x96, 0x7b, 0xdf, 0x7e,
	0xa8, 0x65, 0x1e, 0xfc, 0x91, 0xf2, 0x43, 0x2f, 0xc4, 0x23, 0xb3, 0x8d, 0x74, 0xbb, 0xba, 0xd7,
	0xed, 0x77, 0x5a, 0x9c, 0x72, 0x8b, 0xf4, 0xbe, 0x79, 0xaf, 0x35, 0xdc, 0x13, 0x43, 0x25, 0x29,
	0x84, 0xc8, 0x25, 0x2f, 0x69, 0xe9, 0x36, 0x35, 0x7d, 0xc6, 0xa7, 0x35, 0x05, 0xba, 0x66, 0xdb,
	0x1d, 0x8e, 0xb4, 0x22, 0xd3, 0xa0, 0x86, 0x5f, 0x31, 0xad, 0xf4, 0x40, 0x87, 0xaa, 0xf2, 0xeb,
	0x00, 0xd4, 0x86, 0x19, 0x1c, 0xcb, 0xc7, 0xb9, 0x18, 0x78, 0x69, 0x99, 0x07, 0x1f, 0xa1, 0xb1,
	0x52, 0xde, 0xeb, 0xd3, 0xef, 0xc4, 0x7a, 0xfe, 0xa9, 0x39, 0x93, 0x7c, 0xf6, 0x22, 0xb0, 0xb5,
	0x0c, 0xdd, 0x95, 0xb1, 0xe5, 0xcb, 0x7e, 0x2d, 0xfb, 0xe0, 0xe7, 0xd0, 0xbc, 0xea, 0x2e, 0x0a,
	0x96, 0x6a, 0xef, 0xb5, 0xe8, 0xbe, 0x0f, 0x8e, 0xf3, 0xc0, 0x10, 0x50, 0x46, 0x5c, 0x97, 0xea,
	0x75, 0xe8, 0xd8, 0xed, 0xc1, 0x2f, 0x33, 0x8a, 0x36, 0x8c, 0x2e, 0x1e, 0xc4, 0x08, 0x39, 0x92,
	0x2a, 0x8a, 0xdb, 0xa6, 0xa5, 0x65, 0xd8, 0x0d, 0x60, 0x29, 0x54, 0xcf, 0x9b, 0x98, 0x33, 0x2d,
	0x4b, 0x07, 0x6c, 0x11, 0xfe, 0xb9, 0xef, 0x84, 0xb6, 0x96, 0x63, 0xaf, 0xc2, 0xad, 0x18, 0xd7,
	0xf3, 0xce, 0x0e, 0x7c, 0x07, 0x23, 0xc3, 0x0b, 0x41, 0xce, 0xef, 0xfc, 0xec, 0x5f, 0xfd, 0xfa,
	0x6e, 0xe6, 0xdf, 0xfc, 0xfa, 0x6e, 0xe6, 0x3f, 0xfd, 0xfa, 0xee, 0xda, 0x9f, 0xff, 0x97, 0xbb,
	0x99, 0x3f, 0x50, 0x7f, 0x60, 0xfd, 0xd4, 0x0c, 0x7d, 0xe7, 0x5c, 0x38, 0xa2, 0x11, 0xe0, 0xda,
	0x8f, 0xe6, 0x27, 0x47, 0x8f, 0xe6, 0xe3, 0x47, 0xa8, 0x39, 0xc7, 0x45, 0xfa, 0x9d, 0xf5, 0x0f,
	0xfe, 0x57, 0x00, 0x00, 0x00, 0xff, 0xff, 0xb5, 0xad, 0x3b, 0xa2, 0xaa, 0x5d, 0x00, 0x00,
}

func (m *Type) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Type) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Type) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x32
	}
	if m.Scale != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Scale))
		i--
		dAtA[i] = 0x28
	}
	if m.Width != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x20
	}
	if m.AutoIncr {
		i--
		if m.AutoIncr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.NotNullable {
		i--
		if m.NotNullable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Const) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Const) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Src != nil {
		{
			size, err := m.Src.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.IsBin {
		i--
		if m.IsBin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.Value != nil {
		{
			size := m.Value.ProtoSize()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Isnull {
		i--
		if m.Isnull {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Const_I8Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_I8Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.I8Val))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *Const_I16Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_I16Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.I16Val))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *Const_I32Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_I32Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.I32Val))
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *Const_I64Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_I64Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.I64Val))
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *Const_U8Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_U8Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.U8Val))
	i--
	dAtA[i] = 0x30
	return len(dAtA) - i, nil
}
func (m *Const_U16Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_U16Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.U16Val))
	i--
	dAtA[i] = 0x38
	return len(dAtA) - i, nil
}
func (m *Const_U32Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_U32Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.U32Val))
	i--
	dAtA[i] = 0x40
	return len(dAtA) - i, nil
}
func (m *Const_U64Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_U64Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.U64Val))
	i--
	dAtA[i] = 0x48
	return len(dAtA) - i, nil
}
func (m *Const_Dval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Dval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Dval))))
	i--
	dAtA[i] = 0x51
	return len(dAtA) - i, nil
}
func (m *Const_Sval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Sval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Sval)
	copy(dAtA[i:], m.Sval)
	i = encodeVarintPlan(dAtA, i, uint64(len(m.Sval)))
	i--
	dAtA[i] = 0x5a
	return len(dAtA) - i, nil
}
func (m *Const_Bval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Bval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Bval {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x60
	return len(dAtA) - i, nil
}
func (m *Const_Fval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Fval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Fval))))
	i--
	dAtA[i] = 0x6d
	return len(dAtA) - i, nil
}
func (m *Const_Dateval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Dateval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.Dateval))
	i--
	dAtA[i] = 0x70
	return len(dAtA) - i, nil
}
func (m *Const_Timeval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Timeval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.Timeval))
	i--
	dAtA[i] = 0x78
	return len(dAtA) - i, nil
}
func (m *Const_Datetimeval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Datetimeval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.Datetimeval))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	return len(dAtA) - i, nil
}
func (m *Const_Decimal64Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Decimal64Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Decimal64Val != nil {
		{
			size, err := m.Decimal64Val.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *Const_Decimal128Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Decimal128Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Decimal128Val != nil {
		{
			size, err := m.Decimal128Val.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *Const_Timestampval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Timestampval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPlan(dAtA, i, uint64(m.Timestampval))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x98
	return len(dAtA) - i, nil
}
func (m *Const_Jsonval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Jsonval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Jsonval)
	copy(dAtA[i:], m.Jsonval)
	i = encodeVarintPlan(dAtA, i, uint64(len(m.Jsonval)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa2
	return len(dAtA) - i, nil
}
func (m *Const_Defaultval) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_Defaultval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Defaultval {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa8
	return len(dAtA) - i, nil
}
func (m *Const_UpdateVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Const_UpdateVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.UpdateVal {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb0
	return len(dAtA) - i, nil
}
func (m *ParamRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParamRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParamRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Pos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Pos))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VarRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VarRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VarRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Global {
		i--
		if m.Global {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.System {
		i--
		if m.System {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ColRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ColPos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ColPos))
		i--
		dAtA[i] = 0x10
	}
	if m.RelPos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RelPos))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RawColRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawColRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawColRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ColId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ColId))
		i--
		dAtA[i] = 0x10
	}
	if m.TblId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TblId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CorrColRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CorrColRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CorrColRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Depth != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Depth))
		i--
		dAtA[i] = 0x18
	}
	if m.ColPos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ColPos))
		i--
		dAtA[i] = 0x10
	}
	if m.RelPos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RelPos))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExprList) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExprList) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExprList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MaxValue) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaxValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaxValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TargetType) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TargetType) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TargetType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Typ != nil {
		{
			size, err := m.Typ.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubqueryRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubqueryRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubqueryRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RowSize != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RowSize))
		i--
		dAtA[i] = 0x28
	}
	if m.Child != nil {
		{
			size, err := m.Child.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Op) > 0 {
		i -= len(m.Op)
		copy(dAtA[i:], m.Op)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Op)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NodeId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x10
	}
	if m.Typ != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Typ))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ObjectRef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PubInfo != nil {
		{
			size, err := m.PubInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.SubscriptionName) > 0 {
		i -= len(m.SubscriptionName)
		copy(dAtA[i:], m.SubscriptionName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.SubscriptionName)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ObjName) > 0 {
		i -= len(m.ObjName)
		copy(dAtA[i:], m.ObjName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ObjName)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SchemaName) > 0 {
		i -= len(m.SchemaName)
		copy(dAtA[i:], m.SchemaName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.SchemaName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ServerName) > 0 {
		i -= len(m.ServerName)
		copy(dAtA[i:], m.ServerName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ServerName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Obj != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Obj))
		i--
		dAtA[i] = 0x20
	}
	if m.Schema != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Schema))
		i--
		dAtA[i] = 0x18
	}
	if m.Db != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Db))
		i--
		dAtA[i] = 0x10
	}
	if m.Server != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Server))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PubInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PubInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PubInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TenantId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TenantId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubscriptionMeta) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscriptionMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscriptionMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SubName) > 0 {
		i -= len(m.SubName)
		copy(dAtA[i:], m.SubName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.SubName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AccountName) > 0 {
		i -= len(m.AccountName)
		copy(dAtA[i:], m.AccountName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.AccountName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AccountId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.AccountId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Function) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Function) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Function) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Args[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Func != nil {
		{
			size, err := m.Func.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Expr) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Expr) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Selectivity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Selectivity))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x81
	}
	if m.Ndv != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Ndv))))
		i--
		dAtA[i] = 0x79
	}
	if m.AuxId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.AuxId))
		i--
		dAtA[i] = 0x70
	}
	if m.Expr != nil {
		{
			size := m.Expr.ProtoSize()
			i -= size
			if _, err := m.Expr.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Typ != nil {
		{
			size, err := m.Typ.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Expr_C) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_C) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.C != nil {
		{
			size, err := m.C.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Expr_P) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_P) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.P != nil {
		{
			size, err := m.P.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Expr_V) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_V) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.V != nil {
		{
			size, err := m.V.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Expr_Col) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_Col) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Col != nil {
		{
			size, err := m.Col.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Expr_Raw) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_Raw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Raw != nil {
		{
			size, err := m.Raw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Expr_F) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_F) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.F != nil {
		{
			size, err := m.F.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Expr_W) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_W) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.W != nil {
		{
			size, err := m.W.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Expr_Sub) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_Sub) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Sub != nil {
		{
			size, err := m.Sub.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Expr_Corr) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_Corr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Corr != nil {
		{
			size, err := m.Corr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *Expr_T) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_T) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.T != nil {
		{
			size, err := m.T.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *Expr_List) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_List) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.List != nil {
		{
			size, err := m.List.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *Expr_Max) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr_Max) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Max != nil {
		{
			size, err := m.Max.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *Decimal64) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Decimal64) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Decimal64) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.A != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.A))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Decimal128) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Decimal128) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Decimal128) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.B != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.B))
		i--
		dAtA[i] = 0x10
	}
	if m.A != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.A))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResultColDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultColDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResultColDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ResultCols) > 0 {
		for iNdEx := len(m.ResultCols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResultCols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ColDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Pkidx != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Pkidx))
		i--
		dAtA[i] = 0x70
	}
	if m.Primary {
		i--
		if m.Primary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.ClusterBy {
		i--
		if m.ClusterBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.Seqnum != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Seqnum))
		i--
		dAtA[i] = 0x58
	}
	if m.LowCard {
		i--
		if m.LowCard {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.OnUpdate != nil {
		{
			size, err := m.OnUpdate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x42
	}
	if m.Default != nil {
		{
			size, err := m.Default.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.NotNull {
		i--
		if m.NotNull {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Typ != nil {
		{
			size, err := m.Typ.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Alg != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Alg))
		i--
		dAtA[i] = 0x20
	}
	if m.Hidden {
		i--
		if m.Hidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ColId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ColId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Default) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Default) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Default) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NullAbility {
		i--
		if m.NullAbility {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.OriginString) > 0 {
		i -= len(m.OriginString)
		copy(dAtA[i:], m.OriginString)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.OriginString)))
		i--
		dAtA[i] = 0x12
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OnUpdate) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OnUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OriginString) > 0 {
		i -= len(m.OriginString)
		copy(dAtA[i:], m.OriginString)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.OriginString)))
		i--
		dAtA[i] = 0x12
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IndexOption) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CreateExtraTable {
		i--
		if m.CreateExtraTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PrimaryKeyDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrimaryKeyDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrimaryKeyDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CompPkeyCol != nil {
		{
			size, err := m.CompPkeyCol.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Names) > 0 {
		for iNdEx := len(m.Names) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Names[iNdEx])
			copy(dAtA[i:], m.Names[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.Names[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.PkeyColName) > 0 {
		i -= len(m.PkeyColName)
		copy(dAtA[i:], m.PkeyColName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.PkeyColName)))
		i--
		dAtA[i] = 0x22
	}
	if m.Option != nil {
		{
			size, err := m.Option.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PkeyColId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.PkeyColId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Cols) > 0 {
		dAtA29 := make([]byte, len(m.Cols)*10)
		var j28 int
		for _, num := range m.Cols {
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		i -= j28
		copy(dAtA[i:], dAtA29[:j28])
		i = encodeVarintPlan(dAtA, i, uint64(j28))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IndexDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Option != nil {
		{
			size, err := m.Option.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Visible {
		i--
		if m.Visible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x3a
	}
	if m.TableExist {
		i--
		if m.TableExist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.IndexTableName) > 0 {
		i -= len(m.IndexTableName)
		copy(dAtA[i:], m.IndexTableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexTableName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Unique {
		i--
		if m.Unique {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Parts) > 0 {
		for iNdEx := len(m.Parts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Parts[iNdEx])
			copy(dAtA[i:], m.Parts[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.Parts[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.IndexName) > 0 {
		i -= len(m.IndexName)
		copy(dAtA[i:], m.IndexName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.IdxId) > 0 {
		i -= len(m.IdxId)
		copy(dAtA[i:], m.IdxId)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IdxId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ForeignKeyDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForeignKeyDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForeignKeyDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OnUpdate != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.OnUpdate))
		i--
		dAtA[i] = 0x30
	}
	if m.OnDelete != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.OnDelete))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ForeignCols) > 0 {
		dAtA32 := make([]byte, len(m.ForeignCols)*10)
		var j31 int
		for _, num := range m.ForeignCols {
			for num >= 1<<7 {
				dAtA32[j31] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j31++
			}
			dAtA32[j31] = uint8(num)
			j31++
		}
		i -= j31
		copy(dAtA[i:], dAtA32[:j31])
		i = encodeVarintPlan(dAtA, i, uint64(j31))
		i--
		dAtA[i] = 0x22
	}
	if m.ForeignTbl != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ForeignTbl))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Cols) > 0 {
		dAtA34 := make([]byte, len(m.Cols)*10)
		var j33 int
		for _, num := range m.Cols {
			for num >= 1<<7 {
				dAtA34[j33] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j33++
			}
			dAtA34[j33] = uint8(num)
			j33++
		}
		i -= j33
		copy(dAtA[i:], dAtA34[:j33])
		i = encodeVarintPlan(dAtA, i, uint64(j33))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Check != nil {
		{
			size, err := m.Check.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterByDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterByDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterByDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CompCbkeyCol != nil {
		{
			size, err := m.CompCbkeyCol.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PropertyDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropertyDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PropertyDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Property) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Property) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Property) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PropertiesDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropertiesDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PropertiesDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Properties) > 0 {
		for iNdEx := len(m.Properties) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Properties[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PartitionByDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionByDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionByDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PartitionTableNames) > 0 {
		for iNdEx := len(m.PartitionTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionTableNames[iNdEx])
			copy(dAtA[i:], m.PartitionTableNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionTableNames[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.PartitionMsg) > 0 {
		i -= len(m.PartitionMsg)
		copy(dAtA[i:], m.PartitionMsg)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionMsg)))
		i--
		dAtA[i] = 0x4a
	}
	if m.IsSubPartition {
		i--
		if m.IsSubPartition {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Algorithm != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Algorithm))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Partitions) > 0 {
		for iNdEx := len(m.Partitions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Partitions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.PartitionNum != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.PartitionNum))
		i--
		dAtA[i] = 0x28
	}
	if m.PartitionColumns != nil {
		{
			size, err := m.PartitionColumns.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PartitionExpression != nil {
		{
			size, err := m.PartitionExpression.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PartitionExpr != nil {
		{
			size, err := m.PartitionExpr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PartitionExpr) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionExpr) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionExpr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExprStr) > 0 {
		i -= len(m.ExprStr)
		copy(dAtA[i:], m.ExprStr)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ExprStr)))
		i--
		dAtA[i] = 0x12
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PartitionColumns) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionColumns) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionColumns) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PartitionColumns) > 0 {
		for iNdEx := len(m.PartitionColumns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionColumns[iNdEx])
			copy(dAtA[i:], m.PartitionColumns[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionColumns[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PartitionItem) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PartitionTableName) > 0 {
		i -= len(m.PartitionTableName)
		copy(dAtA[i:], m.PartitionTableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionTableName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.InValues) > 0 {
		for iNdEx := len(m.InValues) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InValues[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.LessThan) > 0 {
		for iNdEx := len(m.LessThan) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LessThan[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OrdinalPosition != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.OrdinalPosition))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PartitionName) > 0 {
		i -= len(m.PartitionName)
		copy(dAtA[i:], m.PartitionName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ViewDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ViewDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.View) > 0 {
		i -= len(m.View)
		copy(dAtA[i:], m.View)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.View)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableDef) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDef) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AutoIncrOffset != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.AutoIncrOffset))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.IsTemporary {
		i--
		if m.IsTemporary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.TableLockType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TableLockType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.IsLocked {
		i--
		if m.IsLocked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if len(m.Name2ColIndex) > 0 {
		for k := range m.Name2ColIndex {
			v := m.Name2ColIndex[k]
			baseI := i
			i = encodeVarintPlan(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPlan(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPlan(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if len(m.Defs) > 0 {
		for iNdEx := len(m.Defs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Defs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	if m.ViewSql != nil {
		{
			size, err := m.ViewSql.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if len(m.Props) > 0 {
		for iNdEx := len(m.Props) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Props[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if m.ClusterBy != nil {
		{
			size, err := m.ClusterBy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.Partition != nil {
		{
			size, err := m.Partition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.Checks) > 0 {
		for iNdEx := len(m.Checks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Checks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.RefChildTbls) > 0 {
		dAtA45 := make([]byte, len(m.RefChildTbls)*10)
		var j44 int
		for _, num := range m.RefChildTbls {
			for num >= 1<<7 {
				dAtA45[j44] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j44++
			}
			dAtA45[j44] = uint8(num)
			j44++
		}
		i -= j44
		copy(dAtA[i:], dAtA45[:j44])
		i = encodeVarintPlan(dAtA, i, uint64(j44))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Fkeys) > 0 {
		for iNdEx := len(m.Fkeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fkeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.Indexes) > 0 {
		for iNdEx := len(m.Indexes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Indexes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.Pkey != nil {
		{
			size, err := m.Pkey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Version != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x40
	}
	if m.TblFunc != nil {
		{
			size, err := m.TblFunc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Createsql) > 0 {
		i -= len(m.Createsql)
		copy(dAtA[i:], m.Createsql)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Createsql)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.TableType) > 0 {
		i -= len(m.TableType)
		copy(dAtA[i:], m.TableType)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TableType)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Cols) > 0 {
		for iNdEx := len(m.Cols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Hidden {
		i--
		if m.Hidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.TblId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TblId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableDef_DefType) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDef_DefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDef_DefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Def != nil {
		{
			size := m.Def.ProtoSize()
			i -= size
			if _, err := m.Def.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *TableDef_DefType_Properties) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDef_DefType_Properties) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Properties != nil {
		{
			size, err := m.Properties.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *TableFunction) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableFunction) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableFunction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Param) > 0 {
		i -= len(m.Param)
		copy(dAtA[i:], m.Param)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Param)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HashMapStats) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HashMapStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HashMapStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ShuffleMethod != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ShuffleMethod))
		i--
		dAtA[i] = 0x40
	}
	if m.ShuffleColMax != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ShuffleColMax))
		i--
		dAtA[i] = 0x38
	}
	if m.ShuffleColMin != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ShuffleColMin))
		i--
		dAtA[i] = 0x30
	}
	if m.ShuffleType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ShuffleType))
		i--
		dAtA[i] = 0x28
	}
	if m.ShuffleColIdx != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ShuffleColIdx))
		i--
		dAtA[i] = 0x20
	}
	if m.Shuffle {
		i--
		if m.Shuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.HashOnPK {
		i--
		if m.HashOnPK {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.HashmapSize != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.HashmapSize))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Stats) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stats) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Stats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HashmapStats != nil {
		{
			size, err := m.HashmapStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Selectivity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Selectivity))))
		i--
		dAtA[i] = 0x31
	}
	if m.TableCnt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TableCnt))))
		i--
		dAtA[i] = 0x29
	}
	if m.Rowsize != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Rowsize))))
		i--
		dAtA[i] = 0x21
	}
	if m.Outcnt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Outcnt))))
		i--
		dAtA[i] = 0x19
	}
	if m.Cost != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Cost))))
		i--
		dAtA[i] = 0x11
	}
	if m.BlockNum != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.BlockNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RowsetExpr) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowsetExpr) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowsetExpr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Pos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Pos))
		i--
		dAtA[i] = 0x10
	}
	if m.RowPos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RowPos))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColData) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColData) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RowsetData) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowsetData) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowsetData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cols) > 0 {
		for iNdEx := len(m.Cols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OrderBySpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderBySpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderBySpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Flag != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Flag))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Collation) > 0 {
		i -= len(m.Collation)
		copy(dAtA[i:], m.Collation)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Collation)))
		i--
		dAtA[i] = 0x12
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WindowSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WindowSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Frame != nil {
		{
			size, err := m.Frame.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.OrderBy) > 0 {
		for iNdEx := len(m.OrderBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OrderBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.PartitionBy) > 0 {
		for iNdEx := len(m.PartitionBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PartitionBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.WindowFunc != nil {
		{
			size, err := m.WindowFunc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FrameClause) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FrameClause) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FrameClause) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.End != nil {
		{
			size, err := m.End.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Start != nil {
		{
			size, err := m.Start.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FrameBound) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FrameBound) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FrameBound) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Val != nil {
		{
			size, err := m.Val.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.UnBounded {
		i--
		if m.UnBounded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OnDuplicateKeyCtx) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnDuplicateKeyCtx) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OnDuplicateKeyCtx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OnDuplicateExpr) > 0 {
		for k := range m.OnDuplicateExpr {
			v := m.OnDuplicateExpr[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPlan(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPlan(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPlan(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.OnDuplicateIdx) > 0 {
		dAtA59 := make([]byte, len(m.OnDuplicateIdx)*10)
		var j58 int
		for _, num1 := range m.OnDuplicateIdx {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA59[j58] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j58++
			}
			dAtA59[j58] = uint8(num)
			j58++
		}
		i -= j58
		copy(dAtA[i:], dAtA59[:j58])
		i = encodeVarintPlan(dAtA, i, uint64(j58))
		i--
		dAtA[i] = 0x12
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InsertCtx) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsertCtx) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InsertCtx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PartitionIdx != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.PartitionIdx))
		i--
		dAtA[i] = 0x38
	}
	if len(m.PartitionTableNames) > 0 {
		for iNdEx := len(m.PartitionTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionTableNames[iNdEx])
			copy(dAtA[i:], m.PartitionTableNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionTableNames[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.PartitionTableIds) > 0 {
		dAtA62 := make([]byte, len(m.PartitionTableIds)*10)
		var j61 int
		for _, num := range m.PartitionTableIds {
			for num >= 1<<7 {
				dAtA62[j61] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j61++
			}
			dAtA62[j61] = uint8(num)
			j61++
		}
		i -= j61
		copy(dAtA[i:], dAtA62[:j61])
		i = encodeVarintPlan(dAtA, i, uint64(j61))
		i--
		dAtA[i] = 0x2a
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.IsClusterTable {
		i--
		if m.IsClusterTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AddAffectedRows {
		i--
		if m.AddAffectedRows {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Ref != nil {
		{
			size, err := m.Ref.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceCtx) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceCtx) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceCtx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PartitionIdx != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.PartitionIdx))
		i--
		dAtA[i] = 0x40
	}
	if len(m.PartitionTableNames) > 0 {
		for iNdEx := len(m.PartitionTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionTableNames[iNdEx])
			copy(dAtA[i:], m.PartitionTableNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionTableNames[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.PartitionTableIds) > 0 {
		dAtA66 := make([]byte, len(m.PartitionTableIds)*10)
		var j65 int
		for _, num := range m.PartitionTableIds {
			for num >= 1<<7 {
				dAtA66[j65] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j65++
			}
			dAtA66[j65] = uint8(num)
			j65++
		}
		i -= j65
		copy(dAtA[i:], dAtA66[:j65])
		i = encodeVarintPlan(dAtA, i, uint64(j65))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DeleteCond) > 0 {
		i -= len(m.DeleteCond)
		copy(dAtA[i:], m.DeleteCond)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DeleteCond)))
		i--
		dAtA[i] = 0x2a
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.IsClusterTable {
		i--
		if m.IsClusterTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AddAffectedRows {
		i--
		if m.AddAffectedRows {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Ref != nil {
		{
			size, err := m.Ref.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AnalyzeInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnalyzeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnalyzeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.InsertTime != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.InsertTime))
		i--
		dAtA[i] = 0x70
	}
	if m.ScanTime != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ScanTime))
		i--
		dAtA[i] = 0x68
	}
	if m.NetworkIO != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.NetworkIO))
		i--
		dAtA[i] = 0x60
	}
	if m.S3IOOutputCount != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.S3IOOutputCount))
		i--
		dAtA[i] = 0x58
	}
	if m.S3IOInputCount != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.S3IOInputCount))
		i--
		dAtA[i] = 0x50
	}
	if m.S3IOByte != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.S3IOByte))
		i--
		dAtA[i] = 0x48
	}
	if m.DiskIO != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.DiskIO))
		i--
		dAtA[i] = 0x40
	}
	if m.WaitTimeConsumed != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.WaitTimeConsumed))
		i--
		dAtA[i] = 0x38
	}
	if m.MemorySize != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.MemorySize))
		i--
		dAtA[i] = 0x30
	}
	if m.TimeConsumed != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TimeConsumed))
		i--
		dAtA[i] = 0x28
	}
	if m.OutputSize != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.OutputSize))
		i--
		dAtA[i] = 0x20
	}
	if m.InputSize != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.InputSize))
		i--
		dAtA[i] = 0x18
	}
	if m.OutputRows != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.OutputRows))
		i--
		dAtA[i] = 0x10
	}
	if m.InputRows != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.InputRows))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for iNdEx := len(m.RuntimeFilterBuildList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterBuildList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.RuntimeFilterProbeList) > 0 {
		for iNdEx := len(m.RuntimeFilterProbeList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuntimeFilterProbeList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.BlockFilterList) > 0 {
		for iNdEx := len(m.BlockFilterList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BlockFilterList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.LockTargets) > 0 {
		for iNdEx := len(m.LockTargets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LockTargets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.IsEnd {
		i--
		if m.IsEnd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.OnDuplicateKey != nil {
		{
			size, err := m.OnDuplicateKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if m.PreInsertUkCtx != nil {
		{
			size, err := m.PreInsertUkCtx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.PreInsertCtx != nil {
		{
			size, err := m.PreInsertCtx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if m.PreDeleteCtx != nil {
		{
			size, err := m.PreDeleteCtx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if len(m.SourceStep) > 0 {
		dAtA74 := make([]byte, len(m.SourceStep)*10)
		var j73 int
		for _, num1 := range m.SourceStep {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA74[j73] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j73++
			}
			dAtA74[j73] = uint8(num)
			j73++
		}
		i -= j73
		copy(dAtA[i:], dAtA74[:j73])
		i = encodeVarintPlan(dAtA, i, uint64(j73))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if m.ReplaceCtx != nil {
		{
			size, err := m.ReplaceCtx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.InsertCtx != nil {
		{
			size, err := m.InsertCtx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.NotCacheable {
		i--
		if m.NotCacheable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.ClusterTable != nil {
		{
			size, err := m.ClusterTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.TblFuncExprList) > 0 {
		for iNdEx := len(m.TblFuncExprList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TblFuncExprList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if m.AnalyzeInfo != nil {
		{
			size, err := m.AnalyzeInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.BindingTags) > 0 {
		dAtA80 := make([]byte, len(m.BindingTags)*10)
		var j79 int
		for _, num1 := range m.BindingTags {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA80[j79] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j79++
			}
			dAtA80[j79] = uint8(num)
			j79++
		}
		i -= j79
		copy(dAtA[i:], dAtA80[:j79])
		i = encodeVarintPlan(dAtA, i, uint64(j79))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.DeleteCtx != nil {
		{
			size, err := m.DeleteCtx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.ExtraOptions) > 0 {
		i -= len(m.ExtraOptions)
		copy(dAtA[i:], m.ExtraOptions)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ExtraOptions)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.RowsetData != nil {
		{
			size, err := m.RowsetData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.ObjRef != nil {
		{
			size, err := m.ObjRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.TableDefVec) > 0 {
		for iNdEx := len(m.TableDefVec) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TableDefVec[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.Offset != nil {
		{
			size, err := m.Offset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Limit != nil {
		{
			size, err := m.Limit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if len(m.OrderBy) > 0 {
		for iNdEx := len(m.OrderBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OrderBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.WinSpecList) > 0 {
		for iNdEx := len(m.WinSpecList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WinSpecList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.AggList) > 0 {
		for iNdEx := len(m.AggList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AggList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.GroupingSet) > 0 {
		for iNdEx := len(m.GroupingSet) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GroupingSet[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.GroupBy) > 0 {
		for iNdEx := len(m.GroupBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GroupBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.FilterList) > 0 {
		for iNdEx := len(m.FilterList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FilterList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.BuildOnLeft {
		i--
		if m.BuildOnLeft {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.OnList) > 0 {
		for iNdEx := len(m.OnList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OnList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.JoinType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.JoinType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ProjectList) > 0 {
		for iNdEx := len(m.ProjectList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProjectList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Children) > 0 {
		dAtA88 := make([]byte, len(m.Children)*10)
		var j87 int
		for _, num1 := range m.Children {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA88[j87] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j87++
			}
			dAtA88[j87] = uint8(num)
			j87++
		}
		i -= j87
		copy(dAtA[i:], dAtA88[:j87])
		i = encodeVarintPlan(dAtA, i, uint64(j87))
		i--
		dAtA[i] = 0x22
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.NodeId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x10
	}
	if m.NodeType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.NodeType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LockTarget) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Block {
		i--
		if m.Block {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.PartitionTableIds) > 0 {
		dAtA91 := make([]byte, len(m.PartitionTableIds)*10)
		var j90 int
		for _, num := range m.PartitionTableIds {
			for num >= 1<<7 {
				dAtA91[j90] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j90++
			}
			dAtA91[j90] = uint8(num)
			j90++
		}
		i -= j90
		copy(dAtA[i:], dAtA91[:j90])
		i = encodeVarintPlan(dAtA, i, uint64(j90))
		i--
		dAtA[i] = 0x42
	}
	if m.IsPartitionTable {
		i--
		if m.IsPartitionTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.LockTable {
		i--
		if m.LockTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.FilterColIdxInBat != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.FilterColIdxInBat))
		i--
		dAtA[i] = 0x28
	}
	if m.RefreshTsIdxInBat != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RefreshTsIdxInBat))
		i--
		dAtA[i] = 0x20
	}
	if m.PrimaryColTyp != nil {
		{
			size, err := m.PrimaryColTyp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PrimaryColIdxInBat != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.PrimaryColIdxInBat))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PreInsertUkCtx) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreInsertUkCtx) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PreInsertUkCtx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.UkType != nil {
		{
			size, err := m.UkType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PkType != nil {
		{
			size, err := m.PkType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PkColumn != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.PkColumn))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Columns) > 0 {
		dAtA97 := make([]byte, len(m.Columns)*10)
		var j96 int
		for _, num1 := range m.Columns {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA97[j96] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j96++
			}
			dAtA97[j96] = uint8(num)
			j96++
		}
		i -= j96
		copy(dAtA[i:], dAtA97[:j96])
		i = encodeVarintPlan(dAtA, i, uint64(j96))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PreDeleteCtx) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreDeleteCtx) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PreDeleteCtx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Idx) > 0 {
		dAtA99 := make([]byte, len(m.Idx)*10)
		var j98 int
		for _, num1 := range m.Idx {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA99[j98] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j98++
			}
			dAtA99[j98] = uint8(num)
			j98++
		}
		i -= j98
		copy(dAtA[i:], dAtA99[:j98])
		i = encodeVarintPlan(dAtA, i, uint64(j98))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PreInsertCtx) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreInsertCtx) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PreInsertCtx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsUpdate {
		i--
		if m.IsUpdate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.HasAutoCol {
		i--
		if m.HasAutoCol {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Ref != nil {
		{
			size, err := m.Ref.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RuntimeFilterSpec) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuntimeFilterSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RuntimeFilterSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Tag != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IdList) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdList) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IdList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.List) > 0 {
		dAtA104 := make([]byte, len(m.List)*10)
		var j103 int
		for _, num1 := range m.List {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA104[j103] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j103++
			}
			dAtA104[j103] = uint8(num)
			j103++
		}
		i -= j103
		copy(dAtA[i:], dAtA104[:j103])
		i = encodeVarintPlan(dAtA, i, uint64(j103))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ColPosMap) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColPosMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColPosMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Map) > 0 {
		for k := range m.Map {
			v := m.Map[k]
			baseI := i
			i = encodeVarintPlan(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPlan(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPlan(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeleteCtx) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteCtx) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteCtx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PrimaryKeyIdx != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.PrimaryKeyIdx))
		i--
		dAtA[i] = 0x48
	}
	if m.PartitionIdx != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.PartitionIdx))
		i--
		dAtA[i] = 0x40
	}
	if len(m.PartitionTableNames) > 0 {
		for iNdEx := len(m.PartitionTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionTableNames[iNdEx])
			copy(dAtA[i:], m.PartitionTableNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionTableNames[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.PartitionTableIds) > 0 {
		dAtA106 := make([]byte, len(m.PartitionTableIds)*10)
		var j105 int
		for _, num := range m.PartitionTableIds {
			for num >= 1<<7 {
				dAtA106[j105] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j105++
			}
			dAtA106[j105] = uint8(num)
			j105++
		}
		i -= j105
		copy(dAtA[i:], dAtA106[:j105])
		i = encodeVarintPlan(dAtA, i, uint64(j105))
		i--
		dAtA[i] = 0x32
	}
	if m.IsClusterTable {
		i--
		if m.IsClusterTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.AddAffectedRows {
		i--
		if m.AddAffectedRows {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.RowIdIdx != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RowIdIdx))
		i--
		dAtA[i] = 0x18
	}
	if m.Ref != nil {
		{
			size, err := m.Ref.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CanTruncate {
		i--
		if m.CanTruncate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Query) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Query) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Query) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LoadTag {
		i--
		if m.LoadTag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Headings) > 0 {
		for iNdEx := len(m.Headings) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Headings[iNdEx])
			copy(dAtA[i:], m.Headings[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.Headings[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Params) > 0 {
		for iNdEx := len(m.Params) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Params[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Steps) > 0 {
		dAtA109 := make([]byte, len(m.Steps)*10)
		var j108 int
		for _, num1 := range m.Steps {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA109[j108] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j108++
			}
			dAtA109[j108] = uint8(num)
			j108++
		}
		i -= j108
		copy(dAtA[i:], dAtA109[:j108])
		i = encodeVarintPlan(dAtA, i, uint64(j108))
		i--
		dAtA[i] = 0x12
	}
	if m.StmtType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.StmtType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransationControl) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransationControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Action != nil {
		{
			size := m.Action.ProtoSize()
			i -= size
			if _, err := m.Action.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TclType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TclType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransationControl_Begin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationControl_Begin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Begin != nil {
		{
			size, err := m.Begin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *TransationControl_Commit) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationControl_Commit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *TransationControl_Rollback) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationControl_Rollback) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Rollback != nil {
		{
			size, err := m.Rollback.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *TransationBegin) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransationBegin) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationBegin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mode != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransationCommit) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransationCommit) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationCommit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CompletionType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.CompletionType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransationRollback) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransationRollback) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransationRollback) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CompletionType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.CompletionType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Plan) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Plan) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsPrepare {
		i--
		if m.IsPrepare {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.TryRunTimes != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TryRunTimes))
		i--
		dAtA[i] = 0x28
	}
	if m.Plan != nil {
		{
			size := m.Plan.ProtoSize()
			i -= size
			if _, err := m.Plan.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Plan_Query) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan_Query) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Plan_Tcl) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan_Tcl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Tcl != nil {
		{
			size, err := m.Tcl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Plan_Ddl) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan_Ddl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ddl != nil {
		{
			size, err := m.Ddl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Plan_Dcl) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan_Dcl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Dcl != nil {
		{
			size, err := m.Dcl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Column) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Column) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Column) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Column) > 0 {
		for iNdEx := len(m.Column) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Column[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataControl) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Control != nil {
		{
			size := m.Control.ProtoSize()
			i -= size
			if _, err := m.Control.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DclType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.DclType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataControl_SetVariables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataControl_SetVariables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SetVariables != nil {
		{
			size, err := m.SetVariables.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *DataControl_Prepare) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataControl_Prepare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Prepare != nil {
		{
			size, err := m.Prepare.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DataControl_Execute) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataControl_Execute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Execute != nil {
		{
			size, err := m.Execute.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DataControl_Deallocate) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataControl_Deallocate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Deallocate != nil {
		{
			size, err := m.Deallocate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataDefinition) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Definition != nil {
		{
			size := m.Definition.ProtoSize()
			i -= size
			if _, err := m.Definition.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Query != nil {
		{
			size, err := m.Query.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.DdlType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.DdlType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataDefinition_CreateDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_CreateDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateDatabase != nil {
		{
			size, err := m.CreateDatabase.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_AlterDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_AlterDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterDatabase != nil {
		{
			size, err := m.AlterDatabase.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_DropDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_DropDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DropDatabase != nil {
		{
			size, err := m.DropDatabase.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_CreateTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_CreateTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateTable != nil {
		{
			size, err := m.CreateTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_AlterTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_AlterTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterTable != nil {
		{
			size, err := m.AlterTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_DropTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_DropTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DropTable != nil {
		{
			size, err := m.DropTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_CreateIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_CreateIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateIndex != nil {
		{
			size, err := m.CreateIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_AlterIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_AlterIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterIndex != nil {
		{
			size, err := m.AlterIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_DropIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_DropIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DropIndex != nil {
		{
			size, err := m.DropIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_TruncateTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_TruncateTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TruncateTable != nil {
		{
			size, err := m.TruncateTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_ShowVariables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_ShowVariables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ShowVariables != nil {
		{
			size, err := m.ShowVariables.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_AlterView) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_AlterView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterView != nil {
		{
			size, err := m.AlterView.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_LockTables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_LockTables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LockTables != nil {
		{
			size, err := m.LockTables.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_UnlockTables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_UnlockTables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UnlockTables != nil {
		{
			size, err := m.UnlockTables.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_CreateSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_CreateSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateSequence != nil {
		{
			size, err := m.CreateSequence.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_DropSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_DropSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DropSequence != nil {
		{
			size, err := m.DropSequence.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *DataDefinition_AlterSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataDefinition_AlterSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterSequence != nil {
		{
			size, err := m.AlterSequence.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *SubscriptionOption) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscriptionOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscriptionOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Publication) > 0 {
		i -= len(m.Publication)
		copy(dAtA[i:], m.Publication)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Publication)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateDatabase) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubscriptionOption != nil {
		{
			size, err := m.SubscriptionOption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfNotExists {
		i--
		if m.IfNotExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlterDatabase) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfExists {
		i--
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DropDatabase) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DatabaseId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.DatabaseId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfExists {
		i--
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FkColName) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FkColName) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FkColName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cols) > 0 {
		for iNdEx := len(m.Cols) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Cols[iNdEx])
			copy(dAtA[i:], m.Cols[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.Cols[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateTable) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PartitionTables) > 0 {
		for iNdEx := len(m.PartitionTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PartitionTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.FkCols) > 0 {
		for iNdEx := len(m.FkCols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FkCols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.FkTables) > 0 {
		for iNdEx := len(m.FkTables) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FkTables[iNdEx])
			copy(dAtA[i:], m.FkTables[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.FkTables[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.FkDbs) > 0 {
		for iNdEx := len(m.FkDbs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FkDbs[iNdEx])
			copy(dAtA[i:], m.FkDbs[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.FkDbs[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.IndexTables) > 0 {
		for iNdEx := len(m.IndexTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IndexTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Temporary {
		i--
		if m.Temporary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.IfNotExists {
		i--
		if m.IfNotExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlterTableDrop) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTableDrop) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTableDrop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IndexTableName) > 0 {
		i -= len(m.IndexTableName)
		copy(dAtA[i:], m.IndexTableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexTableName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Typ != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Typ))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlterTableAddFk) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTableAddFk) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTableAddFk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Fkey != nil {
		{
			size, err := m.Fkey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Cols) > 0 {
		for iNdEx := len(m.Cols) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Cols[iNdEx])
			copy(dAtA[i:], m.Cols[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.Cols[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterTableAddIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTableAddIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTableAddIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IndexTableExist {
		i--
		if m.IndexTableExist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.IndexInfo != nil {
		{
			size, err := m.IndexInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.OriginTablePrimaryKey) > 0 {
		i -= len(m.OriginTablePrimaryKey)
		copy(dAtA[i:], m.OriginTablePrimaryKey)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.OriginTablePrimaryKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterTableDropIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTableDropIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTableDropIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IndexTableName) > 0 {
		i -= len(m.IndexTableName)
		copy(dAtA[i:], m.IndexTableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexTableName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.IndexName) > 0 {
		i -= len(m.IndexName)
		copy(dAtA[i:], m.IndexName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterTableAlterIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTableAlterIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTableAlterIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Visible {
		i--
		if m.Visible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.IndexName) > 0 {
		i -= len(m.IndexName)
		copy(dAtA[i:], m.IndexName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterTableComment) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTableComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTableComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NewComment) > 0 {
		i -= len(m.NewComment)
		copy(dAtA[i:], m.NewComment)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.NewComment)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterTableName) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTableName) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTableName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NewName) > 0 {
		i -= len(m.NewName)
		copy(dAtA[i:], m.NewName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.NewName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OldName) > 0 {
		i -= len(m.OldName)
		copy(dAtA[i:], m.OldName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.OldName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterAddCol) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterAddCol) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterAddCol) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Pos != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Pos))
		i--
		dAtA[i] = 0x20
	}
	if m.Type != nil {
		{
			size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PreName) > 0 {
		i -= len(m.PreName)
		copy(dAtA[i:], m.PreName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.PreName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterDropCol) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterDropCol) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterDropCol) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Seq != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x10
	}
	if m.Idx != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.Idx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlterTable) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ChangeTblColIdMap) > 0 {
		for k := range m.ChangeTblColIdMap {
			v := m.ChangeTblColIdMap[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPlan(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintPlan(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintPlan(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.InsertDataSql) > 0 {
		i -= len(m.InsertDataSql)
		copy(dAtA[i:], m.InsertDataSql)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.InsertDataSql)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.CreateTableSql) > 0 {
		i -= len(m.CreateTableSql)
		copy(dAtA[i:], m.CreateTableSql)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.CreateTableSql)))
		i--
		dAtA[i] = 0x3a
	}
	if m.AlgorithmType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.AlgorithmType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Actions) > 0 {
		for iNdEx := len(m.Actions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Actions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.IsClusterTable {
		i--
		if m.IsClusterTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.CopyTableDef != nil {
		{
			size, err := m.CopyTableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterTable_Action) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterTable_Action) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Action != nil {
		{
			size := m.Action.ProtoSize()
			i -= size
			if _, err := m.Action.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AlterTable_Action_Drop) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action_Drop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Drop != nil {
		{
			size, err := m.Drop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AlterTable_Action_AddFk) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action_AddFk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddFk != nil {
		{
			size, err := m.AddFk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AlterTable_Action_AddIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action_AddIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddIndex != nil {
		{
			size, err := m.AddIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AlterTable_Action_AlterIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action_AlterIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterIndex != nil {
		{
			size, err := m.AlterIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AlterTable_Action_AlterComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action_AlterComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterComment != nil {
		{
			size, err := m.AlterComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *AlterTable_Action_AlterName) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action_AlterName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AlterName != nil {
		{
			size, err := m.AlterName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *AlterTable_Action_AddCol) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action_AddCol) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddCol != nil {
		{
			size, err := m.AddCol.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *AlterTable_Action_DropCol) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterTable_Action_DropCol) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DropCol != nil {
		{
			size, err := m.DropCol.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *DropTable) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.IsView {
		i--
		if m.IsView {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.PartitionTableNames) > 0 {
		for iNdEx := len(m.PartitionTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionTableNames[iNdEx])
			copy(dAtA[i:], m.PartitionTableNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionTableNames[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ForeignTbl) > 0 {
		dAtA157 := make([]byte, len(m.ForeignTbl)*10)
		var j156 int
		for _, num := range m.ForeignTbl {
			for num >= 1<<7 {
				dAtA157[j156] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j156++
			}
			dAtA157[j156] = uint8(num)
			j156++
		}
		i -= j156
		copy(dAtA[i:], dAtA157[:j156])
		i = encodeVarintPlan(dAtA, i, uint64(j156))
		i--
		dAtA[i] = 0x3a
	}
	if m.TableId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x30
	}
	if m.ClusterTable != nil {
		{
			size, err := m.ClusterTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.IndexTableNames) > 0 {
		for iNdEx := len(m.IndexTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IndexTableNames[iNdEx])
			copy(dAtA[i:], m.IndexTableNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexTableNames[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfExists {
		i--
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlterView) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterView) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfExists {
		i--
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateSequence) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfNotExists {
		i--
		if m.IfNotExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DropSequence) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x12
	}
	if m.IfExists {
		i--
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlterSequence) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *CreateIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableExist {
		i--
		if m.TableExist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Index != nil {
		{
			size, err := m.Index.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OriginTablePrimaryKey) > 0 {
		i -= len(m.OriginTablePrimaryKey)
		copy(dAtA[i:], m.OriginTablePrimaryKey)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.OriginTablePrimaryKey)))
		i--
		dAtA[i] = 0x22
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AlterIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlterIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlterIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Index) > 0 {
		i -= len(m.Index)
		copy(dAtA[i:], m.Index)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Index)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DropIndex) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IndexTableName) > 0 {
		i -= len(m.IndexTableName)
		copy(dAtA[i:], m.IndexTableName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexTableName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.IndexName) > 0 {
		i -= len(m.IndexName)
		copy(dAtA[i:], m.IndexName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TruncateTable) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TruncateTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TruncateTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ForeignTbl) > 0 {
		dAtA164 := make([]byte, len(m.ForeignTbl)*10)
		var j163 int
		for _, num := range m.ForeignTbl {
			for num >= 1<<7 {
				dAtA164[j163] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j163++
			}
			dAtA164[j163] = uint8(num)
			j163++
		}
		i -= j163
		copy(dAtA[i:], dAtA164[:j163])
		i = encodeVarintPlan(dAtA, i, uint64(j163))
		i--
		dAtA[i] = 0x3a
	}
	if m.TableId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x30
	}
	if m.ClusterTable != nil {
		{
			size, err := m.ClusterTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PartitionTableNames) > 0 {
		for iNdEx := len(m.PartitionTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PartitionTableNames[iNdEx])
			copy(dAtA[i:], m.PartitionTableNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.PartitionTableNames[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.IndexTableNames) > 0 {
		for iNdEx := len(m.IndexTableNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IndexTableNames[iNdEx])
			copy(dAtA[i:], m.IndexTableNames[iNdEx])
			i = encodeVarintPlan(dAtA, i, uint64(len(m.IndexTableNames[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterTable) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ColumnIndexOfAccountId != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.ColumnIndexOfAccountId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AccountIDs) > 0 {
		dAtA167 := make([]byte, len(m.AccountIDs)*10)
		var j166 int
		for _, num := range m.AccountIDs {
			for num >= 1<<7 {
				dAtA167[j166] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j166++
			}
			dAtA167[j166] = uint8(num)
			j166++
		}
		i -= j166
		copy(dAtA[i:], dAtA167[:j166])
		i = encodeVarintPlan(dAtA, i, uint64(j166))
		i--
		dAtA[i] = 0x12
	}
	if m.IsClusterTable {
		i--
		if m.IsClusterTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShowVariables) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowVariables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShowVariables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Where) > 0 {
		for iNdEx := len(m.Where) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Where[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Global {
		i--
		if m.Global {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetVariables) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetVariables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetVariables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SetVariablesItem) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetVariablesItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetVariablesItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Reserved != nil {
		{
			size, err := m.Reserved.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Global {
		i--
		if m.Global {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.System {
		i--
		if m.System {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Prepare) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Prepare) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Prepare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ParamTypes) > 0 {
		dAtA171 := make([]byte, len(m.ParamTypes)*10)
		var j170 int
		for _, num1 := range m.ParamTypes {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA171[j170] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j170++
			}
			dAtA171[j170] = uint8(num)
			j170++
		}
		i -= j170
		copy(dAtA[i:], dAtA171[:j170])
		i = encodeVarintPlan(dAtA, i, uint64(j170))
		i--
		dAtA[i] = 0x22
	}
	if m.Plan != nil {
		{
			size, err := m.Plan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Schemas) > 0 {
		for iNdEx := len(m.Schemas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Schemas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Execute) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Execute) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Execute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Args[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Deallocate) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deallocate) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Deallocate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableLockInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableLockInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableLockInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableDef != nil {
		{
			size, err := m.TableDef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LockType != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.LockType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LockTables) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockTables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockTables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TableLocks) > 0 {
		for iNdEx := len(m.TableLocks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TableLocks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UnLockTables) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnLockTables) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnLockTables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *MetadataScanInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetadataScanInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetadataScanInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Max) > 0 {
		i -= len(m.Max)
		copy(dAtA[i:], m.Max)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Max)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.Min) > 0 {
		i -= len(m.Min)
		copy(dAtA[i:], m.Min)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.Min)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.OriginSize != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.OriginSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.CompressSize != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.CompressSize))
		i--
		dAtA[i] = 0x78
	}
	if m.NullCnt != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.NullCnt))
		i--
		dAtA[i] = 0x70
	}
	if m.RowCnt != 0 {
		i = encodeVarintPlan(dAtA, i, uint64(m.RowCnt))
		i--
		dAtA[i] = 0x68
	}
	if len(m.SegId) > 0 {
		i -= len(m.SegId)
		copy(dAtA[i:], m.SegId)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.SegId)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.DeleteTs) > 0 {
		i -= len(m.DeleteTs)
		copy(dAtA[i:], m.DeleteTs)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DeleteTs)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.CreateTs) > 0 {
		i -= len(m.CreateTs)
		copy(dAtA[i:], m.CreateTs)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.CreateTs)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.CommitTs) > 0 {
		i -= len(m.CommitTs)
		copy(dAtA[i:], m.CommitTs)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.CommitTs)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.DelLoc) > 0 {
		i -= len(m.DelLoc)
		copy(dAtA[i:], m.DelLoc)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.DelLoc)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.MetaLoc) > 0 {
		i -= len(m.MetaLoc)
		copy(dAtA[i:], m.MetaLoc)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.MetaLoc)))
		i--
		dAtA[i] = 0x3a
	}
	if m.IsHidden {
		i--
		if m.IsHidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Sorted {
		i--
		if m.Sorted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.EntryState {
		i--
		if m.EntryState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.ObjectName) > 0 {
		i -= len(m.ObjectName)
		copy(dAtA[i:], m.ObjectName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ObjectName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BlockId) > 0 {
		i -= len(m.BlockId)
		copy(dAtA[i:], m.BlockId)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.BlockId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ColName) > 0 {
		i -= len(m.ColName)
		copy(dAtA[i:], m.ColName)
		i = encodeVarintPlan(dAtA, i, uint64(len(m.ColName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPlan(dAtA []byte, offset int, v uint64) int {
	offset -= sovPlan(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Type) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlan(uint64(m.Id))
	}
	if m.NotNullable {
		n += 2
	}
	if m.AutoIncr {
		n += 2
	}
	if m.Width != 0 {
		n += 1 + sovPlan(uint64(m.Width))
	}
	if m.Scale != 0 {
		n += 1 + sovPlan(uint64(m.Scale))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Const) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Isnull {
		n += 2
	}
	if m.Value != nil {
		n += m.Value.ProtoSize()
	}
	if m.IsBin {
		n += 3
	}
	if m.Src != nil {
		l = m.Src.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Const_I8Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.I8Val))
	return n
}
func (m *Const_I16Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.I16Val))
	return n
}
func (m *Const_I32Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.I32Val))
	return n
}
func (m *Const_I64Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.I64Val))
	return n
}
func (m *Const_U8Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.U8Val))
	return n
}
func (m *Const_U16Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.U16Val))
	return n
}
func (m *Const_U32Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.U32Val))
	return n
}
func (m *Const_U64Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.U64Val))
	return n
}
func (m *Const_Dval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *Const_Sval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sval)
	n += 1 + l + sovPlan(uint64(l))
	return n
}
func (m *Const_Bval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *Const_Fval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	return n
}
func (m *Const_Dateval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.Dateval))
	return n
}
func (m *Const_Timeval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPlan(uint64(m.Timeval))
	return n
}
func (m *Const_Datetimeval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sovPlan(uint64(m.Datetimeval))
	return n
}
func (m *Const_Decimal64Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Decimal64Val != nil {
		l = m.Decimal64Val.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Const_Decimal128Val) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Decimal128Val != nil {
		l = m.Decimal128Val.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Const_Timestampval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sovPlan(uint64(m.Timestampval))
	return n
}
func (m *Const_Jsonval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Jsonval)
	n += 2 + l + sovPlan(uint64(l))
	return n
}
func (m *Const_Defaultval) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 3
	return n
}
func (m *Const_UpdateVal) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 3
	return n
}
func (m *ParamRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pos != 0 {
		n += 1 + sovPlan(uint64(m.Pos))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VarRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.System {
		n += 2
	}
	if m.Global {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RelPos != 0 {
		n += 1 + sovPlan(uint64(m.RelPos))
	}
	if m.ColPos != 0 {
		n += 1 + sovPlan(uint64(m.ColPos))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RawColRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TblId != 0 {
		n += 1 + sovPlan(uint64(m.TblId))
	}
	if m.ColId != 0 {
		n += 1 + sovPlan(uint64(m.ColId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CorrColRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RelPos != 0 {
		n += 1 + sovPlan(uint64(m.RelPos))
	}
	if m.ColPos != 0 {
		n += 1 + sovPlan(uint64(m.ColPos))
	}
	if m.Depth != 0 {
		n += 1 + sovPlan(uint64(m.Depth))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExprList) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MaxValue) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TargetType) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Typ != nil {
		l = m.Typ.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubqueryRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Typ != 0 {
		n += 1 + sovPlan(uint64(m.Typ))
	}
	if m.NodeId != 0 {
		n += 1 + sovPlan(uint64(m.NodeId))
	}
	l = len(m.Op)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Child != nil {
		l = m.Child.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.RowSize != 0 {
		n += 1 + sovPlan(uint64(m.RowSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectRef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Server != 0 {
		n += 1 + sovPlan(uint64(m.Server))
	}
	if m.Db != 0 {
		n += 1 + sovPlan(uint64(m.Db))
	}
	if m.Schema != 0 {
		n += 1 + sovPlan(uint64(m.Schema))
	}
	if m.Obj != 0 {
		n += 1 + sovPlan(uint64(m.Obj))
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.SchemaName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.ObjName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.SubscriptionName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.PubInfo != nil {
		l = m.PubInfo.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PubInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TenantId != 0 {
		n += 1 + sovPlan(uint64(m.TenantId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubscriptionMeta) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.AccountId != 0 {
		n += 1 + sovPlan(uint64(m.AccountId))
	}
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.AccountName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.SubName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Function) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Func != nil {
		l = m.Func.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, e := range m.Args {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Expr) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Typ != nil {
		l = m.Typ.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Expr != nil {
		n += m.Expr.ProtoSize()
	}
	if m.AuxId != 0 {
		n += 1 + sovPlan(uint64(m.AuxId))
	}
	if m.Ndv != 0 {
		n += 9
	}
	if m.Selectivity != 0 {
		n += 10
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Expr_C) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.C != nil {
		l = m.C.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_P) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.P != nil {
		l = m.P.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_V) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.V != nil {
		l = m.V.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_Col) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Col != nil {
		l = m.Col.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_Raw) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Raw != nil {
		l = m.Raw.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_F) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.F != nil {
		l = m.F.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_W) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.W != nil {
		l = m.W.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_Sub) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sub != nil {
		l = m.Sub.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_Corr) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Corr != nil {
		l = m.Corr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_T) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.T != nil {
		l = m.T.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_List) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.List != nil {
		l = m.List.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Expr_Max) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Max != nil {
		l = m.Max.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Decimal64) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A != 0 {
		n += 1 + sovPlan(uint64(m.A))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Decimal128) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A != 0 {
		n += 1 + sovPlan(uint64(m.A))
	}
	if m.B != 0 {
		n += 1 + sovPlan(uint64(m.B))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultColDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ResultCols) > 0 {
		for _, e := range m.ResultCols {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColId != 0 {
		n += 1 + sovPlan(uint64(m.ColId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Hidden {
		n += 2
	}
	if m.Alg != 0 {
		n += 1 + sovPlan(uint64(m.Alg))
	}
	if m.Typ != nil {
		l = m.Typ.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.NotNull {
		n += 2
	}
	if m.Default != nil {
		l = m.Default.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.OnUpdate != nil {
		l = m.OnUpdate.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.LowCard {
		n += 2
	}
	if m.Seqnum != 0 {
		n += 1 + sovPlan(uint64(m.Seqnum))
	}
	if m.ClusterBy {
		n += 2
	}
	if m.Primary {
		n += 2
	}
	if m.Pkidx != 0 {
		n += 1 + sovPlan(uint64(m.Pkidx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Default) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.OriginString)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.NullAbility {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OnUpdate) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.OriginString)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IndexOption) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateExtraTable {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrimaryKeyDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cols) > 0 {
		l = 0
		for _, e := range m.Cols {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.PkeyColId != 0 {
		n += 1 + sovPlan(uint64(m.PkeyColId))
	}
	if m.Option != nil {
		l = m.Option.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.PkeyColName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.CompPkeyCol != nil {
		l = m.CompPkeyCol.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IndexDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IdxId)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Parts) > 0 {
		for _, s := range m.Parts {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Unique {
		n += 2
	}
	l = len(m.IndexTableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableExist {
		n += 2
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Visible {
		n += 2
	}
	if m.Option != nil {
		l = m.Option.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ForeignKeyDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Cols) > 0 {
		l = 0
		for _, e := range m.Cols {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.ForeignTbl != 0 {
		n += 1 + sovPlan(uint64(m.ForeignTbl))
	}
	if len(m.ForeignCols) > 0 {
		l = 0
		for _, e := range m.ForeignCols {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.OnDelete != 0 {
		n += 1 + sovPlan(uint64(m.OnDelete))
	}
	if m.OnUpdate != 0 {
		n += 1 + sovPlan(uint64(m.OnUpdate))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Check != nil {
		l = m.Check.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterByDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.CompCbkeyCol != nil {
		l = m.CompCbkeyCol.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PropertyDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Property) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PropertiesDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Properties) > 0 {
		for _, e := range m.Properties {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionByDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPlan(uint64(m.Type))
	}
	if m.PartitionExpr != nil {
		l = m.PartitionExpr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.PartitionExpression != nil {
		l = m.PartitionExpression.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.PartitionColumns != nil {
		l = m.PartitionColumns.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.PartitionNum != 0 {
		n += 1 + sovPlan(uint64(m.PartitionNum))
	}
	if len(m.Partitions) > 0 {
		for _, e := range m.Partitions {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Algorithm != 0 {
		n += 1 + sovPlan(uint64(m.Algorithm))
	}
	if m.IsSubPartition {
		n += 2
	}
	l = len(m.PartitionMsg)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.PartitionTableNames) > 0 {
		for _, s := range m.PartitionTableNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionExpr) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.ExprStr)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionColumns) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.PartitionColumns) > 0 {
		for _, s := range m.PartitionColumns {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionItem) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PartitionName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.OrdinalPosition != 0 {
		n += 1 + sovPlan(uint64(m.OrdinalPosition))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.LessThan) > 0 {
		for _, e := range m.LessThan {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.InValues) > 0 {
		for _, e := range m.InValues {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	l = len(m.PartitionTableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ViewDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.View)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableDef) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TblId != 0 {
		n += 1 + sovPlan(uint64(m.TblId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Hidden {
		n += 2
	}
	if len(m.Cols) > 0 {
		for _, e := range m.Cols {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	l = len(m.TableType)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Createsql)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TblFunc != nil {
		l = m.TblFunc.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovPlan(uint64(m.Version))
	}
	if m.Pkey != nil {
		l = m.Pkey.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Indexes) > 0 {
		for _, e := range m.Indexes {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Fkeys) > 0 {
		for _, e := range m.Fkeys {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.RefChildTbls) > 0 {
		l = 0
		for _, e := range m.RefChildTbls {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.Checks) > 0 {
		for _, e := range m.Checks {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Partition != nil {
		l = m.Partition.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.ClusterBy != nil {
		l = m.ClusterBy.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if len(m.Props) > 0 {
		for _, e := range m.Props {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if m.ViewSql != nil {
		l = m.ViewSql.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if len(m.Defs) > 0 {
		for _, e := range m.Defs {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Name2ColIndex) > 0 {
		for k, v := range m.Name2ColIndex {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPlan(uint64(len(k))) + 1 + sovPlan(uint64(v))
			n += mapEntrySize + 2 + sovPlan(uint64(mapEntrySize))
		}
	}
	if m.IsLocked {
		n += 3
	}
	if m.TableLockType != 0 {
		n += 2 + sovPlan(uint64(m.TableLockType))
	}
	if m.IsTemporary {
		n += 3
	}
	if m.AutoIncrOffset != 0 {
		n += 2 + sovPlan(uint64(m.AutoIncrOffset))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableDef_DefType) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Def != nil {
		n += m.Def.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableDef_DefType_Properties) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Properties != nil {
		l = m.Properties.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TableFunction) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Param)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HashMapStats) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HashmapSize != 0 {
		n += 9
	}
	if m.HashOnPK {
		n += 2
	}
	if m.Shuffle {
		n += 2
	}
	if m.ShuffleColIdx != 0 {
		n += 1 + sovPlan(uint64(m.ShuffleColIdx))
	}
	if m.ShuffleType != 0 {
		n += 1 + sovPlan(uint64(m.ShuffleType))
	}
	if m.ShuffleColMin != 0 {
		n += 1 + sovPlan(uint64(m.ShuffleColMin))
	}
	if m.ShuffleColMax != 0 {
		n += 1 + sovPlan(uint64(m.ShuffleColMax))
	}
	if m.ShuffleMethod != 0 {
		n += 1 + sovPlan(uint64(m.ShuffleMethod))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Stats) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockNum != 0 {
		n += 1 + sovPlan(uint64(m.BlockNum))
	}
	if m.Cost != 0 {
		n += 9
	}
	if m.Outcnt != 0 {
		n += 9
	}
	if m.Rowsize != 0 {
		n += 9
	}
	if m.TableCnt != 0 {
		n += 9
	}
	if m.Selectivity != 0 {
		n += 9
	}
	if m.HashmapStats != nil {
		l = m.HashmapStats.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RowsetExpr) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RowPos != 0 {
		n += 1 + sovPlan(uint64(m.RowPos))
	}
	if m.Pos != 0 {
		n += 1 + sovPlan(uint64(m.Pos))
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColData) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RowsetData) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cols) > 0 {
		for _, e := range m.Cols {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrderBySpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Collation)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Flag != 0 {
		n += 1 + sovPlan(uint64(m.Flag))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WindowSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WindowFunc != nil {
		l = m.WindowFunc.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.PartitionBy) > 0 {
		for _, e := range m.PartitionBy {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OrderBy) > 0 {
		for _, e := range m.OrderBy {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Frame != nil {
		l = m.Frame.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FrameClause) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPlan(uint64(m.Type))
	}
	if m.Start != nil {
		l = m.Start.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.End != nil {
		l = m.End.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FrameBound) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPlan(uint64(m.Type))
	}
	if m.UnBounded {
		n += 2
	}
	if m.Val != nil {
		l = m.Val.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OnDuplicateKeyCtx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.OnDuplicateIdx) > 0 {
		l = 0
		for _, e := range m.OnDuplicateIdx {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.OnDuplicateExpr) > 0 {
		for k, v := range m.OnDuplicateExpr {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.ProtoSize()
				l += 1 + sovPlan(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPlan(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPlan(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InsertCtx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ref != nil {
		l = m.Ref.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.AddAffectedRows {
		n += 2
	}
	if m.IsClusterTable {
		n += 2
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.PartitionTableIds) > 0 {
		l = 0
		for _, e := range m.PartitionTableIds {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.PartitionTableNames) > 0 {
		for _, s := range m.PartitionTableNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.PartitionIdx != 0 {
		n += 1 + sovPlan(uint64(m.PartitionIdx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReplaceCtx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ref != nil {
		l = m.Ref.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.AddAffectedRows {
		n += 2
	}
	if m.IsClusterTable {
		n += 2
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.DeleteCond)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.PartitionTableIds) > 0 {
		l = 0
		for _, e := range m.PartitionTableIds {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.PartitionTableNames) > 0 {
		for _, s := range m.PartitionTableNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.PartitionIdx != 0 {
		n += 1 + sovPlan(uint64(m.PartitionIdx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnalyzeInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InputRows != 0 {
		n += 1 + sovPlan(uint64(m.InputRows))
	}
	if m.OutputRows != 0 {
		n += 1 + sovPlan(uint64(m.OutputRows))
	}
	if m.InputSize != 0 {
		n += 1 + sovPlan(uint64(m.InputSize))
	}
	if m.OutputSize != 0 {
		n += 1 + sovPlan(uint64(m.OutputSize))
	}
	if m.TimeConsumed != 0 {
		n += 1 + sovPlan(uint64(m.TimeConsumed))
	}
	if m.MemorySize != 0 {
		n += 1 + sovPlan(uint64(m.MemorySize))
	}
	if m.WaitTimeConsumed != 0 {
		n += 1 + sovPlan(uint64(m.WaitTimeConsumed))
	}
	if m.DiskIO != 0 {
		n += 1 + sovPlan(uint64(m.DiskIO))
	}
	if m.S3IOByte != 0 {
		n += 1 + sovPlan(uint64(m.S3IOByte))
	}
	if m.S3IOInputCount != 0 {
		n += 1 + sovPlan(uint64(m.S3IOInputCount))
	}
	if m.S3IOOutputCount != 0 {
		n += 1 + sovPlan(uint64(m.S3IOOutputCount))
	}
	if m.NetworkIO != 0 {
		n += 1 + sovPlan(uint64(m.NetworkIO))
	}
	if m.ScanTime != 0 {
		n += 1 + sovPlan(uint64(m.ScanTime))
	}
	if m.InsertTime != 0 {
		n += 1 + sovPlan(uint64(m.InsertTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Node) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeType != 0 {
		n += 1 + sovPlan(uint64(m.NodeType))
	}
	if m.NodeId != 0 {
		n += 1 + sovPlan(uint64(m.NodeId))
	}
	if m.Stats != nil {
		l = m.Stats.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Children) > 0 {
		l = 0
		for _, e := range m.Children {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.ProjectList) > 0 {
		for _, e := range m.ProjectList {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.JoinType != 0 {
		n += 1 + sovPlan(uint64(m.JoinType))
	}
	if len(m.OnList) > 0 {
		for _, e := range m.OnList {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.BuildOnLeft {
		n += 2
	}
	if len(m.FilterList) > 0 {
		for _, e := range m.FilterList {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.GroupBy) > 0 {
		for _, e := range m.GroupBy {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.GroupingSet) > 0 {
		for _, e := range m.GroupingSet {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.AggList) > 0 {
		for _, e := range m.AggList {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.WinSpecList) > 0 {
		for _, e := range m.WinSpecList {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.OrderBy) > 0 {
		for _, e := range m.OrderBy {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Limit != nil {
		l = m.Limit.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Offset != nil {
		l = m.Offset.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if len(m.TableDefVec) > 0 {
		for _, e := range m.TableDefVec {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if m.ObjRef != nil {
		l = m.ObjRef.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.RowsetData != nil {
		l = m.RowsetData.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	l = len(m.ExtraOptions)
	if l > 0 {
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.DeleteCtx != nil {
		l = m.DeleteCtx.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if len(m.BindingTags) > 0 {
		l = 0
		for _, e := range m.BindingTags {
			l += sovPlan(uint64(e))
		}
		n += 2 + sovPlan(uint64(l)) + l
	}
	if m.AnalyzeInfo != nil {
		l = m.AnalyzeInfo.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if len(m.TblFuncExprList) > 0 {
		for _, e := range m.TblFuncExprList {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if m.ClusterTable != nil {
		l = m.ClusterTable.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.NotCacheable {
		n += 3
	}
	if m.InsertCtx != nil {
		l = m.InsertCtx.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.ReplaceCtx != nil {
		l = m.ReplaceCtx.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if len(m.SourceStep) > 0 {
		l = 0
		for _, e := range m.SourceStep {
			l += sovPlan(uint64(e))
		}
		n += 2 + sovPlan(uint64(l)) + l
	}
	if m.PreDeleteCtx != nil {
		l = m.PreDeleteCtx.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.PreInsertCtx != nil {
		l = m.PreInsertCtx.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.PreInsertUkCtx != nil {
		l = m.PreInsertUkCtx.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.OnDuplicateKey != nil {
		l = m.OnDuplicateKey.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.IsEnd {
		n += 3
	}
	if len(m.LockTargets) > 0 {
		for _, e := range m.LockTargets {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if len(m.BlockFilterList) > 0 {
		for _, e := range m.BlockFilterList {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if len(m.RuntimeFilterProbeList) > 0 {
		for _, e := range m.RuntimeFilterProbeList {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	if len(m.RuntimeFilterBuildList) > 0 {
		for _, e := range m.RuntimeFilterBuildList {
			l = e.ProtoSize()
			n += 2 + l + sovPlan(uint64(l))
		}
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LockTarget) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovPlan(uint64(m.TableId))
	}
	if m.PrimaryColIdxInBat != 0 {
		n += 1 + sovPlan(uint64(m.PrimaryColIdxInBat))
	}
	if m.PrimaryColTyp != nil {
		l = m.PrimaryColTyp.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.RefreshTsIdxInBat != 0 {
		n += 1 + sovPlan(uint64(m.RefreshTsIdxInBat))
	}
	if m.FilterColIdxInBat != 0 {
		n += 1 + sovPlan(uint64(m.FilterColIdxInBat))
	}
	if m.LockTable {
		n += 2
	}
	if m.IsPartitionTable {
		n += 2
	}
	if len(m.PartitionTableIds) > 0 {
		l = 0
		for _, e := range m.PartitionTableIds {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.Block {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PreInsertUkCtx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		l = 0
		for _, e := range m.Columns {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.PkColumn != 0 {
		n += 1 + sovPlan(uint64(m.PkColumn))
	}
	if m.PkType != nil {
		l = m.PkType.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.UkType != nil {
		l = m.UkType.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PreDeleteCtx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Idx) > 0 {
		l = 0
		for _, e := range m.Idx {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PreInsertCtx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ref != nil {
		l = m.Ref.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.HasAutoCol {
		n += 2
	}
	if m.IsUpdate {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RuntimeFilterSpec) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovPlan(uint64(m.Tag))
	}
	if m.Expr != nil {
		l = m.Expr.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IdList) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		l = 0
		for _, e := range m.List {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ColPosMap) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Map) > 0 {
		for k, v := range m.Map {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPlan(uint64(len(k))) + 1 + sovPlan(uint64(v))
			n += mapEntrySize + 1 + sovPlan(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteCtx) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CanTruncate {
		n += 2
	}
	if m.Ref != nil {
		l = m.Ref.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.RowIdIdx != 0 {
		n += 1 + sovPlan(uint64(m.RowIdIdx))
	}
	if m.AddAffectedRows {
		n += 2
	}
	if m.IsClusterTable {
		n += 2
	}
	if len(m.PartitionTableIds) > 0 {
		l = 0
		for _, e := range m.PartitionTableIds {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.PartitionTableNames) > 0 {
		for _, s := range m.PartitionTableNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.PartitionIdx != 0 {
		n += 1 + sovPlan(uint64(m.PartitionIdx))
	}
	if m.PrimaryKeyIdx != 0 {
		n += 1 + sovPlan(uint64(m.PrimaryKeyIdx))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Query) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StmtType != 0 {
		n += 1 + sovPlan(uint64(m.StmtType))
	}
	if len(m.Steps) > 0 {
		l = 0
		for _, e := range m.Steps {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Params) > 0 {
		for _, e := range m.Params {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.Headings) > 0 {
		for _, s := range m.Headings {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.LoadTag {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransationControl) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TclType != 0 {
		n += 1 + sovPlan(uint64(m.TclType))
	}
	if m.Action != nil {
		n += m.Action.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransationControl_Begin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Begin != nil {
		l = m.Begin.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TransationControl_Commit) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TransationControl_Rollback) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rollback != nil {
		l = m.Rollback.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *TransationBegin) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovPlan(uint64(m.Mode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransationCommit) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompletionType != 0 {
		n += 1 + sovPlan(uint64(m.CompletionType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransationRollback) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompletionType != 0 {
		n += 1 + sovPlan(uint64(m.CompletionType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Plan) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Plan != nil {
		n += m.Plan.ProtoSize()
	}
	if m.TryRunTimes != 0 {
		n += 1 + sovPlan(uint64(m.TryRunTimes))
	}
	if m.IsPrepare {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Plan_Query) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Query != nil {
		l = m.Query.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Plan_Tcl) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tcl != nil {
		l = m.Tcl.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Plan_Ddl) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ddl != nil {
		l = m.Ddl.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Plan_Dcl) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dcl != nil {
		l = m.Dcl.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *Column) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Column) > 0 {
		for _, e := range m.Column {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataControl) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DclType != 0 {
		n += 1 + sovPlan(uint64(m.DclType))
	}
	if m.Control != nil {
		n += m.Control.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataControl_SetVariables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SetVariables != nil {
		l = m.SetVariables.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataControl_Prepare) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prepare != nil {
		l = m.Prepare.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataControl_Execute) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Execute != nil {
		l = m.Execute.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataControl_Deallocate) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Deallocate != nil {
		l = m.Deallocate.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DdlType != 0 {
		n += 1 + sovPlan(uint64(m.DdlType))
	}
	if m.Query != nil {
		l = m.Query.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Definition != nil {
		n += m.Definition.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataDefinition_CreateDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateDatabase != nil {
		l = m.CreateDatabase.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_AlterDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterDatabase != nil {
		l = m.AlterDatabase.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_DropDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropDatabase != nil {
		l = m.DropDatabase.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_CreateTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateTable != nil {
		l = m.CreateTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_AlterTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterTable != nil {
		l = m.AlterTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_DropTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropTable != nil {
		l = m.DropTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_CreateIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateIndex != nil {
		l = m.CreateIndex.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_AlterIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterIndex != nil {
		l = m.AlterIndex.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_DropIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropIndex != nil {
		l = m.DropIndex.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_TruncateTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TruncateTable != nil {
		l = m.TruncateTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_ShowVariables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowVariables != nil {
		l = m.ShowVariables.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_AlterView) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterView != nil {
		l = m.AlterView.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_LockTables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LockTables != nil {
		l = m.LockTables.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_UnlockTables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnlockTables != nil {
		l = m.UnlockTables.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_CreateSequence) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateSequence != nil {
		l = m.CreateSequence.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_DropSequence) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropSequence != nil {
		l = m.DropSequence.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DataDefinition_AlterSequence) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterSequence != nil {
		l = m.AlterSequence.ProtoSize()
		n += 2 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *SubscriptionOption) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Publication)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfNotExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.SubscriptionOption != nil {
		l = m.SubscriptionOption.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DropDatabase) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.DatabaseId != 0 {
		n += 1 + sovPlan(uint64(m.DatabaseId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FkColName) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cols) > 0 {
		for _, s := range m.Cols {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfNotExists {
		n += 2
	}
	if m.Temporary {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.IndexTables) > 0 {
		for _, e := range m.IndexTables {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.FkDbs) > 0 {
		for _, s := range m.FkDbs {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.FkTables) > 0 {
		for _, s := range m.FkTables {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.FkCols) > 0 {
		for _, e := range m.FkCols {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.PartitionTables) > 0 {
		for _, e := range m.PartitionTables {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTableDrop) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Typ != 0 {
		n += 1 + sovPlan(uint64(m.Typ))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexTableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTableAddFk) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Cols) > 0 {
		for _, s := range m.Cols {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Fkey != nil {
		l = m.Fkey.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTableAddIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.OriginTablePrimaryKey)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.IndexInfo != nil {
		l = m.IndexInfo.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.IndexTableExist {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTableDropIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexTableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTableAlterIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Visible {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTableComment) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NewComment)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTableName) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OldName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.NewName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterAddCol) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.PreName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Type != nil {
		l = m.Type.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Pos != 0 {
		n += 1 + sovPlan(uint64(m.Pos))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterDropCol) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Idx != 0 {
		n += 1 + sovPlan(uint64(m.Idx))
	}
	if m.Seq != 0 {
		n += 1 + sovPlan(uint64(m.Seq))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.CopyTableDef != nil {
		l = m.CopyTableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.IsClusterTable {
		n += 2
	}
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.AlgorithmType != 0 {
		n += 1 + sovPlan(uint64(m.AlgorithmType))
	}
	l = len(m.CreateTableSql)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.InsertDataSql)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.ChangeTblColIdMap) > 0 {
		for k, v := range m.ChangeTblColIdMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.ProtoSize()
				l += 1 + sovPlan(uint64(l))
			}
			mapEntrySize := 1 + sovPlan(uint64(k)) + l
			n += mapEntrySize + 1 + sovPlan(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTable_Action) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != nil {
		n += m.Action.ProtoSize()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterTable_Action_Drop) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Drop != nil {
		l = m.Drop.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *AlterTable_Action_AddFk) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddFk != nil {
		l = m.AddFk.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *AlterTable_Action_AddIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddIndex != nil {
		l = m.AddIndex.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *AlterTable_Action_AlterIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterIndex != nil {
		l = m.AlterIndex.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *AlterTable_Action_AlterComment) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterComment != nil {
		l = m.AlterComment.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *AlterTable_Action_AlterName) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AlterName != nil {
		l = m.AlterName.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *AlterTable_Action_AddCol) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddCol != nil {
		l = m.AddCol.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *AlterTable_Action_DropCol) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropCol != nil {
		l = m.DropCol.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	return n
}
func (m *DropTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.IndexTableNames) > 0 {
		for _, s := range m.IndexTableNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.ClusterTable != nil {
		l = m.ClusterTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableId != 0 {
		n += 1 + sovPlan(uint64(m.TableId))
	}
	if len(m.ForeignTbl) > 0 {
		l = 0
		for _, e := range m.ForeignTbl {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if len(m.PartitionTableNames) > 0 {
		for _, s := range m.PartitionTableNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.IsView {
		n += 2
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterView) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateSequence) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfNotExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DropSequence) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IfExists {
		n += 2
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableId != 0 {
		n += 1 + sovPlan(uint64(m.TableId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterSequence) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.OriginTablePrimaryKey)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Index != nil {
		l = m.Index.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableExist {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlterIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Index)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DropIndex) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.IndexTableName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TruncateTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.IndexTableNames) > 0 {
		for _, s := range m.IndexTableNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if len(m.PartitionTableNames) > 0 {
		for _, s := range m.PartitionTableNames {
			l = len(s)
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.ClusterTable != nil {
		l = m.ClusterTable.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.TableId != 0 {
		n += 1 + sovPlan(uint64(m.TableId))
	}
	if len(m.ForeignTbl) > 0 {
		l = 0
		for _, e := range m.ForeignTbl {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterTable) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsClusterTable {
		n += 2
	}
	if len(m.AccountIDs) > 0 {
		l = 0
		for _, e := range m.AccountIDs {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.ColumnIndexOfAccountId != 0 {
		n += 1 + sovPlan(uint64(m.ColumnIndexOfAccountId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowVariables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Global {
		n += 2
	}
	if len(m.Where) > 0 {
		for _, e := range m.Where {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetVariables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetVariablesItem) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.System {
		n += 2
	}
	if m.Global {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.Reserved != nil {
		l = m.Reserved.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Prepare) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Schemas) > 0 {
		for _, e := range m.Schemas {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.Plan != nil {
		l = m.Plan.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.ParamTypes) > 0 {
		l = 0
		for _, e := range m.ParamTypes {
			l += sovPlan(uint64(e))
		}
		n += 1 + sovPlan(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Execute) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, e := range m.Args {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Deallocate) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableLockInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LockType != 0 {
		n += 1 + sovPlan(uint64(m.LockType))
	}
	if m.TableDef != nil {
		l = m.TableDef.ProtoSize()
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LockTables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TableLocks) > 0 {
		for _, e := range m.TableLocks {
			l = e.ProtoSize()
			n += 1 + l + sovPlan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnLockTables) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetadataScanInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ColName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.BlockId)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.ObjectName)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.EntryState {
		n += 2
	}
	if m.Sorted {
		n += 2
	}
	if m.IsHidden {
		n += 2
	}
	l = len(m.MetaLoc)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.DelLoc)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.CommitTs)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.CreateTs)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.DeleteTs)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	l = len(m.SegId)
	if l > 0 {
		n += 1 + l + sovPlan(uint64(l))
	}
	if m.RowCnt != 0 {
		n += 1 + sovPlan(uint64(m.RowCnt))
	}
	if m.NullCnt != 0 {
		n += 1 + sovPlan(uint64(m.NullCnt))
	}
	if m.CompressSize != 0 {
		n += 1 + sovPlan(uint64(m.CompressSize))
	}
	if m.OriginSize != 0 {
		n += 2 + sovPlan(uint64(m.OriginSize))
	}
	l = len(m.Min)
	if l > 0 {
		n += 2 + l + sovPlan(uint64(l))
	}
	l = len(m.Max)
	if l > 0 {
		n += 2 + l + sovPlan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPlan(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPlan(x uint64) (n int) {
	return sovPlan(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Type) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotNullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotNullable = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoIncr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoIncr = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			m.Scale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scale |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Const) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Const: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Const: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isnull", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Isnull = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field I8Val", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_I8Val{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field I16Val", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_I16Val{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field I32Val", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_I32Val{v}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field I64Val", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_I64Val{v}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field U8Val", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_U8Val{v}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field U16Val", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_U16Val{v}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field U32Val", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_U32Val{v}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field U64Val", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_U64Val{v}
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dval", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = &Const_Dval{float64(math.Float64frombits(v))}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &Const_Sval{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bval", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &Const_Bval{b}
		case 13:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fval", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Value = &Const_Fval{float32(math.Float32frombits(v))}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dateval", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_Dateval{v}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeval", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_Timeval{v}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datetimeval", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_Datetimeval{v}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimal64Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Decimal64{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Const_Decimal64Val{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimal128Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Decimal128{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Const_Decimal128Val{v}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestampval", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Const_Timestampval{v}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jsonval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &Const_Jsonval{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defaultval", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &Const_Defaultval{b}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateVal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &Const_UpdateVal{b}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBin = bool(v != 0)
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Src == nil {
				m.Src = &Expr{}
			}
			if err := m.Src.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParamRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParamRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParamRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VarRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VarRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VarRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field System", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.System = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Global = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelPos", wireType)
			}
			m.RelPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColPos", wireType)
			}
			m.ColPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawColRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawColRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawColRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TblId", wireType)
			}
			m.TblId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TblId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColId", wireType)
			}
			m.ColId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CorrColRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CorrColRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CorrColRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelPos", wireType)
			}
			m.RelPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColPos", wireType)
			}
			m.ColPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depth", wireType)
			}
			m.Depth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Depth |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExprList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExprList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExprList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &Expr{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaxValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaxValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaxValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TargetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Typ == nil {
				m.Typ = &Type{}
			}
			if err := m.Typ.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubqueryRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubqueryRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubqueryRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			m.Typ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typ |= SubqueryRef_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Op = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Child == nil {
				m.Child = &Expr{}
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowSize", wireType)
			}
			m.RowSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			m.Server = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Server |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Db", wireType)
			}
			m.Db = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Db |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			m.Schema = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Schema |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Obj", wireType)
			}
			m.Obj = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Obj |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubscriptionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PubInfo == nil {
				m.PubInfo = &PubInfo{}
			}
			if err := m.PubInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PubInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PubInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PubInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			m.TenantId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscriptionMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriptionMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriptionMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			m.AccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Function) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Function: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Function: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Func", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Func == nil {
				m.Func = &ObjectRef{}
			}
			if err := m.Func.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, &Expr{})
			if err := m.Args[len(m.Args)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Expr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Typ == nil {
				m.Typ = &Type{}
			}
			if err := m.Typ.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field C", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Const{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_C{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ParamRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_P{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VarRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_V{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Col", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Col{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Raw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RawColRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Raw{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Function{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_F{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field W", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WindowSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_W{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sub", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SubqueryRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Sub{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Corr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CorrColRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Corr{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TargetType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_T{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ExprList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_List{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MaxValue{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Max{v}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuxId", wireType)
			}
			m.AuxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuxId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ndv", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Ndv = float64(math.Float64frombits(v))
		case 16:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selectivity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Selectivity = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Decimal64) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: decimal64: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: decimal64: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			m.A = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.A |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Decimal128) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: decimal128: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: decimal128: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			m.A = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.A |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			m.B = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.B |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultColDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultColDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultColDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultCols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResultCols = append(m.ResultCols, &ColDef{})
			if err := m.ResultCols[len(m.ResultCols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColId", wireType)
			}
			m.ColId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hidden = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alg", wireType)
			}
			m.Alg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alg |= CompressType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Typ == nil {
				m.Typ = &Type{}
			}
			if err := m.Typ.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotNull", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotNull = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Default == nil {
				m.Default = &Default{}
			}
			if err := m.Default.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OnUpdate == nil {
				m.OnUpdate = &OnUpdate{}
			}
			if err := m.OnUpdate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowCard", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LowCard = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seqnum", wireType)
			}
			m.Seqnum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seqnum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClusterBy = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Primary = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pkidx", wireType)
			}
			m.Pkidx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pkidx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Default) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Default: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Default: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullAbility", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NullAbility = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateExtraTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateExtraTable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimaryKeyDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimaryKeyDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimaryKeyDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cols = append(m.Cols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Cols) == 0 {
					m.Cols = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cols = append(m.Cols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkeyColId", wireType)
			}
			m.PkeyColId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PkeyColId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Option == nil {
				m.Option = &IndexOption{}
			}
			if err := m.Option.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkeyColName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PkeyColName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompPkeyCol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompPkeyCol == nil {
				m.CompPkeyCol = &ColDef{}
			}
			if err := m.CompPkeyCol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parts = append(m.Parts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unique = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableExist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TableExist = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Visible = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Option == nil {
				m.Option = &IndexOption{}
			}
			if err := m.Option.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForeignKeyDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForeignKeyDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForeignKeyDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cols = append(m.Cols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Cols) == 0 {
					m.Cols = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cols = append(m.Cols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForeignTbl", wireType)
			}
			m.ForeignTbl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForeignTbl |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ForeignCols = append(m.ForeignCols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ForeignCols) == 0 {
					m.ForeignCols = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ForeignCols = append(m.ForeignCols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ForeignCols", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDelete", wireType)
			}
			m.OnDelete = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnDelete |= ForeignKeyDef_RefAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnUpdate", wireType)
			}
			m.OnUpdate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnUpdate |= ForeignKeyDef_RefAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Check", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Check == nil {
				m.Check = &Expr{}
			}
			if err := m.Check.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterByDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterByDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterByDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompCbkeyCol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompCbkeyCol == nil {
				m.CompCbkeyCol = &ColDef{}
			}
			if err := m.CompCbkeyCol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropertyDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropertyDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropertyDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Property) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Property: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Property: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropertiesDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropertiesDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropertiesDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = append(m.Properties, &Property{})
			if err := m.Properties[len(m.Properties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionByDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionByDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionByDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= PartitionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PartitionExpr == nil {
				m.PartitionExpr = &PartitionExpr{}
			}
			if err := m.PartitionExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionExpression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PartitionExpression == nil {
				m.PartitionExpression = &Expr{}
			}
			if err := m.PartitionExpression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PartitionColumns == nil {
				m.PartitionColumns = &PartitionColumns{}
			}
			if err := m.PartitionColumns.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionNum", wireType)
			}
			m.PartitionNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partitions = append(m.Partitions, &PartitionItem{})
			if err := m.Partitions[len(m.Partitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algorithm", wireType)
			}
			m.Algorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algorithm |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSubPartition", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSubPartition = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTableNames = append(m.PartitionTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExprStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExprStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionColumns) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionColumns: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionColumns: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &Expr{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionColumns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionColumns = append(m.PartitionColumns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrdinalPosition", wireType)
			}
			m.OrdinalPosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrdinalPosition |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LessThan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LessThan = append(m.LessThan, &Expr{})
			if err := m.LessThan[len(m.LessThan)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InValues = append(m.InValues, &Expr{})
			if err := m.InValues[len(m.InValues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.View = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TblId", wireType)
			}
			m.TblId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TblId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hidden = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cols = append(m.Cols, &ColDef{})
			if err := m.Cols[len(m.Cols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Createsql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Createsql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TblFunc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TblFunc == nil {
				m.TblFunc = &TableFunction{}
			}
			if err := m.TblFunc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pkey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pkey == nil {
				m.Pkey = &PrimaryKeyDef{}
			}
			if err := m.Pkey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Indexes = append(m.Indexes, &IndexDef{})
			if err := m.Indexes[len(m.Indexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fkeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fkeys = append(m.Fkeys, &ForeignKeyDef{})
			if err := m.Fkeys[len(m.Fkeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RefChildTbls = append(m.RefChildTbls, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RefChildTbls) == 0 {
					m.RefChildTbls = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RefChildTbls = append(m.RefChildTbls, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RefChildTbls", wireType)
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checks = append(m.Checks, &CheckDef{})
			if err := m.Checks[len(m.Checks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Partition == nil {
				m.Partition = &PartitionByDef{}
			}
			if err := m.Partition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterBy == nil {
				m.ClusterBy = &ClusterByDef{}
			}
			if err := m.ClusterBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Props", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Props = append(m.Props, &PropertyDef{})
			if err := m.Props[len(m.Props)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewSql", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ViewSql == nil {
				m.ViewSql = &ViewDef{}
			}
			if err := m.ViewSql.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Defs = append(m.Defs, &TableDef_DefType{})
			if err := m.Defs[len(m.Defs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name2ColIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name2ColIndex == nil {
				m.Name2ColIndex = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPlan
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPlan
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPlan(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPlan
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Name2ColIndex[mapkey] = mapvalue
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLocked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLocked = bool(v != 0)
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableLockType", wireType)
			}
			m.TableLockType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableLockType |= TableLockType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTemporary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTemporary = bool(v != 0)
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoIncrOffset", wireType)
			}
			m.AutoIncrOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoIncrOffset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDef_DefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PropertiesDef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Def = &TableDef_DefType_Properties{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableFunction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableFunction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableFunction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Param = append(m.Param[:0], dAtA[iNdEx:postIndex]...)
			if m.Param == nil {
				m.Param = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HashMapStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HashMapStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HashMapStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashmapSize", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.HashmapSize = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOnPK", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HashOnPK = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Shuffle = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleColIdx", wireType)
			}
			m.ShuffleColIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleColIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleType", wireType)
			}
			m.ShuffleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleType |= ShuffleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleColMin", wireType)
			}
			m.ShuffleColMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleColMin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleColMax", wireType)
			}
			m.ShuffleColMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleColMax |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShuffleMethod", wireType)
			}
			m.ShuffleMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShuffleMethod |= ShuffleMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNum", wireType)
			}
			m.BlockNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Cost = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outcnt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Outcnt = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rowsize", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Rowsize = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableCnt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TableCnt = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selectivity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Selectivity = float64(math.Float64frombits(v))
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashmapStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HashmapStats == nil {
				m.HashmapStats = &HashMapStats{}
			}
			if err := m.HashmapStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowsetExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowsetExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowsetExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowPos", wireType)
			}
			m.RowPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &RowsetExpr{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowsetData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowsetData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowsetData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cols = append(m.Cols, &ColData{})
			if err := m.Cols[len(m.Cols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderBySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderBySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderBySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= OrderBySpec_OrderByFlag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowFunc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WindowFunc == nil {
				m.WindowFunc = &Expr{}
			}
			if err := m.WindowFunc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionBy = append(m.PartitionBy, &Expr{})
			if err := m.PartitionBy[len(m.PartitionBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBy = append(m.OrderBy, &OrderBySpec{})
			if err := m.OrderBy[len(m.OrderBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frame", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Frame == nil {
				m.Frame = &FrameClause{}
			}
			if err := m.Frame.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FrameClause) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FrameClause: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FrameClause: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= FrameClause_FrameType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &FrameBound{}
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &FrameBound{}
			}
			if err := m.End.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FrameBound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FrameBound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FrameBound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= FrameBound_BoundType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnBounded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UnBounded = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Val == nil {
				m.Val = &Expr{}
			}
			if err := m.Val.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnDuplicateKeyCtx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnDuplicateKeyCtx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnDuplicateKeyCtx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OnDuplicateIdx = append(m.OnDuplicateIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OnDuplicateIdx) == 0 {
					m.OnDuplicateIdx = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OnDuplicateIdx = append(m.OnDuplicateIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDuplicateIdx", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDuplicateExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OnDuplicateExpr == nil {
				m.OnDuplicateExpr = make(map[string]*Expr)
			}
			var mapkey string
			var mapvalue *Expr
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPlan
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPlan
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPlan
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPlan
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Expr{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPlan(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPlan
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.OnDuplicateExpr[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsertCtx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsertCtx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsertCtx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ref == nil {
				m.Ref = &ObjectRef{}
			}
			if err := m.Ref.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddAffectedRows", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddAffectedRows = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClusterTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClusterTable = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartitionTableIds = append(m.PartitionTableIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PartitionTableIds) == 0 {
					m.PartitionTableIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartitionTableIds = append(m.PartitionTableIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableIds", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTableNames = append(m.PartitionTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionIdx", wireType)
			}
			m.PartitionIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceCtx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceCtx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceCtx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ref == nil {
				m.Ref = &ObjectRef{}
			}
			if err := m.Ref.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddAffectedRows", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddAffectedRows = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClusterTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClusterTable = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteCond", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeleteCond = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartitionTableIds = append(m.PartitionTableIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PartitionTableIds) == 0 {
					m.PartitionTableIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartitionTableIds = append(m.PartitionTableIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableIds", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTableNames = append(m.PartitionTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionIdx", wireType)
			}
			m.PartitionIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnalyzeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalyzeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalyzeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputRows", wireType)
			}
			m.InputRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputRows |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputRows", wireType)
			}
			m.OutputRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputRows |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputSize", wireType)
			}
			m.InputSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputSize", wireType)
			}
			m.OutputSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeConsumed", wireType)
			}
			m.TimeConsumed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeConsumed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemorySize", wireType)
			}
			m.MemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemorySize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitTimeConsumed", wireType)
			}
			m.WaitTimeConsumed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitTimeConsumed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskIO", wireType)
			}
			m.DiskIO = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskIO |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3IOByte", wireType)
			}
			m.S3IOByte = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.S3IOByte |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3IOInputCount", wireType)
			}
			m.S3IOInputCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.S3IOInputCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3IOOutputCount", wireType)
			}
			m.S3IOOutputCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.S3IOOutputCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkIO", wireType)
			}
			m.NetworkIO = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkIO |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanTime", wireType)
			}
			m.ScanTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScanTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertTime", wireType)
			}
			m.InsertTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InsertTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeType", wireType)
			}
			m.NodeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeType |= Node_NodeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &Stats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Children = append(m.Children, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Children) == 0 {
					m.Children = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Children = append(m.Children, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectList = append(m.ProjectList, &Expr{})
			if err := m.ProjectList[len(m.ProjectList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinType", wireType)
			}
			m.JoinType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JoinType |= Node_JoinType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnList = append(m.OnList, &Expr{})
			if err := m.OnList[len(m.OnList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildOnLeft", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BuildOnLeft = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilterList = append(m.FilterList, &Expr{})
			if err := m.FilterList[len(m.FilterList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = append(m.GroupBy, &Expr{})
			if err := m.GroupBy[len(m.GroupBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupingSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupingSet = append(m.GroupingSet, &Expr{})
			if err := m.GroupingSet[len(m.GroupingSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggList = append(m.AggList, &Expr{})
			if err := m.AggList[len(m.AggList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinSpecList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WinSpecList = append(m.WinSpecList, &Expr{})
			if err := m.WinSpecList[len(m.WinSpecList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderBy = append(m.OrderBy, &OrderBySpec{})
			if err := m.OrderBy[len(m.OrderBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limit == nil {
				m.Limit = &Expr{}
			}
			if err := m.Limit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Offset == nil {
				m.Offset = &Expr{}
			}
			if err := m.Offset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDefVec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableDefVec = append(m.TableDefVec, &TableDef{})
			if err := m.TableDefVec[len(m.TableDefVec)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjRef == nil {
				m.ObjRef = &ObjectRef{}
			}
			if err := m.ObjRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowsetData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RowsetData == nil {
				m.RowsetData = &RowsetData{}
			}
			if err := m.RowsetData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraOptions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraOptions = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteCtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteCtx == nil {
				m.DeleteCtx = &DeleteCtx{}
			}
			if err := m.DeleteCtx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BindingTags = append(m.BindingTags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BindingTags) == 0 {
					m.BindingTags = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BindingTags = append(m.BindingTags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BindingTags", wireType)
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnalyzeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnalyzeInfo == nil {
				m.AnalyzeInfo = &AnalyzeInfo{}
			}
			if err := m.AnalyzeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TblFuncExprList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TblFuncExprList = append(m.TblFuncExprList, &Expr{})
			if err := m.TblFuncExprList[len(m.TblFuncExprList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterTable == nil {
				m.ClusterTable = &ClusterTable{}
			}
			if err := m.ClusterTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotCacheable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotCacheable = bool(v != 0)
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertCtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InsertCtx == nil {
				m.InsertCtx = &InsertCtx{}
			}
			if err := m.InsertCtx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaceCtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplaceCtx == nil {
				m.ReplaceCtx = &ReplaceCtx{}
			}
			if err := m.ReplaceCtx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SourceStep = append(m.SourceStep, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SourceStep) == 0 {
					m.SourceStep = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SourceStep = append(m.SourceStep, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceStep", wireType)
			}
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreDeleteCtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreDeleteCtx == nil {
				m.PreDeleteCtx = &PreDeleteCtx{}
			}
			if err := m.PreDeleteCtx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreInsertCtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreInsertCtx == nil {
				m.PreInsertCtx = &PreInsertCtx{}
			}
			if err := m.PreInsertCtx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreInsertUkCtx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreInsertUkCtx == nil {
				m.PreInsertUkCtx = &PreInsertUkCtx{}
			}
			if err := m.PreInsertUkCtx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDuplicateKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OnDuplicateKey == nil {
				m.OnDuplicateKey = &OnDuplicateKeyCtx{}
			}
			if err := m.OnDuplicateKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEnd = bool(v != 0)
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTargets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockTargets = append(m.LockTargets, &LockTarget{})
			if err := m.LockTargets[len(m.LockTargets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockFilterList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockFilterList = append(m.BlockFilterList, &Expr{})
			if err := m.BlockFilterList[len(m.BlockFilterList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterProbeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterProbeList = append(m.RuntimeFilterProbeList, &RuntimeFilterSpec{})
			if err := m.RuntimeFilterProbeList[len(m.RuntimeFilterProbeList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeFilterBuildList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeFilterBuildList = append(m.RuntimeFilterBuildList, &RuntimeFilterSpec{})
			if err := m.RuntimeFilterBuildList[len(m.RuntimeFilterBuildList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryColIdxInBat", wireType)
			}
			m.PrimaryColIdxInBat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryColIdxInBat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryColTyp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrimaryColTyp == nil {
				m.PrimaryColTyp = &Type{}
			}
			if err := m.PrimaryColTyp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshTsIdxInBat", wireType)
			}
			m.RefreshTsIdxInBat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefreshTsIdxInBat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterColIdxInBat", wireType)
			}
			m.FilterColIdxInBat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilterColIdxInBat |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LockTable = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPartitionTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPartitionTable = bool(v != 0)
		case 8:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartitionTableIds = append(m.PartitionTableIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PartitionTableIds) == 0 {
					m.PartitionTableIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartitionTableIds = append(m.PartitionTableIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableIds", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Block = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreInsertUkCtx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreInsertUkCtx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreInsertUkCtx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Columns = append(m.Columns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Columns) == 0 {
					m.Columns = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Columns = append(m.Columns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkColumn", wireType)
			}
			m.PkColumn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PkColumn |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PkType == nil {
				m.PkType = &Type{}
			}
			if err := m.PkType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UkType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UkType == nil {
				m.UkType = &Type{}
			}
			if err := m.UkType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreDeleteCtx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreDeleteCtx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreDeleteCtx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Idx = append(m.Idx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Idx) == 0 {
					m.Idx = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Idx = append(m.Idx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreInsertCtx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreInsertCtx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreInsertCtx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ref == nil {
				m.Ref = &ObjectRef{}
			}
			if err := m.Ref.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasAutoCol", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasAutoCol = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUpdate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUpdate = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuntimeFilterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuntimeFilterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuntimeFilterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.List = append(m.List, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.List) == 0 {
					m.List = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.List = append(m.List, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColPosMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColPosMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColPosMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Map == nil {
				m.Map = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPlan
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPlan
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPlan(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPlan
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Map[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteCtx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteCtx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteCtx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanTruncate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanTruncate = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ref == nil {
				m.Ref = &ObjectRef{}
			}
			if err := m.Ref.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowIdIdx", wireType)
			}
			m.RowIdIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowIdIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddAffectedRows", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddAffectedRows = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClusterTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClusterTable = bool(v != 0)
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartitionTableIds = append(m.PartitionTableIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PartitionTableIds) == 0 {
					m.PartitionTableIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartitionTableIds = append(m.PartitionTableIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableIds", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTableNames = append(m.PartitionTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionIdx", wireType)
			}
			m.PartitionIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKeyIdx", wireType)
			}
			m.PrimaryKeyIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryKeyIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Query) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Query: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Query: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StmtType", wireType)
			}
			m.StmtType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StmtType |= Query_StatementType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Steps = append(m.Steps, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Steps) == 0 {
					m.Steps = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Steps = append(m.Steps, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params, &Expr{})
			if err := m.Params[len(m.Params)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headings = append(m.Headings, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadTag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LoadTag = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransationControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransationControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransationControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TclType", wireType)
			}
			m.TclType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TclType |= TransationControl_TclType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TransationBegin{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &TransationControl_Begin{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TransationCommit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &TransationControl_Commit{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rollback", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TransationRollback{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &TransationControl_Rollback{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransationBegin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransationBegin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransationBegin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= TransationBegin_TransationMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransationCommit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransationCommit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransationCommit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionType", wireType)
			}
			m.CompletionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletionType |= TransationCompletionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransationRollback) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransationRollback: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransationRollback: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionType", wireType)
			}
			m.CompletionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletionType |= TransationCompletionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Plan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Plan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Plan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Query{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Plan = &Plan_Query{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tcl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TransationControl{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Plan = &Plan_Tcl{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ddl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataDefinition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Plan = &Plan_Ddl{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dcl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataControl{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Plan = &Plan_Dcl{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TryRunTimes", wireType)
			}
			m.TryRunTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TryRunTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrepare", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPrepare = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Column) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: column: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: column: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Column = append(m.Column, &Expr{})
			if err := m.Column[len(m.Column)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DclType", wireType)
			}
			m.DclType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DclType |= DataControl_DclType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetVariables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SetVariables{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Control = &DataControl_SetVariables{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prepare", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Prepare{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Control = &DataControl_Prepare{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Execute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Execute{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Control = &DataControl_Execute{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deallocate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Deallocate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Control = &DataControl_Deallocate{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DdlType", wireType)
			}
			m.DdlType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DdlType |= DataDefinition_DdlType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &Query{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateDatabase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateDatabase{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_CreateDatabase{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterDatabase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterDatabase{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_AlterDatabase{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropDatabase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DropDatabase{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_DropDatabase{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_CreateTable{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_AlterTable{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DropTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_DropTable{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_CreateIndex{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_AlterIndex{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DropIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_DropIndex{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TruncateTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TruncateTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_TruncateTable{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowVariables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShowVariables{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_ShowVariables{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterView", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterView{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_AlterView{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LockTables{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_LockTables{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UnLockTables{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_UnlockTables{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateSequence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateSequence{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_CreateSequence{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropSequence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DropSequence{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_DropSequence{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterSequence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterSequence{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Definition = &DataDefinition_AlterSequence{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscriptionOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriptionOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriptionOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publication", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Publication = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateDatabase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateDatabase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateDatabase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfNotExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfNotExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubscriptionOption == nil {
				m.SubscriptionOption = &SubscriptionOption{}
			}
			if err := m.SubscriptionOption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterDatabase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterDatabase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterDatabase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropDatabase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropDatabase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropDatabase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseId", wireType)
			}
			m.DatabaseId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FkColName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FkColName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FkColName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cols = append(m.Cols, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfNotExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfNotExists = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temporary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Temporary = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTables = append(m.IndexTables, &TableDef{})
			if err := m.IndexTables[len(m.IndexTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FkDbs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FkDbs = append(m.FkDbs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FkTables", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FkTables = append(m.FkTables, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FkCols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FkCols = append(m.FkCols, &FkColName{})
			if err := m.FkCols[len(m.FkCols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTables = append(m.PartitionTables, &TableDef{})
			if err := m.PartitionTables[len(m.PartitionTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTableDrop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTableDrop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTableDrop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			m.Typ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typ |= AlterTableDrop_Typ(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTableAddFk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTableAddFk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTableAddFk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cols = append(m.Cols, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fkey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fkey == nil {
				m.Fkey = &ForeignKeyDef{}
			}
			if err := m.Fkey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTableAddIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTableAddIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTableAddIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginTablePrimaryKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginTablePrimaryKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IndexInfo == nil {
				m.IndexInfo = &CreateTable{}
			}
			if err := m.IndexInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTableExist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IndexTableExist = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTableDropIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTableDropIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTableDropIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTableAlterIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTableAlterIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTableAlterIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Visible = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTableComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTableComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTableComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewComment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewComment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTableName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTableName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTableName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterAddCol) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterAddCol: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterAddCol: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &Type{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterDropCol) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterDropCol: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterDropCol: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyTableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CopyTableDef == nil {
				m.CopyTableDef = &TableDef{}
			}
			if err := m.CopyTableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClusterTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClusterTable = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &AlterTable_Action{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlgorithmType", wireType)
			}
			m.AlgorithmType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlgorithmType |= AlterTable_AlgorithmType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTableSql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreateTableSql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertDataSql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsertDataSql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeTblColIdMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangeTblColIdMap == nil {
				m.ChangeTblColIdMap = make(map[uint64]*ColDef)
			}
			var mapkey uint64
			var mapvalue *ColDef
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPlan
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPlan
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ColDef{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPlan(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPlan
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ChangeTblColIdMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterTable_Action) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Action: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Action: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterTableDrop{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AlterTable_Action_Drop{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddFk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterTableAddFk{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AlterTable_Action_AddFk{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterTableAddIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AlterTable_Action_AddIndex{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterTableAlterIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AlterTable_Action_AlterIndex{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterTableComment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AlterTable_Action_AlterComment{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlterName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterTableName{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AlterTable_Action_AlterName{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddCol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterAddCol{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AlterTable_Action_AddCol{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropCol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AlterDropCol{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &AlterTable_Action_DropCol{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTableNames = append(m.IndexTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterTable == nil {
				m.ClusterTable = &ClusterTable{}
			}
			if err := m.ClusterTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ForeignTbl = append(m.ForeignTbl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ForeignTbl) == 0 {
					m.ForeignTbl = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ForeignTbl = append(m.ForeignTbl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ForeignTbl", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTableNames = append(m.PartitionTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsView", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsView = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfNotExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfNotExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginTablePrimaryKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginTablePrimaryKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Index == nil {
				m.Index = &CreateTable{}
			}
			if err := m.Index.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableExist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TableExist = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlterIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlterIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlterIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TruncateTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TruncateTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TruncateTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexTableNames = append(m.IndexTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionTableNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionTableNames = append(m.PartitionTableNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterTable == nil {
				m.ClusterTable = &ClusterTable{}
			}
			if err := m.ClusterTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ForeignTbl = append(m.ForeignTbl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ForeignTbl) == 0 {
					m.ForeignTbl = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ForeignTbl = append(m.ForeignTbl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ForeignTbl", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClusterTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClusterTable = bool(v != 0)
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AccountIDs = append(m.AccountIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AccountIDs) == 0 {
					m.AccountIDs = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AccountIDs = append(m.AccountIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountIDs", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIndexOfAccountId", wireType)
			}
			m.ColumnIndexOfAccountId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnIndexOfAccountId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowVariables) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowVariables: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowVariables: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Global = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Where = append(m.Where, &Expr{})
			if err := m.Where[len(m.Where)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetVariables) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetVariables: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetVariables: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &SetVariablesItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetVariablesItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetVariablesItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetVariablesItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field System", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.System = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Global = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Expr{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reserved == nil {
				m.Reserved = &Expr{}
			}
			if err := m.Reserved.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Prepare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Prepare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Prepare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schemas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schemas = append(m.Schemas, &ObjectRef{})
			if err := m.Schemas[len(m.Schemas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Plan == nil {
				m.Plan = &Plan{}
			}
			if err := m.Plan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ParamTypes = append(m.ParamTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ParamTypes) == 0 {
					m.ParamTypes = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ParamTypes = append(m.ParamTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ParamTypes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Execute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Execute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Execute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, &Expr{})
			if err := m.Args[len(m.Args)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deallocate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deallocate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deallocate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableLockInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableLockInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableLockInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockType", wireType)
			}
			m.LockType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockType |= TableLockType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDef == nil {
				m.TableDef = &TableDef{}
			}
			if err := m.TableDef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockTables) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockTables: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockTables: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableLocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableLocks = append(m.TableLocks, &TableLockInfo{})
			if err := m.TableLocks[len(m.TableLocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnLockTables) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnLockTables: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnLockTables: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetadataScanInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetadataScanInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetadataScanInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockId = append(m.BlockId[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockId == nil {
				m.BlockId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EntryState = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sorted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sorted = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHidden = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaLoc", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaLoc = append(m.MetaLoc[:0], dAtA[iNdEx:postIndex]...)
			if m.MetaLoc == nil {
				m.MetaLoc = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelLoc", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelLoc = append(m.DelLoc[:0], dAtA[iNdEx:postIndex]...)
			if m.DelLoc == nil {
				m.DelLoc = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitTs = append(m.CommitTs[:0], dAtA[iNdEx:postIndex]...)
			if m.CommitTs == nil {
				m.CommitTs = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreateTs = append(m.CreateTs[:0], dAtA[iNdEx:postIndex]...)
			if m.CreateTs == nil {
				m.CreateTs = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteTs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeleteTs = append(m.DeleteTs[:0], dAtA[iNdEx:postIndex]...)
			if m.DeleteTs == nil {
				m.DeleteTs = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SegId = append(m.SegId[:0], dAtA[iNdEx:postIndex]...)
			if m.SegId == nil {
				m.SegId = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowCnt", wireType)
			}
			m.RowCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowCnt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullCnt", wireType)
			}
			m.NullCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NullCnt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressSize", wireType)
			}
			m.CompressSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginSize", wireType)
			}
			m.OriginSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Min = append(m.Min[:0], dAtA[iNdEx:postIndex]...)
			if m.Min == nil {
				m.Min = []byte{}
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPlan
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPlan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Max = append(m.Max[:0], dAtA[iNdEx:postIndex]...)
			if m.Max == nil {
				m.Max = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPlan(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPlan
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlan
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPlan
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPlan
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPlan
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPlan        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPlan          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPlan = fmt.Errorf("proto: unexpected end of group")
)
