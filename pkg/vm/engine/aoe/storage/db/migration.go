package db

import (
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"github.com/matrixorigin/matrixone/pkg/logutil"
	"github.com/matrixorigin/matrixone/pkg/vm/engine/aoe/storage/common"
	"github.com/matrixorigin/matrixone/pkg/vm/engine/aoe/storage/layout/dataio"
	"github.com/matrixorigin/matrixone/pkg/vm/engine/aoe/storage/layout/table/v1/iface"
	"github.com/matrixorigin/matrixone/pkg/vm/engine/aoe/storage/metadata/v1"
)

var (
	CopyTableFn func(t iface.ITableData, destDir string) error
	CopyFileFn  func(src, dest string) error
)

func init() {
	CopyTableFn = func(t iface.ITableData, destDir string) error {
		return t.LinkTo(destDir)
	}
	// CopyTableFn = func(t iface.ITableData, destDir string) error {
	// 	return t.CopyTo(destDir)
	// }
	CopyFileFn = os.Link
	// CopyFileFn = func(src, dest string) error {
	// 	_, err := dataio.CopyFile(src, dest)
	// 	return err
	// }
}

func CopyTBlockFileToDestDir(file, srcDir, destDir string, idMapFn func(*common.ID) (*common.ID, error)) error {
	name, _ := common.ParseTBlockfileName(file)
	count, tag, id, err := dataio.ParseTBlockfileName(name)
	if err != nil {
		return err
	}
	nid, err := idMapFn(&id)
	if err != nil {
		return err
	}
	src := filepath.Join(srcDir, file)
	dest := dataio.MakeTblockFileName(destDir, tag, count, *nid, false)
	logutil.Infof("Copy \"%s\" to \"%s\"", src, dest)
	err = CopyFileFn(src, dest)
	return err
}

func CopyBlockFileToDestDir(file, srcDir, destDir string, idMapFn func(*common.ID) (*common.ID, error)) error {
	name, _ := common.ParseBlockfileName(file)
	id, err := common.ParseBlkNameToID(name)
	if err != nil {
		return err
	}
	nid, err := idMapFn(&id)
	if err != nil {
		return err
	}
	src := filepath.Join(srcDir, file)
	dest := common.MakeBlockFileName(destDir, nid.ToBlockFileName(), nid.TableID, false)
	logutil.Infof("Copy \"%s\" to \"%s\"", src, dest)
	err = CopyFileFn(src, dest)
	return err
}

func CopySegmentFileToDestDir(file, srcDir, destDir string, idMapFn func(*common.ID) (*common.ID, error)) error {
	name, _ := common.ParseSegmentFileName(file)
	id, err := common.ParseSegmentNameToID(name)
	if err != nil {
		return err
	}
	nid, err := idMapFn(&id)
	if err != nil {
		return err
	}
	src := filepath.Join(srcDir, file)
	dest := common.MakeSegmentFileName(destDir, nid.ToSegmentFileName(), nid.TableID, false)
	logutil.Infof("Copy \"%s\" to \"%s\"", src, dest)
	err = CopyFileFn(src, dest)
	return err
}

func ScanMigrationDir(path string) (metas []string, tblks []string, blks []string, segs []string, err error) {
	files, err := ioutil.ReadDir(path)
	if err != nil {
		return
	}
	for _, file := range files {
		name := file.Name()
		if common.IsSegmentFile(name) {
			segs = append(segs, name)
		} else if common.IsBlockFile(name) {
			blks = append(blks, name)
		} else if common.IsTBlockFile(name) {
			tblks = append(tblks, name)
		} else if strings.HasSuffix(name, ".meta") {
			metas = append(metas, name)
		}
	}
	return
}

func CopyDataFiles(tblks, blks, segs []string, srcDir, destDir string, blkMapFn, segMapFn func(*common.ID) (*common.ID, error)) error {
	var err error
	for _, tblk := range tblks {
		if err = CopyTBlockFileToDestDir(tblk, srcDir, destDir, blkMapFn); err != nil {
			if err == metadata.AddressNotFoundErr {
				logutil.Warnf("%s cannot be used", tblk)
				err = nil
				continue
			}
			return err
		}
	}
	for _, blk := range blks {
		if err = CopyBlockFileToDestDir(blk, srcDir, destDir, blkMapFn); err != nil {
			if err == metadata.AddressNotFoundErr {
				logutil.Warnf("%s cannot be used", blk)
				err = nil
				continue
			}
			return err
		}
	}
	for _, seg := range segs {
		if err = CopySegmentFileToDestDir(seg, srcDir, destDir, segMapFn); err != nil {
			if err == metadata.AddressNotFoundErr {
				logutil.Warnf("%s cannot be used", seg)
				err = nil
				continue
			}
			return err
		}
	}
	return err
}
