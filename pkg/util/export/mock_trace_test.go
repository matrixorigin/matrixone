// Copyright 2024 Matrix Origin
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/util/trace/impl/motrace/trace.go
//
// Generated by this command:
//
//	mockgen -source pkg/util/trace/impl/motrace/trace.go --destination pkg/util/export/mock_trace_test.go -package=export
//

// Package export is a generated GoMock package.
package export

import (
	bytes "bytes"
	context "context"
	reflect "reflect"
	time "time"

	"github.com/golang/mock/gomock"

	batchpipe "github.com/matrixorigin/matrixone/pkg/util/batchpipe"
	table "github.com/matrixorigin/matrixone/pkg/util/export/table"
	motrace "github.com/matrixorigin/matrixone/pkg/util/trace/impl/motrace"
)

// MockPipeImpl is a mock of PipeImpl interface.
type MockPipeImpl struct {
	ctrl     *gomock.Controller
	recorder *MockPipeImplMockRecorder
}

// MockPipeImplMockRecorder is the mock recorder for MockPipeImpl.
type MockPipeImplMockRecorder struct {
	mock *MockPipeImpl
}

// NewMockPipeImpl creates a new mock instance.
func NewMockPipeImpl(ctrl *gomock.Controller) *MockPipeImpl {
	mock := &MockPipeImpl{ctrl: ctrl}
	mock.recorder = &MockPipeImplMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPipeImpl) EXPECT() *MockPipeImplMockRecorder {
	return m.recorder
}

// NewAggregator mocks base method.
func (m *MockPipeImpl) NewAggregator(arg0 context.Context, arg1 string) table.Aggregator {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewAggregator", arg0, arg1)
	ret0, _ := ret[0].(table.Aggregator)
	return ret0
}

// NewAggregator indicates an expected call of NewAggregator.
func (mr *MockPipeImplMockRecorder) NewAggregator(arg0, arg1 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewAggregator", reflect.TypeOf((*MockPipeImpl)(nil).NewAggregator), arg0, arg1)
}

// NewItemBatchHandler mocks base method.
func (m *MockPipeImpl) NewItemBatchHandler(ctx context.Context) func(any) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewItemBatchHandler", ctx)
	ret0, _ := ret[0].(func(any))
	return ret0
}

// NewItemBatchHandler indicates an expected call of NewItemBatchHandler.
func (mr *MockPipeImplMockRecorder) NewItemBatchHandler(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewItemBatchHandler", reflect.TypeOf((*MockPipeImpl)(nil).NewItemBatchHandler), ctx)
}

// NewItemBuffer mocks base method.
func (m *MockPipeImpl) NewItemBuffer(name string) batchpipe.ItemBuffer[batchpipe.HasName, any] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewItemBuffer", name)
	ret0, _ := ret[0].(batchpipe.ItemBuffer[batchpipe.HasName, any])
	return ret0
}

// NewItemBuffer indicates an expected call of NewItemBuffer.
func (mr *MockPipeImplMockRecorder) NewItemBuffer(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewItemBuffer", reflect.TypeOf((*MockPipeImpl)(nil).NewItemBuffer), name)
}

// MockBuffer is a mock of Buffer interface.
type MockBuffer struct {
	ctrl     *gomock.Controller
	recorder *MockBufferMockRecorder
}

// MockBufferMockRecorder is the mock recorder for MockBuffer.
type MockBufferMockRecorder struct {
	mock *MockBuffer
}

// NewMockBuffer creates a new mock instance.
func NewMockBuffer(ctrl *gomock.Controller) *MockBuffer {
	mock := &MockBuffer{ctrl: ctrl}
	mock.recorder = &MockBufferMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBuffer) EXPECT() *MockBufferMockRecorder {
	return m.recorder
}

// Add mocks base method.
func (m *MockBuffer) Add(item batchpipe.HasName) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Add", item)
}

// Add indicates an expected call of Add.
func (mr *MockBufferMockRecorder) Add(item any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockBuffer)(nil).Add), item)
}

// GetBatch mocks base method.
func (m *MockBuffer) GetBatch(ctx context.Context, buf *bytes.Buffer) any {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBatch", ctx, buf)
	ret0, _ := ret[0].(any)
	return ret0
}

// GetBatch indicates an expected call of GetBatch.
func (mr *MockBufferMockRecorder) GetBatch(ctx, buf any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBatch", reflect.TypeOf((*MockBuffer)(nil).GetBatch), ctx, buf)
}

// IsEmpty mocks base method.
func (m *MockBuffer) IsEmpty() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsEmpty")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsEmpty indicates an expected call of IsEmpty.
func (mr *MockBufferMockRecorder) IsEmpty() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsEmpty", reflect.TypeOf((*MockBuffer)(nil).IsEmpty))
}

// RemindBackOff mocks base method.
func (m *MockBuffer) RemindBackOff() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RemindBackOff")
}

// RemindBackOff indicates an expected call of RemindBackOff.
func (mr *MockBufferMockRecorder) RemindBackOff() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemindBackOff", reflect.TypeOf((*MockBuffer)(nil).RemindBackOff))
}

// RemindBackOffCnt mocks base method.
func (m *MockBuffer) RemindBackOffCnt() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemindBackOffCnt")
	ret0, _ := ret[0].(int)
	return ret0
}

// RemindBackOffCnt indicates an expected call of RemindBackOffCnt.
func (mr *MockBufferMockRecorder) RemindBackOffCnt() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemindBackOffCnt", reflect.TypeOf((*MockBuffer)(nil).RemindBackOffCnt))
}

// RemindNextAfter mocks base method.
func (m *MockBuffer) RemindNextAfter() time.Duration {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemindNextAfter")
	ret0, _ := ret[0].(time.Duration)
	return ret0
}

// RemindNextAfter indicates an expected call of RemindNextAfter.
func (mr *MockBufferMockRecorder) RemindNextAfter() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemindNextAfter", reflect.TypeOf((*MockBuffer)(nil).RemindNextAfter))
}

// RemindReset mocks base method.
func (m *MockBuffer) RemindReset() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RemindReset")
}

// RemindReset indicates an expected call of RemindReset.
func (mr *MockBufferMockRecorder) RemindReset() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemindReset", reflect.TypeOf((*MockBuffer)(nil).RemindReset))
}

// Reset mocks base method.
func (m *MockBuffer) Reset() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Reset")
}

// Reset indicates an expected call of Reset.
func (mr *MockBufferMockRecorder) Reset() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Reset", reflect.TypeOf((*MockBuffer)(nil).Reset))
}

// ShouldFlush mocks base method.
func (m *MockBuffer) ShouldFlush() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ShouldFlush")
	ret0, _ := ret[0].(bool)
	return ret0
}

// ShouldFlush indicates an expected call of ShouldFlush.
func (mr *MockBufferMockRecorder) ShouldFlush() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ShouldFlush", reflect.TypeOf((*MockBuffer)(nil).ShouldFlush))
}

// Size mocks base method.
func (m *MockBuffer) Size() int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Size")
	ret0, _ := ret[0].(int64)
	return ret0
}

// Size indicates an expected call of Size.
func (mr *MockBufferMockRecorder) Size() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Size", reflect.TypeOf((*MockBuffer)(nil).Size))
}

// MockBatchProcessor is a mock of BatchProcessor interface.
type MockBatchProcessor struct {
	ctrl     *gomock.Controller
	recorder *MockBatchProcessorMockRecorder
}

// MockBatchProcessorMockRecorder is the mock recorder for MockBatchProcessor.
type MockBatchProcessorMockRecorder struct {
	mock *MockBatchProcessor
}

// NewMockBatchProcessor creates a new mock instance.
func NewMockBatchProcessor(ctrl *gomock.Controller) *MockBatchProcessor {
	mock := &MockBatchProcessor{ctrl: ctrl}
	mock.recorder = &MockBatchProcessorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBatchProcessor) EXPECT() *MockBatchProcessorMockRecorder {
	return m.recorder
}

// Collect mocks base method.
func (m *MockBatchProcessor) Collect(arg0 context.Context, arg1 batchpipe.HasName) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Collect", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Collect indicates an expected call of Collect.
func (mr *MockBatchProcessorMockRecorder) Collect(arg0, arg1 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Collect", reflect.TypeOf((*MockBatchProcessor)(nil).Collect), arg0, arg1)
}

// Register mocks base method.
func (m *MockBatchProcessor) Register(name batchpipe.HasName, impl motrace.PipeImpl) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Register", name, impl)
}

// Register indicates an expected call of Register.
func (mr *MockBatchProcessorMockRecorder) Register(name, impl any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Register", reflect.TypeOf((*MockBatchProcessor)(nil).Register), name, impl)
}

// Start mocks base method.
func (m *MockBatchProcessor) Start() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockBatchProcessorMockRecorder) Start() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockBatchProcessor)(nil).Start))
}

// Stop mocks base method.
func (m *MockBatchProcessor) Stop(graceful bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stop", graceful)
	ret0, _ := ret[0].(error)
	return ret0
}

// Stop indicates an expected call of Stop.
func (mr *MockBatchProcessorMockRecorder) Stop(graceful any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockBatchProcessor)(nil).Stop), graceful)
}

// MockDiscardableCollector is a mock of DiscardableCollector interface.
type MockDiscardableCollector struct {
	ctrl     *gomock.Controller
	recorder *MockDiscardableCollectorMockRecorder
}

// MockDiscardableCollectorMockRecorder is the mock recorder for MockDiscardableCollector.
type MockDiscardableCollectorMockRecorder struct {
	mock *MockDiscardableCollector
}

// NewMockDiscardableCollector creates a new mock instance.
func NewMockDiscardableCollector(ctrl *gomock.Controller) *MockDiscardableCollector {
	mock := &MockDiscardableCollector{ctrl: ctrl}
	mock.recorder = &MockDiscardableCollectorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDiscardableCollector) EXPECT() *MockDiscardableCollectorMockRecorder {
	return m.recorder
}

// DiscardableCollect mocks base method.
func (m *MockDiscardableCollector) DiscardableCollect(arg0 context.Context, arg1 batchpipe.HasName) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DiscardableCollect", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// DiscardableCollect indicates an expected call of DiscardableCollect.
func (mr *MockDiscardableCollectorMockRecorder) DiscardableCollect(arg0, arg1 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DiscardableCollect", reflect.TypeOf((*MockDiscardableCollector)(nil).DiscardableCollect), arg0, arg1)
}
