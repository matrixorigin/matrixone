// Copyright 2022 Matrix Origin
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Bin to show how Merge Task work. Helps to debug code, or optimization.
//
// There are two type table data: one is dummyStatementTable, with primary key; another is dummyRawlogTable, without primary key.
// Both of them are code-copied from pkg "github.com/matrixorigin/matrixone/pkg/util/trace", caused by import-cycle issue.
//
// If you want to run this code, you need some source data, that could copy from folder `mo-data/etl/sys/logs/...`, which generated by mo-service startup with config `etc/launch-tae-logservice`
package main

import (
	"context"
	"github.com/matrixorigin/matrixone/pkg/util/export/table"
	"net/http"
	"os"
	"runtime"
	"sync"
	"time"

	_ "net/http/pprof"
	"runtime/pprof"

	"github.com/matrixorigin/matrixone/pkg/fileservice"
	"github.com/matrixorigin/matrixone/pkg/logutil"
	"github.com/matrixorigin/matrixone/pkg/util/export"
)

// following variables is copy code from "github.com/matrixorigin/matrixone/pkg/util/trace"
// helps to run with data from `mo-data/etl/sys/logs/...`, which generated by mo-service startup with config `etc/launch-tae-logservice`
var (
	etlFileServiceName = "etl"
	statsDatabase      = "system"
	statementInfoTbl   = "statement_info"
	rawLogTbl          = "rawlog"

	uuidColType        = "varchar(36)"
	spanIDType         = "varchar(16)"
	datetime6Type      = "datetime(6)"
	bigintUnsignedType = "bigint unsigned"
	stringType         = "varchar(1024)"
	jsonColumnDEFAULT  = "{}"

	stmtIDCol    = table.Column{Name: "statement_id", Type: uuidColType, Default: "0", Comment: "statement uniq id"}
	txnIDCol     = table.Column{Name: "transaction_id", Type: uuidColType, Default: "0", Comment: "txn uniq id"}
	sesIDCol     = table.Column{Name: "session_id", Type: uuidColType, Default: "0", Comment: "session uniq id"}
	accountCol   = table.Column{Name: "account", Type: stringType, Default: "", Comment: "account name"}
	userCol      = table.Column{Name: "user", Type: stringType, Default: "", Comment: "user name"}
	hostCol      = table.Column{Name: "host", Type: stringType, Default: "", Comment: "user client ip"}
	dbCol        = table.Column{Name: "database", Type: stringType, Default: "", Comment: "what database current session stay in."}
	stmtCol      = table.Column{Name: "statement", Type: "TEXT", Default: "", Comment: "sql statement"}
	stmtTagCol   = table.Column{Name: "statement_tag", Type: "TEXT", Default: "", Comment: "note tag in statement(Reserved)"}
	stmtFgCol    = table.Column{Name: "statement_fingerprint", Type: "TEXT", Default: "", Comment: "note tag in statement(Reserved)"}
	nodeUUIDCol  = table.Column{Name: "node_uuid", Type: uuidColType, Default: "0", Comment: "node uuid, which node gen this data."}
	nodeTypeCol  = table.Column{Name: "node_type", Type: "varchar(64)", Default: "node", Comment: "node type in MO, val in [DN, CN, LOG]"}
	reqAtCol     = table.Column{Name: "request_at", Type: datetime6Type, Default: "", Comment: "request accept datetime"}
	respAtCol    = table.Column{Name: "response_at", Type: datetime6Type, Default: "", Comment: "response send datetime"}
	durationCol  = table.Column{Name: "duration", Type: bigintUnsignedType, Default: "0", Comment: "exec time, unit: ns"}
	statusCol    = table.Column{Name: "status", Type: "varchar(32)", Default: "Running", Comment: "sql statement running status, enum: Running, Success, Failed"}
	errorCol     = table.Column{Name: "error", Type: "TEXT", Default: "", Comment: "error message"}
	execPlanCol  = table.Column{Name: "exec_plan", Type: "JSON", Default: jsonColumnDEFAULT, Comment: "statement execution plan"}
	rowsReadCol  = table.Column{Name: "rows_read", Type: bigintUnsignedType, Default: "0", Comment: "rows read total"}
	bytesScanCol = table.Column{Name: "bytes_scan", Type: bigintUnsignedType, Default: "0", Comment: "bytes scan total"}

	// dummyStatementTable helps to handle statement records.
	// One statement identified by statement_id, but may record 2 times in different files.
	// So it defines primary key to do help some compaction: remove old record.
	dummyStatementTable = &table.Table{
		Account:  table.AccountAll,
		Database: statsDatabase,
		Table:    statementInfoTbl,
		Columns: []table.Column{
			stmtIDCol,
			txnIDCol,
			sesIDCol,
			accountCol,
			userCol,
			hostCol,
			dbCol,
			stmtCol,
			stmtTagCol,
			stmtFgCol,
			nodeUUIDCol,
			nodeTypeCol,
			reqAtCol,
			respAtCol,
			durationCol,
			statusCol,
			errCodeCol,
			errorCol,
			execPlanCol,
			rowsReadCol,
			bytesScanCol,
		},
		PrimaryKeyColumn: []table.Column{stmtIDCol},
		Engine:           table.ExternalTableEngine,
		Comment:          "record each statement and stats info",
		PathBuilder:      table.NewAccountDatePathBuilder(),
		AccountColumn:    &accountCol,
		// SupportUserAccess
		SupportUserAccess: true,
	}

	rawItemCol      = table.Column{Name: "raw_item", Type: stringType, Comment: "raw log item"}
	timestampCol    = table.Column{Name: "timestamp", Type: datetime6Type, Comment: "timestamp of action"}
	loggerNameCol   = table.Column{Name: "logger_name", Type: stringType, Comment: "logger name"}
	levelCol        = table.Column{Name: "level", Type: stringType, Comment: "log level, enum: debug, info, warn, error, panic, fatal"}
	callerCol       = table.Column{Name: "caller", Type: stringType, Comment: "where it log, like: package/file.go:123"}
	messageCol      = table.Column{Name: "message", Type: "TEXT", Comment: "log message"}
	extraCol        = table.Column{Name: "extra", Type: "JSON", Default: jsonColumnDEFAULT, Comment: "log dynamic fields"}
	errCodeCol      = table.Column{Name: "err_code", Type: stringType, Default: "0"}
	stackCol        = table.Column{Name: "stack", Type: "varchar(4096)"}
	spanIDCol       = table.Column{Name: "span_id", Type: spanIDType, Default: "0", Comment: "span uniq id"}
	parentSpanIDCol = table.Column{Name: "parent_span_id", Type: spanIDType, Default: "0", Comment: "parent span uniq id"}
	spanNameCol     = table.Column{Name: "span_name", Type: stringType, Default: "", Comment: "span name, for example: step name of execution plan, function name in code, ..."}
	startTimeCol    = table.Column{Name: "start_time", Type: datetime6Type, Default: ""}
	endTimeCol      = table.Column{Name: "end_time", Type: datetime6Type, Default: ""}
	resourceCol     = table.Column{Name: "resource", Type: "JSON", Default: jsonColumnDEFAULT, Comment: "static resource information"}

	// dummyRawlogTable helps to handle error, log, span data.
	dummyRawlogTable = &table.Table{
		Account:  table.AccountAll,
		Database: statsDatabase,
		Table:    rawLogTbl,
		Columns: []table.Column{
			rawItemCol,
			nodeUUIDCol,
			nodeTypeCol,
			spanIDCol,
			stmtIDCol,
			loggerNameCol,
			timestampCol,
			levelCol,
			callerCol,
			messageCol,
			extraCol,
			errCodeCol,
			errorCol,
			stackCol,
			spanNameCol,
			parentSpanIDCol,
			startTimeCol,
			endTimeCol,
			durationCol,
			resourceCol,
		},
		PrimaryKeyColumn: nil,
		Engine:           table.ExternalTableEngine,
		Comment:          "read merge data from log, error, span",
		PathBuilder:      table.NewAccountDatePathBuilder(),
		AccountColumn:    nil,
		// SupportUserAccess
		SupportUserAccess: false,
	}
)

func main() {

	ctx := context.Background()

	fs, err := fileservice.NewLocalETLFS(etlFileServiceName, "mo-data/etl")
	if err != nil {
		logutil.Infof("failed open fileservice: %v", err)
		return
	}
	files, err := fs.List(ctx, "/")
	if err != nil {
		logutil.Infof("failed list /: %v", err)
		return
	}
	if len(files) == 0 {
		logutil.Infof("skipping, no mo-data/etl folder")
		return
	}

	httpWG := sync.WaitGroup{}
	httpWG.Add(1)
	go func() {
		httpWG.Done()
		http.ListenAndServe("0.0.0.0:8123", nil)
	}()
	httpWG.Wait()
	time.Sleep(time.Second)

	cctx, cancel := context.WithCancel(ctx)
	go traceMemStats(cctx)

	mergeTable(ctx, fs, dummyStatementTable)
	mergeTable(ctx, fs, dummyRawlogTable)

	logutil.Infof("all done, run sleep(5)")
	time.Sleep(5 * time.Second)
	cancel()
}

func mergeTable(ctx context.Context, fs *fileservice.LocalETLFS, table *table.Table) {
	var err error
	merge := export.NewMerge(ctx, export.WithTable(table), export.WithFileService(fs))
	logutil.Infof("[%v] create merge task", table.GetName())
	ts, err := time.Parse("2006-01-02 15:04:05", "2022-11-03 00:00:00")
	logutil.Infof("[%v] create ts: %v, err: %v", table.GetName(), ts, err)
	err = merge.Main(ts)
	if err != nil {
		logutil.Infof("[%v] failed to merge: %v", table.GetName(), err)
	} else {
		logutil.Infof("[%v] merge succeed.", table.GetName())
	}

	writeAllocsProfile(table.GetName())
}

func writeAllocsProfile(suffix string) {
	profile := pprof.Lookup("heap")
	if profile == nil {
		return
	}
	profilePath := ""
	if profilePath == "" {
		profilePath = "heap-profile"
	}
	if len(suffix) > 0 {
		profilePath = profilePath + "." + suffix
	}
	f, err := os.Create(profilePath)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	if err := profile.WriteTo(f, 0); err != nil {
		panic(err)
	}
	logutil.Infof("Allocs profile written to %s", profilePath)
}

func traceMemStats(ctx context.Context) {
	var ms runtime.MemStats
Loop:
	for {
		select {
		case <-ctx.Done():
			break Loop
		case <-time.After(time.Second):
			runtime.ReadMemStats(&ms)
			logutil.Infof("Alloc:%10d(bytes) HeapIdle:%10d(bytes) HeapReleased:%10d(bytes)", ms.Alloc, ms.HeapIdle, ms.HeapReleased)
		}
	}
}
